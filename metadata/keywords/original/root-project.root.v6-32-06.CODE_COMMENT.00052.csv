id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.cxx:897,Testability,Test,Testing,897,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:110,Deployability,integrat,integrated,110,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method *; * *; * Authors (alphabetical): *; * Vladimir Ilievsky <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:110,Integrability,integrat,integrated,110,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method *; * *; * Authors (alphabetical): *; * Vladimir Ilievsky <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:225,Testability,Test,Testing,225,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method *; * *; * Authors (alphabetical): *; * Vladimir Ilievsky <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:903,Testability,Test,Testing,903,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method *; * *; * Authors (alphabetical): *; * Vladimir Ilievsky <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 1:; * depth = 1, image height = 5, image width = 5,; * filter depth = 1, filter height = 2, filter width = 2,; * stride rows = 1, stride cols = 1,; * zero-padding height = 1, zero-padding width = 1,; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 2:; * depth = 2, image height = 5, image width = 5,; * filter depth = 2, filter height = 2, filter width = 3,; * stride rows = 1, stride cols = 1,; * zero-padding height = 1, zero-padding width = 1,; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 3:; * depth = 3, image height = 2, image width = 3,; * filter depth = 3, filter height = 3, filter width = 2,; * stride rows = 3, stride cols = 1,; * zero-padding height = 2, zero-padding width = 1,; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2Col.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2Col.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx:919,Testability,Test,Testing,919,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the method Im2col //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx:110,Deployability,integrat,integrated,110,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on the GPU *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic Im2Col test for //; // CUDA architectures. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx:110,Integrability,integrat,integrated,110,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on the GPU *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic Im2Col test for //; // CUDA architectures. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx:225,Testability,Test,Testing,225,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on the GPU *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic Im2Col test for //; // CUDA architectures. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx:887,Testability,test,test,887,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Im2Col method on the GPU *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Concrete instantiation of the generic Im2Col test for //; // CUDA architectures. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestIm2ColCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Method DL for Conv Net for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Method DL for Conv Net for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Method DL for Conv Net for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Method DL for Conv Net *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Method DL for Conv Net *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Method DL for Conv Net *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:23,Deployability,pipeline,pipeline,23,"/** Testing the entire pipeline of the Method DL, when only a Convolutional Net; * is constructed. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:4,Testability,Test,Testing,4,"/** Testing the entire pipeline of the Method DL, when only a Convolutional Net; * is constructed. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:3,Performance,Load,Load,3,"// Load the input data",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h:35,Testability,test,testing,35,"// generate the files; // 1000 for testing 1000 for training",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMethodDLCNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx:300,Usability,Learn,Learning,300,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:300,Usability,Learn,Learning,300,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:24,Testability,test,test,24,"// Initialize train and test input",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:24,Testability,test,test,24,"// Initialize train and test output",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h:24,Testability,test,test,24,"// Initialize train and test weights",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimization.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the CPU backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the CPU backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the CPU backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx:300,Usability,Learn,Learning,300,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Deep Learning Minimizer for the CPU backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMinimizationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Conv Net Forward Pass for the CPU *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Conv Net Forward Pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Conv Net Forward Pass for the CPU *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Conv Net Forward Pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Conv Net Forward Pass for the CPU *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Conv Net Forward Pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx:917,Testability,Test,Testing,917,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Conv Net Forward Pass for the CPU *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Conv Net Forward Pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestMixedArchitectures.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx:931,Availability,Down,Downsample,931,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx:171,Deployability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx:171,Integrability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx:286,Testability,Test,Testing,286,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx:919,Testability,Test,Testing,919,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:110,Deployability,integrat,integrated,110,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling layer in an architecture agnostic manner. *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Max Pooling Layer //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:110,Integrability,integrat,integrated,110,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling layer in an architecture agnostic manner. *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Max Pooling Layer //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:225,Testability,Test,Testing,225,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling layer in an architecture agnostic manner. *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Max Pooling Layer //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:871,Testability,Test,Testing,871,"/**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling layer in an architecture agnostic manner. *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Max Pooling Layer //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 1:; * depth = 2, image height = 4, image width = 5,; * frame depth = 2, filter height = 2, filter width = 2,; * stride rows = 2, stride cols = 1,; * zero-padding height = 0, zero-padding width = 0,; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 1:; * depth = 1, image height = 6, image width = 6,; * frame depth = 1, filter height = 2, filter width = 3,; * stride rows = 1, stride cols = 3,; * zero-padding height = 0, zero-padding width = 0,; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test BackWard 1:; * depth = 1, image height = 6, image width = 6,; * frame depth = 1, filter height = 2, filter width = 3,; * stride rows = 1, stride cols = 3,; * zero-padding height = 0, zero-padding width = 0,; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h:81,Testability,Test,Test,81,"/*************************************************************************; // * Test Backward 2:; // * depth = 2, image height = 4, image width = 5,; // * frame depth = 2, filter height = 2, filter width = 2,; // * stride rows = 2, stride cols = 1,; // * zero-padding height = 0, zero-padding width = 0,; // *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayer.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx:930,Availability,Down,Downsample,930,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx:171,Deployability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx:171,Integrability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx:286,Testability,Test,Testing,286,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx:918,Testability,Test,Testing,918,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx:930,Availability,Down,Downsample,930,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx:171,Deployability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx:171,Integrability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx:286,Testability,Test,Testing,286,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx:918,Testability,Test,Testing,918,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:930,Availability,Down,Downsample,930,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:171,Deployability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:171,Integrability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:286,Testability,Test,Testing,286,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:918,Testability,Test,Testing,918,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing the Pooling Layer on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Downsample function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:159,Availability,ERROR,ERROR,159,"// FIXME: Prepare forward pass for this test; /*std::cout << ""Test Back-propagation 2: "" << std::endl;; if (!testBackward2<TCpu<Scalar_t>>()) {; std::cerr << ""ERROR - Back-propagation failed "" << std::endl;; return -1;; }*/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:40,Testability,test,test,40,"// FIXME: Prepare forward pass for this test; /*std::cout << ""Test Back-propagation 2: "" << std::endl;; if (!testBackward2<TCpu<Scalar_t>>()) {; std::cerr << ""ERROR - Back-propagation failed "" << std::endl;; return -1;; }*/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx:62,Testability,Test,Test,62,"// FIXME: Prepare forward pass for this test; /*std::cout << ""Test Back-propagation 2: "" << std::endl;; if (!testBackward2<TCpu<Scalar_t>>()) {; std::cerr << ""ERROR - Back-propagation failed "" << std::endl;; return -1;; }*/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestPoolingLayerCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx:163,Deployability,integrat,integrated,163,"// @(#)root/tmva $Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the Reference architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx:163,Integrability,integrat,integrated,163,"// @(#)root/tmva $Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the Reference architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx:278,Testability,Test,Testing,278,"// @(#)root/tmva $Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the Reference architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx:913,Testability,Test,Testing,913,"// @(#)root/tmva $Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the Reference architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h:162,Deployability,integrat,integrated,162,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for every architecture using templates *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h:162,Integrability,integrat,integrated,162,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for every architecture using templates *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h:277,Testability,Test,Testing,277,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for every architecture using templates *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h:79,Testability,Test,Test,79,"/////////////////////////////////////////////////////////////////////////; /// Test Reshape:; /// Input Shape: (3, 5); /// Output Shape: (5, 3); /////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 1:; * depth = 3, width = 5, height = 5; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 1:; * depth = 3, width = 5, height = 5; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshape.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshape.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx:162,Deployability,integrat,integrated,162,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the CPU architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx:162,Integrability,integrat,integrated,162,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the CPU architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx:277,Testability,Test,Testing,277,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the CPU architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx:908,Testability,Test,Testing,908,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flatten/Deflatten on the CPU architecture //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx:162,Deployability,integrat,integrated,162,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flattening/Deflattening on the GPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx:162,Integrability,integrat,integrated,162,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flattening/Deflattening on the GPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx:277,Testability,Test,Testing,277,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flattening/Deflattening on the GPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx:907,Testability,Test,Testing,907,"// @(#)root/tmva $Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Flatten function for Reference backend *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing Flattening/Deflattening on the GPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestReshapeCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx:904,Testability,Test,Testing,904,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h:171,Deployability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h:171,Integrability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h:286,Testability,Test,Testing,286,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h:921,Testability,Test,Testing,921,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 1:; * filter depth = 3, filter height = 2, filter width = 2, num. filters = 4; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h:78,Testability,Test,Test,78,"/*************************************************************************; * Test 2:; * filter depth = 2, filter height = 2, filter width = 3, num. filters = 4; *************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeights.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx:172,Deployability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function on the CPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx:172,Integrability,integrat,integrated,172,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function on the CPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx:287,Testability,Test,Testing,287,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function on the CPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx:994,Testability,Test,Testing,994,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Rotate Weights function on the CPU //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx:171,Deployability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx:171,Integrability,integrat,integrated,171,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx:286,Testability,Test,Testing,286,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Manos Stergiadis; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing RotateWeights method on a CPU architecture *; * *; * Authors (alphabetical): *; * Manos Stergiadis <em.stergiadis@gmail.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestRotateWeightsCuda.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 02/07/19; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing full GRU network (for Reference) //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRU.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx:2,Testability,test,testFullGRU,2,"//testFullGRU(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector; // batchsize, statesize, inputsize, outputsize",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRU.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx:176,Integrability,depend,dependent,176,"//testFullGRU<TReference<double>>(64, 10, 8, 8) ;; //testFullGRU<TReference<double>>(3, 8, 100, 50) ;; // test a full GRU with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRU.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx:2,Testability,test,testFullGRU,2,"//testFullGRU<TReference<double>>(64, 10, 8, 8) ;; //testFullGRU<TReference<double>>(3, 8, 100, 50) ;; // test a full GRU with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRU.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx:53,Testability,test,testFullGRU,53,"//testFullGRU<TReference<double>>(64, 10, 8, 8) ;; //testFullGRU<TReference<double>>(3, 8, 100, 50) ;; // test a full GRU with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRU.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx:106,Testability,test,test,106,"//testFullGRU<TReference<double>>(64, 10, 8, 8) ;; //testFullGRU<TReference<double>>(3, 8, 100, 50) ;; // test a full GRU with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRU.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRU.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 02/07/19; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing full GRU network (for CPU) //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx:3,Testability,test,testFullRNN,3,"// testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx:73,Integrability,depend,dependent,73,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx:3,Testability,test,test,3,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 02/07/19; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing full GRU network (for CPU) //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx:3,Testability,test,testFullRNN,3,"// testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx:73,Integrability,depend,dependent,73,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx:3,Testability,test,test,3,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestFullGRUCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 26/06219; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRULayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:470,Testability,test,tests,470,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the GRULayer Backward pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Testability,test,test,24,"/*! Generate a DeepNet, test backward pass */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:11,Deployability,Update,Update,11,"// Weights Update gate, k = 2",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:11,Deployability,Update,Update,11,"// Weights Update Gate State, k = 3",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:3,Testability,test,testing,3,"// testing reset gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:11,Deployability,update,update,11,"// testing update gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:3,Testability,test,testing,3,"// testing update gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:3,Testability,test,testing,3,"// testing candidate gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 26/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRULayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx:3,Testability,test,test,3,"// test with a dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx:3,Testability,test,test,3,"// test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx:3,Testability,test,test,3,"// test using reset gate after =On as for cudnn",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 26/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRULayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx:3,Testability,test,test,3,"// test with a dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx:3,Testability,test,test,3,"// test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRU-Layer forward pass for Reference implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h:481,Testability,test,tests,481,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the GRU-Layer Forward Pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h:19,Testability,test,test,19,"/*! Generic sample test for forward propagation in GRU network. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h:3,Deployability,Update,Update,3,"// Update state",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPassCpu.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRU-Layer forward pass for CPU implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUForwardPassCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPassCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPassCudnn.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRU-Layer forward pass for CPU implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/GRU/TestGRUForwardPassCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/TestGRUForwardPassCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 02/07/19; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing full LSTM network (for Reference) //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx:2,Testability,test,testFullLSTM,2,"//testFullLSTM(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector; // batchsize, statesize, inputsize, outputsize",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx:179,Integrability,depend,dependent,179,"//testFullLSTM<TReference<double>>(64, 10, 8, 8) ;; //testFullLSTM<TReference<double>>(3, 8, 100, 50) ;; // test a full LSTM with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx:2,Testability,test,testFullLSTM,2,"//testFullLSTM<TReference<double>>(64, 10, 8, 8) ;; //testFullLSTM<TReference<double>>(3, 8, 100, 50) ;; // test a full LSTM with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx:54,Testability,test,testFullLSTM,54,"//testFullLSTM<TReference<double>>(64, 10, 8, 8) ;; //testFullLSTM<TReference<double>>(3, 8, 100, 50) ;; // test a full LSTM with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx:108,Testability,test,test,108,"//testFullLSTM<TReference<double>>(64, 10, 8, 8) ;; //testFullLSTM<TReference<double>>(3, 8, 100, 50) ;; // test a full LSTM with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTM.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 02/07/19; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing full LSTM network (for CPU) //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx:3,Testability,test,testFullRNN,3,"// testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx:73,Integrability,depend,dependent,73,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx:3,Testability,test,test,3,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 02/07/19; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing full LSTM network (for CPU) //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx:3,Testability,test,testFullRNN,3,"// testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx:73,Integrability,depend,dependent,73,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx:3,Testability,test,test,3,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestFullLSTMCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.cxx:471,Testability,Test,Testing,471,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 26/06219; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing LSTMLayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.cxx:50,Testability,test,testLSTMBackpropagation,50,"// timesteps, batchsize, statesize, inputsize; // testLSTMBackpropagation<TReference<double>>(1, 2, 1, 10, 1e-5);",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:470,Testability,test,tests,470,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the LSTMLayer Backward pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Testability,test,test,24,"/*! Generate a DeepNet, test backward pass */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:3,Testability,test,testing,3,"// testing input gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:3,Testability,test,testing,3,"// testing foget gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:3,Testability,test,testing,3,"// testing candidate gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:3,Testability,test,testing,3,"// testing output gate bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 26/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing LSTMLayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx:3,Testability,test,test,3,"// test with a dense layer (does not work for large input , why ???)",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx:3,Testability,test,test,3,"// test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 26/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing LSTMLayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx:3,Testability,test,test,3,"// test with a dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx:10,Testability,test,testLSTMBackpropagation,10,"//iret |= testLSTMBackpropagation<Architecture_t>(4, 4, 10, 20, 1e-5, {false, true}, debug);; // test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx:97,Testability,test,test,97,"//iret |= testLSTMBackpropagation<Architecture_t>(4, 4, 10, 20, 1e-5, {false, true}, debug);; // test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing LSTM-Layer forward pass for Reference implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx:15,Testability,test,testForwardPass,15,"//std::cout << testForwardPass<TReference<double>>(1, 8, 100, 50) << ""\n"";; //std::cout << testForwardPass<TReference<double>>(5, 9, 128, 64) << ""\n"";",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx:91,Testability,test,testForwardPass,91,"//std::cout << testForwardPass<TReference<double>>(1, 8, 100, 50) << ""\n"";; //std::cout << testForwardPass<TReference<double>>(5, 9, 128, 64) << ""\n"";",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.h:481,Testability,test,tests,481,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the LSTM-Layer Forward Pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.h:19,Testability,test,test,19,"/*! Generic sample test for forward propagation in LSTM network. */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPassCpu.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing LSTM-Layer forward pass for CPU implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPassCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPassCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPassCudnn.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRU-Layer forward pass for CPU implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/LSTM/TestLSTMForwardPassCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/TestLSTMForwardPassCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx:468,Testability,Test,Testing,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 02/08/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; //Testing RNNLayer for incrementing a number //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx:2,Testability,test,testFullRNN,2,"//testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector; // batchsize, statesize, inputsize, outputsize",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx:176,Integrability,depend,dependent,176,"//testFullRNN<TReference<double>>(64, 10, 8, 8) ;; //testFullRNN<TReference<double>>(3, 8, 100, 50) ;; // test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx:2,Testability,test,testFullRNN,2,"//testFullRNN<TReference<double>>(64, 10, 8, 8) ;; //testFullRNN<TReference<double>>(3, 8, 100, 50) ;; // test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx:53,Testability,test,testFullRNN,53,"//testFullRNN<TReference<double>>(64, 10, 8, 8) ;; //testFullRNN<TReference<double>>(3, 8, 100, 50) ;; // test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx:106,Testability,test,test,106,"//testFullRNN<TReference<double>>(64, 10, 8, 8) ;; //testFullRNN<TReference<double>>(3, 8, 100, 50) ;; // test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h:468,Testability,test,tests,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the RNNLayer Forward pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h:97,Safety,predict,predictions,97,"//Matrix_t & out = rnn.GetLayers().back()->GetOutputAt(0);; //out.Print();; //YArch.Print();; // predictions",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h:3,Safety,predict,predicted,3,"// predicted output and labels",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx:468,Testability,Test,Testing,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 02/08/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; //Testing RNNLayer for incrementing a number //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx:2,Testability,test,testFullRNN,2,"//testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx:73,Integrability,depend,dependent,73,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx:3,Testability,test,test,3,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx:468,Testability,Test,Testing,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 02/08/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; //Testing RNNLayer for incrementing a number //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx:2,Testability,test,testFullRNN,2,"//testFullRNN(size_t batchSize, size_t stateSize, size_t inputSize, size_t outputSize); // reconstruct 8 bit vector",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx:73,Integrability,depend,dependent,73,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx:3,Testability,test,test,3,"// test a full RNN with 5 time steps and different signal/backgrund time dependent shapes; // batchsize, statesize , inputsize, seed",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNNCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.cxx:469,Testability,Test,Testing,469,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 30/11/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing RNNLayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:468,Testability,test,tests,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the RNNLayer Backward pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:24,Testability,test,test,24,"/*! Generate a DeepNet, test backward pass */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:21,Testability,test,test,21,"// don't use tanh in test due to limited vdt precision",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:106,Modifiability,layers,layers,106,"// for Cudnn all weights are collapsed in one; // if (Architecture::IsCudnn()); // continue;; // if other layers (not RNN) continue",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:4,Testability,test,testing,4,"/// testing weight state gradient; // Weights State, k = 1",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:3,Testability,test,testing,3,"// testing bias gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:24,Testability,test,test,24,"/*! Generate a DeepNet, test backward pass */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:24,Availability,error,error,24,"// Compute the relative error if dy != 0.",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h:27,Availability,error,error,27,"//maximum_error = std::max(error, maximum_error);",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagation.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx:469,Testability,Test,Testing,469,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 16/02/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing RNNLayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx:3,Testability,test,test,3,"// test returning the full sequence",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx:3,Testability,test,test,3,"// test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:469,Testability,Test,Testing,469,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 16/02/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing RNNLayer backpropagation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:3,Testability,test,test,3,"// test returning the full sequence",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:41,Availability,error,error,41,"// use batch size <= 16 or get numerical error in numrical gradients",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:90,Availability,error,errors,90,"// with a dense layer (also use not too large batch size or input size to avoid numerical errors)",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:74,Safety,avoid,avoid,74,"// with a dense layer (also use not too large batch size or input size to avoid numerical errors)",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:3,Testability,test,test,3,"// test returning the full sequence and dense layer",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx:468,Testability,Test,Testing,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 22/06/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; //Testing RNNLayer forward pass for Reference implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx:2,Testability,TEST,TEST,2,"//TEST(RNNTest, ForwardPass); //{; // EXPECT_EQ(testForwardPass<TReference<double>>(3, 8, 100, 50), 0.0);; //}",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx:48,Testability,test,testForwardPass,48,"//TEST(RNNTest, ForwardPass); //{; // EXPECT_EQ(testForwardPass<TReference<double>>(3, 8, 100, 50), 0.0);; //}",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.h:468,Testability,test,tests,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the RNNLayer Forward pass //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.h:868,Testability,test,test,868,"// template <typename Architecture>; // auto printTensor1(const std::vector<typename Architecture::Matrix_t> &A, const std::string name = ""matrix""); // -> void; // {; // std::cout << name << ""\n"";; // for (size_t l = 0; l < A.size(); ++l) {; // for (size_t i = 0; i < A[l].GetNrows(); ++i) {; // for (size_t j = 0; j < A[l].GetNcols(); ++j) {; // std::cout << A[l](i, j) << "" "";; // }; // std::cout << ""\n"";; // }; // std::cout << ""********\n"";; // }; // }; // template <typename Architecture>; // auto printMatrix1(const typename Architecture::Matrix_t &A, const std::string name = ""matrix""); // -> void; // {; // std::cout << name << ""\n"";; // for (size_t i = 0; i < A.GetNrows(); ++i) {; // for (size_t j = 0; j < A.GetNcols(); ++j) {; // std::cout << A(i, j) << "" "";; // }; // std::cout << ""\n"";; // }; // std::cout << ""********\n"";; // }; /*! Generate a DeepNet, test forward pass */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx:468,Testability,Test,Testing,468,"// @(#)root/tmva $Id$; // Author: Saurav Shekhar 01/08/17; /*************************************************************************; * Copyright (C) 2017, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; //Testing RNNLayer forward pass for Reference implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx:2,Testability,TEST,TEST,2,"//TEST(RNNTest, ForwardPass); //{; // EXPECT_EQ(testForwardPass<TReference<double>>(3, 8, 100, 50), 0.0);; //}",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx:48,Testability,test,testForwardPass,48,"//TEST(RNNTest, ForwardPass); //{; // EXPECT_EQ(testForwardPass<TReference<double>>(3, 8, 100, 50), 0.0);; //}",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCpu.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCudnn.cxx:473,Testability,Test,Testing,473,"// @(#)root/tmva $Id$; // Author: Surya S Dwivedi 07/06/2019; /*************************************************************************; * Copyright (C) 2019, Surya S Dwivedi *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing GRU-Layer forward pass for CPU implementation //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCudnn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentForwardPassCudnn.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:23,Deployability,configurat,configuration,23,"// class to load basic configuration for all classification tests,; // like environment variables and data in the DataLoader.",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:23,Modifiability,config,configuration,23,"// class to load basic configuration for all classification tests,; // like environment variables and data in the DataLoader.",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:88,Modifiability,variab,variables,88,"// class to load basic configuration for all classification tests,; // like environment variables and data in the DataLoader.",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:12,Performance,load,load,12,"// class to load basic configuration for all classification tests,; // like environment variables and data in the DataLoader.",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:60,Testability,test,tests,60,"// class to load basic configuration for all classification tests,; // like environment variables and data in the DataLoader.",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:3,Testability,Test,Test,3,"// Test calling Train/Test without call evaluation method and without output file",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:22,Testability,Test,Test,22,"// Test calling Train/Test without call evaluation method and without output file",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:3,Testability,test,testing,3,"// testing methods and Train/Test",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:29,Testability,Test,Test,29,"// testing methods and Train/Test",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:3,Testability,Test,Test,3,"// Test calling Train/Test with output file",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:22,Testability,Test,Test,22,"// Test calling Train/Test with output file",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:3,Testability,test,tests,3,"// tests to check that the output in the file is right",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx:32,Testability,test,tested,32,"// looking output for the first tested method",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testClassification.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testClassification.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testEnvelope.cxx:3,Testability,test,test,3,"// test without DataLoader or output file",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testEnvelope.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testEnvelope.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testEnvelope.cxx:3,Testability,test,test,3,"// test with DataLoader and output file",MatchSource.CODE_COMMENT,tmva/tmva/test/envelope/testEnvelope.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/testEnvelope.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:44,Testability,test,test,44,"// To aviod triggering crash if there is no test tree",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:40,Availability,error,error,40,"// 100% - all events in training set -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:43,Availability,error,error,43,"// 101% - more events than training set -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:29,Availability,error,error,29,"// -1% - negative numnber -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:21,Availability,error,error,21,"// 0% - no events -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:29,Availability,error,error,29,"// -0.1 - negative number -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:22,Availability,error,error,22,"// 0.0 - no events -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:59,Availability,error,error,59,"// 100 - uses all events in training set for validation -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:45,Security,validat,validation,45,"// 100 - uses all events in training set for validation -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:27,Availability,error,error,27,"// -1 - negative number -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx:45,Availability,error,error,45,"// 101 - more events than in training set -> error",MatchSource.CODE_COMMENT,tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/TestMethodDNNValidationSize.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:476,Testability,test,tests,476,"// @(#)root/tmva $Id$; // Author: Kim Albertsson; /*************************************************************************; * Copyright (C) 2017, Kim Albertsson *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////; // Collection of tests to verify that roc curves and integrals are //; // calculated correctly. //; //////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:21,Modifiability,variab,variables,21,"/**; * Generates two variables, the signal class (A) will be uniformly; * distributed while the background class (B) will be triangular.; * __________; * |\_ |; * | \_ A |; * | B \_ |; * |______\_|; *; * The analytical roc curve has in this case an area of 2/3.; */",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:43,Modifiability,variab,variables,43,"/**; * Generates two uniformly distributed variables. When doing a; * classification, you can do no better than random -> AUC = 0.5.; */",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:10,Safety,sanity check,sanity check,10,"// Simple sanity check to make sure weights are respected.; // Simple in the sense it only uses 4 non-random datapoints.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:3,Usability,Simpl,Simple,3,"// Simple sanity check to make sure weights are respected.; // Simple in the sense it only uses 4 non-random datapoints.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:63,Usability,Simpl,Simple,63,"// Simple sanity check to make sure weights are respected.; // Simple in the sense it only uses 4 non-random datapoints.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:10,Safety,sanity check,sanity check,10,"// Larger sanity check. Two uniform distributions; // with equal weights should yield AUC of 0.5.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:181,Availability,error,error,181,"// Larger sanity check. Using uniform dist as signal; // and triangular as background should yield AUC of 2/3.; //; // Using 0.002 as the limit should yield a probability; // of an error of 0.0001%. (Estimated numerically).; // If the error is triggered, consider changing the seed of ""generator"" and/or; // increase either the error limit, the number of datapoints or the number of; // averagings.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:235,Availability,error,error,235,"// Larger sanity check. Using uniform dist as signal; // and triangular as background should yield AUC of 2/3.; //; // Using 0.002 as the limit should yield a probability; // of an error of 0.0001%. (Estimated numerically).; // If the error is triggered, consider changing the seed of ""generator"" and/or; // increase either the error limit, the number of datapoints or the number of; // averagings.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:328,Availability,error,error,328,"// Larger sanity check. Using uniform dist as signal; // and triangular as background should yield AUC of 2/3.; //; // Using 0.002 as the limit should yield a probability; // of an error of 0.0001%. (Estimated numerically).; // If the error is triggered, consider changing the seed of ""generator"" and/or; // increase either the error limit, the number of datapoints or the number of; // averagings.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:10,Safety,sanity check,sanity check,10,"// Larger sanity check. Using uniform dist as signal; // and triangular as background should yield AUC of 2/3.; //; // Using 0.002 as the limit should yield a probability; // of an error of 0.0001%. (Estimated numerically).; // If the error is triggered, consider changing the seed of ""generator"" and/or; // increase either the error limit, the number of datapoints or the number of; // averagings.",MatchSource.CODE_COMMENT,tmva/tmva/test/ROC/testRocWeights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/annconvergencetest.h:84,Availability,error,error,84,"// this macro serves to assess the convergence of the MLP ANN. ; // It compares the error estimator for the training and testing samples.; // If overtraining occurred, the estimator for the training sample should ; // monotoneously decrease, while the estimator of the testing sample should ; // show a minimum after which it increases.; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/annconvergencetest.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/annconvergencetest.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/annconvergencetest.h:121,Testability,test,testing,121,"// this macro serves to assess the convergence of the MLP ANN. ; // It compares the error estimator for the training and testing samples.; // If overtraining occurred, the estimator for the training sample should ; // monotoneously decrease, while the estimator of the testing sample should ; // show a minimum after which it increases.; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/annconvergencetest.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/annconvergencetest.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/annconvergencetest.h:269,Testability,test,testing,269,"// this macro serves to assess the convergence of the MLP ANN. ; // It compares the error estimator for the training and testing samples.; // If overtraining occurred, the estimator for the training sample should ; // monotoneously decrease, while the estimator of the testing sample should ; // show a minimum after which it increases.; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/annconvergencetest.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/annconvergencetest.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT.h:137,Deployability,release,release,137,"// Uncomment this only if the link problem is solved. The include statement tends; // to use the ROOT classes rather than the local TMVA release; // #include ""TMVA/DecisionTree.h""; // #include ""TMVA/DecisionTreeNode.h""",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/BDT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT.h:9,Energy Efficiency,green,green,9,"// novel green",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/BDT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT_Reg.h:137,Deployability,release,release,137,"// Uncomment this only if the link problem is solved. The include statement tends; // to use the ROOT classes rather than the local TMVA release; // #include ""TMVA/DecisionTree.h""; // #include ""TMVA/DecisionTreeNode.h""",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/BDT_Reg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/BDT_Reg.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlations.h:68,Modifiability,variab,variables,68,"// this macro plots the correlation matrix of the various input; // variables used in TMVA (e.g. running TMVAnalysis.C). Signal and; // Background are plotted separately; // input: - Input file (result from TMVA),; // - use of colors or grey scale; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/correlations.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlations.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlationscatters.h:82,Modifiability,variab,variable,82,"// this macro plots the correlations (as scatter plots); of; // the various input variable combinations used in TMVA (e.g. running; // TMVAnalysis.C). Signal and Background are plotted separately; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/correlationscatters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlationscatters.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlationscattersMultiClass.h:82,Modifiability,variab,variable,82,"// this macro plots the correlations (as scatter plots); of; // the various input variable combinations used in TMVA (e.g. running; // TMVAnalysis.C). Signal and Background are plotted separately; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/correlationscattersMultiClass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlationscattersMultiClass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlationsMultiClass.h:68,Modifiability,variab,variables,68,"// this macro plots the correlation matrix of the various input; // variables used in TMVA (e.g. running TMVAnalysis.C). Signal and; // Background are plotted separately; // input: - Input file (result from TMVA),; // - use of colors or grey scale; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/correlationsMultiClass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/correlationsMultiClass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/likelihoodrefs.h:100,Modifiability,variab,variables,100,"// this macro plots the reference distribuions for the Likelihood; // methods for the various input variables used in TMVA (e.g. running; // TMVAnalysis.C). Signal and Background are plotted separately; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/likelihoodrefs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/likelihoodrefs.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/regression_averagedevs.h:124,Testability,test,test,124,"/*; this macro plots the quadratic deviation of the estimated from the target value, averaged over the first nevt events in test sample (all if Nevt=-1);; a); normal average; b); truncated average, using best 90%; created January 2009, Eckhard von Toerne, University of Bonn, Germany; */",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/regression_averagedevs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/regression_averagedevs.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/rulevis.h:61,Modifiability,variab,variables,61,"// This macro plots the distributions of the different input variables overlaid on; // the sum of importance per bin.; // The scale goes from violett (no importance); to red (high importance).; // Areas where many important rules are active, will thus be very red.; //; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/rulevis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/rulevis.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/rulevisCorr.h:61,Modifiability,variab,variables,61,"// This macro plots the distributions of the different input variables overlaid on; // the sum of importance per bin.; // The scale goes from violett (no importance); to red (high importance).; // Areas where many important rules are active, will thus be very red.; //; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/rulevisCorr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/rulevisCorr.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/rulevisHists.h:61,Modifiability,variab,variables,61,"// This macro plots the distributions of the different input variables overlaid on; // the sum of importance per bin.; // The scale goes from violett (no importance); to red (high importance).; // Areas where many important rules are active, will thus be very red.; //; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/rulevisHists.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/rulevisHists.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/variables.h:61,Modifiability,variab,variables,61,"// this macro plots the distributions of the different input variables; // used in TMVA (e.g. running TMVAnalysis.C). Signal and Background are overlayed.; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/variables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/variables.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/variablesMultiClass.h:61,Modifiability,variab,variables,61,"// this macro plots the distributions of the different input variables; // used in TMVA (e.g. running TMVAnalysis.C). Signal and Background are overlayed.; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/inc/TMVA/variablesMultiClass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/inc/TMVA/variablesMultiClass.h
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/annconvergencetest.cxx:83,Availability,error,error,83,"// this macro serves to assess the convergence of the MLP ANN.; // It compares the error estimator for the training and testing samples.; // If overtraining occurred, the estimator for the training sample should; // monotoneously decrease, while the estimator of the testing sample should; // show a minimum after which it increases.; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/annconvergencetest.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/annconvergencetest.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/annconvergencetest.cxx:120,Testability,test,testing,120,"// this macro serves to assess the convergence of the MLP ANN.; // It compares the error estimator for the training and testing samples.; // If overtraining occurred, the estimator for the training sample should; // monotoneously decrease, while the estimator of the testing sample should; // show a minimum after which it increases.; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/annconvergencetest.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/annconvergencetest.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/annconvergencetest.cxx:267,Testability,test,testing,267,"// this macro serves to assess the convergence of the MLP ANN.; // It compares the error estimator for the training and testing samples.; // If overtraining occurred, the estimator for the training sample should; // monotoneously decrease, while the estimator of the testing sample should; // show a minimum after which it increases.; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/annconvergencetest.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/annconvergencetest.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:38,Availability,error,error,38,"// doesn't seem to exist .. gives an 'error message' and seems to work just fine without ... :); // fDrawButton->Connect(""ValueSet(Long_t)"",""TGNumberEntry"",fInput, ""Clicked()"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:44,Integrability,message,message,44,"// doesn't seem to exist .. gives an 'error message' and seems to work just fine without ... :); // fDrawButton->Connect(""ValueSet(Long_t)"",""TGNumberEntry"",fInput, ""Clicked()"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:22,Availability,Error,Error,22,"// file not found --> Error",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:22,Availability,Error,Error,22,"// file not found --> Error",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:41,Modifiability,variab,variables,41,"// the rest of header line; // number of variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:3,Modifiability,variab,variable,3,"// variable mins and maxes",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:16,Availability,avail,available,16,"// --- read the available BDT weight files; // destroy all open cavases",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx:22,Availability,Error,Error,22,"// file not found --> Error",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDTControlPlots.cxx:15,Availability,avail,available,15,"// a plot only available in case DoBoostMontior option has bee set",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDTControlPlots.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDTControlPlots.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDTControlPlots.cxx:15,Availability,avail,available,15,"// a plot only available in case DoBoostMontior option has bee set",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDTControlPlots.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDTControlPlots.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:38,Availability,error,error,38,"// doesn't seem to exist .. gives an 'error message' and seems to work just fine without ... :); // fDrawButton->Connect(""Clicked()"",""TGNumberEntry"",fInput, ""ValueSet(Long_t)"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:44,Integrability,message,message,44,"// doesn't seem to exist .. gives an 'error message' and seems to work just fine without ... :); // fDrawButton->Connect(""Clicked()"",""TGNumberEntry"",fInput, ""ValueSet(Long_t)"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:22,Availability,Error,Error,22,"// file not found --> Error",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:22,Availability,Error,Error,22,"// file not found --> Error",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:41,Modifiability,variab,variables,41,"// the rest of header line; // number of variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:3,Modifiability,variab,variable,3,"// variable mins and maxes",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:16,Availability,avail,available,16,"// --- read the available BDT weight files; // destroy all open cavases",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx:22,Availability,Error,Error,22,"// file not found --> Error",MatchSource.CODE_COMMENT,tmva/tmvagui/src/BDT_Reg.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/BDT_Reg.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/compareanapp.cxx:30,Modifiability,variab,variables,30,"// size of canvas; // counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/compareanapp.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/compareanapp.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlations.cxx:68,Modifiability,variab,variables,68,"// this macro plots the correlation matrix of the various input; // variables used in TMVA (e.g. running TMVAnalysis.C). Signal and; // Background are plotted separately; // input: - Input file (result from TMVA),; // - use of colors or grey scale; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlations.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlations.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscatters.cxx:81,Modifiability,variab,variable,81,"// this macro plots the correlations (as scatter plots) of; // the various input variable combinations used in TMVA (e.g. running; // TMVAnalysis.C). Signal and Background are plotted separately; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationscatters.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscatters.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscatters.cxx:28,Modifiability,variab,variables,28,"// find out number of input variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationscatters.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscatters.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscatters.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationscatters.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscatters.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscattersMultiClass.cxx:81,Modifiability,variab,variable,81,"// this macro plots the correlations (as scatter plots) of; // the various input variable combinations used in TMVA (e.g. running; // TMVAnalysis.C). Signal and Background are plotted separately; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationscattersMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscattersMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscattersMultiClass.cxx:28,Modifiability,variab,variables,28,"// find out number of input variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationscattersMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscattersMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscattersMultiClass.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationscattersMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationscattersMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationsMultiClass.cxx:68,Modifiability,variab,variables,68,"// this macro plots the correlation matrix of the various input; // variables used in TMVA (e.g. running TMVAnalysis.C). Signal and; // Background are plotted separately; // input: - Input file (result from TMVA),; // - use of colors or grey scale; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/correlationsMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/correlationsMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGui.cxx:3,Modifiability,config,configure,3,"// configure buttons ; // checks if file with name ""fin"" is already open, and if not opens one",MatchSource.CODE_COMMENT,tmva/tmvagui/src/CorrGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGui.cxx:12,Modifiability,variab,variables,12,"// how many variables are in the directory?",MatchSource.CODE_COMMENT,tmva/tmvagui/src/CorrGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGuiMultiClass.cxx:3,Modifiability,config,configure,3,"// configure buttons ; // checks if file with name ""fin"" is already open, and if not opens one",MatchSource.CODE_COMMENT,tmva/tmvagui/src/CorrGuiMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGuiMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGuiMultiClass.cxx:12,Modifiability,variab,variables,12,"// how many variables are in the directory?",MatchSource.CODE_COMMENT,tmva/tmvagui/src/CorrGuiMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/CorrGuiMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/deviations.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/deviations.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/deviations.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/deviations.cxx:61,Testability,test,test,61,"// methodName.Data(), (htype == kCompareType ? ""training"" : ""test"" )) );",MatchSource.CODE_COMMENT,tmva/tmvagui/src/deviations.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/deviations.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/deviations.cxx:3,Deployability,update,update,3,"// update and print",MatchSource.CODE_COMMENT,tmva/tmvagui/src/deviations.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/deviations.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficiencies.cxx:57,Performance,tune,tuned,57,"// rescale legend box size; // current box size has been tuned for 3 MVAs + 1 title",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficiencies.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficiencies.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:160,Deployability,integrat,integrated,160,"// @(#)Root/tmva $Id$; // Author: Kim Albertsson; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVAGUI *; * *; * *; * Description: *; * Implementation (see header for description) *; * *; * Authors : *; * Kim Albertsson <kim.albertsson@cern.ch> - LTU & CERN *; * *; * Copyright (c) 2005-2017: *; * CERN, Switzerland *; * LTU, Sweden *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:160,Integrability,integrat,integrated,160,"// @(#)Root/tmva $Id$; // Author: Kim Albertsson; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVAGUI *; * *; * *; * Description: *; * Implementation (see header for description) *; * *; * Authors : *; * Kim Albertsson <kim.albertsson@cern.ch> - LTU & CERN *; * *; * Copyright (c) 2005-2017: *; * CERN, Switzerland *; * LTU, Sweden *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:1002,Integrability,wrap,wrapper,1002,"////////////////////////////////////////////////////////////////////////////////; ///; /// Note: This file assumes a certain structure on the input file. The structure; /// is as follows:; ///; /// - dataset (TDirectory); /// - ... some variables, plots ...; /// - Method_XXX (TDirectory); /// + XXX (TDirectory); /// * ... some plots ...; /// * MVA_Method_XXX_Test_#classname#; /// * MVA_Method_XXX_Train_#classname#; /// * ... some plots ...; /// - Method_YYY (TDirectory); /// + YYY (TDirectory); /// * ... some plots ...; /// * MVA_Method_YYY_Test_#classname#; /// * MVA_Method_YYY_Train_#classname#; /// * ... some plots ...; /// - TestTree (TTree); /// + ... data...; /// - TrainTree (TTree); /// + ... data...; ///; /// Keeping this in mind makes the main loop in getRocCurves easier to follow :); ///; ////////////////////////////////////////////////////////////////////////////////; /// Private class that simplify drawing plots combining information from; /// several methods.; ///; /// Each wrapper will manage a canvas and a legend and provide convenience; /// functions to add data to these. It also provides a save function for; /// saving an image representation to disk.; ///; /// Feel free to extend this class as you see fit. It is intended as a; /// convenience when showing multiclass roccurves, not a fully general tool.; ///; /// Usage:; /// auto p = new EfficiencyPlotWrapper(name, title, dataset, i):; /// for (TGraph * g : listOfGraphs) {; /// p->AddGraph(g);; /// p->AddLegendEntry(methodName);; /// }; /// p->save();; ///",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:237,Modifiability,variab,variables,237,"////////////////////////////////////////////////////////////////////////////////; ///; /// Note: This file assumes a certain structure on the input file. The structure; /// is as follows:; ///; /// - dataset (TDirectory); /// - ... some variables, plots ...; /// - Method_XXX (TDirectory); /// + XXX (TDirectory); /// * ... some plots ...; /// * MVA_Method_XXX_Test_#classname#; /// * MVA_Method_XXX_Train_#classname#; /// * ... some plots ...; /// - Method_YYY (TDirectory); /// + YYY (TDirectory); /// * ... some plots ...; /// * MVA_Method_YYY_Test_#classname#; /// * MVA_Method_YYY_Train_#classname#; /// * ... some plots ...; /// - TestTree (TTree); /// + ... data...; /// - TrainTree (TTree); /// + ... data...; ///; /// Keeping this in mind makes the main loop in getRocCurves easier to follow :); ///; ////////////////////////////////////////////////////////////////////////////////; /// Private class that simplify drawing plots combining information from; /// several methods.; ///; /// Each wrapper will manage a canvas and a legend and provide convenience; /// functions to add data to these. It also provides a save function for; /// saving an image representation to disk.; ///; /// Feel free to extend this class as you see fit. It is intended as a; /// convenience when showing multiclass roccurves, not a fully general tool.; ///; /// Usage:; /// auto p = new EfficiencyPlotWrapper(name, title, dataset, i):; /// for (TGraph * g : listOfGraphs) {; /// p->AddGraph(g);; /// p->AddLegendEntry(methodName);; /// }; /// p->save();; ///",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:1210,Modifiability,extend,extend,1210,"////////////////////////////////////////////////////////////////////////////////; ///; /// Note: This file assumes a certain structure on the input file. The structure; /// is as follows:; ///; /// - dataset (TDirectory); /// - ... some variables, plots ...; /// - Method_XXX (TDirectory); /// + XXX (TDirectory); /// * ... some plots ...; /// * MVA_Method_XXX_Test_#classname#; /// * MVA_Method_XXX_Train_#classname#; /// * ... some plots ...; /// - Method_YYY (TDirectory); /// + YYY (TDirectory); /// * ... some plots ...; /// * MVA_Method_YYY_Test_#classname#; /// * MVA_Method_YYY_Train_#classname#; /// * ... some plots ...; /// - TestTree (TTree); /// + ... data...; /// - TrainTree (TTree); /// + ... data...; ///; /// Keeping this in mind makes the main loop in getRocCurves easier to follow :); ///; ////////////////////////////////////////////////////////////////////////////////; /// Private class that simplify drawing plots combining information from; /// several methods.; ///; /// Each wrapper will manage a canvas and a legend and provide convenience; /// functions to add data to these. It also provides a save function for; /// saving an image representation to disk.; ///; /// Feel free to extend this class as you see fit. It is intended as a; /// convenience when showing multiclass roccurves, not a fully general tool.; ///; /// Usage:; /// auto p = new EfficiencyPlotWrapper(name, title, dataset, i):; /// for (TGraph * g : listOfGraphs) {; /// p->AddGraph(g);; /// p->AddLegendEntry(methodName);; /// }; /// p->save();; ///",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:637,Testability,Test,TestTree,637,"////////////////////////////////////////////////////////////////////////////////; ///; /// Note: This file assumes a certain structure on the input file. The structure; /// is as follows:; ///; /// - dataset (TDirectory); /// - ... some variables, plots ...; /// - Method_XXX (TDirectory); /// + XXX (TDirectory); /// * ... some plots ...; /// * MVA_Method_XXX_Test_#classname#; /// * MVA_Method_XXX_Train_#classname#; /// * ... some plots ...; /// - Method_YYY (TDirectory); /// + YYY (TDirectory); /// * ... some plots ...; /// * MVA_Method_YYY_Test_#classname#; /// * MVA_Method_YYY_Train_#classname#; /// * ... some plots ...; /// - TestTree (TTree); /// + ... data...; /// - TrainTree (TTree); /// + ... data...; ///; /// Keeping this in mind makes the main loop in getRocCurves easier to follow :); ///; ////////////////////////////////////////////////////////////////////////////////; /// Private class that simplify drawing plots combining information from; /// several methods.; ///; /// Each wrapper will manage a canvas and a legend and provide convenience; /// functions to add data to these. It also provides a save function for; /// saving an image representation to disk.; ///; /// Feel free to extend this class as you see fit. It is intended as a; /// convenience when showing multiclass roccurves, not a fully general tool.; ///; /// Usage:; /// auto p = new EfficiencyPlotWrapper(name, title, dataset, i):; /// for (TGraph * g : listOfGraphs) {; /// p->AddGraph(g);; /// p->AddLegendEntry(methodName);; /// }; /// p->save();; ///",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:915,Usability,simpl,simplify,915,"////////////////////////////////////////////////////////////////////////////////; ///; /// Note: This file assumes a certain structure on the input file. The structure; /// is as follows:; ///; /// - dataset (TDirectory); /// - ... some variables, plots ...; /// - Method_XXX (TDirectory); /// + XXX (TDirectory); /// * ... some plots ...; /// * MVA_Method_XXX_Test_#classname#; /// * MVA_Method_XXX_Train_#classname#; /// * ... some plots ...; /// - Method_YYY (TDirectory); /// + YYY (TDirectory); /// * ... some plots ...; /// * MVA_Method_YYY_Test_#classname#; /// * MVA_Method_YYY_Train_#classname#; /// * ... some plots ...; /// - TestTree (TTree); /// + ... data...; /// - TrainTree (TTree); /// + ... data...; ///; /// Keeping this in mind makes the main loop in getRocCurves easier to follow :); ///; ////////////////////////////////////////////////////////////////////////////////; /// Private class that simplify drawing plots combining information from; /// several methods.; ///; /// Each wrapper will manage a canvas and a legend and provide convenience; /// functions to add data to these. It also provides a save function for; /// saving an image representation to disk.; ///; /// Feel free to extend this class as you see fit. It is intended as a; /// convenience when showing multiclass roccurves, not a fully general tool.; ///; /// Usage:; /// auto p = new EfficiencyPlotWrapper(name, title, dataset, i):; /// for (TGraph * g : listOfGraphs) {; /// p->AddGraph(g);; /// p->AddLegendEntry(methodName);; /// }; /// p->save();; ///",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx:3,Modifiability,config,configure,3,"// configure buttons",MatchSource.CODE_COMMENT,tmva/tmvagui/src/efficienciesMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/efficienciesMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:100,Modifiability,variab,variables,100,"// this macro plots the reference distribuions for the Likelihood; // methods for the various input variables used in TMVA (e.g. running; // TMVAnalysis.C). Signal and Background are plotted separately; // input: - Input file (result from TMVA),; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/likelihoodrefs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:3,Safety,avoid,avoid,3,"// avoid duplicated printing",MatchSource.CODE_COMMENT,tmva/tmvagui/src/likelihoodrefs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:3,Safety,avoid,avoid,3,"// avoid duplicated plotting",MatchSource.CODE_COMMENT,tmva/tmvagui/src/likelihoodrefs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:9,Deployability,Update,Update,9,"//c[ic]->Update();",MatchSource.CODE_COMMENT,tmva/tmvagui/src/likelihoodrefs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/MovieMaker.cxx:28,Energy Efficiency,monitor,monitoring,28,"// loop over all epoch-wise monitoring histograms",MatchSource.CODE_COMMENT,tmva/tmvagui/src/MovieMaker.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/MovieMaker.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvaeffs.cxx:3,Deployability,update,update,3,"// update the text in the lower left corner",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvaeffs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvaeffs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvaeffs.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvaeffs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvaeffs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvas.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx:26,Performance,load,load,26,"// if overtraining check, load additional histograms",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvas.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx:3,Performance,perform,perform,3,"// perform K-S test",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvas.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx:15,Testability,test,test,15,"// perform K-S test",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvas.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx:3,Deployability,update,update,3,"// update canvas",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvas.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvas.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:29,Modifiability,variab,variable,29,"// find directory from input variable transformation and extract class names",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:26,Performance,load,load,26,"// if overtraining check, load additional histograms",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:3,Performance,perform,perform,3,"// perform K-S test",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:15,Testability,test,test,15,"// perform K-S test",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:40,Testability,test,test,40,"//TString probatext(""Kolmogorov-Smirnov test: "");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx:513,Deployability,update,update,513,"// text for overflows; //Int_t nbin = sig->GetNbinsX();; //Double_t dxu = sig->GetBinWidth(0);; //Double_t dxo = sig->GetBinWidth(nbin+1);; //TString uoflow = TString::Format( ""U/O-flow (S,B): (%.1f, %.1f)%% / (%.1f, %.1f)%%"",; // sig->GetBinContent(0)*dxu*100, bgd->GetBinContent(0)*dxu*100,; // sig->GetBinContent(nbin+1)*dxo*100, bgd->GetBinContent(nbin+1)*dxo*100 );; //TText* t = new TText( 0.975, 0.115, uoflow );; //t->SetNDC();; //t->SetTextSize( 0.030 );; //t->SetTextAngle( 90 );; //t->AppendPad();; // update canvas",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvasMulticlass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvasMulticlass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvaweights.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/mvaweights.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/mvaweights.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/PlotFoams.cxx:45,Integrability,message,message,45,"// loop over all foams and print out a debug message",MatchSource.CODE_COMMENT,tmva/tmvagui/src/PlotFoams.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/PlotFoams.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/PlotFoams.cxx:17,Modifiability,variab,variable,17,"// best division variable",MatchSource.CODE_COMMENT,tmva/tmvagui/src/PlotFoams.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/PlotFoams.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/probas.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/probas.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/probas.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/regression_averagedevs.cxx:124,Testability,test,test,124,"/*; this macro plots the quadratic deviation of the estimated from the target value, averaged over the first nevt events in test sample (all if Nevt=-1); a) normal average; b) truncated average, using best 90%; created January 2009, Eckhard von Toerne, University of Bonn, Germany; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/regression_averagedevs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/regression_averagedevs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/regression_averagedevs.cxx:34,Testability,test,test-all,34,"// h0 train-all, h1 train-90%, h2 test-all, h3 test-90%",MatchSource.CODE_COMMENT,tmva/tmvagui/src/regression_averagedevs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/regression_averagedevs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/regression_averagedevs.cxx:47,Testability,test,test-,47,"// h0 train-all, h1 train-90%, h2 test-all, h3 test-90%",MatchSource.CODE_COMMENT,tmva/tmvagui/src/regression_averagedevs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/regression_averagedevs.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevis.cxx:61,Modifiability,variab,variables,61,"// This macro plots the distributions of the different input variables overlaid on; // the sum of importance per bin.; // The scale goes from violett (no importance) to red (high importance).; // Areas where many important rules are active, will thus be very red.; //; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevis.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisCorr.cxx:61,Modifiability,variab,variables,61,"// This macro plots the distributions of the different input variables overlaid on; // the sum of importance per bin.; // The scale goes from violett (no importance) to red (high importance).; // Areas where many important rules are active, will thus be very red.; //; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevisCorr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisCorr.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisCorr.cxx:43,Modifiability,variab,variables,43,"// get top dir containing all hists of the variables; // TDirectory* vardir = (TDirectory*)file->Get( ""InputVariables_Id"" );; // TDirectory* vardir = TMVAGlob::GetInputVariablesDir( type );; // if (vardir==0) return;; // TDirectory* corrdir = TMVAGlob::GetCorrelationPlotsDir( type, vardir );; // if (corrdir==0) return;; // get all titles of the method rulefit",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevisCorr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisCorr.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisCorr.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevisCorr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisCorr.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisHists.cxx:61,Modifiability,variab,variables,61,"// This macro plots the distributions of the different input variables overlaid on; // the sum of importance per bin.; // The scale goes from violett (no importance) to red (high importance).; // Areas where many important rules are active, will thus be very red.; //; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevisHists.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisHists.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisHists.cxx:43,Modifiability,variab,variables,43,"// get top dir containing all hists of the variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevisHists.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisHists.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisHists.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/rulevisHists.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/rulevisHists.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx:15,Testability,log,logo,15,"// we like the logo to sit a bit above the histo",MatchSource.CODE_COMMENT,tmva/tmvagui/src/tmvaglob.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx:35,Modifiability,inherit,inheritance,35,"// get a list of keys with a given inheritance; // the list contains TKey objects",MatchSource.CODE_COMMENT,tmva/tmvagui/src/tmvaglob.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx:19,Modifiability,variab,variables,19,"// count number of variables (signal is sufficient), exclude target(s)",MatchSource.CODE_COMMENT,tmva/tmvagui/src/tmvaglob.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx:43,Modifiability,variab,variables,43,"// get top dir containing all hists of the variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/tmvaglob.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/tmvaglob.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx:56,Testability,test,test,56,"// for the sourceforge version, including $ROOTSYS/tmva/test in the; // macro path is a mistake, especially if ""./"" was not part of path; // add ../macros to the path (comment out next line for the ROOT version of TMVA); // gROOT->SetMacroPath(curMacroPath+"":../macros:"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx:3,Modifiability,config,configure,3,"// configure buttons",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx:18,Modifiability,variab,variables,18,"// find all input variables types",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx:179,Modifiability,variab,variables,179,"// ActionButton( cbar,; // TString::Format( ""(%i) Rule Ensemble Importance Plots (RuleFit)"", ++ic ),; // TString::Format( ""TMVA::rulevis(\""%s\"",0)"", fName ),; // ""Plots all input variables with rule ensemble weights, including linear terms (macro rulevis.cxx)"",; // buttonType, ""RuleFit"" );",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:56,Testability,test,test,56,"// for the sourceforge version, including $ROOTSYS/tmva/test in the; // macro path is a mistake, especially if ""./"" was not part of path; // add ../macros to the path (comment out next line for the ROOT version of TMVA); // gROOT->SetMacroPath(curMacroPath+"":../macros:"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:3,Modifiability,config,configure,3,"// configure buttons ",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:18,Modifiability,variab,variables,18,"// find all input variables types",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:74,Testability,test,test,74,"/*; title = TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kProbaType)"", fName ),; ""Plots the probability of each classifier for the test data (macro mvas(...,1))"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kRarityType)"", fName ),; ""Plots the Rarity of each classifier for the test data (macro mvas(...,2)) - background distribution should be; uniform"", buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%ia) Classifier Cut Efficiencies"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::mvaeffs(\""%s\"")"", fName ),; ""Plots signal and background efficiencies versus cut on classifier output (macro mvaeffs.cxx)"",; buttonType, defaultRequiredClassifier );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:189,Testability,test,test,189,"/*; title = TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kProbaType)"", fName ),; ""Plots the probability of each classifier for the test data (macro mvas(...,1))"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kRarityType)"", fName ),; ""Plots the Rarity of each classifier for the test data (macro mvas(...,2)) - background distribution should be; uniform"", buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%ia) Classifier Cut Efficiencies"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::mvaeffs(\""%s\"")"", fName ),; ""Plots signal and background efficiencies versus cut on classifier output (macro mvaeffs.cxx)"",; buttonType, defaultRequiredClassifier );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:327,Testability,test,test,327,"/*; title = TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kProbaType)"", fName ),; ""Plots the probability of each classifier for the test data (macro mvas(...,1))"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kRarityType)"", fName ),; ""Plots the Rarity of each classifier for the test data (macro mvas(...,2)) - background distribution should be; uniform"", buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%ia) Classifier Cut Efficiencies"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::mvaeffs(\""%s\"")"", fName ),; ""Plots signal and background efficiencies versus cut on classifier output (macro mvaeffs.cxx)"",; buttonType, defaultRequiredClassifier );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:466,Testability,test,test,466,"/*; title = TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kProbaType)"", fName ),; ""Plots the probability of each classifier for the test data (macro mvas(...,1))"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kRarityType)"", fName ),; ""Plots the Rarity of each classifier for the test data (macro mvas(...,2)) - background distribution should be; uniform"", buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%ia) Classifier Cut Efficiencies"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::mvaeffs(\""%s\"")"", fName ),; ""Plots signal and background efficiencies versus cut on classifier output (macro mvaeffs.cxx)"",; buttonType, defaultRequiredClassifier );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:576,Testability,test,test,576,"/*; title = TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kProbaType)"", fName ),; ""Plots the probability of each classifier for the test data (macro mvas(...,1))"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kRarityType)"", fName ),; ""Plots the Rarity of each classifier for the test data (macro mvas(...,2)) - background distribution should be; uniform"", buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%ia) Classifier Cut Efficiencies"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::mvaeffs(\""%s\"")"", fName ),; ""Plots signal and background efficiencies versus cut on classifier output (macro mvaeffs.cxx)"",; buttonType, defaultRequiredClassifier );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:710,Testability,test,test,710,"/*; title = TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%ic) Classifier Probability Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kProbaType)"", fName ),; ""Plots the probability of each classifier for the test data (macro mvas(...,1))"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic );; MultiClassActionButton( cbar,; TString::Format( ""(%id) Classifier Rarity Distributions (test sample)"", ic ),; TString::Format( ""TMVA::mvas(\""%s\"",TMVA::kRarityType)"", fName ),; ""Plots the Rarity of each classifier for the test data (macro mvas(...,2)) - background distribution should be; uniform"", buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%ia) Classifier Cut Efficiencies"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::mvaeffs(\""%s\"")"", fName ),; ""Plots signal and background efficiencies versus cut on classifier output (macro mvaeffs.cxx)"",; buttonType, defaultRequiredClassifier );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:678,Modifiability,variab,variables,678,"// title = TString::Format(""(%i) Classifier (1/Backgr. Rejection) vs Sig. Eff. (1-vs-1 ROC curve)"", ++ic);; // MultiClassActionButton(cbar, title, TString::Format(""TMVA::efficienciesMulticlass(\""%s\"", \""%s\"")"", dataset.Data(), fName),; // ""Plots background rejection vs signal efficiencies (macro efficiencies.cxx) [\""ROC\"" stands; // ""; // ""for \""Receiver Operation Characteristics\""]"",; // buttonType, defaultRequiredClassifier);; /*; title = TString::Format( ""(%i) Parallel Coordinates (requires ROOT-version >= 5.17)"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::paracoor(\""%s\"")"", fName ),; ""Plots parallel coordinates for classifiers and input variables (macro paracoor.cxx, requires ROOT >= 5.17)"",; buttonType, defaultRequiredClassifier );. title =TString::Format( ""(%i) PDFs of Classifiers (requires \""CreateMVAPdfs\"" option set)"", ++ic );; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::probas(\""%s\"")"", fName ),; ""Plots the PDFs of the classifier output distributions for signal and background - if requested (macro probas.cxx)"",; buttonType, defaultRequiredClassifier );. title = TString::Format( ""(%i) Likelihood Reference Distributiuons"", ++ic);; MultiClassActionButton( cbar,; title,; TString::Format( ""TMVA::likelihoodrefs(\""%s\"")"", fName ),; ""Plots to verify the likelihood reference distributions (macro likelihoodrefs.cxx)"",; buttonType, ""Likelihood"" );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:190,Energy Efficiency,monitor,monitor,190,"/*; title = TString::Format( ""(%i) Decision Tree Control Plots (BDT)"", ++ic );; MultiClassActionButton( cbar, ; title,; TString::Format( ""TMVA::BDTControlPlots(\""%s\"")"", fName ),; ""Plots to monitor boosting and pruning of decision trees (macro BDTControlPlots.cxx)"",; buttonType, ""BDT"" );. */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx:186,Energy Efficiency,monitor,monitor,186,"/*; title = TString::Format( ""(%i) General Boost Control Plots"", ++ic );; MultiClassActionButton( cbar, ; title,; TString::Format( ""TMVA::BoostControlPlots(\""%s\"")"", fName ),; ""Plots to monitor boosting of general classifiers (macro BoostControlPlots.cxx)"",; buttonType, ""Boost"" );; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVAMultiClassGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVAMultiClassGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVARegGui.cxx:56,Testability,test,test,56,"// for the sourceforge version, including $ROOTSYS/tmva/test in the; // macro path is a mistake, especially if ""./"" was not part of path; // add ../macros to the path (comment out next line for the ROOT version of TMVA); // gROOT->SetMacroPath(curMacroPath+"":../macros:"");",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVARegGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVARegGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVARegGui.cxx:3,Modifiability,config,configure,3,"// configure buttons ",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVARegGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVARegGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVARegGui.cxx:18,Modifiability,variab,variables,18,"// find all input variables types",MatchSource.CODE_COMMENT,tmva/tmvagui/src/TMVARegGui.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/TMVARegGui.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/training_history.cxx:57,Performance,tune,tuned,57,"// rescale legend box size; // current box size has been tuned for 3 MVAs + 1 title",MatchSource.CODE_COMMENT,tmva/tmvagui/src/training_history.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/training_history.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variables.cxx:61,Modifiability,variab,variables,61,"// this macro plots the distributions of the different input variables; // used in TMVA (e.g. running TMVAnalysis.C). Signal and Background are overlayed.; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variables.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variables.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variables.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variables.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variables.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx:61,Modifiability,variab,variables,61,"// this macro plots the distributions of the different input variables; // used in TMVA (e.g. running TMVAnalysis.C). Signal and Background are overlayed.; // input: - Input file (result from TMVA),; // - normal/decorrelated/PCA; // - use of TMVA plotting TStyle",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variablesMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx:11,Modifiability,variab,variables,11,"// counter variables",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variablesMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx:84,Availability,Avail,Available,84,"/*; std::vector<TString>::const_iterator variter = varnames.begin();; std::cout << ""Available variables:"" << std::endl;; while(variter != varnames.end()){; std::cout << *variter << std::endl;; variter++;; }; ; std::vector<TString>::const_iterator classiter = classnames.begin();; std::cout << ""Available classes:"" << std::endl;; while(classiter != classnames.end()){; std::cout << *classiter << std::endl;; classiter++;; }; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variablesMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx:294,Availability,Avail,Available,294,"/*; std::vector<TString>::const_iterator variter = varnames.begin();; std::cout << ""Available variables:"" << std::endl;; while(variter != varnames.end()){; std::cout << *variter << std::endl;; variter++;; }; ; std::vector<TString>::const_iterator classiter = classnames.begin();; std::cout << ""Available classes:"" << std::endl;; while(classiter != classnames.end()){; std::cout << *classiter << std::endl;; classiter++;; }; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variablesMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx:94,Modifiability,variab,variables,94,"/*; std::vector<TString>::const_iterator variter = varnames.begin();; std::cout << ""Available variables:"" << std::endl;; while(variter != varnames.end()){; std::cout << *variter << std::endl;; variter++;; }; ; std::vector<TString>::const_iterator classiter = classnames.begin();; std::cout << ""Available classes:"" << std::endl;; while(classiter != classnames.end()){; std::cout << *classiter << std::endl;; classiter++;; }; */",MatchSource.CODE_COMMENT,tmva/tmvagui/src/variablesMultiClass.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/variablesMultiClass.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx:29,Energy Efficiency,consumption,consumption,29,"// marks the progress of the consumption of the csv lines",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RCsvDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx:55,Safety,avoid,avoid,55,"// one per column per slot; // This must be a deque to avoid the specialisation vector<bool>. This would not; // work given that the pointer to the boolean in that case cannot be taken",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RCsvDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataFrame.hxx:525,Integrability,interface,interface,525,"// Author: Enrico Guiraud, Danilo Piparo CERN 12/2016; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup dataframe Dataframe; ROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataFrame.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataFrame.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:163,Performance,perform,performed,163,"/// Mother class of TTypedPointerHolder. The instances; /// of this class can be put in a container. Upon destruction,; /// the correct deletion of the pointer is performed in the; /// derived class.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:13,Integrability,wrap,wrap,13,"/// Class to wrap a pointer and delete the memory associated to it; /// correctly",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:303,Energy Efficiency,adapt,adaptor,303,"// clang-format off; /**; \class ROOT::RDF::RDataSource; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are cal",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:224,Modifiability,inherit,inherits,224,"// clang-format off; /**; \class ROOT::RDF::RDataSource; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are cal",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:303,Modifiability,adapt,adaptor,303,"// clang-format off; /**; \class ROOT::RDF::RDataSource; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are cal",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:2345,Modifiability,inherit,inheritance,2345,"nformation about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are called once per event-loop, right before starting and right after finishing.; - \b InitSlot(), \b SetEntry(), and \b FinalizeSlot() can be called concurrently from multiple threads, multiple times per event-loop. Advanced users that plan to implement a custom RDataSource can check out existing implementations, e.g. RCsvDS or RNTupleDS.; See the inheritance diagram below for the full list of existing concrete implementations.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:655,Performance,perform,performs,655,"// clang-format off; /**; \class ROOT::RDF::RDataSource; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are cal",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:1018,Performance,concurren,concurrently,1018,"Source; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are called once per event-loop, right before starting an",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:1943,Performance,concurren,concurrently,1943,"nformation about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are called once per event-loop, right before starting and right after finishing.; - \b InitSlot(), \b SetEntry(), and \b FinalizeSlot() can be called concurrently from multiple threads, multiple times per event-loop. Advanced users that plan to implement a custom RDataSource can check out existing implementations, e.g. RCsvDS or RNTupleDS.; See the inheritance diagram below for the full list of existing concrete implementations.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:2144,Performance,concurren,concurrently,2144,"nformation about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are called once per event-loop, right before starting and right after finishing.; - \b InitSlot(), \b SetEntry(), and \b FinalizeSlot() can be called concurrently from multiple threads, multiple times per event-loop. Advanced users that plan to implement a custom RDataSource can check out existing implementations, e.g. RCsvDS or RNTupleDS.; See the inheritance diagram below for the full list of existing concrete implementations.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:312,Performance,concurren,concurrently,312,"// clang-format off; /// \brief Inform RDataSource of the number of processing slots (i.e. worker threads) used by the associated RDataFrame.; /// Slots numbers are used to simplify parallel execution: RDataFrame guarantees that different threads will always; /// pass different slot values when calling methods concurrently.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:173,Usability,simpl,simplify,173,"// clang-format off; /// \brief Inform RDataSource of the number of processing slots (i.e. worker threads) used by the associated RDataFrame.; /// Slots numbers are used to simplify parallel execution: RDataFrame guarantees that different threads will always; /// pass different slot values when calling methods concurrently.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDataSource.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:469,Availability,down,down,469,"// Author: Enrico Guiraud, Danilo Piparo CERN 02/2018; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // This header contains helper free functions that slim down RDataFrame's programming model",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:296,Integrability,interoperab,interoperability,296,"// clang-format off; /// Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result; ///; /// The callable must have one single non-template definition of operator(). This is a limitation with respect to; /// std::not_fn, required for interoperability with RDataFrame.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:236,Availability,down,down,236,"// clang-format off; /// PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection.; ///; /// PassAsVec<N, T>(func) returns a callable that takes N arguments of type T, passes them down to function `func` as; /// an initializer list `{t1, t2, t3,..., tN}` and returns whatever f({t1, t2, t3, ..., tN}) returns.; ///; /// Note that for this to work with RDataFrame the type of all columns that the callable is applied to must be exactly T.; /// Example usage together with RDataFrame (""varX"" columns must all be `float` variables):; /// \code; /// bool myVecFunc(std::vector<float> args);; /// df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});; /// \endcode; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:81,Modifiability,variab,variables,81,"// clang-format off; /// PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection.; ///; /// PassAsVec<N, T>(func) returns a callable that takes N arguments of type T, passes them down to function `func` as; /// an initializer list `{t1, t2, t3,..., tN}` and returns whatever f({t1, t2, t3, ..., tN}) returns.; ///; /// Note that for this to work with RDataFrame the type of all columns that the callable is applied to must be exactly T.; /// Example usage together with RDataFrame (""varX"" columns must all be `float` variables):; /// \code; /// bool myVecFunc(std::vector<float> args);; /// df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});; /// \endcode; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:574,Modifiability,variab,variables,574,"// clang-format off; /// PassAsVec is a callable generator that allows passing N variables of type T to a function as a single collection.; ///; /// PassAsVec<N, T>(func) returns a callable that takes N arguments of type T, passes them down to function `func` as; /// an initializer list `{t1, t2, t3,..., tN}` and returns whatever f({t1, t2, t3, ..., tN}) returns.; ///; /// Note that for this to work with RDataFrame the type of all columns that the callable is applied to must be exactly T.; /// Example usage together with RDataFrame (""varX"" columns must all be `float` variables):; /// \code; /// bool myVecFunc(std::vector<float> args);; /// df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});; /// \endcode; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:447,Availability,down,downstream,447,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, return it as a string.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:529,Performance,optimiz,optimized,529,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, return it as a string.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:644,Performance,concurren,concurrently,644,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, return it as a string.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:616,Safety,safe,safe,616,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, return it as a string.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:522,Availability,down,downstream,522,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; /// \param[in] outputFile file where to save the representation.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:604,Performance,optimiz,optimized,604,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; /// \param[in] outputFile file where to save the representation.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:719,Performance,concurren,concurrently,719,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; /// \param[in] outputFile file where to save the representation.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:691,Safety,safe,safe,691,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; /// \param[in] outputFile file where to save the representation.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:550,Energy Efficiency,efficient,efficient,550,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:72,Performance,concurren,concurrently,72,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:463,Performance,concurren,concurrently,463,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:708,Performance,concurren,concurrently,708,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:695,Safety,safe,safe,695,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:400,Security,access,accessing,400,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:279,Availability,down,down,279,"/// \brief Produce all required systematic variations for the given result.; /// \param[in] resPtr The result for which variations should be produced.; /// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; /// (e.g. ""pt:down"") and the corresponding varied results as values.; ///; /// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; /// key that will return a value identical to the one contained in the original RResultPtr.; /// Other keys correspond to the varied values of this result, one for each variation; /// that the result depends on.; /// VariationsFor does not trigger the event loop. The event loop is only triggered; /// upon first access to a valid key, similarly to what happens with RResultPtr.; ///; /// If the result does not depend, directly or indirectly, from any registered systematic variation, the; /// returned RResultMap will contain only the ""nominal"" key.; ///; /// See RDataFrame's \ref ROOT::RDF::RInterface::Vary() ""Vary"" method for more information and example usages.; ///; /// \note Currently, producing variations for the results of \ref ROOT::RDF::RInterface::Display() ""Display"",; /// \ref ROOT::RDF::RInterface::Report() ""Report"" and \ref ROOT::RDF::RInterface::Snapshot() ""Snapshot""; /// actions is not supported.; //; // An overview of how systematic variations work internally. Given N variations (including the nominal):; //; // RResultMap owns RVariedAction; // N results N action helpers; // N previous filters; // N*#input_cols column readers; //; // ...and each RFilter and RDefine knows for what universe it needs to construct column readers (""nominal"" by default).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:629,Integrability,depend,depends,629,"/// \brief Produce all required systematic variations for the given result.; /// \param[in] resPtr The result for which variations should be produced.; /// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; /// (e.g. ""pt:down"") and the corresponding varied results as values.; ///; /// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; /// key that will return a value identical to the one contained in the original RResultPtr.; /// Other keys correspond to the varied values of this result, one for each variation; /// that the result depends on.; /// VariationsFor does not trigger the event loop. The event loop is only triggered; /// upon first access to a valid key, similarly to what happens with RResultPtr.; ///; /// If the result does not depend, directly or indirectly, from any registered systematic variation, the; /// returned RResultMap will contain only the ""nominal"" key.; ///; /// See RDataFrame's \ref ROOT::RDF::RInterface::Vary() ""Vary"" method for more information and example usages.; ///; /// \note Currently, producing variations for the results of \ref ROOT::RDF::RInterface::Display() ""Display"",; /// \ref ROOT::RDF::RInterface::Report() ""Report"" and \ref ROOT::RDF::RInterface::Snapshot() ""Snapshot""; /// actions is not supported.; //; // An overview of how systematic variations work internally. Given N variations (including the nominal):; //; // RResultMap owns RVariedAction; // N results N action helpers; // N previous filters; // N*#input_cols column readers; //; // ...and each RFilter and RDefine knows for what universe it needs to construct column readers (""nominal"" by default).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:841,Integrability,depend,depend,841,"/// \brief Produce all required systematic variations for the given result.; /// \param[in] resPtr The result for which variations should be produced.; /// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; /// (e.g. ""pt:down"") and the corresponding varied results as values.; ///; /// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; /// key that will return a value identical to the one contained in the original RResultPtr.; /// Other keys correspond to the varied values of this result, one for each variation; /// that the result depends on.; /// VariationsFor does not trigger the event loop. The event loop is only triggered; /// upon first access to a valid key, similarly to what happens with RResultPtr.; ///; /// If the result does not depend, directly or indirectly, from any registered systematic variation, the; /// returned RResultMap will contain only the ""nominal"" key.; ///; /// See RDataFrame's \ref ROOT::RDF::RInterface::Vary() ""Vary"" method for more information and example usages.; ///; /// \note Currently, producing variations for the results of \ref ROOT::RDF::RInterface::Display() ""Display"",; /// \ref ROOT::RDF::RInterface::Report() ""Report"" and \ref ROOT::RDF::RInterface::Snapshot() ""Snapshot""; /// actions is not supported.; //; // An overview of how systematic variations work internally. Given N variations (including the nominal):; //; // RResultMap owns RVariedAction; // N results N action helpers; // N previous filters; // N*#input_cols column readers; //; // ...and each RFilter and RDefine knows for what universe it needs to construct column readers (""nominal"" by default).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:742,Security,access,access,742,"/// \brief Produce all required systematic variations for the given result.; /// \param[in] resPtr The result for which variations should be produced.; /// \return A \ref ROOT::RDF::Experimental::RResultMap ""RResultMap"" object with full variation names as strings; /// (e.g. ""pt:down"") and the corresponding varied results as values.; ///; /// A given input RResultPtr<T> produces a corresponding RResultMap<T> with a ""nominal""; /// key that will return a value identical to the one contained in the original RResultPtr.; /// Other keys correspond to the varied values of this result, one for each variation; /// that the result depends on.; /// VariationsFor does not trigger the event loop. The event loop is only triggered; /// upon first access to a valid key, similarly to what happens with RResultPtr.; ///; /// If the result does not depend, directly or indirectly, from any registered systematic variation, the; /// returned RResultMap will contain only the ""nominal"" key.; ///; /// See RDataFrame's \ref ROOT::RDF::RInterface::Vary() ""Vary"" method for more information and example usages.; ///; /// \note Currently, producing variations for the results of \ref ROOT::RDF::RInterface::Display() ""Display"",; /// \ref ROOT::RDF::RInterface::Report() ""Report"" and \ref ROOT::RDF::RInterface::Snapshot() ""Snapshot""; /// actions is not supported.; //; // An overview of how systematic variations work internally. Given N variations (including the nominal):; //; // RResultMap owns RVariedAction; // N results N action helpers; // N previous filters; // N*#input_cols column readers; //; // ...and each RFilter and RDefine knows for what universe it needs to construct column readers (""nominal"" by default).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:32,Modifiability,inherit,inherits,32,"// Check if the result's type T inherits from TNamed",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:32,Integrability,inject,inject,32,"// Create the RVariedAction and inject it in the computation graph.; // This recursively creates all the required varied column readers and upstream nodes of the computation graph.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:32,Security,inject,inject,32,"// Create the RVariedAction and inject it in the computation graph.; // This recursively creates all the required varied column readers and upstream nodes of the computation graph.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:429,Safety,safe,safe,429,"/// RDF progress helper.; /// This class provides callback functions to the RDataFrame. The event statistics; /// (including elapsed time, currently processed file, currently processed events, the rate of event processing; /// and an estimated remaining time (per file being processed)); /// are recorded and printed in the terminal every m events and every n seconds.; /// ProgressHelper::operator()(unsigned int, T&) is thread safe, and can be used as a callback in MT mode.; /// ProgressBar should be added after creating the dataframe object (df):; /// ~~~{.cpp}; /// ROOT::RDataFrame df(""tree"", ""file.root"");; /// ROOT::RDF::Experimental::AddProgressBar(df);; /// ~~~; /// alternatively RDataFrame can be cast to an RNode first giving it more flexibility.; /// For example, it can be called at any computational node, such as Filter or Define, not only the head node,; /// with no change to the ProgressBar function itself:; /// ~~~{.cpp}; /// ROOT::RDataFrame df(""tree"", ""file.root"");; /// auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; /// ROOT::RDF::Experimental::AddProgressBar(df_1);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:283,Deployability,Update,Update,283,"/// Create a progress helper.; /// \param increment RDF callbacks are called every `n` events. Pass this `n` here.; /// \param totalFiles read total number of files in the RDF.; /// \param progressBarWidth Number of characters the progress bar will occupy.; /// \param printInterval Update every stats every `n` seconds.; /// \param useColors Use shell colour codes to colour the output. Automatically disabled when; /// we are not writing to a tty.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:231,Usability,progress bar,progress bar,231,"/// Create a progress helper.; /// \param increment RDF callbacks are called every `n` events. Pass this `n` here.; /// \param totalFiles read total number of files in the RDF.; /// \param progressBarWidth Number of characters the progress bar will occupy.; /// \param printInterval Update every stats every `n` seconds.; /// \param useColors Use shell colour codes to colour the output. Automatically disabled when; /// we are not writing to a tty.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:657,Usability,simpl,simply,657,"/// Register a new sample for completion statistics.; /// \see ROOT::RDF::RInterface::DefinePerSample().; /// The *id.AsString()* refers to the name of the currently processed file.; /// The idea is to populate the event entries in the *fSampleNameToEventEntries* map; /// by selecting the greater of the two values:; /// *id.EntryRange().second* which is the upper event entry range of the processed sample; /// and the current value of the event entries in the *fSampleNameToEventEntries* map.; /// In the single threaded case, the two numbers are the same as the entry range corresponds; /// to the number of events in an individual file (each sample is simply a single file).; /// In the multithreaded case, the idea is to accumulate the higher event entry value until; /// the total number of events in a given file is reached.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:11,Safety,safe,safe,11,"/// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; /// fPrintInterval). \param slot Ignored. \param value Ignored.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:109,Usability,progress bar,progress bar,109,"/// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; /// fPrintInterval). \param slot Ignored. \param value Ignored.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:32,Safety,safe,safe,32,"// clang-format off; /// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; /// \param value Ignored.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:130,Usability,progress bar,progress bar,130,"// clang-format off; /// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; /// \param value Ignored.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:104,Safety,safe,safe,104,"// ***************************************************; // Warning: Here, everything needs to be thread safe:; // ***************************************************",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDFHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:283,Usability,Feedback,Feedback,283,"/// \file RNTupleDS.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Enrico Guiraud <enrico.guiraud@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RNTupleDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:488,Availability,avail,available,488,"/// The staging area is relevant for chains of files, i.e. when fFileNames is not empty. In this case,; /// files are opened in the background in batches of size `fNSlots` and kept in the staging area.; /// The first file (chains or no chains) is always opened on construction in order to process the schema.; /// For all subsequent files, the corresponding page sources in the staging area only executed `LoadStructure()`,; /// i.e. they should have a compressed buffer of the meta-data available.; /// Concretely:; /// 1. We open the first file on construction to read the schema and then move the corresponding page source; /// in the staging area.; /// 2. On `Initialize()`, we start the I/O background thread, which in turn opens the first batch of files.; /// 3. At the beginning of `GetEntryRanges()`, we; /// a) wait for the I/O thread to finish,; /// b) call `PrepareNextRanges()` in the main thread to move the page sources from the staging area; /// into `fNextRanges`; this will also call `Attach()` on the page sources (i.e., deserialize the meta-data),; /// and; /// c) trigger staging of the next batch of files in the I/O background thread.; /// 4. On `Finalize()`, the I/O background thread is stopped.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RNTupleDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:406,Performance,Load,LoadStructure,406,"/// The staging area is relevant for chains of files, i.e. when fFileNames is not empty. In this case,; /// files are opened in the background in batches of size `fNSlots` and kept in the staging area.; /// The first file (chains or no chains) is always opened on construction in order to process the schema.; /// For all subsequent files, the corresponding page sources in the staging area only executed `LoadStructure()`,; /// i.e. they should have a compressed buffer of the meta-data available.; /// Concretely:; /// 1. We open the first file on construction to read the schema and then move the corresponding page source; /// in the staging area.; /// 2. On `Initialize()`, we start the I/O background thread, which in turn opens the first batch of files.; /// 3. At the beginning of `GetEntryRanges()`, we; /// a) wait for the I/O thread to finish,; /// b) call `PrepareNextRanges()` in the main thread to move the page sources from the staging area; /// into `fNextRanges`; this will also call `Attach()` on the page sources (i.e., deserialize the meta-data),; /// and; /// c) trigger staging of the next batch of files in the I/O background thread.; /// 4. On `Finalize()`, the I/O background thread is stopped.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RNTupleDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:149,Availability,avail,available,149,"/// Starting from `fNextFileIndex`, opens the next `fNSlots` files. Calls `LoadStructure()` on the opened files.; /// The very first file is already available from the constructor.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RNTupleDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:75,Performance,Load,LoadStructure,75,"/// Starting from `fNextFileIndex`, opens the next `fNSlots` files. Calls `LoadStructure()` on the opened files.; /// The very first file is already available from the constructor.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RNTupleDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:159,Energy Efficiency,schedul,scheduling,159,"/// Populates fNextRanges with the next set of entry ranges. Moves files from the staging area as necessary; /// and aligns ranges with cluster boundaries for scheduling the tail of files.; /// Upon return, the fNextRanges list is ordered. It has usually fNSlots elements; fewer if there; /// is not enough work to give at least one cluster to every slot.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RNTupleDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:289,Security,access,access,289,"/// \brief A type-erased version of RResultPtr and RResultMap.; /// RResultHandles are used to invoke ROOT::RDF::RunGraphs() and can also be useful; /// to store result pointers of different types in the same collection. Knowledge; /// about the actual result type will still be needed to access it.; /// \note Varied results are stripped away when a RResultMap is converted to a RResultHandle:; /// Only the nominal result will be accessible from the RResultHandle.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:432,Security,access,accessible,432,"/// \brief A type-erased version of RResultPtr and RResultMap.; /// RResultHandles are used to invoke ROOT::RDF::RunGraphs() and can also be useful; /// to store result pointers of different types in the same collection. Knowledge; /// about the actual result type will still be needed to access it.; /// \note Varied results are stripped away when a RResultMap is converted to a RResultHandle:; /// Only the nominal result will be accessible from the RResultHandle.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:50,Integrability,wrap,wrapped,50,"///< Type erased shared pointer encapsulating the wrapped result; /// Owning pointer to the varied action that will produce these results if any.; /// Null if the RResultHandle was created from a RResultPtr, so no variations were present.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:17,Integrability,wrap,wrapped,17,"///< Type of the wrapped result; // The ROOT::RDF::RunGraphs helper has to access the loop manager to check whether two RResultHandles belong to the same computation graph",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:75,Security,access,access,75,"///< Type of the wrapped result; // The ROOT::RDF::RunGraphs helper has to access the loop manager to check whether two RResultHandles belong to the same computation graph",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:42,Integrability,wrap,wrapped,42,"/// Compare given type to the type of the wrapped result and throw if the types don't match.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:197,Security,access,access,197,"/// Check whether the result has already been computed; ///; /// ~~~{.cpp}; /// std::vector<RResultHandle> results;; /// results.emplace_back(df.Mean<double>(""var""));; /// res.IsReady(); // false, access will trigger event loop; /// std::cout << res.GetValue<double>() << std::endl; // triggers event loop; /// res.IsReady(); // true; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultHandle.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:780,Availability,error,error,780,"/// Smart pointer for the return type of actions; /**; \class ROOT::RDF::RResultPtr; \ingroup dataframe; \brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; \tparam T Type of the action result. A smart pointer which allows to access the result of a RDataFrame action. The; methods of the encapsulated object can be accessed via the arrow operator.; Upon invocation of the arrow operator or dereferencing (`operator*`), the; loop on the events and calculations of all scheduled actions are executed; if needed.; It is possible to iterate on the result proxy if the proxied object is a collection.; ~~~{.cpp}; for (auto& myItem : myResultProxy) { ... };; ~~~; If iteration is not supported by the type of the proxied object, a compilation error is thrown. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:510,Energy Efficiency,schedul,scheduled,510,"/// Smart pointer for the return type of actions; /**; \class ROOT::RDF::RResultPtr; \ingroup dataframe; \brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; \tparam T Type of the action result. A smart pointer which allows to access the result of a RDataFrame action. The; methods of the encapsulated object can be accessed via the arrow operator.; Upon invocation of the arrow operator or dereferencing (`operator*`), the; loop on the events and calculations of all scheduled actions are executed; if needed.; It is possible to iterate on the result proxy if the proxied object is a collection.; ~~~{.cpp}; for (auto& myItem : myResultProxy) { ... };; ~~~; If iteration is not supported by the type of the proxied object, a compilation error is thrown. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:114,Integrability,wrap,wrapper,114,"/// Smart pointer for the return type of actions; /**; \class ROOT::RDF::RResultPtr; \ingroup dataframe; \brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; \tparam T Type of the action result. A smart pointer which allows to access the result of a RDataFrame action. The; methods of the encapsulated object can be accessed via the arrow operator.; Upon invocation of the arrow operator or dereferencing (`operator*`), the; loop on the events and calculations of all scheduled actions are executed; if needed.; It is possible to iterate on the result proxy if the proxied object is a collection.; ~~~{.cpp}; for (auto& myItem : myResultProxy) { ... };; ~~~; If iteration is not supported by the type of the proxied object, a compilation error is thrown. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:269,Security,access,access,269,"/// Smart pointer for the return type of actions; /**; \class ROOT::RDF::RResultPtr; \ingroup dataframe; \brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; \tparam T Type of the action result. A smart pointer which allows to access the result of a RDataFrame action. The; methods of the encapsulated object can be accessed via the arrow operator.; Upon invocation of the arrow operator or dereferencing (`operator*`), the; loop on the events and calculations of all scheduled actions are executed; if needed.; It is possible to iterate on the result proxy if the proxied object is a collection.; ~~~{.cpp}; for (auto& myItem : myResultProxy) { ... };; ~~~; If iteration is not supported by the type of the proxied object, a compilation error is thrown. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:358,Security,access,accessed,358,"/// Smart pointer for the return type of actions; /**; \class ROOT::RDF::RResultPtr; \ingroup dataframe; \brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; \tparam T Type of the action result. A smart pointer which allows to access the result of a RDataFrame action. The; methods of the encapsulated object can be accessed via the arrow operator.; Upon invocation of the arrow operator or dereferencing (`operator*`), the; loop on the events and calculations of all scheduled actions are executed; if needed.; It is possible to iterate on the result proxy if the proxied object is a collection.; ~~~{.cpp}; for (auto& myItem : myResultProxy) { ... };; ~~~; If iteration is not supported by the type of the proxied object, a compilation error is thrown. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:38,Integrability,wrap,wrapped,38,"///< Shared pointer encapsulating the wrapped result; /// Owning pointer to the action that will produce this result.; /// Ownership is shared with other copies of this ResultPtr.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:35,Security,access,access,35,"///< Convenience alias to simplify access to proxied type",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:26,Usability,simpl,simplify,26,"///< Convenience alias to simplify access to proxied type",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:110,Availability,error,error,110,"/// Return an iterator to the beginning of the contained object if this makes; /// sense, throw a compilation error otherwise",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:104,Availability,error,error,104,"/// Return an iterator to the end of the contained object if this makes; /// sense, throw a compilation error otherwise",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1863,Availability,avail,available,1863,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1235,Deployability,Update,Update,1235,"r; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// The callback must be a callable (lambda, function, functor class...) that takes a reference to the result type as; /// argument and returns nothing. RDataFrame will invoke registered callbacks passing partial action results as; /// arguments to them (e.g. a histogram filled with a part of the selected events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": p",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:2050,Performance,multi-thread,multi-threading,2050,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:2142,Performance,concurren,concurrently,2142,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:2285,Performance,multi-thread,multi-thread,2285,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:2668,Performance,concurren,concurrently,2668,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:2179,Safety,safe,safe,2179,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:96,Performance,concurren,concurrently,96,"// clang-format off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // cla",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:827,Performance,concurren,concurrently,827,"// clang-format off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // cla",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:963,Performance,multi-thread,multi-thread,963,"rmat off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1124,Performance,concurren,concurrently,1124,"rmat off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:874,Safety,safe,safe,874,"rmat off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1052,Safety,safe,safe,1052,"rmat off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1338,Safety,safe,safe,1338,"t off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1909,Security,access,accessing,1909,"t off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1028,Usability,simpl,simplify,1028,"rmat off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:1343,Usability,progress bar,progress bar,1343,"t off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:154,Security,access,access,154,"// clang-format off; /// Check whether the result has already been computed; ///; /// ~~~{.cpp}; /// auto res = df.Count();; /// res.IsReady(); // false, access will trigger event loop; /// std::cout << *res << std::endl; // triggers event loop; /// res.IsReady(); // true; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:139,Security,access,access,139,"/// Create a RResultPtr and set its pointer to the corresponding RAction; /// This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:277,Integrability,wrap,wrapped,277,"////////////////////////////////////////////////////////////////////////////////; /// \brief Retrieve a mergeable value from an RDataFrame action.; /// \param[in] rptr lvalue reference of an RResultPtr object.; /// \returns An RMergeableValue holding the result of the action, wrapped in an; /// `std::unique_ptr`.; ///; /// This function triggers the execution of the RDataFrame computation graph.; /// Then retrieves an RMergeableValue object created with the result wrapped by; /// the RResultPtr argument. The user obtains ownership of the mergeable, which; /// in turn holds a copy of the result of the action. The RResultPtr is not; /// destroyed in the process and will still retain (shared) ownership of the; /// original result.; ///; /// Example usage:; /// ~~~{.cpp}; /// using namespace ROOT::Detail::RDF;; /// ROOT::RDataFrame d(""myTree"", ""file_*.root"");; /// auto h = d.Histo1D(""Branch_A"");; /// auto mergeablehisto = GetMergeableValue(h);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:469,Integrability,wrap,wrapped,469,"////////////////////////////////////////////////////////////////////////////////; /// \brief Retrieve a mergeable value from an RDataFrame action.; /// \param[in] rptr lvalue reference of an RResultPtr object.; /// \returns An RMergeableValue holding the result of the action, wrapped in an; /// `std::unique_ptr`.; ///; /// This function triggers the execution of the RDataFrame computation graph.; /// Then retrieves an RMergeableValue object created with the result wrapped by; /// the RResultPtr argument. The user obtains ownership of the mergeable, which; /// in turn holds a copy of the result of the action. The RResultPtr is not; /// destroyed in the process and will still retain (shared) ownership of the; /// original result.; ///; /// Example usage:; /// ~~~{.cpp}; /// using namespace ROOT::Detail::RDF;; /// ROOT::RDataFrame d(""myTree"", ""file_*.root"");; /// auto h = d.Histo1D(""Branch_A"");; /// auto mergeablehisto = GetMergeableValue(h);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RResultPtr.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSnapshotOptions.hxx:18,Deployability,UPDATE,UPDATE,18,"///< If fMode is ""UPDATE"", overwrite object in output file if it already exists",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RSnapshotOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSnapshotOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSqliteDS.hxx:1040,Safety,avoid,avoid,1040,"// clang-format off; /**; \class ROOT::RDF::RSqliteDS; \ingroup dataframe; \brief RSqliteDS is an RDF data source implementation for SQL result sets from sqlite3 files. The RSqliteDS is able to feed an RDataFrame with data from a SQlite SELECT query. One can use it like. auto rdf = ROOT::RDF::FromSqlite(""/path/to/file.sqlite"", ""select name from table"");; auto h = rdf.Define(""lName"", ""name.length()"").Histo1D(""lName"");. The data source has to provide column types for all the columns. Determining column types in SQlite is tricky; as it is dynamically typed and in principle each row can have different column types. The following heuristics; is used:. - If a table column is queried as is (""SELECT colname FROM table""), the default/declared column type is taken.; - For expressions (""SELECT 1+1 FROM table""), the type of the first row of the result set determines the column type.; That can result in a column to be of thought of type NULL where subsequent rows actually have meaningful values.; The provided SELECT query can be used to avoid such ambiguities.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RSqliteDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSqliteDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSqliteDS.hxx:125,Availability,avail,available,125,"// clang-format on; /// Used to hold a single ""cell"" of the SELECT query's result table. Can be changed to std::variant once available.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RSqliteDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSqliteDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx:345,Testability,test,test,345,"/// \brief A simple data-source implementation, for demo purposes.; ///; /// Constructing an RDataFrame as `RDataFrame(nEntries)` is a superior alternative.; /// If size is std::numeric_limits<ULong64_t>::max(), this acts as an infinite data-source:; /// it returns entries from GetEntryRanges forever or until a Range stops the event loop (for test purposes).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RTrivialDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx:13,Usability,simpl,simple,13,"/// \brief A simple data-source implementation, for demo purposes.; ///; /// Constructing an RDataFrame as `RDataFrame(nEntries)` is a superior alternative.; /// If size is std::numeric_limits<ULong64_t>::max(), this acts as an infinite data-source:; /// it returns entries from GetEntryRanges forever or until a Range stops the event loop (for test purposes).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RTrivialDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx:22,Integrability,wrap,wrapping,22,"/// \brief Make a RDF wrapping a RTrivialDS with the specified amount of entries.; ///; /// Constructing an RDataFrame as `RDataFrame(nEntries)` is a superior alternative.; /// If size is std::numeric_limits<ULong64_t>::max(), this acts as an infinite data-source:; /// it returns entries from GetEntryRanges forever or until a Range stops the event loop (for test purposes).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RTrivialDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx:360,Testability,test,test,360,"/// \brief Make a RDF wrapping a RTrivialDS with the specified amount of entries.; ///; /// Constructing an RDataFrame as `RDataFrame(nEntries)` is a superior alternative.; /// If size is std::numeric_limits<ULong64_t>::max(), this acts as an infinite data-source:; /// it returns entries from GetEntryRanges forever or until a Range stops the event loop (for test purposes).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RTrivialDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx:22,Integrability,wrap,wrapping,22,"/// \brief Make a RDF wrapping a RTrivialDS with infinite entries, for demo purposes.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RTrivialDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RTrivialDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx:16,Modifiability,variab,variable,16,"// avoid unused variable warnings",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RVecDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx:3,Safety,avoid,avoid,3,"// avoid unused variable warnings",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RVecDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx:3,Deployability,Release,Release,3,"// Release the data associated to this data source",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RVecDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:19,Availability,error,error,19,"// otherwise build error message and throw",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:25,Integrability,message,message,25,"// otherwise build error message and throw",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:91,Safety,avoid,avoid,91,"/// The container type for each thread's partial result in an action helper; // We have to avoid to instantiate std::vector<bool> as that makes it impossible to return a reference to one of; // the thread-local results. In addition, a common definition for the type of the container makes it easy to swap; // the type of the underlying container if e.g. we see problems with false sharing of the thread-local results..",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:523,Integrability,synchroniz,synchronizing,523,"/// This helper fills TH1Ds for which no axes were specified by buffering the fill values to pick good axes limits.; ///; /// TH1Ds have an automatic mechanism to pick good limits based on the first N entries they were filled with, but; /// that does not work in multi-thread event loops as it might yield histograms with incompatible binning in each; /// thread, making it impossible to merge the per-thread results.; /// Instead, this helper delays the decision on the axes limits until all threads have done processing, synchronizing; /// the decision on the limits as part of the merge operation.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:263,Performance,multi-thread,multi-thread,263,"/// This helper fills TH1Ds for which no axes were specified by buffering the fill values to pick good axes limits.; ///; /// TH1Ds have an automatic mechanism to pick good limits based on the first N entries they were filled with, but; /// that does not work in multi-thread event loops as it might yield histograms with incompatible binning in each; /// thread, making it impossible to merge the per-thread results.; /// Instead, this helper delays the decision on the axes limits until all threads have done processing, synchronizing; /// the decision on the limits as part of the merge operation.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:21,Availability,error,error,21,"// Merge overload to error out in case no valid HIST::Merge method was detected",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:71,Safety,detect,detected,71,"// Merge overload to error out in case no valid HIST::Merge method was detected",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:15,Integrability,wrap,wraps,15,"// class which wraps a pointer and implements a no-op increment operator",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:96,Usability,simpl,simplified,96,"// loop increments all of the iterators while leaving scalars unmodified; // TODO this could be simplified with fold expressions or std::apply in C++17",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:91,Availability,error,error,91,"// case: types are combination of containers and non-containers; // this is not supported, error out",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:91,Availability,error,error,91,"// case: types are combination of containers and non-containers; // this is not supported, error out",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:253,Modifiability,polymorphi,polymorphic,253,"// Respect the original bufsize and splitlevel arguments; // In particular, by keeping splitlevel equal to 0 if this was the case for `inputBranch`, we avoid; // writing garbage when unsplit objects cannot be written as split objects (e.g. in case of a polymorphic; // TObject branch, see https://bit.ly/2EjLMId ).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:152,Safety,avoid,avoid,152,"// Respect the original bufsize and splitlevel arguments; // In particular, by keeping splitlevel equal to 0 if this was the case for `inputBranch`, we avoid; // writing garbage when unsplit objects cannot be written as split objects (e.g. in case of a polymorphic; // TObject branch, see https://bit.ly/2EjLMId ).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:177,Availability,avail,available,177,"// The output array branch `bname` has dynamic size stored in leaf `sizeLeafName`, but that leaf has not been; // added to the output tree yet. However, the size leaf has to be available for the creation of the array; // branch to be successful. So we create the size leaf here.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:132,Energy Efficiency,allocate,allocated,132,"// This code deals with branches which hold C arrays of variable size. It can happen that the buffers; // associated to those is re-allocated. As a result the value of the pointer can change therewith; // leaving associated to the branch of the output tree an invalid pointer.; // With this code, we set the value of the pointer in the output branch anew when needed.; // Nota bene: the extra "",0"" after the invocation of SetAddress, is because that method returns void and; // we need an int for the expander list.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:56,Modifiability,variab,variable,56,"// This code deals with branches which hold C arrays of variable size. It can happen that the buffers; // associated to those is re-allocated. As a result the value of the pointer can change therewith; // leaving associated to the branch of the output tree an invalid pointer.; // With this code, we set the value of the pointer in the output branch anew when needed.; // Nota bene: the extra "",0"" after the invocation of SetAddress, is because that method returns void and; // we need an int for the expander list.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:16,Modifiability,variab,variable,16,"// avoid unused variable warnings for older compilers such as gcc 4.9",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,Safety,avoid,avoid,3,"// avoid unused variable warnings for older compilers such as gcc 4.9",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:16,Modifiability,variab,variable,16,"// avoid unused variable warnings for older compilers such as gcc 4.9",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,Safety,avoid,avoid,3,"// avoid unused variable warnings for older compilers such as gcc 4.9",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:24,Performance,multi-thread,multi-thread,24,"/// Helper object for a multi-thread Snapshot action",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:31,Performance,concurren,concurrent,31,"// vector<bool> does not allow concurrent writing of different elements",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:34,Availability,down,down,34,"// struct holding options to pass down to TFile and TTree in this action",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:81,Modifiability,variab,variables,81,"// re-create output tree as we need to create its branches again, with new input variables; // TODO we could instead create the output tree and its branches, change addresses of input variables in each task",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:184,Modifiability,variab,variables,184,"// re-create output tree as we need to create its branches again, with new input variables; // TODO we could instead create the output tree and its branches, change addresses of input variables in each task",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:22,Performance,concurren,concurrent,22,"// clear now to avoid concurrent destruction of output trees and input tree (which has them listed as fClones)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:16,Safety,avoid,avoid,16,"// clear now to avoid concurrent destruction of output trees and input tree (which has them listed as fClones)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,Usability,clear,clear,3,"// clear now to avoid concurrent destruction of output trees and input tree (which has them listed as fClones)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:132,Energy Efficiency,allocate,allocated,132,"// This code deals with branches which hold C arrays of variable size. It can happen that the buffers; // associated to those is re-allocated. As a result the value of the pointer can change therewith; // leaving associated to the branch of the output tree an invalid pointer.; // With this code, we set the value of the pointer in the output branch anew when needed.; // Nota bene: the extra "",0"" after the invocation of SetAddress, is because that method returns void and; // we need an int for the expander list.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:56,Modifiability,variab,variable,56,"// This code deals with branches which hold C arrays of variable size. It can happen that the buffers; // associated to those is re-allocated. As a result the value of the pointer can change therewith; // leaving associated to the branch of the output tree an invalid pointer.; // With this code, we set the value of the pointer in the output branch anew when needed.; // Nota bene: the extra "",0"" after the invocation of SetAddress, is because that method returns void and; // we need an int for the expander list.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warnings (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warnings (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/GraphUtils.hxx:264,Usability,clear,clears,264,"// clang-format off; /**; \class ROOT::Internal::RDF::GraphCreatorHelper; \ingroup dataframe; \brief Helper class that provides the operation graph nodes. This class is the single point from which graph nodes can be retrieved. Every time an object is created,; it clears the static members and starts again.; By asking this class to create a node, it will return an existing node if already created, otherwise a new one.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/GraphUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/GraphUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:3,Performance,multi-thread,multi-thread,3,"// multi-thread snapshot",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:369,Availability,alive,alive,369,"// Allocate a weak_ptr on the heap, return a pointer to it. The user is responsible for deleting this weak_ptr.; // This function is meant to be used by RInterface's methods that book code for jitting.; // The problem it solves is that we generate code to be lazily jitted with the addresses of certain objects in them,; // and we need to check those objects are still alive when the generated code is finally jitted and executed.; // So we pass addresses to weak_ptrs allocated on the heap to the jitted code, which is then responsible for; // the deletion of the weak_ptr object.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate a weak_ptr on the heap, return a pointer to it. The user is responsible for deleting this weak_ptr.; // This function is meant to be used by RInterface's methods that book code for jitting.; // The problem it solves is that we generate code to be lazily jitted with the addresses of certain objects in them,; // and we need to check those objects are still alive when the generated code is finally jitted and executed.; // So we pass addresses to weak_ptrs allocated on the heap to the jitted code, which is then responsible for; // the deletion of the weak_ptr object.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:469,Energy Efficiency,allocate,allocated,469,"// Allocate a weak_ptr on the heap, return a pointer to it. The user is responsible for deleting this weak_ptr.; // This function is meant to be used by RInterface's methods that book code for jitting.; // The problem it solves is that we generate code to be lazily jitted with the addresses of certain objects in them,; // and we need to check those objects are still alive when the generated code is finally jitted and executed.; // So we pass addresses to weak_ptrs allocated on the heap to the jitted code, which is then responsible for; // the deletion of the weak_ptr object.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:97,Availability,alive,alive,97,"// Same as MakeWeakOnHeap, but create a shared_ptr that makes sure the object is definitely kept alive.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:75,Integrability,interface,interface,75,"// using the new GetColumnReaders mechanism; // TODO consider changing the interface so we return all of these for all slots in one go",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:3,Testability,mock,mock,3,"// mock Filter logic -- validity checks and Define-ition of RDataSource columns",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:15,Testability,log,logic,15,"// mock Filter logic -- validity checks and Define-ition of RDataSource columns",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:30,Energy Efficiency,allocate,allocated,30,"// a helper to delete objects allocated before jitting, so that the jitter can share data with lazily jitted code",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:67,Energy Efficiency,reduce,reduce,67,"// use unique_ptr<RDefineBase> instead of make_unique<NewCol_t> to reduce jit/compile-times",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:30,Energy Efficiency,allocate,allocated,30,"// a helper to delete objects allocated before jitting, so that the jitter can share data with lazily jitted code",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:67,Energy Efficiency,reduce,reduce,67,"// use unique_ptr<RDefineBase> instead of make_unique<NewCol_t> to reduce jit/compile-times",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:30,Energy Efficiency,allocate,allocated,30,"// a helper to delete objects allocated before jitting, so that the jitter can share data with lazily jitted code",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:101,Availability,alive,alive,101,"// colRegister must be deleted before prevNodeOnHeap because their dtor needs the RLoopManager to be alive; // and prevNodeOnHeap is what keeps it alive if the rest of the computation graph is already out of scope",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:147,Availability,alive,alive,147,"// colRegister must be deleted before prevNodeOnHeap because their dtor needs the RLoopManager to be alive; // and prevNodeOnHeap is what keeps it alive if the rest of the computation graph is already out of scope",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:86,Availability,alive,alive,86,"// if we are here it means we are jitting, if we are jitting the loop manager must be alive",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx:10,Integrability,wrap,wrapper,10,"// return wrapper around f that prepends an `unsigned int slot` parameter",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/InterfaceUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/PyROOTHelpers.hxx:103,Integrability,interface,interface,103,"// RDataFrame.AsNumpy helpers; // NOTE: This is a workaround for the missing Take action in the PyROOT interface",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/PyROOTHelpers.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/PyROOTHelpers.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:243,Testability,log,logic,243,"// namespace GraphDrawing; // clang-format off; /**; * \class ROOT::Internal::RDF::RAction; * \ingroup dataframe; * \brief A RDataFrame node that produces a result; * \tparam Helper The action helper type, which implements the concrete action logic (e.g. FillHelper, SnapshotHelper); * \tparam PrevNode The type of the parent node in the computation graph; * \tparam ColumnTypes_t A TypeList with the types of the input columns; *; */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:16,Integrability,wrap,wrapper,16,/**; Retrieve a wrapper to the result of the action that knows how to merge; with others of the same type.; */,MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warning (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:30,Deployability,update,update,30,"/// This method is invoked to update a partial result during the event loop, right before passing the result to a; /// user-defined callback registered via RResultPtr::RegisterCallback",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RActionBase.hxx:30,Deployability,update,update,30,"/// This method is invoked to update a partial result during the event loop, right before passing the result to a; /// user-defined callback registered via RResultPtr::RegisterCallback",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RActionBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RActionBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RActionBase.hxx:16,Integrability,wrap,wrapper,16,/**; Retrieve a wrapper to the result of the action that knows how to merge; with others of the same type.; */,MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RActionBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RActionBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx:1148,Deployability,update,updated,1148,"/**; * \class ROOT::Internal::RDF::RColumnRegister; * \ingroup dataframe; * \brief A binder for user-defined columns, variations and aliases.; *; * The storage is copy-on-write and shared between all instances of the class that have the same values.; *; * Several components of an RDF computation graph make use of a column register. It keeps track of which columns have; * been defined, varied or aliased at each point of the computation graph.; * In many cases, the contents of the different column register instances are the same or only differ by a single; * extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines,; * fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across; * RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added; * between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data; * members with the previous instance except for the one data member that needed updating, which is replaced with a new; * updated instance.; *; * The contents of the collections that keep track of other objects of the computation graph are not owned by the; * RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the; * RColumnRegister.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx:629,Safety,avoid,avoid,629,"/**; * \class ROOT::Internal::RDF::RColumnRegister; * \ingroup dataframe; * \brief A binder for user-defined columns, variations and aliases.; *; * The storage is copy-on-write and shared between all instances of the class that have the same values.; *; * Several components of an RDF computation graph make use of a column register. It keeps track of which columns have; * been defined, varied or aliased at each point of the computation graph.; * In many cases, the contents of the different column register instances are the same or only differ by a single; * extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines,; * fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across; * RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added; * between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data; * members with the previous instance except for the one data member that needed updating, which is replaced with a new; * updated instance.; *; * The contents of the collections that keep track of other objects of the computation graph are not owned by the; * RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the; * RColumnRegister.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx:1369,Security,access,accessed,1369,"/**; * \class ROOT::Internal::RDF::RColumnRegister; * \ingroup dataframe; * \brief A binder for user-defined columns, variations and aliases.; *; * The storage is copy-on-write and shared between all instances of the class that have the same values.; *; * Several components of an RDF computation graph make use of a column register. It keeps track of which columns have; * been defined, varied or aliased at each point of the computation graph.; * In many cases, the contents of the different column register instances are the same or only differ by a single; * extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines,; * fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across; * RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added; * between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data; * members with the previous instance except for the one data member that needed updating, which is replaced with a new; * updated instance.; *; * The contents of the collections that keep track of other objects of the computation graph are not owned by the; * RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the; * RColumnRegister.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDatasetSpec.hxx:480,Availability,avail,available,480,"// clang-format off; /**; \class ROOT::RDF::Experimental::RDatasetSpec; \ingroup dataframe; \brief The dataset specification for RDataFrame. This class allows users to create the dataset specification for RDataFrame ; to which they add samples (using the RSample class object) with tree names and file names, ; and, optionally, the metadata information (using the RMetaData class objects). ; Adding global friend trees and/or setting the range of events to be processed; are also available. Note, there exists yet another method to build RDataFrame from the dataset information using the JSON file format: \ref FromSpec(const std::string &jsonFile) ""FromSpec()"". ; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDatasetSpec.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDatasetSpec.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:197,Deployability,Update,Update,197,"/**; * \brief The implementation of the DefaultValueFor transformation.; *; * The class takes in the default value provided by the user to fill-in missing; * values of the input column. During the Update step, the class checks for the; * presence of the value of the column at the current event. If that value is; * missing, it will return the default value to requesting nodes of the graph.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:3,Safety,Avoid,Avoid,3,"// Avoid instantiating vector<bool> as `operator[]` returns temporaries in that case. Use std::deque instead.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:15,Availability,error,errors,15,"// We suppress errors that TTreeReader prints regarding the missing branch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:4,Deployability,Update,Update,4,"/// Update the value at the address returned by GetValuePtr with the content corresponding to the given entry",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:36,Performance,cache,cache,36,"// evaluate this define expression, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:34,Integrability,depend,depend,34,"// this Defined quantity does not depend on this variation, so no need to create a varied RDefine",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:78,Integrability,depend,depend,78,"// We don't have a varied RDefine for this variation.; // This means we don't depend on it and we can return ourselves, i.e. the RDefine for the nominal universe.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:3,Safety,Avoid,Avoid,3,"// Avoid instantiating vector<bool> as `operator[]` returns temporaries in that case. Use std::deque instead.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warning (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warning (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:4,Deployability,Update,Update,4,"/// Update the value at the address returned by GetValuePtr with the content corresponding to the given entry",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:36,Performance,cache,cache,36,"// evaluate this define expression, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:34,Integrability,depend,depend,34,"// this Defined quantity does not depend on this variation, so no need to create a varied RDefine",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx:78,Integrability,depend,depend,78,"// We don't have a varied RDefine for this variation.; // This means we don't depend on it and we can return ourselves, i.e. the RDefine for the nominal universe.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx:4,Deployability,Update,Update,4,"/// Update the value at the address returned by GetValuePtr with the content corresponding to the given entry",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx:4,Deployability,Update,Update,4,"/// Update function to be called once per sample, used if the derived type is a RDefinePerSample",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefineBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx:3,Safety,Avoid,Avoid,3,"// Avoid instantiating vector<bool> as `operator[]` returns temporaries in that case. Use std::deque instead.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx:4,Deployability,Update,Update,4,"/// Update the value at the address returned by GetValuePtr with the content corresponding to the given entry",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx:40,Integrability,depend,depends,40,"// No-op for RDefinePerSample: it never depends on systematic variations",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDisplay.hxx:21,Testability,log,logic,21,"// Short-circuit the logic and just insert the string representation of; // the symple type at the right index.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDisplay.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDisplay.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDisplay.hxx:21,Testability,log,logic,21,"// Short-circuit the logic and just insert the string representation of; // the boolean value at the right index.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RDisplay.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDisplay.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:37,Performance,cache,cache,37,"// a filter upstream returned false, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:25,Performance,cache,cache,25,"// evaluate this filter, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warnings (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:56,Performance,perform,perform,56,"/* If the returned node is not new, there is no need to perform any other operation.; * This is a likely scenario when building the entire graph in which branches share; * some nodes. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx:87,Integrability,depend,depend,87,"// nobody should ask for a varied filter for a variation on which this filter does not depend:; // they can just use the nominal filter.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx:52,Safety,safe,safely,52,"// std::vector<bool> cannot be used in a MT context safely",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:161,Integrability,Depend,Depending,161,"/**; * \brief implementation of FilterAvailable and FilterMissing operations; *; * The filter evaluates if the entry is missing a value for the input column.; * Depending on which function was called by the user, the entry with the; * missing value:; * - will be discarded in case the user called FilterAvailable; * - will be kept in case the user called FilterMissing; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:15,Availability,error,errors,15,"// We suppress errors that TTreeReader prints regarding the missing branch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:37,Performance,cache,cache,37,"// a filter upstream returned false, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:25,Performance,cache,cache,25,"// evaluate this filter, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:31,Availability,avail,available,31,"// Try to check if there is an available reader from the column register first; // We do not check that the type of the reader matches the type of the input column of this node,; // because this node does not keep track of that anyway",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:56,Performance,perform,perform,56,"/* If the returned node is not new, there is no need to perform any other operation.; * This is a likely scenario when building the entire graph in which branches share; * some nodes. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx:87,Integrability,depend,depend,87,"// nobody should ask for a varied filter for a variation on which this filter does not depend:; // they can just use the nominal filter.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterWithMissingValues.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:100,Integrability,interface,interface,100,"// clang-format off; /**; * \class ROOT::RDF::RInterface; * \ingroup dataframe; * \brief The public interface to the RDataFrame federation of classes.; * \tparam Proxied One of the ""node"" base types (e.g. RLoopManager, RFilterBase). The user never specifies this type manually.; * \tparam DataSource The type of the RDataSource which is providing the data to the data frame. There is no source by default.; *; * The documentation of each method features a one liner illustrating how to use the method, for example showing how; * the majority of the template parameters are automatically deduced requiring no or very little effort by the user.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:159,Availability,avail,available,159,"////////////////////////////////////////////////////////////////////////////; /// \brief Build a RInterface from a RLoopManager.; /// This constructor is only available for RInterface<RLoopManager>.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:291,Performance,perform,performance,291,"////////////////////////////////////////////////////////////////////////////; /// \brief Cast any RDataFrame node to a common type ROOT::RDF::RNode.; /// Different RDataFrame methods return different C++ types. All nodes, however,; /// can be cast to this common type at the cost of a small performance penalty.; /// This allows, for example, storing RDataFrame nodes in a vector, or passing them; /// around via (non-template, C++11) helper functions.; /// Example usage:; /// ~~~{.cpp}; /// // a function that conditionally adds a Range to a RDataFrame node.; /// RNode MaybeAddRange(RNode df, bool mustAddRange); /// {; /// return mustAddRange ? df.Range(1) : df;; /// }; /// // use as :; /// ROOT::RDataFrame df(10);; /// auto maybeRanged = MaybeAddRange(df, true);; /// ~~~; /// Note that it is not a problem to pass RNode's by value.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1096,Integrability,depend,depend,1096,"////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:749,Modifiability,variab,variable,749,"////////////////////////////////////////////////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](f",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1538,Modifiability,variab,variable,1538,"////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:804,Performance,multi-thread,multi-threading,804,"////////////////////////////////////////////////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](f",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1211,Performance,cache,cached,1211,"////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:420,Modifiability,variab,variable,420,"////////////////////////////////////////////////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] expression The filter expression in C++; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// The expression is just-in-time compiled and used to filter entries. It must; /// be valid C++ syntax in which variable names are substituted with the names; /// of branches/columns.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto filtered_df = df.Filter(""myCollection.size() > 3"");; /// auto filtered_name_df = df.Filter(""myCollection.size() > 3"", ""Minumum collection size"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:982,Energy Efficiency,efficient,efficient,982,"////////////////////////////////////////////////////////; /// \brief Define a new column.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// Define a column that will be visible from all subsequent nodes; /// of the functional chain. The `expression` is only evaluated for entries that pass; /// all the preceding filters.; /// A new variable is created called `name`, accessible as if it was contained; /// in the dataset from subsequent transformations/actions.; ///; /// Use cases include:; /// * caching the results of complex calculations for easy and efficient multiple access; /// * extraction of quantities of interest from complex objects; ///; /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // assuming a function with signature:; /// double myComplexCalculation(const RVec<float> &muon_pts);; /// // we can pass it directly to Define; /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; /// // alternatively, we can pass the body of the function as a string, as in Filter:; /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Define(""x2"", ""return Map(v, [](float e) { return ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:759,Modifiability,variab,variable,759,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// Define a column that will be visible from all subsequent nodes; /// of the functional chain. The `expression` is only evaluated for entries that pass; /// all the preceding filters.; /// A new variable is created called `name`, accessible as if it was contained; /// in the dataset from subsequent transformations/actions.; ///; /// Use cases include:; /// * caching the results of complex calculations for easy and efficient multiple access; /// * extraction of quantities of interest from complex objects; ///; /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // assuming a function with signature:; /// double myComplexCalculation(const RVec<float> &muon_pts);; /// // we can pass it directly to Define; /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; /// // alternatively, we can pass the body of the function as a string, as in Filter:; /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Define(""x",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:794,Security,access,accessible,794,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// Define a column that will be visible from all subsequent nodes; /// of the functional chain. The `expression` is only evaluated for entries that pass; /// all the preceding filters.; /// A new variable is created called `name`, accessible as if it was contained; /// in the dataset from subsequent transformations/actions.; ///; /// Use cases include:; /// * caching the results of complex calculations for easy and efficient multiple access; /// * extraction of quantities of interest from complex objects; ///; /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // assuming a function with signature:; /// double myComplexCalculation(const RVec<float> &muon_pts);; /// // we can pass it directly to Define; /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; /// // alternatively, we can pass the body of the function as a string, as in Filter:; /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Define(""x",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1001,Security,access,access,1001,"////////////////////////////////////////////////////////; /// \brief Define a new column.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// Define a column that will be visible from all subsequent nodes; /// of the functional chain. The `expression` is only evaluated for entries that pass; /// all the preceding filters.; /// A new variable is created called `name`, accessible as if it was contained; /// in the dataset from subsequent transformations/actions.; ///; /// Use cases include:; /// * caching the results of complex calculations for easy and efficient multiple access; /// * extraction of quantities of interest from complex objects; ///; /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // assuming a function with signature:; /// double myComplexCalculation(const RVec<float> &muon_pts);; /// // we can pass it directly to Define; /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; /// // alternatively, we can pass the body of the function as a string, as in Filter:; /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Define(""x2"", ""return Map(v, [](float e) { return ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,Integrability,depend,dependent,163,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; ///; /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, double, double);; /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1302,Performance,perform,performant,1302,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; ///; /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, double, double);; /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:767,Safety,safe,safe,767,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; ///; /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, double, double);; /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,Integrability,depend,dependent,163,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot and the current entry.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; ///; /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, ULong64_t, double, double);; /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); /// DefineSlotEntry(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1469,Performance,perform,performant,1469,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot and the current entry.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; ///; /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, ULong64_t, double, double);; /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); /// DefineSlotEntry(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:780,Safety,safe,safe,780,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot and the current entry.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; ///; /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, ULong64_t, double, double);; /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); /// DefineSlotEntry(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:490,Modifiability,variab,variable,490,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column.; /// \param[in] name The name of the defined column.; /// \param[in] expression An expression in C++ which represents the defined value; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The expression is just-in-time compiled and used to produce the column entries.; /// It must be valid C++ syntax in which variable names are substituted with the names; /// of branches/columns.; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Define(""x2"", ""return Map(v, [](float e) { return e*e; })""); /// ~~~; ///; /// Refer to the first overload of this method for the full documentation.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:508,Modifiability,variab,variable,508,"////////////////////////////////////////////////////////////////////////////; /// \brief Overwrite the value and/or type of an existing column.; /// \param[in] name The name of the column to redefine.; /// \param[in] expression An expression in C++ which represents the defined value; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The expression is just-in-time compiled and used to produce the column entries.; /// It must be valid C++ syntax in which variable names are substituted with the names; /// of branches/columns.; ///; /// The old value of the column can be used as an input for the expression.; /// An exception is thrown in case the column to re-define does not already exist.; ///; /// Aliases cannot be overridden. See the corresponding Define() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:719,Availability,down,downstream,719,"////////////////////////////////////////////////////////////////////////////; /// \brief In case the value in the given column is missing, provide a default value; /// \tparam T The type of the column; /// \param[in] column Column name where missing values should be replaced by the given default value; /// \param[in] defaultValue Value to provide instead of a missing value; /// \return The node of the graph that will provide a default value; ///; /// This operation is useful in case an entry of the dataset is incomplete,; /// i.e. if one or more of the columns do not have valid values. It does not; /// modify the values of the column, but in case any entry is missing, it; /// will provide the default value to downstream nodes instead.; ///; /// Use cases include:; /// * When processing multiple files, one or more of them is missing a column; /// * In horizontal joining with entry matching, a certain dataset has no; /// match for the current entry.; ///; /// ### Example usage:; ///; /// \code{.cpp}; /// // Assume a dataset with columns [idx, x] matching another dataset with; /// // columns [idx, y]. For idx == 42, the right-hand dataset has no match; /// ROOT::RDataFrame df{dataset};; /// auto df_default = df.DefaultValueFor(""y"", 33); /// .Define(""z"", [](int x, int y) { return x + y; }, {""x"", ""y""});; /// auto colz = df_default.Take<int>(""z"");; /// \endcode; ///; /// \code{.py}; /// df = ROOT.RDataFrame(dataset); /// df_default = df.DefaultValueFor(""y"", 33).Define(""z"", ""x + y""); /// colz = df_default.Take[int](""z""); /// \endcode",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:61,Availability,error,error,61,"// The type is not known to the interpreter.; // We must not error out here, but if/when this column is used in jitted code",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1778,Availability,error,errors,1778,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:138,Deployability,update,updated,138,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1083,Integrability,depend,depends,1083,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1151,Integrability,inject,inject,1151,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1357,Performance,multi-thread,multi-thread,1357,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:752,Safety,safe,safe,752,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1151,Security,inject,inject,1151,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:713,Usability,simpl,simplify,713,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:61,Availability,error,error,61,"// The type is not known to the interpreter.; // We must not error out here, but if/when this column is used in jitted code",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:138,Deployability,update,updated,138,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A valid C++ expression as a string, which will be used to compute the defined value.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The expression is just-in-time compiled and used to produce the column entries.; /// It must be valid C++ syntax and the usage of the special variable names `rdfslot_` and `rdfsampleinfo_` is; /// permitted, where these variables will take the same values as the `slot` and `id` parameters described at the; /// DefinePerSample(std::string_view name, F expression) overload. See the documentation of that overload for more information.; ///; /// ### Example usage:; /// ~~~{.py}; /// df = ROOT.RDataFrame('mytree', ['sample1.root','sample2.root']); /// df.DefinePerSample('weightbysample', 'rdfsampleinfo_.Contains(""sample1"") ? 1.0f : 2.0f'); /// ~~~; ///; /// \note; /// If you have declared some C++ function to the interpreter, the correct syntax to call that function with this; /// overload of DefinePerSample is by calling it explicitly with the special names `rdfslot_` and `rdfsampleinfo_` as; /// input parameters. This is for example the correct way to call this overload when working in PyROOT:; /// ~~~{.py}; /// ROOT.gInterpreter.Declare(; /// """"""; /// float weights(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; /// return id.Contains(""sample1"") ? 1.0f : 2.0f;; /// }; /// """"""); /// df = ROOT.RDataFrame(""mytree"", [""sample1.root"",""sample2.root""]); /// df.DefinePerSample(""weightsbysample"", ""weights(rdfslot_, rdfsampleinfo_)""); /// ~~~; ///; /// \note; /// Differently from what happens in Define(), the string expression passed to DefinePerSample cannot contain; /// column names other than those mentioned above: the expression is e",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:586,Modifiability,variab,variable,586,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A valid C++ expression as a string, which will be used to compute the defined value.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The expression is just-in-time compiled and used to produce the column entries.; /// It must be valid C++ syntax and the usage of the special variable names `rdfslot_` and `rdfsampleinfo_` is; /// permitted, where these variables will take the same values as the `slot` and `id` parameters described at the; /// DefinePerSample(std::string_view name, F expression) overload. See the documentation of that overload for more information.; ///; /// ### Example usage:; /// ~~~{.py}; /// df = ROOT.RDataFrame('mytree', ['sample1.root','sample2.root']); /// df.DefinePerSample('weightbysample', 'rdfsampleinfo_.Contains(""sample1"") ? 1.0f : 2.0f'); /// ~~~; ///; /// \note; /// If you have declared some C++ function to the interpreter, the correct syntax to call that function with this; /// overload of DefinePerSample is by calling it explicitly with the special names `rdfslot_` and `rdfsampleinfo_` as; /// input parameters. This is for example the correct way to call this overload when working in PyROOT:; /// ~~~{.py}; /// ROOT.gInterpreter.Declare(; /// """"""; /// float weights(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; /// return id.Contains(""sample1"") ? 1.0f : 2.0f;; /// }; /// """"""); /// df = ROOT.RDataFrame(""mytree"", [""sample1.root"",""sample2.root""]); /// df.DefinePerSample(""weightsbysample"", ""weights(rdfslot_, rdfsampleinfo_)""); /// ~~~; ///; /// \note; /// Differently from what happens in Define(), the string expression passed to DefinePerSample cannot contain; /// column names other than those mentioned above: the expression is e",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:664,Modifiability,variab,variables,664,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A valid C++ expression as a string, which will be used to compute the defined value.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The expression is just-in-time compiled and used to produce the column entries.; /// It must be valid C++ syntax and the usage of the special variable names `rdfslot_` and `rdfsampleinfo_` is; /// permitted, where these variables will take the same values as the `slot` and `id` parameters described at the; /// DefinePerSample(std::string_view name, F expression) overload. See the documentation of that overload for more information.; ///; /// ### Example usage:; /// ~~~{.py}; /// df = ROOT.RDataFrame('mytree', ['sample1.root','sample2.root']); /// df.DefinePerSample('weightbysample', 'rdfsampleinfo_.Contains(""sample1"") ? 1.0f : 2.0f'); /// ~~~; ///; /// \note; /// If you have declared some C++ function to the interpreter, the correct syntax to call that function with this; /// overload of DefinePerSample is by calling it explicitly with the special names `rdfslot_` and `rdfsampleinfo_` as; /// input parameters. This is for example the correct way to call this overload when working in PyROOT:; /// ~~~{.py}; /// ROOT.gInterpreter.Declare(; /// """"""; /// float weights(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; /// return id.Contains(""sample1"") ? 1.0f : 2.0f;; /// }; /// """"""); /// df = ROOT.RDataFrame(""mytree"", [""sample1.root"",""sample2.root""]); /// df.DefinePerSample(""weightsbysample"", ""weights(rdfslot_, rdfsampleinfo_)""); /// ~~~; ///; /// \note; /// Differently from what happens in Define(), the string expression passed to DefinePerSample cannot contain; /// column names other than those mentioned above: the expression is e",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2094,Security,access,accessible,2094,"umn that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A valid C++ expression as a string, which will be used to compute the defined value.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The expression is just-in-time compiled and used to produce the column entries.; /// It must be valid C++ syntax and the usage of the special variable names `rdfslot_` and `rdfsampleinfo_` is; /// permitted, where these variables will take the same values as the `slot` and `id` parameters described at the; /// DefinePerSample(std::string_view name, F expression) overload. See the documentation of that overload for more information.; ///; /// ### Example usage:; /// ~~~{.py}; /// df = ROOT.RDataFrame('mytree', ['sample1.root','sample2.root']); /// df.DefinePerSample('weightbysample', 'rdfsampleinfo_.Contains(""sample1"") ? 1.0f : 2.0f'); /// ~~~; ///; /// \note; /// If you have declared some C++ function to the interpreter, the correct syntax to call that function with this; /// overload of DefinePerSample is by calling it explicitly with the special names `rdfslot_` and `rdfsampleinfo_` as; /// input parameters. This is for example the correct way to call this overload when working in PyROOT:; /// ~~~{.py}; /// ROOT.gInterpreter.Declare(; /// """"""; /// float weights(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; /// return id.Contains(""sample1"") ? 1.0f : 2.0f;; /// }; /// """"""); /// df = ROOT.RDataFrame(""mytree"", [""sample1.root"",""sample2.root""]); /// df.DefinePerSample(""weightsbysample"", ""weights(rdfslot_, rdfsampleinfo_)""); /// ~~~; ///; /// \note; /// Differently from what happens in Define(), the string expression passed to DefinePerSample cannot contain; /// column names other than those mentioned above: the expression is evaluated once before the processing of the; /// sample even starts, so column values are not accessible.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:666,Availability,down,down,666,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1577,Availability,down,down,1577,"/// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values requir",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1651,Availability,down,down,1651,"own""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values required to produce the; /// outputs of \ref ROOT::RDF::Experimental::VariationsFor ""Varia",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1814,Availability,down,down,1814,"/ Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values required to produce the; /// outputs of \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". If \ref; /// ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" was not called for a result, th",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1931,Availability,down,down,1931,"usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values required to produce the; /// outputs of \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". If \ref; /// ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" was not called for a result, the computations are only; /// run for the nominal case.; ///; /// See other overloads for examples when variations are added for multiple existing columns,; ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2135,Availability,down,down,2135,"lts that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values required to produce the; /// outputs of \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". If \ref; /// ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" was not called for a result, the computations are only; /// run for the nominal case.; ///; /// See other overloads for examples when variations are added for multiple existing columns,; /// or when the tags are auto-generated instead of being directly defined.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1021,Integrability,depend,depend,1021,"ngle existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1425,Integrability,depend,dependencies,1425," similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1715,Integrability,depend,depends,1715,"own""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation of values shared; /// among variations only happen once for all variations. Thus, the event loop; /// run-time typically scales much better than linearly with the number of; /// variations.; ///; /// RDataFrame lazily computes the varied values required to produce the; /// outputs of \ref ROOT::RDF::Experimental::VariationsFor ""Varia",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:810,Modifiability,flexible,flexible,810,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1234,Security,access,accessed,1234," similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; /// ROOT::RDF::Experimental::VariationsFor (see the example below).; ///; /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; ///; /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; /// RDataFrame computes all variations as part of a single loop over the data.; /// In particular, this means that I/O and computation o",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:989,Security,access,accessible,989,"/// \brief Register systematic variations for a single existing column using auto-generated variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; /// `""1""`, etc. ; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// This overload of Vary takes an nVariations parameter instead of a list of tag names.; /// The varied results will be accessible via the keys of the dictionary with the form `variationName:N` where `N`; /// is the corresponding sequential tag starting at 0 and going up to `nVariations - 1`.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, 2); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""x:0""].Draw(""SAME"");; /// hx[""x:1""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:677,Availability,down,down,677,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`; ///; /// This overload of Vary takes a list of column names as first argument and; /// requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each; /// affected column. The `variationTags` are defined as `{""down"", ""up""}`.; ///; /// Example usage:; /// ~~~{.cpp}; /// // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; /// auto nominal_hx =; /// df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; /// [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; /// {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; /// {""down"", ""up""}, // variation tags; /// ""ptAndEta"") // variation name; /// .Histo1D(""pt"", ""eta"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""ptAndEta:down""].Draw(""SAME"");; /// hx[""ptAndEta:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1037,Availability,down,down,1037,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`; ///; /// This overload of Vary takes a list of column names as first argument and; /// requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each; /// affected column. The `variationTags` are defined as `{""down"", ""up""}`.; ///; /// Example usage:; /// ~~~{.cpp}; /// // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; /// auto nominal_hx =; /// df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; /// [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; /// {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; /// {""down"", ""up""}, // variation tags; /// ""ptAndEta"") // variation name; /// .Histo1D(""pt"", ""eta"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""ptAndEta:down""].Draw(""SAME"");; /// hx[""ptAndEta:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1129,Availability,down,down,1129,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`; ///; /// This overload of Vary takes a list of column names as first argument and; /// requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each; /// affected column. The `variationTags` are defined as `{""down"", ""up""}`.; ///; /// Example usage:; /// ~~~{.cpp}; /// // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; /// auto nominal_hx =; /// df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; /// [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; /// {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; /// {""down"", ""up""}, // variation tags; /// ""ptAndEta"") // variation name; /// .Histo1D(""pt"", ""eta"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""ptAndEta:down""].Draw(""SAME"");; /// hx[""ptAndEta:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1443,Availability,down,down,1443,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`; ///; /// This overload of Vary takes a list of column names as first argument and; /// requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each; /// affected column. The `variationTags` are defined as `{""down"", ""up""}`.; ///; /// Example usage:; /// ~~~{.cpp}; /// // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; /// auto nominal_hx =; /// df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; /// [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; /// {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; /// {""down"", ""up""}, // variation tags; /// ""ptAndEta"") // variation name; /// .Histo1D(""pt"", ""eta"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""ptAndEta:down""].Draw(""SAME"");; /// hx[""ptAndEta:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1655,Availability,down,down,1655,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`; ///; /// This overload of Vary takes a list of column names as first argument and; /// requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each; /// affected column. The `variationTags` are defined as `{""down"", ""up""}`.; ///; /// Example usage:; /// ~~~{.cpp}; /// // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; /// auto nominal_hx =; /// df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; /// [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; /// {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; /// {""down"", ""up""}, // variation tags; /// ""ptAndEta"") // variation name; /// .Histo1D(""pt"", ""eta"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""ptAndEta:down""].Draw(""SAME"");; /// hx[""ptAndEta:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:677,Availability,down,down,677,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:955,Safety,avoid,avoided,955,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1083,Safety,avoid,avoided,1083,"/// \brief Register systematic variations for for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; /// `""1""`, etc. ; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:414,Availability,down,down,414,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; /// defined as `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:816,Availability,down,down,816,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; /// defined as `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:921,Availability,down,down,921,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; /// defined as `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1125,Availability,down,down,1125,"/// \brief Register systematic variations for a single existing column using custom variation tags.; /// \param[in] colName name of the column for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; /// defined as `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); /// .Filter(""pt > k""); /// .Define(""x"", someFunc, {""pt""}); /// .Histo1D(""x"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""pt:down""].Draw(""SAME"");; /// hx[""pt:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:820,Security,access,accessible,820,"/// \brief Register systematic variations for multiple existing columns using auto-generated variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; /// values for the specified columns.; /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; /// `""1""`, etc. ; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. It takes an nVariations parameter instead of a list of tag names.; /// The varied results will be accessible via the keys of the dictionary with the form `variationName:N` where `N`; /// is the corresponding sequential tag starting at 0 and going up to `nVariations - 1`.; /// The example below shows how Vary() is used while dealing with multiple columns.; ///; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", 2, ""xy""); /// .Histo1D(""x"", ""y"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""xy:0""].Draw(""SAME"");; /// hx[""xy:1""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:751,Safety,avoid,avoided,751,"/// \brief Register systematic variations for multiple existing columns using auto-generated variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; /// `""1""`, etc. ; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:435,Availability,down,down,435,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; /// values for the specified columns.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; /// `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); /// .Histo1D(""x"", ""y"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""xy:down""].Draw(""SAME"");; /// hx[""xy:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:786,Availability,down,down,786,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; /// values for the specified columns.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; /// `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); /// .Histo1D(""x"", ""y"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""xy:down""].Draw(""SAME"");; /// hx[""xy:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:925,Availability,down,down,925,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; /// values for the specified columns.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; /// `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); /// .Histo1D(""x"", ""y"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""xy:down""].Draw(""SAME"");; /// hx[""xy:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1081,Availability,down,down,1081,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; /// values for the specified columns.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; ///; /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; /// `{""down"", ""up""}`.; /// ~~~{.cpp}; /// auto nominal_hx =; /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); /// .Histo1D(""x"", ""y"");; ///; /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; /// hx[""nominal""].Draw();; /// hx[""xy:down""].Draw(""SAME"");; /// hx[""xy:up""].Draw(""SAME"");; /// ~~~; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:317,Availability,avail,available,317,"////////////////////////////////////////////////////////////////////////////; /// \brief Allow to refer to a column with a different name.; /// \param[in] alias name of the column alias; /// \param[in] columnName of the column to be aliased; /// \return the first node of the computation graph for which the alias is available.; ///; /// Aliasing an alias is supported.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto df_with_alias = df.Alias(""simple_name"", ""very_long&complex_name!!!"");; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:138,Security,access,accessible,138,"// The symmetry with Define is clear. We want to:; // - Create globally the alias and return this very node, unchanged; // - Make aliases accessible based on chains and not globally; // Helper to find out if a name is a column",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:31,Usability,clear,clear,31,"// The symmetry with Define is clear. We want to:; // - Create globally the alias and return this very node, unchanged; // - Make aliases accessible based on chains and not globally; // Helper to find out if a name is a column",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2489,Availability,error,error,2489,"e/TChain with names of the form; /// `<friendname>_<branchname>` in order to differentiate them from the branches in the main tree/chain.; ///; /// ### Writing to a sub-directory; ///; /// Snapshot supports writing the TTree in a sub-directory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; ///; /// ### Example invocations:; ///; /// ~~~{.cpp}; /// // without specifying template parameters (column types automatically deduced); /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:3026,Availability,avail,available,3026,"bdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; ///; /// ### Example invocations:; ///; /// ~~~{.cpp}; /// // without specifying template parameters (column types automatically deduced); /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});; ///; /// // specifying template parameters (""x"" is `int`, ""y"" is `float`); /// df.Snapshot<int, float>(""outputTree"", ""outputFile.root"", {""x"", ""y""});; /// ~~~; ///; /// To book a Snapshot without triggering the event loop, one needs to set the appropriate flag in; /// `RSnapshotOptions`:; /// ~~~{.cpp}; /// RSnapshotOptions opts;; /// opts.fLazy = true;; /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x""}, opts);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:551,Integrability,wrap,wraps,551,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnList The list of names of the columns/branches to be written.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree.; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// Support for writing of nested branches is limited (although RDataFrame is able to read them) and dot ('.'); /// characters in input column names will be replaced by underscores ('_') in the branches produced by Snapshot.; /// When writing a variable size array through Snapshot, it is required that the column indicating its size is also; /// written out and it appears before the array in the columnList.; ///; /// By default, in case of TTree or TChain inputs, Snapshot will try to write out all top-level branches. For other; /// types of inputs, all columns returned by GetColumnNames() will be written out. If friend trees or chains are; /// present, by default all friend top-level branches that have names that do not collide with; /// names of branches in the main TTree/TChain will be written out. Since v6.24, Snapshot will also write out; /// friend branches with the same names of branches in the main TTree/TChain with names of the form; /// `<friendname>_<branchname>` in order to differentiate them from the branches in the main tree/chain.; ///; /// ### Writing to a sub-directory; ///; /// Snapshot supports writing the TTree in a sub-directory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as ne",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:833,Modifiability,variab,variable,833,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnList The list of names of the columns/branches to be written.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree.; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// Support for writing of nested branches is limited (although RDataFrame is able to read them) and dot ('.'); /// characters in input column names will be replaced by underscores ('_') in the branches produced by Snapshot.; /// When writing a variable size array through Snapshot, it is required that the column indicating its size is also; /// written out and it appears before the array in the columnList.; ///; /// By default, in case of TTree or TChain inputs, Snapshot will try to write out all top-level branches. For other; /// types of inputs, all columns returned by GetColumnNames() will be written out. If friend trees or chains are; /// present, by default all friend top-level branches that have names that do not collide with; /// names of branches in the main TTree/TChain will be written out. Since v6.24, Snapshot will also write out; /// friend branches with the same names of branches in the main TTree/TChain with names of the form; /// `<friendname>_<branchname>` in order to differentiate them from the branches in the main tree/chain.; ///; /// ### Writing to a sub-directory; ///; /// Snapshot supports writing the TTree in a sub-directory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as ne",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:3204,Modifiability,variab,variable,3204,"bdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; ///; /// ### Example invocations:; ///; /// ~~~{.cpp}; /// // without specifying template parameters (column types automatically deduced); /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});; ///; /// // specifying template parameters (""x"" is `int`, ""y"" is `float`); /// df.Snapshot<int, float>(""outputTree"", ""outputFile.root"", {""x"", ""y""});; /// ~~~; ///; /// To book a Snapshot without triggering the event loop, one needs to set the appropriate flag in; /// `RSnapshotOptions`:; /// ~~~{.cpp}; /// RSnapshotOptions opts;; /// opts.fLazy = true;; /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x""}, opts);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2032,Performance,multi-thread,multi-thread,2032," TTree or TChain inputs, Snapshot will try to write out all top-level branches. For other; /// types of inputs, all columns returned by GetColumnNames() will be written out. If friend trees or chains are; /// present, by default all friend top-level branches that have names that do not collide with; /// names of branches in the main TTree/TChain will be written out. Since v6.24, Snapshot will also write out; /// friend branches with the same names of branches in the main TTree/TChain with names of the form; /// `<friendname>_<branchname>` in order to differentiate them from the branches in the main tree/chain.; ///; /// ### Writing to a sub-directory; ///; /// Snapshot supports writing the TTree in a sub-directory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made avai",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2695,Performance,multi-thread,multi-thread,2695,"ory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; ///; /// ### Example invocations:; ///; /// ~~~{.cpp}; /// // without specifying template parameters (column types automatically deduced); /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});; ///; /// // specifying template parameters (""x"" is `int`, ""y"" is `float`); /// df.Snapshot<int, float>(""outputTree"", ""outputFile.root"", {""x"", ""y""});; /// ~~~; ///; /// To book a Snapshot without triggering the event loop, one needs to set ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2832,Performance,multi-thread,multi-thread,2832,"ory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; ///; /// ### Example invocations:; ///; /// ~~~{.cpp}; /// // without specifying template parameters (column types automatically deduced); /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});; ///; /// // specifying template parameters (""x"" is `int`, ""y"" is `float`); /// df.Snapshot<int, float>(""outputTree"", ""outputFile.root"", {""x"", ""y""});; /// ~~~; ///; /// To book a Snapshot without triggering the event loop, one needs to set ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:488,Integrability,wrap,wraps,488,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnList The list of names of the columns/branches to be written.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree.; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// This function returns a `RDataFrame` built with the output tree as a source.; /// The types of the columns are automatically inferred and do not need to be specified.; ///; /// See above for a more complete description and example usages.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:736,Integrability,wrap,wraps,736,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// This function returns a `RDataFrame` built with the output tree as a source.; /// The types of the columns are automatically inferred and do not need to be specified.; ///; /// See above for a more complete description and example usages.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:529,Integrability,wrap,wraps,529,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns to disk, in a new TTree `treename` in file `filename`.; /// \param[in] treename The name of the output TTree.; /// \param[in] filename The name of the output TFile.; /// \param[in] columnList The list of names of the columns/branches to be written.; /// \param[in] options RSnapshotOptions struct with extra options to pass to TFile and TTree.; /// \return a `RDataFrame` that wraps the snapshotted dataset.; ///; /// This function returns a `RDataFrame` built with the output tree as a source.; /// The types of the columns are automatically inferred and do not need to be specified.; ///; /// See above for a more complete description and example usages.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:847,Availability,avail,available,847,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:297,Integrability,wrap,wraps,297,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1025,Modifiability,variab,variable,1025,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:246,Performance,cache,cached,246,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:307,Performance,cache,cached,307,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:476,Performance,cache,cached,476,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:585,Performance,Cache,Cache,585,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:736,Performance,Cache,Cache,736,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1104,Performance,Cache,Cache,1104,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1261,Performance,Cache,Cache,1261,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1462,Performance,Cache,Cache,1462,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1653,Performance,Cache,Cache,1653,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:562,Security,access,access,562,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:699,Security,access,accessed,699,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:213,Integrability,wrap,wraps,213,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,Performance,cache,cached,163,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:223,Performance,cache,cached,223,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:69,Performance,Cache,Cache,69,"// build a string equivalent to; // ""(RInterface<nodetype*>*)(this)->Cache<Ts...>(*(ColumnNames_t*)(&columnList))""",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:467,Integrability,wrap,wraps,467,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// The existing columns are matched against the regular expression. If the string provided; /// is empty, all columns are selected. See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:477,Performance,cache,cached,477,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// The existing columns are matched against the regular expression. If the string provided; /// is empty, all columns are selected. See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:214,Integrability,wrap,wraps,214,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,Performance,cache,cached,163,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:224,Performance,cache,cached,224,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:759,Availability,avail,available,759,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Creates a node that filters entries based on range: [begin, end).; /// \param[in] begin Initial entry number considered for this range.; /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; /// \param[in] stride Process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; /// \return the first node of the computation graph for which the event loop is limited to a certain range of entries.; ///; /// Note that in case of previous Ranges and Filters the selected range refers to the transformed dataset.; /// Ranges are only available if EnableImplicitMT has _not_ been called. Multi-thread ranges are not supported.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto d_0_30 = d.Range(0, 30); // Pick the first 30 entries; /// auto d_15_end = d.Range(15, 0); // Pick all entries from 15 onwards; /// auto d_15_end_3 = d.Range(15, 0, 3); // Stride: from event 15, pick an event every 3; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:812,Performance,Multi-thread,Multi-thread,812,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Creates a node that filters entries based on range: [begin, end).; /// \param[in] begin Initial entry number considered for this range.; /// \param[in] end Final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; /// \param[in] stride Process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; /// \return the first node of the computation graph for which the event loop is limited to a certain range of entries.; ///; /// Note that in case of previous Ranges and Filters the selected range refers to the transformed dataset.; /// Ranges are only available if EnableImplicitMT has _not_ been called. Multi-thread ranges are not supported.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto d_0_30 = d.Range(0, 30); // Pick the first 30 entries; /// auto d_15_end = d.Range(15, 0); // Pick all entries from 15 onwards; /// auto d_15_end_3 = d.Range(15, 0, 3); // Stride: from event 15, pick an event every 3; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:536,Energy Efficiency,schedul,scheduled,536,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// The callable `f` is invoked once per entry. This is an *instant action*:; /// upon invocation, an event loop as well as execution of all scheduled actions; /// is triggered.; /// Users are responsible for the thread-safety of this callable when executing; /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:266,Performance,perform,performing,266,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// The callable `f` is invoked once per entry. This is an *instant action*:; /// upon invocation, an event loop as well as execution of all scheduled actions; /// is triggered.; /// Users are responsible for the thread-safety of this callable when executing; /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:673,Performance,multi-thread,multi-threading,673,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// The callable `f` is invoked once per entry. This is an *instant action*:; /// upon invocation, an event loop as well as execution of all scheduled actions; /// is triggered.; /// Users are responsible for the thread-safety of this callable when executing; /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:615,Safety,safe,safety,615,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// The callable `f` is invoked once per entry. This is an *instant action*:; /// upon invocation, an event loop as well as execution of all scheduled actions; /// is triggered.; /// Users are responsible for the thread-safety of this callable when executing; /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:300,Performance,perform,performing,300,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// Same as `Foreach`, but the user-defined function takes an extra; /// `unsigned int` as its first parameter, the *processing slot index*.; /// This *slot index* will be assigned a different value, `0` to `poolSize - 1`,; /// for each thread of execution.; /// This is meant as a helper in writing thread-safe `Foreach`; /// actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`.; /// The user-defined processing callable is able to follow different; /// *streams of processing* indexed by the first parameter.; /// `ForeachSlot` works just as well with single-thread execution: in that; /// case `slot` will always be `0`.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:736,Safety,safe,safe,736,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// Same as `Foreach`, but the user-defined function takes an extra; /// `unsigned int` as its first parameter, the *processing slot index*.; /// This *slot index* will be assigned a different value, `0` to `poolSize - 1`,; /// for each thread of execution.; /// This is meant as a helper in writing thread-safe `Foreach`; /// actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`.; /// The user-defined processing callable is able to follow different; /// *streams of processing* indexed by the first parameter.; /// `ForeachSlot` works just as well with single-thread execution: in that; /// case `slot` will always be `0`.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:133,Energy Efficiency,reduce,reduce,133,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:208,Energy Efficiency,reduce,reduce,208,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:433,Energy Efficiency,reduce,reduced,433,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:513,Energy Efficiency,reduce,reduced,513,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1026,Energy Efficiency,reduce,reduced,1026,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1445,Energy Efficiency,Reduce,Reduce,1445,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1538,Energy Efficiency,Reduce,Reduce,1538,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:530,Integrability,wrap,wrapped,530,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:707,Performance,perform,performs,707,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; ///; /// A reduction takes two values of a column and merges them into one (e.g.; /// by summing them, taking the maximum, etc). This action performs the; /// specified reduction operation on all processed column values, returning; /// a single value of the same type. The callable f must satisfy the general; /// requirements of a *processing function* besides having signature `T(T,T)`; /// where `T` is the type of column columnName.; ///; /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this; /// requirement, users should explicitly specify an initialization value for T by calling the appropriate `Reduce`; /// overload.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; /// ~~~; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:112,Energy Efficiency,reduce,reduce,112,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:187,Energy Efficiency,reduce,reduce,187,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:412,Energy Efficiency,reduce,reduced,412,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:507,Energy Efficiency,reduce,reduced,507,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:584,Energy Efficiency,reduce,reduced,584,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:706,Energy Efficiency,Reduce,Reduce,706,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:811,Energy Efficiency,Reduce,Reduce,811,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:601,Integrability,wrap,wrapped,601,"////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined reduce operation on the values of a column.; /// \tparam F The type of the reduce callable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] f A callable with signature `T(T,T)`; /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; /// \return the reduced quantity wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; /// ~~~; /// See the description of the first Reduce overload for more information.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:180,Integrability,wrap,wrapped,180,"////////////////////////////////////////////////////////////////////////////; /// \brief Return the number of entries processed (*lazy action*).; /// \return the number of entries wrapped in a RResultPtr.; ///; /// Useful e.g. for counting the number of entries passing a certain filter (see also `Report`).; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto nEntriesAfterCuts = myFilteredDf.Count();; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:408,Integrability,wrap,wrapped,408,"////////////////////////////////////////////////////////////////////////////; /// \brief Return a collection of values of a column (*lazy action*, returns a std::vector by default).; /// \tparam T The type of the column.; /// \tparam COLL The type of collection used to store the values.; /// \param[in] column The name of the column to collect the values of.; /// \return the content of the selected column wrapped in a RResultPtr.; ///; /// The collection type to be specified for C-style array columns is `RVec<T>`:; /// in this case the returned collection is a `std::vector<RVec<T>>`.; /// ### Example usage:; /// ~~~{.cpp}; /// // In this case intCol is a std::vector<int>; /// auto intCol = rdf.Take<int>(""integerColumn"");; /// // Same content as above but in this case taken as a RVec<int>; /// auto intColAsRVec = rdf.Take<int, RVec<int>>(""integerColumn"");; /// // In this case intCol is a std::vector<RVec<int>>, a collection of collections; /// auto cArrayIntCol = rdf.Take<RVec<int>>(""cArrayInt"");; /// ~~~; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:450,Integrability,wrap,wrapped,450,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional histogram with the values of a column (*lazy action*).; /// \tparam V The type of the column used to fill the histogram.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] vName The name of the column that will fill the histogram.; /// \return the monodimensional histogram wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. `std::vector<double>`), in which case the histogram; /// is filled with each one of the elements of the container. In case multiple columns of container type; /// are provided (e.g. values and weights) they must have the same length for each one of the events (but; /// possibly different lengths between events).; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo1D({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; /// // Explicit column type; /// auto myHist2 = myDf.Histo1D<float>({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1348,Integrability,interface,interfaces,1348,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional histogram with the values of a column (*lazy action*).; /// \tparam V The type of the column used to fill the histogram.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] vName The name of the column that will fill the histogram.; /// \return the monodimensional histogram wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. `std::vector<double>`), in which case the histogram; /// is filled with each one of the elements of the container. In case multiple columns of container type; /// are provided (e.g. values and weights) they must have the same length for each one of the events (but; /// possibly different lengths between events).; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo1D({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; /// // Explicit column type; /// auto myHist2 = myDf.Histo1D<float>({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:362,Integrability,wrap,wrapped,362,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional histogram with the values of a column (*lazy action*).; /// \tparam V The type of the column used to fill the histogram.; /// \param[in] vName The name of the column that will fill the histogram.; /// \return the monodimensional histogram wrapped in a RResultPtr.; ///; /// This overload uses a default model histogram TH1D(name, title, 128u, 0., 0.).; /// The ""name"" and ""title"" strings are built starting from the input column name.; /// See the description of the first Histo1D() overload for more details.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo1D(""myColumn"");; /// // Explicit column type; /// auto myHist2 = myDf.Histo1D<float>(""myColumn"");; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:590,Integrability,wrap,wrapped,590,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional histogram with the weighted values of a column (*lazy action*).; /// \tparam V The type of the column used to fill the histogram.; /// \tparam W The type of the column used as weights.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] vName The name of the column that will fill the histogram.; /// \param[in] wName The name of the column that will provide the weights.; /// \return the monodimensional histogram wrapped in a RResultPtr.; ///; /// See the description of the first Histo1D() overload for more details.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo1D({""histName"", ""histTitle"", 64u, 0., 128.}, ""myValue"", ""myweight"");; /// // Explicit column type; /// auto myHist2 = myDf.Histo1D<float, int>({""histName"", ""histTitle"", 64u, 0., 128.}, ""myValue"", ""myweight"");; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:502,Integrability,wrap,wrapped,502,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional histogram with the weighted values of a column (*lazy action*).; /// \tparam V The type of the column used to fill the histogram.; /// \tparam W The type of the column used as weights.; /// \param[in] vName The name of the column that will fill the histogram.; /// \param[in] wName The name of the column that will provide the weights.; /// \return the monodimensional histogram wrapped in a RResultPtr.; ///; /// This overload uses a default model histogram TH1D(name, title, 128u, 0., 0.).; /// The ""name"" and ""title"" strings are built starting from the input column names.; /// See the description of the first Histo1D() overload for more details.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo1D(""myValue"", ""myweight"");; /// // Explicit column types; /// auto myHist2 = myDf.Histo1D<float, int>(""myValue"", ""myweight"");; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:439,Integrability,wrap,wrapped,439,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional histogram with the weighted values of a column (*lazy action*).; /// \tparam V The type of the column used to fill the histogram.; /// \tparam W The type of the column used as weights.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \return the monodimensional histogram wrapped in a RResultPtr.; ///; /// This overload will use the first two default columns as column names.; /// See the description of the first Histo1D() overload for more details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:587,Integrability,wrap,wrapped,587,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a two-dimensional histogram (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram.; /// \tparam V2 The type of the column used to fill the y axis of the histogram.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \return the bidimensional histogram wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the histogram; /// is filled with each one of the elements of the container. In case multiple columns of container type; /// are provided (e.g. values and weights) they must have the same length for each one of the events (but; /// possibly different lengths between events).; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo2D({""histName"", ""histTitle"", 64u, 0., 128., 32u, -4., 4.}, ""myValueX"", ""myValueY"");; /// // Explicit column types; /// auto myHist2 = myDf.Histo2D<float, float>({""histName"", ""histTitle"", 64u, 0., 128., 32u, -4., 4.}, ""myValueX"", ""myValueY"");; /// ~~~; ///; ///; /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1549,Integrability,interface,interfaces,1549,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a two-dimensional histogram (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram.; /// \tparam V2 The type of the column used to fill the y axis of the histogram.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \return the bidimensional histogram wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the histogram; /// is filled with each one of the elements of the container. In case multiple columns of container type; /// are provided (e.g. values and weights) they must have the same length for each one of the events (but; /// possibly different lengths between events).; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo2D({""histName"", ""histTitle"", 64u, 0., 128., 32u, -4., 4.}, ""myValueX"", ""myValueY"");; /// // Explicit column types; /// auto myHist2 = myDf.Histo2D<float, float>({""histName"", ""histTitle"", 64u, 0., 128., 32u, -4., 4.}, ""myValueX"", ""myValueY"");; /// ~~~; ///; ///; /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:749,Integrability,wrap,wrapped,749,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a weighted two-dimensional histogram (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram.; /// \tparam V2 The type of the column used to fill the y axis of the histogram.; /// \tparam W The type of the column used for the weights of the histogram.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] wName The name of the column that will provide the weights.; /// \return the bidimensional histogram wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo2D({""histName"", ""histTitle"", 64u, 0., 128., 32u, -4., 4.}, ""myValueX"", ""myValueY"", ""myWeight"");; /// // Explicit column types; /// auto myHist2 = myDf.Histo2D<float, float, double>({""histName"", ""histTitle"", 64u, 0., 128., 32u, -4., 4.}, ""myValueX"", ""myValueY"", ""myWeight"");; /// ~~~; ///; /// See the documentation of the first Histo2D() overload for more details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:819,Integrability,wrap,wrapped,819,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a three-dimensional histogram (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram. Inferred if not present.; /// \tparam V2 The type of the column used to fill the y axis of the histogram. Inferred if not present.; /// \tparam V3 The type of the column used to fill the z axis of the histogram. Inferred if not present.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] v3Name The name of the column that will fill the z axis.; /// \return the tridimensional histogram wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo3D({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; /// ""myValueX"", ""myValueY"", ""myValueZ"");; /// // Explicit column types; /// auto myHist2 = myDf.Histo3D<double, double, float>({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; /// ""myValueX"", ""myValueY"", ""myValueZ"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1471,Integrability,interface,interfaces,1471,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a three-dimensional histogram (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram. Inferred if not present.; /// \tparam V2 The type of the column used to fill the y axis of the histogram. Inferred if not present.; /// \tparam V3 The type of the column used to fill the z axis of the histogram. Inferred if not present.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] v3Name The name of the column that will fill the z axis.; /// \return the tridimensional histogram wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo3D({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; /// ""myValueX"", ""myValueY"", ""myValueZ"");; /// // Explicit column types; /// auto myHist2 = myDf.Histo3D<double, double, float>({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; /// ""myValueX"", ""myValueY"", ""myValueZ"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:997,Integrability,wrap,wrapped,997,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a three-dimensional histogram (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram. Inferred if not present.; /// \tparam V2 The type of the column used to fill the y axis of the histogram. Inferred if not present.; /// \tparam V3 The type of the column used to fill the z axis of the histogram. Inferred if not present.; /// \tparam W The type of the column used for the weights of the histogram. Inferred if not present.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] v3Name The name of the column that will fill the z axis.; /// \param[in] wName The name of the column that will provide the weights.; /// \return the tridimensional histogram wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myHist1 = myDf.Histo3D({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; /// ""myValueX"", ""myValueY"", ""myValueZ"", ""myWeight"");; /// // Explicit column types; /// using d_t = double;; /// auto myHist2 = myDf.Histo3D<d_t, d_t, float, d_t>({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; /// ""myValueX"", ""myValueY"", ""myValueZ"", ""myWeight"");; /// ~~~; ///; ///; /// See the documentation of the first Histo2D() overload for more details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:725,Integrability,wrap,wrapped,725,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return an N-dimensional histogram (*lazy action*).; /// \tparam FirstColumn The first type of the column the values of which are used to fill the object. Inferred if not; /// present.; /// \tparam OtherColumns A list of the other types of the columns the values of which are used to fill the; /// object.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] columnList; /// A list containing the names of the columns that will be passed when calling `Fill`.; /// (N columns for unweighted filling, or N+1 columns for weighted filling); /// \return the N-dimensional histogram wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. See RResultPtr documentation.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto myFilledObj = myDf.HistoND<float, float, float, float>({""name"",""title"", 4,; /// {40,40,40,40}, {20.,20.,20.,20.}, {60.,60.,60.,60.}},; /// {""col0"", ""col1"", ""col2"", ""col3""});; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:465,Integrability,wrap,wrapped,465,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return an N-dimensional histogram (*lazy action*).; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] columnList A list containing the names of the columns that will be passed when calling `Fill`; /// (N columns for unweighted filling, or N+1 columns for weighted filling); /// \return the N-dimensional histogram wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto myFilledObj = myDf.HistoND({""name"",""title"", 4,; /// {40,40,40,40}, {20.,20.,20.,20.}, {60.,60.,60.,60.}},; /// {""col0"", ""col1"", ""col2"", ""col3""});; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:424,Integrability,wrap,wrapped,424,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraph object (*lazy action*).; /// \tparam X The type of the column used to fill the x axis.; /// \tparam Y The type of the column used to fill the y axis.; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \return the TGraph wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the TGraph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; /// If the Graph has to be drawn, it is suggested to the user to sort it on the x before printing.; /// A name and a title to the TGraph is given based on the input column names.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGraph1 = myDf.Graph(""xValues"", ""yValues"");; /// // Explicit column types; /// auto myGraph2 = myDf.Graph<int, float>(""xValues"", ""yValues"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraph is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1332,Integrability,interface,interfaces,1332,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraph object (*lazy action*).; /// \tparam X The type of the column used to fill the x axis.; /// \tparam Y The type of the column used to fill the y axis.; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \return the TGraph wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the TGraph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; /// If the Graph has to be drawn, it is suggested to the user to sort it on the x before printing.; /// A name and a title to the TGraph is given based on the input column names.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGraph1 = myDf.Graph(""xValues"", ""yValues"");; /// // Explicit column types; /// auto myGraph2 = myDf.Graph<int, float>(""xValues"", ""yValues"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraph is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:337,Availability,error,errors,337,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \param[in] exl The name of the column of X low errors; /// \param[in] exh The name of the column of X high errors; /// \param[in] eyl The name of the column of Y low errors; /// \param[in] eyh The name of the column of Y high errors; /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGAE1 = myDf.GraphAsymmErrors(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// // Explicit column types; /// using f = float; /// auto myGAE2 = myDf.GraphAsymmErrors<f, f, f, f, f, f>(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraphAsymmErrors is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:397,Availability,error,errors,397,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \param[in] exl The name of the column of X low errors; /// \param[in] exh The name of the column of X high errors; /// \param[in] eyl The name of the column of Y low errors; /// \param[in] eyh The name of the column of Y high errors; /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGAE1 = myDf.GraphAsymmErrors(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// // Explicit column types; /// using f = float; /// auto myGAE2 = myDf.GraphAsymmErrors<f, f, f, f, f, f>(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraphAsymmErrors is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:456,Availability,error,errors,456,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \param[in] exl The name of the column of X low errors; /// \param[in] exh The name of the column of X high errors; /// \param[in] eyl The name of the column of Y low errors; /// \param[in] eyh The name of the column of Y high errors; /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGAE1 = myDf.GraphAsymmErrors(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// // Explicit column types; /// using f = float; /// auto myGAE2 = myDf.GraphAsymmErrors<f, f, f, f, f, f>(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraphAsymmErrors is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:516,Availability,error,errors,516,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \param[in] exl The name of the column of X low errors; /// \param[in] exh The name of the column of X high errors; /// \param[in] eyl The name of the column of Y low errors; /// \param[in] eyh The name of the column of Y high errors; /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGAE1 = myDf.GraphAsymmErrors(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// // Explicit column types; /// using f = float; /// auto myGAE2 = myDf.GraphAsymmErrors<f, f, f, f, f, f>(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraphAsymmErrors is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:558,Integrability,wrap,wrapped,558,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \param[in] exl The name of the column of X low errors; /// \param[in] exh The name of the column of X high errors; /// \param[in] eyl The name of the column of Y low errors; /// \param[in] eyh The name of the column of Y high errors; /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGAE1 = myDf.GraphAsymmErrors(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// // Explicit column types; /// using f = float; /// auto myGAE2 = myDf.GraphAsymmErrors<f, f, f, f, f, f>(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraphAsymmErrors is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1386,Integrability,interface,interfaces,1386,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; /// \param[in] x The name of the column that will fill the x axis.; /// \param[in] y The name of the column that will fill the y axis.; /// \param[in] exl The name of the column of X low errors; /// \param[in] exh The name of the column of X high errors; /// \param[in] eyl The name of the column of Y low errors; /// \param[in] eyh The name of the column of Y high errors; /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; ///; /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; /// is filled with each one of the elements of the container.; /// If Multithreading is enabled, the order in which points are inserted is undefined.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myGAE1 = myDf.GraphAsymmErrors(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// // Explicit column types; /// using f = float; /// auto myGAE2 = myDf.GraphAsymmErrors<f, f, f, f, f, f>(""xValues"", ""yValues"", ""exl"", ""exh"", ""eyl"", ""eyh"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned TGraphAsymmErrors is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:643,Integrability,wrap,wrapped,643,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional profile (*lazy action*).; /// \tparam V1 The type of the column the values of which are used to fill the profile. Inferred if not present.; /// \tparam V2 The type of the column the values of which are used to fill the profile. Inferred if not present.; /// \param[in] model The model to be considered to build the new return value.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \return the monodimensional profile wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myProf1 = myDf.Profile1D({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; /// // Explicit column types; /// auto myProf2 = myDf.Graph<int, float>({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned profile is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1206,Integrability,interface,interfaces,1206,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional profile (*lazy action*).; /// \tparam V1 The type of the column the values of which are used to fill the profile. Inferred if not present.; /// \tparam V2 The type of the column the values of which are used to fill the profile. Inferred if not present.; /// \param[in] model The model to be considered to build the new return value.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \return the monodimensional profile wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myProf1 = myDf.Profile1D({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; /// // Explicit column types; /// auto myProf2 = myDf.Graph<int, float>({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned profile is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:833,Integrability,wrap,wrapped,833,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a one-dimensional profile (*lazy action*).; /// \tparam V1 The type of the column the values of which are used to fill the profile. Inferred if not present.; /// \tparam V2 The type of the column the values of which are used to fill the profile. Inferred if not present.; /// \tparam W The type of the column the weights of which are used to fill the profile. Inferred if not present.; /// \param[in] model The model to be considered to build the new return value.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] wName The name of the column that will provide the weights.; /// \return the monodimensional profile wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myProf1 = myDf.Profile1D({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"", ""weight"");; /// // Explicit column types; /// auto myProf2 = myDf.Profile1D<int, float, double>({""profName"", ""profTitle"", 64u, -4., 4.},; /// ""xValues"", ""yValues"", ""weight"");; /// ~~~; ///; /// See the first Profile1D() overload for more details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:810,Integrability,wrap,wrapped,810,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a two-dimensional profile (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram. Inferred if not present.; /// \tparam V2 The type of the column used to fill the y axis of the histogram. Inferred if not present.; /// \tparam V3 The type of the column used to fill the z axis of the histogram. Inferred if not present.; /// \param[in] model The returned profile will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] v3Name The name of the column that will fill the z axis.; /// \return the bidimensional profile wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myProf1 = myDf.Profile2D({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; /// ""xValues"", ""yValues"", ""zValues"");; /// // Explicit column types; /// auto myProf2 = myDf.Profile2D<int, float, double>({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; /// ""xValues"", ""yValues"", ""zValues"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned profile is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1447,Integrability,interface,interfaces,1447,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a two-dimensional profile (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram. Inferred if not present.; /// \tparam V2 The type of the column used to fill the y axis of the histogram. Inferred if not present.; /// \tparam V3 The type of the column used to fill the z axis of the histogram. Inferred if not present.; /// \param[in] model The returned profile will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] v3Name The name of the column that will fill the z axis.; /// \return the bidimensional profile wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myProf1 = myDf.Profile2D({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; /// ""xValues"", ""yValues"", ""zValues"");; /// // Explicit column types; /// auto myProf2 = myDf.Profile2D<int, float, double>({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; /// ""xValues"", ""yValues"", ""zValues"");; /// ~~~; ///; /// \note Differently from other ROOT interfaces, the returned profile is not associated to gDirectory; /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:990,Integrability,wrap,wrapped,990,"////////////////////////////////////////////////////////////////////////////; /// \brief Fill and return a two-dimensional profile (*lazy action*).; /// \tparam V1 The type of the column used to fill the x axis of the histogram. Inferred if not present.; /// \tparam V2 The type of the column used to fill the y axis of the histogram. Inferred if not present.; /// \tparam V3 The type of the column used to fill the z axis of the histogram. Inferred if not present.; /// \tparam W The type of the column used for the weights of the histogram. Inferred if not present.; /// \param[in] model The returned histogram will be constructed using this as a model.; /// \param[in] v1Name The name of the column that will fill the x axis.; /// \param[in] v2Name The name of the column that will fill the y axis.; /// \param[in] v3Name The name of the column that will fill the z axis.; /// \param[in] wName The name of the column that will provide the weights.; /// \return the bidimensional profile wrapped in a RResultPtr.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto myProf1 = myDf.Profile2D({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; /// ""xValues"", ""yValues"", ""zValues"", ""weight"");; /// // Explicit column types; /// auto myProf2 = myDf.Profile2D<int, float, double, int>({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; /// ""xValues"", ""yValues"", ""zValues"", ""weight"");; /// ~~~; ///; /// See the first Profile2D() overload for more details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1375,Integrability,wrap,wrapped,1375,"///////////////////////////////; /// \brief Return an object of type T on which `T::Fill` will be called once per event (*lazy action*).; ///; /// Type T must provide at least:; /// - a copy-constructor; /// - a `Fill` method that accepts as many arguments and with same types as the column names passed as columnList; /// (these types can also be passed as template parameters to this method); /// - a `Merge` method with signature `Merge(TCollection *)` or `Merge(const std::vector<T *>&)` that merges the; /// objects passed as argument into the object on which `Merge` was called (an analogous of TH1::Merge). Note that; /// if the signature that takes a `TCollection*` is used, then T must inherit from TObject (to allow insertion in; /// the TCollection*).; ///; /// \tparam FirstColumn The first type of the column the values of which are used to fill the object. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the other types of the columns the values of which are used to fill the object.; /// \tparam T The type of the object to fill. Automatically deduced.; /// \param[in] model The model to be considered to build the new return value.; /// \param[in] columnList A list containing the names of the columns that will be passed when calling `Fill`; /// \return the filled object wrapped in a RResultPtr.; ///; /// The user gives up ownership of the model object.; /// The list of column names to be used for filling must always be specified.; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed.; /// Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// MyClass obj;; /// // Deduce column types (this invocation needs jitting internally, and in this case; /// // MyClass needs to be known to the interpreter); /// auto myFilledObj = myDf.Fill(obj, {""col0"", ""col1""});; /// // explicit column types; /// auto myFilledObj = myDf.Fill<float, float>(obj, {""col0"", ""col1""});; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:740,Modifiability,inherit,inherit,740,"////////////////////////////////////////////////////////////////////////////; /// \brief Return an object of type T on which `T::Fill` will be called once per event (*lazy action*).; ///; /// Type T must provide at least:; /// - a copy-constructor; /// - a `Fill` method that accepts as many arguments and with same types as the column names passed as columnList; /// (these types can also be passed as template parameters to this method); /// - a `Merge` method with signature `Merge(TCollection *)` or `Merge(const std::vector<T *>&)` that merges the; /// objects passed as argument into the object on which `Merge` was called (an analogous of TH1::Merge). Note that; /// if the signature that takes a `TCollection*` is used, then T must inherit from TObject (to allow insertion in; /// the TCollection*).; ///; /// \tparam FirstColumn The first type of the column the values of which are used to fill the object. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the other types of the columns the values of which are used to fill the object.; /// \tparam T The type of the object to fill. Automatically deduced.; /// \param[in] model The model to be considered to build the new return value.; /// \param[in] columnList A list containing the names of the columns that will be passed when calling `Fill`; /// \return the filled object wrapped in a RResultPtr.; ///; /// The user gives up ownership of the model object.; /// The list of column names to be used for filling must always be specified.; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed.; /// Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// MyClass obj;; /// // Deduce column types (this invocation needs jitting internally, and in this case; /// // MyClass needs to be known to the interpreter); /// auto myFilledObj = myDf.Fill(obj, {""col0"", ""col1""});; /// // explicit column types; /// auto myFilledObj = myDf.Fill<float, f",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:337,Integrability,wrap,wrapped,337,"////////////////////////////////////////////////////////////////////////////; /// \brief Return a TStatistic object, filled once per event (*lazy action*).; ///; /// \tparam V The type of the value column; /// \param[in] value The name of the column with the values to fill the statistics with.; /// \return the filled TStatistic object wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto stats0 = myDf.Stats(""values"");; /// // Explicit column type; /// auto stats1 = myDf.Stats<float>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:474,Integrability,wrap,wrapped,474,"////////////////////////////////////////////////////////////////////////////; /// \brief Return a TStatistic object, filled once per event (*lazy action*).; ///; /// \tparam V The type of the value column; /// \tparam W The type of the weight column; /// \param[in] value The name of the column with the values to fill the statistics with.; /// \param[in] weight The name of the column with the weights to fill the statistics with.; /// \return the filled TStatistic object wrapped in a RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column types (this invocation needs jitting internally); /// auto stats0 = myDf.Stats(""values"", ""weights"");; /// // Explicit column types; /// auto stats1 = myDf.Stats<int, float>(""values"", ""weights"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:324,Integrability,wrap,wrapped,324,"////////////////////////////////////////////////////////////////////////////; /// \brief Return the minimum of processed column values (*lazy action*).; /// \tparam T The type of the branch/column.; /// \param[in] columnName The name of the branch/column to be treated.; /// \return the minimum value of the selected column wrapped in a RResultPtr.; ///; /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; /// template specialization of this method.; /// If the type of the column is inferred, the return type is `double`, the type of the column otherwise.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto minVal0 = myDf.Min(""values"");; /// // Explicit column type; /// auto minVal1 = myDf.Min<double>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:324,Integrability,wrap,wrapped,324,"////////////////////////////////////////////////////////////////////////////; /// \brief Return the maximum of processed column values (*lazy action*).; /// \tparam T The type of the branch/column.; /// \param[in] columnName The name of the branch/column to be treated.; /// \return the maximum value of the selected column wrapped in a RResultPtr.; ///; /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; /// template specialization of this method.; /// If the type of the column is inferred, the return type is `double`, the type of the column otherwise.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto maxVal0 = myDf.Max(""values"");; /// // Explicit column type; /// auto maxVal1 = myDf.Max<double>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:318,Integrability,wrap,wrapped,318,"////////////////////////////////////////////////////////////////////////////; /// \brief Return the mean of processed column values (*lazy action*).; /// \tparam T The type of the branch/column.; /// \param[in] columnName The name of the branch/column to be treated.; /// \return the mean value of the selected column wrapped in a RResultPtr.; ///; /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; /// template specialization of this method.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto meanVal0 = myDf.Mean(""values"");; /// // Explicit column type; /// auto meanVal1 = myDf.Mean<double>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:355,Integrability,wrap,wrapped,355,"////////////////////////////////////////////////////////////////////////////; /// \brief Return the unbiased standard deviation of processed column values (*lazy action*).; /// \tparam T The type of the branch/column.; /// \param[in] columnName The name of the branch/column to be treated.; /// \return the standard deviation value of the selected column wrapped in a RResultPtr.; ///; /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; /// template specialization of this method.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto stdDev0 = myDf.StdDev(""values"");; /// // Explicit column type; /// auto stdDev1 = myDf.StdDev<double>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:444,Integrability,wrap,wrapped,444,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Return the sum of processed column values (*lazy action*).; /// \tparam T The type of the branch/column.; /// \param[in] columnName The name of the branch/column.; /// \param[in] initValue Optional initial value for the sum. If not present, the column values must be default-constructible.; /// \return the sum of the selected column wrapped in a RResultPtr.; ///; /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; /// template specialization of this method.; /// If the type of the column is inferred, the return type is `double`, the type of the column otherwise.; ///; /// This action is *lazy*: upon invocation of this method the calculation is; /// booked but not executed. Also see RResultPtr.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // Deduce column type (this invocation needs jitting internally); /// auto sum0 = myDf.Sum(""values"");; /// // Explicit column type; /// auto sum1 = myDf.Sum<double>(""values"");; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:191,Integrability,wrap,wrapped,191,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Gather filtering statistics.; /// \return the resulting `RCutFlowReport` instance wrapped in a RResultPtr.; ///; /// Calling `Report` on the main `RDataFrame` object gathers stats for; /// all named filters in the call graph. Calling this method on a; /// stored chain state (i.e. a graph node different from the first) gathers; /// the stats for all named filters in the chain section between the original; /// `RDataFrame` and that node (included). Stats are gathered in the same; /// order as the named filters have been added to the graph.; /// A RResultPtr<RCutFlowReport> is returned to allow inspection of the; /// effects cuts had.; ///; /// This action is *lazy*: upon invocation of; /// this method the calculation is booked but not executed. See RResultPtr; /// documentation.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto filtered = d.Filter(cut1, {""b1""}, ""Cut1"").Filter(cut2, {""b2""}, ""Cut2"");; /// auto cutReport = filtered3.Report();; /// cutReport->Print();; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1128,Integrability,wrap,wrapped,1128,"///////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregato",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:329,Modifiability,variab,variable,329,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` i",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:667,Modifiability,variab,variable,667,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` i",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:976,Modifiability,variab,variable,976,"///////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregato",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1218,Modifiability,variab,variable,1218,"essing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Exampl",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1262,Modifiability,variab,variable,1262,"U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1455,Modifiability,variab,variable,1455,".; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will pr",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1558,Modifiability,variab,variable,1558,"ure `U(U,T)` or `void(U&,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will produce a vector of partial accumulators.; /// // The merger function performs the final aggregation of these partial results.; /// auto merg",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1901,Modifiability,variab,variables,1901,"t default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will produce a vector of partial accumulators.; /// // The merger function performs the final aggregation of these partial results.; /// auto merger = [](std::vector<double> &accumulators) {; /// for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; /// accumulators[0] *= accumulators[i];; /// }; /// };; ///; /// // The accumulator is initialized at this value by every thread.; /// double initValue = 1.;; ///; /// // Multiplies all elements of the column ""x""; /// auto r",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1827,Performance,multi-thread,multi-thread,1827,"\param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will produce a vector of partial accumulators.; /// // The merger function performs the final aggregation of these partial results.; /// auto merger = [](std::vector<double> &accumulators) {; /// for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; /// accumulators[0] *= accumulators[i];; /// }; /// };; ///; /// // The accumulator is initialized at this value by every thread.; /// double initValue ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2500,Performance,perform,performs,2500,"f each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will produce a vector of partial accumulators.; /// // The merger function performs the final aggregation of these partial results.; /// auto merger = [](std::vector<double> &accumulators) {; /// for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; /// accumulators[0] *= accumulators[i];; /// }; /// };; ///; /// // The accumulator is initialized at this value by every thread.; /// double initValue = 1.;; ///; /// // Multiplies all elements of the column ""x""; /// auto result = d.Aggregate(aggregator, merger, ""x"", initValue);; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:975,Integrability,wrap,wrapped,975,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// See previous Aggregate overload for more information.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:329,Modifiability,variab,variable,329,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// See previous Aggregate overload for more information.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:666,Modifiability,variab,variable,666,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined accumulation operation on the processed column values in each processing slot.; /// \tparam F The type of the aggregator callable. Automatically deduced.; /// \tparam U The type of the aggregator variable. Must be default-constructible, copy-constructible and copy-assignable. Automatically deduced.; /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; /// \param[in] aggregator A callable with signature `U(U,T)` or `void(U,T)`, where T is the type of the column, U is the type of the aggregator variable; /// \param[in] merger A callable with signature `U(U,U)` or `void(std::vector<U>&)` used to merge the results of the accumulations of each thread; /// \param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// See previous Aggregate overload for more information.; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:553,Energy Efficiency,schedul,scheduled,553,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:478,Integrability,interface,interface,478,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:677,Integrability,wrap,wrapped,677,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:802,Integrability,depend,dependent,802,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:875,Integrability,interface,interface,875,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1080,Integrability,interface,interface,1080," of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1125,Modifiability,inherit,inherit,1125," of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2440,Performance,optimiz,optimizations,2440,"tr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2709,Performance,concurren,concurrently,2709," the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; /// RDataFram",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:3594,Performance,concurren,concurrently,3594,"olumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; /// RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; /// * `ROOT::RDF::SampleCallback_t GetSampleCallback()`: if present, it must return a callable with the; /// appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing; /// of every sample, as in DefinePerSample().; /// * `Helper MakeNew(void *newResult)`: if implemented, it enables varying the action's result with VariationsFor(). It takes a; /// type-erased new result that can be safely cast to a `std::shared_ptr<Result_t> *` (a pointer to shared pointer) and should; /// be used as the action's output result.; ///; /// In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled; /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; ///; /// This action is *lazy*: upon invocation of this ",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2844,Safety,safe,safe,2844,"fore starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; /// RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; /// * `ROOT::RDF::SampleCallback_t GetSampleCallback(",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:4175,Safety,safe,safely,4175,"ssed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; /// RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; /// * `ROOT::RDF::SampleCallback_t GetSampleCallback()`: if present, it must return a callable with the; /// appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing; /// of every sample, as in DefinePerSample().; /// * `Helper MakeNew(void *newResult)`: if implemented, it enables varying the action's result with VariationsFor(). It takes a; /// type-erased new result that can be safely cast to a `std::shared_ptr<Result_t> *` (a pointer to shared pointer) and should; /// be used as the action's output result.; ///; /// In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled; /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// ### Examples; /// See [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html) for an example implementation of an action helper.; ///; /// It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx.; ///; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:498,Security,expose,expose,498,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2546,Usability,simpl,simple,2546,"The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the give",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:24,Safety,sanity check,sanity checks,24,"// TODO add more static sanity checks on Helper",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:480,Integrability,wrap,wrapped,480,"////////////////////////////////////////////////////////////////////////////; /// \brief Provides a representation of the columns in the dataset.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList Names of the columns to be displayed.; /// \param[in] nRows Number of events for each column to be displayed.; /// \param[in] nMaxCollectionElements Maximum number of collection elements to display per row.; /// \return the `RDisplay` instance wrapped in a RResultPtr.; ///; /// This function returns a `RResultPtr<RDisplay>` containing all the entries to be displayed, organized in a tabular; /// form. RDisplay will either print on the standard output a summarized version through `RDisplay::Print()` or will; /// return a complete version through `RDisplay::AsString()`.; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see; /// RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// // Preparing the RResultPtr<RDisplay> object with all columns and default number of entries; /// auto d1 = rdf.Display("""");; /// // Preparing the RResultPtr<RDisplay> object with two columns and 128 entries; /// auto d2 = d.Display({""x"", ""y""}, 128);; /// // Printing the short representations, the event loop will run; /// d1->Print();; /// d2->Print();; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:417,Integrability,wrap,wrapped,417,"////////////////////////////////////////////////////////////////////////////; /// \brief Provides a representation of the columns in the dataset.; /// \param[in] columnList Names of the columns to be displayed.; /// \param[in] nRows Number of events for each column to be displayed.; /// \param[in] nMaxCollectionElements Maximum number of collection elements to display per row.; /// \return the `RDisplay` instance wrapped in a RResultPtr.; ///; /// This overload automatically infers the column types.; /// See the previous overloads for further details.; ///; /// Invoked when no types are specified to Display",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:429,Integrability,wrap,wrapped,429,"////////////////////////////////////////////////////////////////////////////; /// \brief Provides a representation of the columns in the dataset.; /// \param[in] columnNameRegexp A regular expression to select the columns.; /// \param[in] nRows Number of events for each column to be displayed.; /// \param[in] nMaxCollectionElements Maximum number of collection elements to display per row.; /// \return the `RDisplay` instance wrapped in a RResultPtr.; ///; /// The existing columns are matched against the regular expression. If the string provided; /// is empty, all columns are selected.; /// See the previous overloads for further details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:401,Integrability,wrap,wrapped,401,"////////////////////////////////////////////////////////////////////////////; /// \brief Provides a representation of the columns in the dataset.; /// \param[in] columnList Names of the columns to be displayed.; /// \param[in] nRows Number of events for each column to be displayed.; /// \param[in] nMaxCollectionElements Number of maximum elements in collection.; /// \return the `RDisplay` instance wrapped in a RResultPtr.; ///; /// See the previous overloads for further details.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:61,Availability,error,error,61,"// The type is not known to the interpreter.; // We must not error out here, but if/when this column is used in jitted code",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:125,Availability,error,error,125,"// This overload is chosen when the callable passed to Define or DefineSlot returns void.; // It simply fires a compile-time error. This is preferable to a static_assert in the main `Define` overload because; // this way compilation of `Define` has no way to continue after throwing the error.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:287,Availability,error,error,287,"// This overload is chosen when the callable passed to Define or DefineSlot returns void.; // It simply fires a compile-time error. This is preferable to a static_assert in the main `Define` overload because; // this way compilation of `Define` has no way to continue after throwing the error.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:97,Usability,simpl,simply,97,"// This overload is chosen when the callable passed to Define or DefineSlot returns void.; // It simply fires a compile-time error. This is preferable to a static_assert in the main `Define` overload because; // this way compilation of `Define` has no way to continue after throwing the error.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:107,Performance,cache,cache,107,"////////////////////////////////////////////////////////////////////////////; /// \brief Implementation of cache.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:66,Availability,error,error,66,"// The type is not known to the interpreter, but we don't want to error out; // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:143,Integrability,inject,inject,143,"// The type is not known to the interpreter, but we don't want to error out; // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:143,Security,inject,inject,143,"// The type is not known to the interpreter, but we don't want to error out; // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx:114,Integrability,interface,interface,114,"// clang-format off; /**; * \class ROOT::Internal::RDF::RInterfaceBase; * \ingroup dataframe; * \brief The public interface to the RDataFrame federation of classes.; * \tparam Proxied One of the ""node"" base types (e.g. RLoopManager, RFilterBase). The user never specifies this type manually.; * \tparam DataSource The type of the RDataSource which is providing the data to the data frame. There is no source by default.; *; * The documentation of each method features a one liner illustrating how to use the method, for example showing how; * the majority of the template parameters are automatically deduced requiring no or very little effort by the user.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx:363,Performance,Cache,Cache,363,"/// Create RAction object, return RResultPtr for the action; /// Overload for the case in which all column types were specified (no jitting).; /// For most actions, `r` and `helperArg` will refer to the same object, because the only argument to forward to; /// the action helper is the result value itself. We need the distinction for actions such as Snapshot or Cache,; /// for which the constructor arguments of the action helper are different from the returned value.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:6,Integrability,wrap,wrapper,6,"/// A wrapper around a concrete RDefine, which forwards all calls to it; /// RJittedDefine is a placeholder that is put in the collection of custom columns in place of a RDefine; /// that will be just-in-time compiled. Jitted code will assign the concrete RDefine to this RJittedDefine; /// before the event-loop starts.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:194,Availability,avail,available,194,"/// Type info obtained through TypeName2TypeID based on the column type name.; /// The expectation is that this always compares equal to fConcreteDefine->GetTypeId() (which however is only; /// available after jitting). It can be null if TypeName2TypeID failed to figure out this type.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:7,Availability,recover,recovering,7,"// try recovering the type_info of this type, no problem if we fail (as long as no one calls GetTypeId)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:7,Safety,recover,recovering,7,"// try recovering the type_info of this type, no problem if we fail (as long as no one calls GetTypeId)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedFilter.hxx:6,Integrability,wrap,wrapper,6,"/// A wrapper around a concrete RFilter, which forwards all calls to it; /// RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set; /// at a later time, from jitted code.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RJittedFilter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedFilter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedVariation.hxx:6,Integrability,wrap,wrapper,6,"/// A wrapper around a concrete RVariation, which forwards all calls to it; /// RJittedVariation is a placeholder that is inserted in the computation graph in place of a RVariation; /// that will be just-in-time compiled. Jitted code will assign the concrete RVariation to this RJittedVariation; /// before the event-loop starts.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RJittedVariation.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedVariation.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLazyDSImpl.hxx:16,Modifiability,variab,variable,16,"// avoid unused variable warnings",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RLazyDSImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLazyDSImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLazyDSImpl.hxx:3,Safety,avoid,avoid,3,"// avoid unused variable warnings",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RLazyDSImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLazyDSImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:31,Safety,unsafe,unsafe,31,"// std::vector<bool> is thread-unsafe for our purposes (and generally evil)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:4,Performance,Cache,Cache,4,"/// Cache of the tree/chain branch names. Never access directy, always use GetBranchNames().",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:48,Security,access,access,48,"/// Cache of the tree/chain branch names. Never access directy, always use GetBranchNames().",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:62,Availability,error,error,62,"// List of branches for which we want to suppress the printed error about; // missing branch when switching to a new tree. This is modified by readers,; // so must be declared before them in this class.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:2361,Availability,avail,available,2361,"RMergeableValue stores the result of the RDataFrame action and has a `Merge`; method to allow the aggregation of information coming from another similar; result into the current. A mergeable value can be retrieved from an RResultPtr through the; [GetMergeableValue]; (namespaceROOT_1_1Detail_1_1RDF.html#a8b3a9c7b416826acc952d78a56d14ecb) free; function and a sequence of mergeables can be merged together with the helper; function [MergeValues]; (namespaceROOT_1_1Detail_1_1RDF.html#af16fefbe2d120983123ddf8a1e137277).; All the classes and functions involved are inside the `ROOT::Detail::RDF`; namespace. In a nutshell:; ~~~{.cpp}; using namespace ROOT::Detail::RDF;; ROOT::RDataFrame d(""myTree"", ""file_*.root"");; auto h1 = d.Histo1D(""Branch_A"");; auto h2 = d.Histo1D(""Branch_A"");. // Retrieve mergeables from the `RResultPtr`s; auto mergeableh1 = GetMergeableValue(h1);; auto mergeableh2 = GetMergeableValue(h2);. // Merge the values and get another mergeable back; auto mergedptr = MergeValues(std::move(mergeableh1), std::move(mergeableh2));. // Retrieve the merged TH1D object; const auto &mergedhisto = mergedptr->GetValue();; ~~~. Though this snippet can run on a single thread of a single machine, it is; straightforward to generalize it to a distributed case, e.g. where `mergeableh1`; and `mergeableh2` are created on separate machines and sent to a `reduce`; process where the `MergeValues` function is called. The final user would then; just be given the final merged result coming from `mergedptr->GetValue`. RMergeableValue is the base class for all the different specializations that may; be needed according to the peculiarities of the result types. The following; subclasses, their names hinting at the action operation of the result, are; currently available:. - RMergeableCount; - RMergeableFill, responsible for the following actions:; - Graph; - Histo{1,2,3}D; - Profile{1,2}D; - Stats; - RMergeableMax; - RMergeableMean; - RMergeableMin; - RMergeableStdDev; - RMergeableSum; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:1955,Energy Efficiency,reduce,reduce,1955,"RMergeableValue stores the result of the RDataFrame action and has a `Merge`; method to allow the aggregation of information coming from another similar; result into the current. A mergeable value can be retrieved from an RResultPtr through the; [GetMergeableValue]; (namespaceROOT_1_1Detail_1_1RDF.html#a8b3a9c7b416826acc952d78a56d14ecb) free; function and a sequence of mergeables can be merged together with the helper; function [MergeValues]; (namespaceROOT_1_1Detail_1_1RDF.html#af16fefbe2d120983123ddf8a1e137277).; All the classes and functions involved are inside the `ROOT::Detail::RDF`; namespace. In a nutshell:; ~~~{.cpp}; using namespace ROOT::Detail::RDF;; ROOT::RDataFrame d(""myTree"", ""file_*.root"");; auto h1 = d.Histo1D(""Branch_A"");; auto h2 = d.Histo1D(""Branch_A"");. // Retrieve mergeables from the `RResultPtr`s; auto mergeableh1 = GetMergeableValue(h1);; auto mergeableh2 = GetMergeableValue(h2);. // Merge the values and get another mergeable back; auto mergedptr = MergeValues(std::move(mergeableh1), std::move(mergeableh2));. // Retrieve the merged TH1D object; const auto &mergedhisto = mergedptr->GetValue();; ~~~. Though this snippet can run on a single thread of a single machine, it is; straightforward to generalize it to a distributed case, e.g. where `mergeableh1`; and `mergeableh2` are created on separate machines and sent to a `reduce`; process where the `MergeValues` function is called. The final user would then; just be given the final merged result coming from `mergedptr->GetValue`. RMergeableValue is the base class for all the different specializations that may; be needed according to the peculiarities of the result types. The following; subclasses, their names hinting at the action operation of the result, are; currently available:. - RMergeableCount; - RMergeableFill, responsible for the following actions:; - Graph; - Histo{1,2,3}D; - Profile{1,2}D; - Stats; - RMergeableMax; - RMergeableMean; - RMergeableMin; - RMergeableStdDev; - RMergeableSum; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:110,Integrability,wrap,wrapped,110,"/////////////////////////////////////////////////////////////////////////////; /// \brief Retrieve the result wrapped by this mergeable.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:562,Deployability,update,update,562,"/////////////////////////////////////////////////////////////////////////////; /// \brief Aggregate the information contained in another RMergeableValue; /// into this.; /// \param[in] other Another RMergeableValue object.; /// \throws std::invalid_argument If the cast of the other object to the same; /// type as this one fails.; ///; /// The other RMergeableValue object is cast to the same type as this object.; /// This is needed to make sure that only results of the same type of action; /// are merged together. Then the two results are added together to update; /// the value held by the current object.; ///; /// \note All the `Merge` methods in the RMergeableValue family are private.; /// To merge multiple RMergeableValue objects please use [MergeValues]; /// (namespaceROOT_1_1Detail_1_1RDF.html#af16fefbe2d120983123ddf8a1e137277).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:106,Integrability,depend,dependent,106,"// RDataFrame's generic Fill method supports two possible signatures for Merge.; // Templated to create a dependent type to SFINAE on - in reality, `U` will always be `T`.; // This overload handles Merge(TCollection*)...",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:40,Modifiability,Extend,ExtendAxis,40,"// if `T == TH1D` Eventually calls TH1::ExtendAxis that creates new instances of TH1D",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:3,Deployability,Update,Update,3,"// Update data members",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:3,Deployability,Update,Update,3,"// Update the data members",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:403,Integrability,wrap,wrapped,403,"/// \endcond; ////////////////////////////////////////////////////////////////////////////////; /// \brief Merge multiple RMergeableValue objects into one.; /// \param[in] OutputMergeable The mergeable object where all the information; /// will be aggregated.; /// \param[in] InputMergeables Other mergeables containing the partial results.; /// \returns An RMergeableValue holding the aggregated value wrapped in an; /// `std::unique_ptr`.; ///; /// This is the recommended way of merging multiple RMergeableValue objects.; /// This overload takes ownership of the mergeables and gives back to the user; /// a mergeable with the aggregated information. All the mergeables with the; /// partial results get destroyed in the process.; ///; /// Example usage:; /// ~~~{.cpp}; /// using namespace ROOT::Detail::RDF;; /// // mh1, mh2, mh3 are std::unique_ptr<RMergeableValue<TH1D>>; /// auto mergedptr = MergeValues(std::move(mh1), std::move(mh2), std::move(mh3));; /// const auto &mergedhisto = mergedptr->GetValue(); // Final merged histogram; /// // Do stuff with it; /// mergedhisto.Draw();; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx:24,Integrability,depend,dependence,24,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMetaData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx:58,Integrability,interface,interface,58,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMetaData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx:216,Integrability,wrap,wrapper,216,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMetaData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx:297,Integrability,interface,interface,297,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMetaData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx:6,Safety,avoid,avoid,6,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMetaData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx:567,Security,access,accessed,567,"/**; \class ROOT::RDF::Experimental::RMetaData; \ingroup dataframe; \brief Class behaving as a heterogenuous dictionary to store the metadata of a dataset. The supported types of the metadata are: std::string, int and double. An example of creating the RMetaData object:; ~~~{.cpp}; ROOT::RDF::Experimental::RMetaData meta;; meta.Add(""sample_name"", ""name"""");; meta.Add(""luminosity"", 10064);; meta.Add(""xsecs"", 1.0);; ~~~. The RMetaData object is passed to an RSample object which represents a single dataset sample. A dataframe built with the RMetaData object can be accessed with the \ref ROOT::RDF::RInterface< Proxied,; DS_t>::DefinePerSample ""DefinePerSample()"" method.; **/",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RMetaData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMetaData.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx:100,Integrability,interface,interface,100,"/// Base class for non-leaf nodes of the computational graph.; /// It only exposes the bare minimum interface required to work as a generic part of the computation graph.; /// RDataFrames and results of transformations can be cast to this type via ROOT::RDF::RNode (or ROOT.RDF.AsRNode in PyROOT).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx:75,Security,expose,exposes,75,"/// Base class for non-leaf nodes of the computational graph.; /// It only exposes the bare minimum interface required to work as a generic part of the computation graph.; /// RDataFrames and results of transformations can be cast to this type via ROOT::RDF::RNode (or ROOT.RDF.AsRNode in PyROOT).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:66,Availability,down,downstream,66,"/// Ranges act as filters when it comes to selecting entries that downstream nodes should process",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:37,Performance,cache,cache,37,"// a filter upstream returned false, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:29,Performance,cache,cache,29,"// apply range filter logic, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:22,Testability,log,logic,22,"// apply range filter logic, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:43,Usability,simpl,simply,43,"// recursive chain of `Report`s; // RRange simply forwards these calls to the previous node",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:56,Performance,perform,perform,56,"/* If the returned node is not new, there is no need to perform any other operation.; * This is a likely scenario when building the entire graph in which branches share; * some nodes. */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:88,Safety,detect,detect,88,"// If there have been some defines between the last Filter and this Range node we won't detect them:; // Ranges don't keep track of Defines (they have no RColumnRegister data member).; // Let's pretend that the Defines of this node are the same as the node above, so that in the graph; // the Defines will just appear below the Range instead (no functional change).; // TODO: Converting the string_views for backward compatibility.; // Since they are names of defined columns, they were added to the; // register of column names of the RLoopManager object by the; // RColumnRegister, so we could also change GetDefinedColumns to return string_views directly",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:87,Integrability,depend,depend,87,"// nobody should ask for a varied filter for a variation on which this filter does not depend:; // they can just use the nominal filter.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRange.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRangeBase.hxx:47,Modifiability,inherit,inherited,47,"///< Number of thread slots used by this node, inherited from parent node.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RRangeBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRangeBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RResultMap.hxx:23,Availability,avail,available,23,"// values are the keys available in fMap",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RResultMap.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RResultMap.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RResultMap.hxx:3,Availability,down,downcast,3,"// downcast unique_ptr",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RResultMap.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RResultMap.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx:445,Performance,multi-thread,multi-thread,445,"/// This type represents a sample identifier, to be used in conjunction with RDataFrame features such as; /// \ref ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" and per-sample callbacks.; ///; /// When the input data comes from a TTree, the string representation of RSampleInfo (which is returned by AsString(); /// and that can be queried e.g. with Contains()) is of the form ""<filename>/<treename>"".; ///; /// In multi-thread runs, different tasks might process different entry ranges of the same sample,; /// so RSampleInfo also provides methods to inspect which part of a sample is being taken into consideration.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx:107,Performance,multi-thread,multi-threading,107,"/// @brief Return the entry range in the sample that is being taken into consideration.; ///; /// Multiple multi-threading tasks might process different entry ranges of the same sample.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:62,Performance,perform,performed,62,"/// Construct the RTreeColumnReader. Actual initialization is performed lazily by the Init method.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:62,Performance,perform,performed,62,"/// Construct the RTreeColumnReader. Actual initialization is performed lazily by the Init method.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:47,Performance,perform,performing,47,"/// Whether we already printed a warning about performing a copy of the TTreeReaderArray contents",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:183,Integrability,wrap,wrap,183,"// We only use TTreeReaderArrays to read columns that users flagged as type `RVec`, so we need to check; // that the branch stores the array as contiguous memory that we can actually wrap in an `RVec`.; // Currently we need the first entry to have been loaded to perform the check; // TODO Move check to constructor once ROOT-10823 is fixed and TTreeReaderArray itself exposes this information",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:253,Performance,load,loaded,253,"// We only use TTreeReaderArrays to read columns that users flagged as type `RVec`, so we need to check; // that the branch stores the array as contiguous memory that we can actually wrap in an `RVec`.; // Currently we need the first entry to have been loaded to perform the check; // TODO Move check to constructor once ROOT-10823 is fixed and TTreeReaderArray itself exposes this information",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:263,Performance,perform,perform,263,"// We only use TTreeReaderArrays to read columns that users flagged as type `RVec`, so we need to check; // that the branch stores the array as contiguous memory that we can actually wrap in an `RVec`.; // Currently we need the first entry to have been loaded to perform the check; // TODO Move check to constructor once ROOT-10823 is fixed and TTreeReaderArray itself exposes this information",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:369,Security,expose,exposes,369,"// We only use TTreeReaderArrays to read columns that users flagged as type `RVec`, so we need to check; // that the branch stores the array as contiguous memory that we can actually wrap in an `RVec`.; // Currently we need the first entry to have been loaded to perform the check; // TODO Move check to constructor once ROOT-10823 is fixed and TTreeReaderArray itself exposes this information",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:11,Performance,load,loading,11,"// trigger loading of the contents of the TTreeReaderArray; // the address of the first element in the reader array is not necessarily equal to; // the address returned by the GetAddress method",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:357,Performance,perform,performance,357,"// We always copy the contents of TTreeReaderArray<bool> into an RVec<bool> (never take a view into the memory; // buffer) because the underlying memory buffer might be the one of a std::vector<bool>, which is not a contiguous; // slab of bool values.; // Note that this also penalizes the case in which the column type is actually bool[], but the possible performance; // gains in this edge case is probably not worth the extra complication required to differentiate the two cases.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:10,Performance,perform,perform,10,"// always perform a copy",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:48,Safety,avoid,avoid,48,"// The data member of this class is an RVec, to avoid an extra copy; // but we need to return the array buffer as the reader expects; // a std::array",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx:75,Integrability,depend,depending,75,"/// Per-slot storage for varied column values (for one or multiple columns depending on IsSingleColumn).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariation.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx:3,Safety,avoid,avoid,3,"// avoid unused parameter warnings (gcc 12.1)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariation.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx:4,Deployability,Update,Update,4,"/// Update the value at the address returned by GetValuePtr with the content corresponding to the given entry",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariation.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx:25,Performance,cache,cache,25,"// evaluate this filter, cache the result",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariation.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariation.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariation.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx:59,Integrability,depend,depend,59,"/// This type includes all parts of RVariation that do not depend on the callable signature.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx:89,Safety,safe,safely,89,"/// Return the (type-erased) address of the value of one variation of one column (can be safely cast back to a T*).",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx:4,Deployability,Update,Update,4,"/// Update the value at the address returned by GetValuePtr with the content corresponding to the given entry",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx:93,Testability,log,logic,93,"/// This constructor takes in input a vector of previous nodes, motivated by the CloneAction logic.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx:30,Performance,perform,performed,30,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx:25,Deployability,update,updated,25,"/// Return the partially-updated value connected to the first variation.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx:22,Availability,avail,available,22,"// this one is always available but has lower precedence thanks to `...`",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariedAction.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:341,Testability,test,tested,341,"/// Check for container traits.; ///; /// Note that for all uses in RDF we don't want to classify std::string as a container.; /// Template specializations of IsDataContainer make it return `true` for std::span<T>, std::vector<bool> and; /// RVec<bool>, which we do want to count as containers even though they do not satisfy all the traits tested by the; /// generic IsDataContainer<T>.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:4,Safety,Detect,Detect,4,"/// Detect whether a type is an instantiation of vector<T,A>",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:91,Availability,error,errors,91,"/// Declare code in the interpreter via the TInterpreter::Declare method, throw in case of errors",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:74,Availability,error,errors,74,"/// Jit code in the interpreter with TInterpreter::Calc, throw in case of errors.; /// The optional `context` parameter, if present, is mentioned in the error message.; /// The pointer returned by the call to TInterpreter::Calc is returned in case of success.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:153,Availability,error,error,153,"/// Jit code in the interpreter with TInterpreter::Calc, throw in case of errors.; /// The optional `context` parameter, if present, is mentioned in the error message.; /// The pointer returned by the call to TInterpreter::Calc is returned in case of success.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:159,Integrability,message,message,159,"/// Jit code in the interpreter with TInterpreter::Calc, throw in case of errors.; /// The optional `context` parameter, if present, is mentioned in the error message.; /// The pointer returned by the call to TInterpreter::Calc is returned in case of success.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:39,Modifiability,variab,variables,39,"// C++17 feature (so we can use inline variables)",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:3,Safety,safe,safe,3,"// safe bet: assume the typical 64 bytes",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:21,Performance,Cache,CacheLineStep,21,"/// Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line.; /// Useful to avoid false sharing.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:80,Performance,cache,cache,80,"/// Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line.; /// Useful to avoid false sharing.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:107,Safety,avoid,avoid,107,"/// Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line.; /// Useful to avoid false sharing.",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:28,Performance,cache,cache,28,"/**; * \brief A Thread-safe cache for strings.; *; * This is used to generically store strings that are created in the computation; * graph machinery, for example when adding a new node.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:23,Safety,safe,safe,23,"/**; * \brief A Thread-safe cache for strings.; *; * This is used to generically store strings that are created in the computation; * graph machinery, for example when adding a new node.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:257,Deployability,Release,Release,257,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:46,Performance,cache,cache,46,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:83,Performance,cache,cached,83,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:244,Performance,cache,cache,244,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:356,Performance,cache,cache,356,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:391,Performance,cache,cached,391,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:439,Performance,cache,cache,439,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:162,Safety,safe,safety,162,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:24,Integrability,wrap,wrap,24,/**; * \brief Struct to wrap the call to a function with a guaranteed order of; * execution of its arguments.; * \tparam F Type of the callable.; * \tparam Args Variadic types of the arguments to the callable.; *; * The execution order is guaranteed by calling the function in the constructor; * thus enabling the exploitation of the list-initialization sequenced-before; * feature (See rule 9 at https://en.cppreference.com/w/cpp/language/eval_order).; */,MatchSource.CODE_COMMENT,tree/dataframe/inc/ROOT/RDF/Utils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:656,Energy Efficiency,adapt,adapts,656,"// Author: Giulio Eulisse CERN 2/2018; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // clang-format off; /** \class ROOT::RDF::RArrowDS; \ingroup dataframe; \brief RDataFrame data source class to interface with Apache Arrow. The RArrowDS implements a proxy RDataSource to be able to use Apache Arrow; tables with RDataFrame. A RDataFrame that adapts an arrow::Table class can be constructed using the factory method; ROOT::RDF::FromArrow, which accepts one parameter:; 1. An arrow::Table smart pointer. The types of the columns are derived from the types in the associated; arrow::Schema. */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:509,Integrability,interface,interface,509,"// Author: Giulio Eulisse CERN 2/2018; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // clang-format off; /** \class ROOT::RDF::RArrowDS; \ingroup dataframe; \brief RDataFrame data source class to interface with Apache Arrow. The RArrowDS implements a proxy RDataSource to be able to use Apache Arrow; tables with RDataFrame. A RDataFrame that adapts an arrow::Table class can be constructed using the factory method; ROOT::RDF::FromArrow, which accepts one parameter:; 1. An arrow::Table smart pointer. The types of the columns are derived from the types in the associated; arrow::Schema. */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:656,Modifiability,adapt,adapts,656,"// Author: Giulio Eulisse CERN 2/2018; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // clang-format off; /** \class ROOT::RDF::RArrowDS; \ingroup dataframe; \brief RDataFrame data source class to interface with Apache Arrow. The RArrowDS implements a proxy RDataSource to be able to use Apache Arrow; tables with RDataFrame. A RDataFrame that adapts an arrow::Table class can be constructed using the factory method; ROOT::RDF::FromArrow, which accepts one parameter:; 1. An arrow::Table smart pointer. The types of the columns are derived from the types in the associated; arrow::Schema. */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:19,Deployability,update,update,19,"/// The pointer to update.",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:45,Performance,cache,cached,45,"// Booleans need to be unpacked, so we use a cached entry.; // FIXME: I should really use a variant here",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:25,Safety,avoid,avoid,25,"// Convenience method to avoid code duplication between; // SetEntry and InitSlot",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:3,Deployability,Update,Update,3,"// Update the pointer to the requested entry.; // Notice that we need to find the entry",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:101,Performance,optimiz,optimizations,101,"// We want to allow people to specify which columns they; // need so that we can think of upfront IO optimizations.",MatchSource.CODE_COMMENT,tree/dataframe/src/RArrowDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RCsvDS.cxx:2908,Availability,avail,available,2908,"o not appear in the map is inferred from the data.; The supported types are:; - Integer: stored as a 64-bit long long int; can be specified in the column types map with 'L'.; - Floating point number: stored with double precision; specified with 'D'.; - Boolean: matches the literals `true` and `false`; specified with 'O'.; - String: stored as an std::string, matches anything that does not fall into any of the; previous types; specified with 'T'. These are some formatting rules expected by the RCsvDS implementation:; - All records must have the same number of fields, in the same order.; - Any field may be quoted.; ~~~; ""1997"",""Ford"",""E350""; ~~~; - Fields with embedded delimiters (e.g. comma) must be quoted.; ~~~; 1997,Ford,E350,""Super, luxurious truck""; ~~~; - Fields with double-quote characters must be quoted, and each of the embedded; double-quote characters must be represented by a pair of double-quote characters.; ~~~; 1997,Ford,E350,""Super, """"luxurious"""" truck""; ~~~; - Fields with embedded line breaks are not supported, even when quoted.; ~~~; 1997,Ford,E350,""Go get one now; they are going fast""; ~~~; - Spaces are considered part of a field and are not ignored.; ~~~; 1997, Ford , E350; not same as; 1997,Ford,E350; but same as; 1997, ""Ford"" , E350; ~~~; - If a header row is provided, it must contain column names for each of the fields.; ~~~; Year,Make,Model; 1997,Ford,E350; 2000,Mercury,Cougar; ~~~. The current implementation of RCsvDS reads the entire CSV file content into memory before; RDataFrame starts processing it. Therefore, before creating a CSV RDataFrame, it is; important to check both how much memory is available and the size of the CSV file. RCsvDS can handle empty cells and also allows the usage of the special keywords ""NaN"" and ""nan"" to; indicate `nan` values. If the column is of type double, these cells are stored internally as `nan`.; Empty cells and explicit `nan`-s inside columns of type Long64_t/bool are stored as zeros.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/src/RCsvDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RCsvDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RCsvDS.cxx:77,Performance,load,loaded,77,"// reset the reading from the second line, because the first line is already loaded in `columns`",MatchSource.CODE_COMMENT,tree/dataframe/src/RCsvDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RCsvDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:329,Availability,avail,available,329,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:4766,Availability,avail,available,4766,"mple() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; | FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; | RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filter",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:10553,Availability,avail,available,10553,"t value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. | **Operation** | **Description** |; |---------------------|-----------------|; | Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:23051,Availability,avail,available,23051,"ypes are inferred automatically. The string must be; valid C++ and it is just-in-time compiled. The process has a small runtime overhead and like with filters it is currently the only possible approach when using PyROOT. Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a; number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define(); transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action.; ~~~{.cpp}; RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ~~~; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a; simple way to make external variables available inside the body of C++ lambdas) to act on the same variable `x` from; both Define() transformations. Second, we have *stored* the transformed dataframe in a variable. This is always; possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more; on this [below](#callgraphs)). You can read more about defining new columns [here](#custom-columns). \image html RDF_Graph.png ""A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:24593,Availability,avail,available,24593,"oint of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); hanging from another Range(). Here are some commented examples:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; // Here we store a dataframe that loops over only the first 30 entries in a variable; auto d30 = d.Range(30);; // This is how you pick all entries from 15 onwards; auto d15on = d.Range(15, 0);; // We can specify a stride too, in this case we pick an event every 3; auto d15each3 = d.Range(0, 15, 3);; ~~~; Note that ranges are not available when multi-threading is enabled. More information on ranges is available; [here](#ranges). ### Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; the filtered events.; By now, you should be able to easily understand what is happening:; ~~~{.cpp}; RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; ~~~; RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced; simultaneously. ### Properly exploiting RDataFrame ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:24666,Availability,avail,available,24666," It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); hanging from another Range(). Here are some commented examples:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; // Here we store a dataframe that loops over only the first 30 entries in a variable; auto d30 = d.Range(30);; // This is how you pick all entries from 15 onwards; auto d15on = d.Range(15, 0);; // We can specify a stride too, in this case we pick an event every 3; auto d15each3 = d.Range(0, 15, 3);; ~~~; Note that ranges are not available when multi-threading is enabled. More information on ranges is available; [here](#ranges). ### Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; the filtered events.; By now, you should be able to easily understand what is happening:; ~~~{.cpp}; RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; ~~~; RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced; simultaneously. ### Properly exploiting RDataFrame laziness. For yet another example of the difference between the correct an",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:30834,Availability,avail,available,30834,"lters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant RDataFrame. \anchor ranges; ### Ranges; When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; Range() transformations are available. These act very much like filters but instead of basing their decision on; a filter expression, they rely on `begin`,`end` and `stride` parameters. - `begin`: initial entry number considered for this range.; - `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; - `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0. The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; entries than that are available). Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding fi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:31329,Availability,down,downstream,31329,"ultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant RDataFrame. \anchor ranges; ### Ranges; When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; Range() transformations are available. These act very much like filters but instead of basing their decision on; a filter expression, they rely on `begin`,`end` and `stride` parameters. - `begin`: initial entry number considered for this range.; - `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; - `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0. The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; entries than that are available). Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding filter*. Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. \anchor custom-columns; ### Custom columns; Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; (function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; strings) as parameters, in the same order as th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:31429,Availability,avail,available,31429,"ultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant RDataFrame. \anchor ranges; ### Ranges; When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; Range() transformations are available. These act very much like filters but instead of basing their decision on; a filter expression, they rely on `begin`,`end` and `stride` parameters. - `begin`: initial entry number considered for this range.; - `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; - `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0. The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; entries than that are available). Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding filter*. Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. \anchor custom-columns; ### Custom columns; Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; (function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; strings) as parameters, in the same order as th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:35408,Availability,avail,available,35408,"ns with a return value; are lazy, the others are instant. ### Return type of a lazy action. When a lazy action is called, it returns a \link ROOT::RDF::RResultPtr ROOT::RDF::RResultPtr<T>\endlink, where T is the; type of the result of the action. The final result will be stored in the `RResultPtr` and can be retrieved by; dereferencing it or via its `GetValue` method. ### Actions that return collections. If the type of the return value of an action is a collection, e.g. `std::vector<int>`, you can iterate its elements; directly through the wrapping `RResultPtr`:. ~~~{.cpp}; ROOT::RDataFrame df{5};; auto df1 = df.Define(""x"", []{ return 42; });; for (const auto &el: df1.Take<int>(""x"")){; std::cout << ""Element: "" << el << ""\n"";; }; ~~~. ~~~{.py}; df = ROOT.RDataFrame(5).Define(""x"", ""42""); for el in df.Take[int](""x""):; print(f""Element: {el}""); ~~~. ### Actions and readers. An action that needs values for its computations will request it from a reader, e.g. a column created via `Define` or; available from the input dataset. The action will request values from each column of the list of input columns (either; inferred or specified by the user), in order. For example:. ~~~{.cpp}; ROOT::RDataFrame df{1};; auto df1 = df.Define(""x"", []{ return 11; });; auto df2 = df1.Define(""y"", []{ return 22; });; auto graph = df2.Graph<int, int>(""x"",""y"");; ~~~. The `Graph` action is going to request first the value from column ""x"", then that of column ""y"". Specifically, the order; of execution of the operations of nodes in this branch of the computation graph is guaranteed to be top to bottom. \anchor distrdf; ## Distributed execution. RDataFrame applications can be executed in parallel through distributed computing frameworks on a set of remote machines; thanks to the Python package `ROOT.RDF.Experimental.Distributed`. This experimental, **Python-only** package allows to scale the; optimized performance RDataFrame can achieve on a single machine to multiple nodes at the same time. It is de",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:37375,Availability,avail,available,37375,"://spark.apache.org/) and; [Dask](https://dask.org/). To make use of distributed RDataFrame, you only need to switch `ROOT.RDataFrame` with; the backend-specific `RDataFrame` of your choice, for example:. ~~~{.py}; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"", ""myfile.root""). # Continue the application with the traditional RDataFrame API; sum = df.Filter(""x > 10"").Sum(""y""); h = df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""). print(sum.GetValue()); h.Draw(); ~~~. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all; parts of the RDataFrame API currently work with this package. The subset that is currently available is:; - AsNumpy; - Count; - Define; - DefinePerSample; - Filter; - Graph; - Histo[1,2,3]D; - HistoND; - Max; - Mean; - Min; - Profile[1,2,3]D; - Redefine; - Snapshot; - Stats; - StdDev; - Sum; - Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; - Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; - Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; currently not supported. \note The distributed RDataFrame module requires at least Python version 3.8. ### Connecting to a Spark cluster. In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = Spar",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:40379,Availability,avail,available,40379," supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed import Client. # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, t",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:40724,Availability,avail,available,40724,"sion don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:41166,Availability,avail,available,41166,"ttp://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame appropriate for the; # backend used in the analysis; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. Note that when processing a TTree or TChain dataset, the `n",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:44866,Availability,error,errors,44866,"e() for histoproxy in histoproxies]; ~~~. Every distributed backend supports this feature and graphs belonging to different backends can be still triggered with; a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time). ### Histogram models in distributed mode. When calling a Histo*D operation in distributed mode, remember to pass to the function the model of the histogram to be; computed, e.g. the axis range and the number of bins:. ~~~{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; df = RDataFrame(""mytree"",""myfile.root"").Define(""x"",""someoperation""); # The model can be passed either as a tuple with the arguments in the correct order; df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""); # Or by creating the specific struct; model = ROOT.RDF.TH1DModel(""name"", ""title"", 10, 0, 10); df.Histo1D(model, ""x""); ~~~. Without this, two partial histograms resulting from two distributed tasks would have incompatible binning, thus leading; to errors when merging them. Failing to pass a histogram model will raise an error on the client side, before starting; the distributed execution. ### Live visualization in distributed mode with dask. The live visualization feature allows real-time data representation of plots generated during the execution ; of a distributed RDataFrame application. ; It enables visualizing intermediate results as they are computed across multiple nodes of a Dask cluster; by creating a canvas and continuously updating it as partial results become available. . The LiveVisualize() function can be imported from the Python package **ROOT.RDF.Experimental.Distributed**:. ~~~{.py}; import ROOT. LiveVisualize = ROOT.RDF.Experimental.Distributed.LiveVisualize; ~~~. The function takes drawable objects (e.g. histograms) and optional callback functions as argument, it accepts 4 different input formats:. - Passing a list or tuple of drawables: ; You can pass a list or",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:44940,Availability,error,error,44940,"an be still triggered with; a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time). ### Histogram models in distributed mode. When calling a Histo*D operation in distributed mode, remember to pass to the function the model of the histogram to be; computed, e.g. the axis range and the number of bins:. ~~~{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; df = RDataFrame(""mytree"",""myfile.root"").Define(""x"",""someoperation""); # The model can be passed either as a tuple with the arguments in the correct order; df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""); # Or by creating the specific struct; model = ROOT.RDF.TH1DModel(""name"", ""title"", 10, 0, 10); df.Histo1D(model, ""x""); ~~~. Without this, two partial histograms resulting from two distributed tasks would have incompatible binning, thus leading; to errors when merging them. Failing to pass a histogram model will raise an error on the client side, before starting; the distributed execution. ### Live visualization in distributed mode with dask. The live visualization feature allows real-time data representation of plots generated during the execution ; of a distributed RDataFrame application. ; It enables visualizing intermediate results as they are computed across multiple nodes of a Dask cluster; by creating a canvas and continuously updating it as partial results become available. . The LiveVisualize() function can be imported from the Python package **ROOT.RDF.Experimental.Distributed**:. ~~~{.py}; import ROOT. LiveVisualize = ROOT.RDF.Experimental.Distributed.LiveVisualize; ~~~. The function takes drawable objects (e.g. histograms) and optional callback functions as argument, it accepts 4 different input formats:. - Passing a list or tuple of drawables: ; You can pass a list or tuple containing the plots you want to visualize. For example:. ~~~{.py}; LiveVisualize([h_gaus, h_exp, h_random]); ~~~. - Passing a ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:45399,Availability,avail,available,45399,"ort ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; df = RDataFrame(""mytree"",""myfile.root"").Define(""x"",""someoperation""); # The model can be passed either as a tuple with the arguments in the correct order; df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""); # Or by creating the specific struct; model = ROOT.RDF.TH1DModel(""name"", ""title"", 10, 0, 10); df.Histo1D(model, ""x""); ~~~. Without this, two partial histograms resulting from two distributed tasks would have incompatible binning, thus leading; to errors when merging them. Failing to pass a histogram model will raise an error on the client side, before starting; the distributed execution. ### Live visualization in distributed mode with dask. The live visualization feature allows real-time data representation of plots generated during the execution ; of a distributed RDataFrame application. ; It enables visualizing intermediate results as they are computed across multiple nodes of a Dask cluster; by creating a canvas and continuously updating it as partial results become available. . The LiveVisualize() function can be imported from the Python package **ROOT.RDF.Experimental.Distributed**:. ~~~{.py}; import ROOT. LiveVisualize = ROOT.RDF.Experimental.Distributed.LiveVisualize; ~~~. The function takes drawable objects (e.g. histograms) and optional callback functions as argument, it accepts 4 different input formats:. - Passing a list or tuple of drawables: ; You can pass a list or tuple containing the plots you want to visualize. For example:. ~~~{.py}; LiveVisualize([h_gaus, h_exp, h_random]); ~~~. - Passing a list or tuple of drawables with a global callback function: ; You can also include a global callback function that will be applied to all plots. For example:. ~~~{.py}; def set_fill_color(hist):; hist.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more c",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:55938,Availability,down,down,55938,"ting from ROOT v6.26, RDataFrame provides a flexible syntax to define systematic variations.; This is done in two steps: a) register variations for one or more existing columns using Vary() and b) extract variations; of normal RDataFrame results using \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". In between these steps, no other change; to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated; through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; explicitly, this is not required for ROOT macros. . An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:. ~~~{.cpp}; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks simila",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:56353,Availability,down,down,56353,": the presence of systematic variations for certain columns is automatically propagated; through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; explicitly, this is not required for ROOT macros. . An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:. ~~~{.cpp}; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks similar. Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cuts that depend on the variation. There is no limitation to the complexity of a Var",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:56744,Availability,down,down,56744," include this header; explicitly, this is not required for ROOT macros. . An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:. ~~~{.cpp}; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks similar. Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cuts that depend on the variation. There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple column",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:56884,Availability,down,down,56884,"""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks similar. Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cuts that depend on the variation. There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple columns in lockstep. In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:57939,Availability,down,down,57939,"how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cuts that depend on the variation. There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple columns in lockstep. In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The; inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in; this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist. The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"". #### Combining multiple variations. Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { re",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:58399,Availability,down,down,58399,"calls, users are; not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple columns in lockstep. In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The; inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in; this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist. The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"". #### Combining multiple variations. Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, Va",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:58763,Availability,down,down,58763,"e Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The; inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in; this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist. The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"". #### Combining multiple variations. Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be var",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:58904,Availability,down,down,58904,", eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The; inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in; this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist. The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"". #### Combining multiple variations. Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See t",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:59135,Availability,down,down,59135," as the column names that are passed as the first argument. Besides the variation tags, in; this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist. The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"". #### Combining multiple variations. Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the an",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:60476,Availability,avail,available,60476,"e, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python u",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:66975,Availability,error,error,66975,"In this case **RDataFrame infers the type of the column** from the TTree itself. This; is why we never needed to specify the column types for all actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69531,Availability,avail,available,69531,"d of the event loop.; void Finalize(); {; *fFinalResult = std::accumulate(fPerThreadResults.begin(), fPerThreadResults.end(), 0);; }. // Called by RDataFrame to retrieve the name of this action.; std::string GetActionName() const { return ""MyCounter""; }; };. int main() {; ROOT::RDataFrame df(10);; ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; // The GetValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression wit",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:75400,Availability,down,down,75400,".; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs (storing and reusing sets of transformations). As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a **computation graph** in which; several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced. RDataFrame detects when several actions use the same filter or the same defined column, and **only evaluates each; filter or defined column once per event**, regardless of how many times that result is used down the computation graph.; Objects read from each column are **built once and never copied**, for maximum efficiency.; When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,; so it might be advisable to put the strictest filters first in the graph. \anchor representgraph; ### Visualizing the computation graph; It is possible to print the computation graph from any node to obtain a [DOT (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) representation either on the standard output; or in a file. Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; the node belongs to is printed. By using the head node, the entire computation graph is printed. Following there is an example of usage:; ~~~{.cpp}; // First, a sample computational graph is built;",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:79522,Availability,avail,available,79522,"he specification in the JSON file is the following:. ~~~{.cpp}; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; ~~~. The metadata information from the specification file can be then accessed using the DefinePerSample function.; For example, to access luminosity information (stored as a double):. ~~~{.python}; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); ~~~. or sample_category information (stored as a string):. ~~~{.python}; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ~~~. or directly the filename:. ~~~{.python}; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); ~~~. An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; provides a corresponding exemplary JSON file for the dataset specification. \anchor progressbar; ### Adding a progress bar . A progress bar showing the processed event statistics can be added to any RDataFrame program.; The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. . ProgressBar is added after creating the dataframe object (df):; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ~~~. Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; For example, it can be called at any computational node, such as Filter ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:84190,Availability,down,downstream,84190,"gcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the input column passed to this function is not; available, the node will provide the default value passed to this function call; instead. Example:. \code{.py}; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value);; auto df_col = df_default.Define(""twice"", ""col * 2"");; \endcode. #### Mixing different strategies to work with missing values in the same RDataFrame. All the operations presented above only act on the particular branch of th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:84223,Availability,avail,available,84223,"gcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the input column passed to this function is not; available, the node will provide the default value passed to this function call; instead. Example:. \code{.py}; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value);; auto df_col = df_default.Define(""twice"", ""col * 2"");; \endcode. #### Mixing different strategies to work with missing values in the same RDataFrame. All the operations presented above only act on the particular branch of th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:84302,Availability,avail,available,84302,"no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the input column passed to this function is not; available, the node will provide the default value passed to this function call; instead. Example:. \code{.py}; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value);; auto df_col = df_default.Define(""twice"", ""col * 2"");; \endcode. #### Mixing different strategies to work with missing values in the same RDataFrame. All the operations presented above only act on the particular branch of the; computation graph where they are called, so that different results can be; obtained by mixing and matching the filtering or providing a default value; strategi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:3035,Deployability,toggle,toggleInherit,3035,"ks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed with RDataFrame. ### Transformations; Transformations are a way to manipulate the data. | **Transformation** | **Description** |; |------------------|--------------------|; | Alias() | Introduce an alias for a particular column name. |; | DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a differen",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:3808,Deployability,update,updated,3808," a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed with RDataFrame. ### Transformations; Transformations are a way to manipulate the data. | **Transformation** | **Description** |; |------------------|--------------------|; | Alias() | Introduce an alias for a particular column name. |; | DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:38460,Deployability,configurat,configuration,38460,"[1,2,3]D; - HistoND; - Max; - Mean; - Min; - Profile[1,2,3]D; - Redefine; - Snapshot; - Stats; - StdDev; - Sum; - Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; - Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; - Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; currently not supported. \note The distributed RDataFrame module requires at least Python version 3.8. ### Connecting to a Spark cluster. In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf). # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:45348,Deployability,continuous,continuously,45348,"ort ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; df = RDataFrame(""mytree"",""myfile.root"").Define(""x"",""someoperation""); # The model can be passed either as a tuple with the arguments in the correct order; df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""); # Or by creating the specific struct; model = ROOT.RDF.TH1DModel(""name"", ""title"", 10, 0, 10); df.Histo1D(model, ""x""); ~~~. Without this, two partial histograms resulting from two distributed tasks would have incompatible binning, thus leading; to errors when merging them. Failing to pass a histogram model will raise an error on the client side, before starting; the distributed execution. ### Live visualization in distributed mode with dask. The live visualization feature allows real-time data representation of plots generated during the execution ; of a distributed RDataFrame application. ; It enables visualizing intermediate results as they are computed across multiple nodes of a Dask cluster; by creating a canvas and continuously updating it as partial results become available. . The LiveVisualize() function can be imported from the Python package **ROOT.RDF.Experimental.Distributed**:. ~~~{.py}; import ROOT. LiveVisualize = ROOT.RDF.Experimental.Distributed.LiveVisualize; ~~~. The function takes drawable objects (e.g. histograms) and optional callback functions as argument, it accepts 4 different input formats:. - Passing a list or tuple of drawables: ; You can pass a list or tuple containing the plots you want to visualize. For example:. ~~~{.py}; LiveVisualize([h_gaus, h_exp, h_random]); ~~~. - Passing a list or tuple of drawables with a global callback function: ; You can also include a global callback function that will be applied to all plots. For example:. ~~~{.py}; def set_fill_color(hist):; hist.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more c",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53743,Deployability,release,released,53743," the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:. ~~~{.cpp}; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2 = df2.Histo1D(""y"");; h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; h2->Draw(""SAME"");. // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time compile here; auto h2 = df2.Histo1D(""y"");; h2->Draw(""SAME""); // we just-in-time compile again here, as the second Histo1D call is new; ~~~. \anchor more-features; ## M",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:59893,Deployability,release,releases,59893,"::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:62527,Deployability,Update,Update,62527,"ects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; ~~~. Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; (e.g. a histogram filled with a part of the selected events). Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot(). \anchor default-branches; ### Default column lists; When constructing an RDataFrame object, it is possible to specify a **default column list** for your analysis, in the; usual form of a list of strings representing branch/column names. The default column list will be used as a fallback; whenever a list specific to the transformation/action is not present. RDataFrame will take as many of these columns as; needed, ignoring trailing extra names if present.; ~~~{.cpp}; // use ""b1"" and ""b2"" as default columns; RDataFrame d1(""",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:2909,Energy Efficiency,Efficient,Efficient,2909,"g""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections](\ref RDFCollections); - [Executing callbacks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:7984,Energy Efficiency,Reduce,Reduce,7984," of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature `T(T,T)` where `T` is the type of the column. Return the final result of the reduction operation. An optional parameter allows initialization of the result object to non-default values. |; | Report() | Obtain statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:7995,Energy Efficiency,Reduce,Reduce,7995," of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature `T(T,T)` where `T` is the type of the column. Return the final result of the reduction operation. An optional parameter allows initialization of the result object to non-default values. |; | Report() | Obtain statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:32681,Energy Efficiency,efficient,efficient,32681,"s a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding filter*. Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. \anchor custom-columns; ### Custom columns; Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; (function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; assigned to the temporary column. A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; transformations/actions. Use cases include:; - caching the results of complex calculations for easy and efficient multiple access; - extraction of quantities of interest from complex objects; - branch aliasing, i.e. changing the name of a branch. An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree. It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; `Define(name, expression)`. For example this invocation. ~~~{.cpp}; df.Define(""pt"", ""sqrt(px*px + py*py)"");; ~~~. will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; from the names of the variables specified by the user. #### Custom columns as function of slot and entry number. It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can; be invoked are:; - `DefineSlot(name, f, column",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:39299,Energy Efficiency,schedul,schedulers,39299,"ng-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf). # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed import Client. # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object,",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:39811,Energy Efficiency,schedul,scheduler,39811," constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed import Client. # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48385,Energy Efficiency,allocate,allocated,48385,"o indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::R",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48667,Energy Efficiency,Reduce,Reduce,48667," of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ diffe",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:52103,Energy Efficiency,Efficient,Efficient,52103,"aw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expe",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:52275,Energy Efficiency,reduce,reduce,52275,"onsiderations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53325,Energy Efficiency,consumption,consumption,53325,"ime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:. ~~~{.cpp}; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"")",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53509,Energy Efficiency,reduce,reduce,53509,"ed to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:. ~~~{.cpp}; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2 = df2.Histo1D(""y"");; h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; h2->Draw(""SAME"");. // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53686,Energy Efficiency,allocate,allocate,53686," the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:. ~~~{.cpp}; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2 = df2.Histo1D(""y"");; h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; h2->Draw(""SAME"");. // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time compile here; auto h2 = df2.Histo1D(""y"");; h2->Draw(""SAME""); // we just-in-time compile again here, as the second Histo1D call is new; ~~~. \anchor more-features; ## M",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:61970,Energy Efficiency,schedul,schedule,61970,"ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; ~~~. Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; (e.g. a histogram filled with a part of the selected events). Read more on R",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:80622,Energy Efficiency,Efficient,Efficient,80622,"n tutorial: df106_HiggstoFourLeptons.py, which also; provides a corresponding exemplary JSON file for the dataset specification. \anchor progressbar; ### Adding a progress bar . A progress bar showing the processed event statistics can be added to any RDataFrame program.; The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. . ProgressBar is added after creating the dataframe object (df):; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ~~~. Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; For example, it can be called at any computational node, such as Filter or Define, not only the head node,; with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; section for appropriate usage in Python): ; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ~~~; Examples of implemented progress bars can be seen by running [Higgs to Four Lepton tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html) and [Dimuon tutorial](https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html). . \anchor missing-values; ### Working with missing values in the dataset. In certain situations a dataset might be missing one or more values at one or; more of its entries. For example:. - If the dataset is composed of multiple files and one or more files is; missing one or more columns required by the analysis.; - When joining different datasets horizontally according to some index value; (e.g. the event numbe",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:130,Integrability,interface,interface,130,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:606,Integrability,Interface,Interface,606,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:4508,Integrability,depend,depends,4508,"issing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; | FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; | RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Acti",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:17952,Integrability,wrap,wrapped,17952,"TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):. ~~~{.cpp}; auto df = ROOT::RDF::FromCSV(""input.csv"");; // use df as usual; ~~~. ### Filling a histogram; Let's now tackle a very common task, filling a histogram:; ~~~{.cpp}; // Fill a TH1D with the ""MET"" branch; RDataFrame d(""myTree"", ""file.root"");; auto h = d.Histo1D(""MET"");; h->Draw();; ~~~; The first line creates an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"". Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be precise) to a TH1D histogram filled; with the `MET` of all events. If the quantity stored in the column is a collection (e.g. a vector or an array), the; histogram is filled with all vector elements for each event. You can use the objects returned by actions as if they were pointers to the desired results. There are many other; possible [actions](\ref cheatsheet), and all their results are wrapped in smart pointers; we'll see why in a minute. ### Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:27707,Integrability,interface,interface,27707,"ssing their results, allowing; RDataFrame to run the loop once and produce all results in one go. ### Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.; The only modification required to the snippets would be the addition of this line *before* constructing the main; dataframe object:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ~~~; Simple as that. More details are given [below](#parallel-execution). \anchor collections; ## Working with collections and object selections. RDataFrame reads collections as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way. RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a rich interface to operate on the array elements in a vectorised fashion, similarly to Python's NumPy arrays. For example, to fill a histogram with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`fal",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:29603,Integrability,depend,depend,29603,"nt has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant R",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:34953,Integrability,wrap,wrapping,34953,"case the callable f has this signature `R(unsigned int, ULong64_t,; T1, T2, ...)`: the first parameter is the slot number while the second one the number of the entry being processed. \anchor actions; ## Actions: getting results; ### Instant and lazy actions; Actions can be **instant** or **lazy**. Instant actions are executed as soon as they are called, while lazy actions are; executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value; are lazy, the others are instant. ### Return type of a lazy action. When a lazy action is called, it returns a \link ROOT::RDF::RResultPtr ROOT::RDF::RResultPtr<T>\endlink, where T is the; type of the result of the action. The final result will be stored in the `RResultPtr` and can be retrieved by; dereferencing it or via its `GetValue` method. ### Actions that return collections. If the type of the return value of an action is a collection, e.g. `std::vector<int>`, you can iterate its elements; directly through the wrapping `RResultPtr`:. ~~~{.cpp}; ROOT::RDataFrame df{5};; auto df1 = df.Define(""x"", []{ return 42; });; for (const auto &el: df1.Take<int>(""x"")){; std::cout << ""Element: "" << el << ""\n"";; }; ~~~. ~~~{.py}; df = ROOT.RDataFrame(5).Define(""x"", ""42""); for el in df.Take[int](""x""):; print(f""Element: {el}""); ~~~. ### Actions and readers. An action that needs values for its computations will request it from a reader, e.g. a column created via `Define` or; available from the input dataset. The action will request values from each column of the list of input columns (either; inferred or specified by the user), in order. For example:. ~~~{.cpp}; ROOT::RDataFrame df{1};; auto df1 = df.Define(""x"", []{ return 11; });; auto df2 = df1.Define(""y"", []{ return 22; });; auto graph = df2.Graph<int, int>(""x"",""y"");; ~~~. The `Graph` action is going to request first the value from column ""x"", then that of column ""y"". Specifically, the order; of execution of the operations of nodes i",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:40662,Integrability,depend,dependent,40662,"sion don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49006,Integrability,depend,dependency,49006,"to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a singl",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:52686,Integrability,depend,depend,52686,"ic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, t",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:55488,Integrability,depend,dependencies,55488,"h2->Draw(""SAME"");. // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time compile here; auto h2 = df2.Histo1D(""y"");; h2->Draw(""SAME""); // we just-in-time compile again here, as the second Histo1D call is new; ~~~. \anchor more-features; ## More features; Here is a list of the most important features that have been omitted in the ""Crash course"" for brevity.; You don't need to read all these to start using RDataFrame, but they are useful to save typing time and runtime. \anchor systematics; ### Systematic variations. Starting from ROOT v6.26, RDataFrame provides a flexible syntax to define systematic variations.; This is done in two steps: a) register variations for one or more existing columns using Vary() and b) extract variations; of normal RDataFrame results using \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". In between these steps, no other change; to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated; through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; explicitly, this is not required for ROOT macros. . An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:. ~~~{.cpp}; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");;",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:57256,Integrability,depend,depend,57256,"ominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks similar. Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cuts that depend on the variation. There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple columns in lockstep. In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The; inner vectors follow the same ordering as the column names that are passed as the first ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:58477,Integrability,depend,depends,58477,"ctions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple columns in lockstep. In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec of two RVecs: each inner vector contains the varied values for one column. The; inner vectors follow the same ordering as the column names that are passed as the first argument. Besides the variation tags, in; this case we also have to explicitly pass the variation name (here: ""ptAndEta"") as the default column name does not exist. The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"". #### Combining multiple variations. Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might st",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:59487,Integrability,interface,interfaces,59487," Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; wh",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:65594,Integrability,message,message,65594,"napshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). \warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. \anchor jitting; ### Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; signature** of the relevant filter function/temporary column expression/action function:; ~~~{.cpp}; // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; ~~~; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at; runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter(). Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of; the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; is why we never needed to specify the column types for all actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:67242,Integrability,inject,inject,67242,"practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;. MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}. // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }. // Called at the",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69192,Integrability,Inject,Injecting,69192," fFinalResult; }. // Called at the beginning of the event loop.; void Initialize() {}. // Called at the beginning of each processing task.; void InitTask(TTreeReader *, int) {}. /// Called at every entry.; void Exec(unsigned int slot); {; fPerThreadResults[slot]++;; }. // Called at the end of the event loop.; void Finalize(); {; *fFinalResult = std::accumulate(fPerThreadResults.begin(), fPerThreadResults.end(), 0);; }. // Called by RDataFrame to retrieve the name of this action.; std::string GetActionName() const { return ""MyCounter""; }; };. int main() {; ROOT::RDataFrame df(10);; ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; // The GetValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69548,Integrability,interface,interface,69548,"d of the event loop.; void Finalize(); {; *fFinalResult = std::accumulate(fPerThreadResults.begin(), fPerThreadResults.end(), 0);; }. // Called by RDataFrame to retrieve the name of this action.; std::string GetActionName() const { return ""MyCounter""; }; };. int main() {; ROOT::RDataFrame df(10);; ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; // The GetValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression wit",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73944,Integrability,interface,interfaced,73944,"shot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs (storing and reusing sets of transformations). As we saw, transformed dataf",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:74001,Integrability,interface,interface,74001,"as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs (storing and reusing sets of transformations). As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly de",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11870,Modifiability,flexible,flexible,11870," in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:12284,Modifiability,extend,extended,12284," inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:13553,Modifiability,flexible,flexible,13553,"T_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them. The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; [crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; <table>; <tr>; <td>; <b>TTreeReader</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ~~~; </td>; </tr>; <tr>; <td>; <b>TTree::Draw</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame df(""myTree"", file);; auto h = df.Filter(""y > 2"").Histo1D(""x"");; h->Draw(); ~~~; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; tree->Draw(""jet_eta"", ""weight*(event == 1)"");; ~~~; </td>; <td>; ~~~{.cpp}; df.Filter(""event == 1"").Histo1",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:20468,Modifiability,variab,variables,20468,"ee"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ~~~. An example of a more complex filter expressed as a string containing C++ code is shown below. ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; ~~~. The code snippet above defines a column `p` that is a fixed-size array using the component column names and then; filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns; like the one above is currently the only possibility when using PyROOT. When writing expressions as such, only constants; and data coming from other columns in the dataset can be involved in the code passed as a string. Local variables and; functions cannot be used, since the interpreter will not know how to find them. When capturing local state is necessary,; it must first be declared to the ROOT C++ interpreter. More information on filters and how to use them to automatically generate cutflow reports can be found [below](#Filters). ### Defining custom columns; Let's now consider the case in which ""myTree"" contains two quantities ""x"" and ""y"", but our analysis relies on a derived; quantity `z = sqrt(x*x + y*y)`. Using the Define() transformation, we can create a new column in the dataset containing; the variable ""z"":; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto sqrtSum = [](double x, double y) { return sqrt(x*x + y*y); };; auto zMean = d.Define(""z"", sqrtSum, {""x"",""y""}).Mean(""z"");; std::cout << *zMean << std::endl;; ~~~; Define() creates the variable ""z"" by applying `sqrtSum` to ""x"" and ""y"". Later in the chain of calls we refer to; variables created with Define() as if they were actual tree branches/columns, but they are evaluated on demand,",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:21057,Modifiability,variab,variable,21057,"snippet above defines a column `p` that is a fixed-size array using the component column names and then; filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns; like the one above is currently the only possibility when using PyROOT. When writing expressions as such, only constants; and data coming from other columns in the dataset can be involved in the code passed as a string. Local variables and; functions cannot be used, since the interpreter will not know how to find them. When capturing local state is necessary,; it must first be declared to the ROOT C++ interpreter. More information on filters and how to use them to automatically generate cutflow reports can be found [below](#Filters). ### Defining custom columns; Let's now consider the case in which ""myTree"" contains two quantities ""x"" and ""y"", but our analysis relies on a derived; quantity `z = sqrt(x*x + y*y)`. Using the Define() transformation, we can create a new column in the dataset containing; the variable ""z"":; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto sqrtSum = [](double x, double y) { return sqrt(x*x + y*y); };; auto zMean = d.Define(""z"", sqrtSum, {""x"",""y""}).Mean(""z"");; std::cout << *zMean << std::endl;; ~~~; Define() creates the variable ""z"" by applying `sqrtSum` to ""x"" and ""y"". Later in the chain of calls we refer to; variables created with Define() as if they were actual tree branches/columns, but they are evaluated on demand, at most; once per event. As with filters, Define() calls can be chained with other transformations to create multiple custom; columns. Define() and Filter() transformations can be concatenated and intermixed at will. As with filters, it is possible to specify new columns as string expressions. This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto zMean = d.Define(""z"", ""sqrt(x*x + y*y)"").Mean(""z"");; std::cout << *zMean << std::endl;; ~~~. Again the names of t",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:21309,Modifiability,variab,variable,21309,"en using PyROOT. When writing expressions as such, only constants; and data coming from other columns in the dataset can be involved in the code passed as a string. Local variables and; functions cannot be used, since the interpreter will not know how to find them. When capturing local state is necessary,; it must first be declared to the ROOT C++ interpreter. More information on filters and how to use them to automatically generate cutflow reports can be found [below](#Filters). ### Defining custom columns; Let's now consider the case in which ""myTree"" contains two quantities ""x"" and ""y"", but our analysis relies on a derived; quantity `z = sqrt(x*x + y*y)`. Using the Define() transformation, we can create a new column in the dataset containing; the variable ""z"":; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto sqrtSum = [](double x, double y) { return sqrt(x*x + y*y); };; auto zMean = d.Define(""z"", sqrtSum, {""x"",""y""}).Mean(""z"");; std::cout << *zMean << std::endl;; ~~~; Define() creates the variable ""z"" by applying `sqrtSum` to ""x"" and ""y"". Later in the chain of calls we refer to; variables created with Define() as if they were actual tree branches/columns, but they are evaluated on demand, at most; once per event. As with filters, Define() calls can be chained with other transformations to create multiple custom; columns. Define() and Filter() transformations can be concatenated and intermixed at will. As with filters, it is possible to specify new columns as string expressions. This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto zMean = d.Define(""z"", ""sqrt(x*x + y*y)"").Mean(""z"");; std::cout << *zMean << std::endl;; ~~~. Again the names of the columns used in the expression and their types are inferred automatically. The string must be; valid C++ and it is just-in-time compiled. The process has a small runtime overhead and like with filters it is currently the only possible approach when using PyROOT. Previously, ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:21401,Modifiability,variab,variables,21401," as a string. Local variables and; functions cannot be used, since the interpreter will not know how to find them. When capturing local state is necessary,; it must first be declared to the ROOT C++ interpreter. More information on filters and how to use them to automatically generate cutflow reports can be found [below](#Filters). ### Defining custom columns; Let's now consider the case in which ""myTree"" contains two quantities ""x"" and ""y"", but our analysis relies on a derived; quantity `z = sqrt(x*x + y*y)`. Using the Define() transformation, we can create a new column in the dataset containing; the variable ""z"":; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto sqrtSum = [](double x, double y) { return sqrt(x*x + y*y); };; auto zMean = d.Define(""z"", sqrtSum, {""x"",""y""}).Mean(""z"");; std::cout << *zMean << std::endl;; ~~~; Define() creates the variable ""z"" by applying `sqrtSum` to ""x"" and ""y"". Later in the chain of calls we refer to; variables created with Define() as if they were actual tree branches/columns, but they are evaluated on demand, at most; once per event. As with filters, Define() calls can be chained with other transformations to create multiple custom; columns. Define() and Filter() transformations can be concatenated and intermixed at will. As with filters, it is possible to specify new columns as string expressions. This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto zMean = d.Define(""z"", ""sqrt(x*x + y*y)"").Mean(""z"");; std::cout << *zMean << std::endl;; ~~~. Again the names of the columns used in the expression and their types are inferred automatically. The string must be; valid C++ and it is just-in-time compiled. The process has a small runtime overhead and like with filters it is currently the only possible approach when using PyROOT. Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a; number of entries as a parameter. In the following",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:23041,Modifiability,variab,variables,23041,"ypes are inferred automatically. The string must be; valid C++ and it is just-in-time compiled. The process has a small runtime overhead and like with filters it is currently the only possible approach when using PyROOT. Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a; number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define(); transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action.; ~~~{.cpp}; RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ~~~; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a; simple way to make external variables available inside the body of C++ lambdas) to act on the same variable `x` from; both Define() transformations. Second, we have *stored* the transformed dataframe in a variable. This is always; possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more; on this [below](#callgraphs)). You can read more about defining new columns [here](#custom-columns). \image html RDF_Graph.png ""A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:23112,Modifiability,variab,variable,23112,"ypes are inferred automatically. The string must be; valid C++ and it is just-in-time compiled. The process has a small runtime overhead and like with filters it is currently the only possible approach when using PyROOT. Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a; number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define(); transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action.; ~~~{.cpp}; RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ~~~; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a; simple way to make external variables available inside the body of C++ lambdas) to act on the same variable `x` from; both Define() transformations. Second, we have *stored* the transformed dataframe in a variable. This is always; possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more; on this [below](#callgraphs)). You can read more about defining new columns [here](#custom-columns). \image html RDF_Graph.png ""A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:23218,Modifiability,variab,variable,23218,"verhead and like with filters it is currently the only possible approach when using PyROOT. Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a; number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define(); transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action.; ~~~{.cpp}; RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ~~~; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a; simple way to make external variables available inside the body of C++ lambdas) to act on the same variable `x` from; both Define() transformations. Second, we have *stored* the transformed dataframe in a variable. This is always; possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more; on this [below](#callgraphs)). You can read more about defining new columns [here](#custom-columns). \image html RDF_Graph.png ""A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); hanging from another Range(). Here are some co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:24338,Modifiability,variab,variable,24338," can store the status of the dataframe for further use (more; on this [below](#callgraphs)). You can read more about defining new columns [here](#custom-columns). \image html RDF_Graph.png ""A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); hanging from another Range(). Here are some commented examples:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; // Here we store a dataframe that loops over only the first 30 entries in a variable; auto d30 = d.Range(30);; // This is how you pick all entries from 15 onwards; auto d15on = d.Range(15, 0);; // We can specify a stride too, in this case we pick an event every 3; auto d15each3 = d.Range(0, 15, 3);; ~~~; Note that ranges are not available when multi-threading is enabled. More information on ranges is available; [here](#ranges). ### Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; the filtered events.; By now, you should be able to easily understand what is happening:; ~~~{.cpp}; RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; ~~~; RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are n",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:27504,Modifiability,variab,variable,27504,"sed? {df_wrong.GetNRuns()} times."") # The answer will be 3 times. ; ~~~. It is therefore good practice to declare all your transformations and actions *before* accessing their results, allowing; RDataFrame to run the loop once and produce all results in one go. ### Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.; The only modification required to the snippets would be the addition of this line *before* constructing the main; dataframe object:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ~~~; Simple as that. More details are given [below](#parallel-execution). \anchor collections; ## Working with collections and object selections. RDataFrame reads collections as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way. RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a rich interface to operate on the array elements in a vectorised fashion, similarly to Python's NumPy arrays. For example, to fill a histogram with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a la",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:28844,Modifiability,variab,variable,28844,"selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `n",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:29016,Modifiability,variab,variable,29016,"s as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:32476,Modifiability,variab,variable,32476,"p the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding filter*. Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. \anchor custom-columns; ### Custom columns; Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; (function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; assigned to the temporary column. A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; transformations/actions. Use cases include:; - caching the results of complex calculations for easy and efficient multiple access; - extraction of quantities of interest from complex objects; - branch aliasing, i.e. changing the name of a branch. An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree. It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; `Define(name, expression)`. For example this invocation. ~~~{.cpp}; df.Define(""pt"", ""sqrt(px*px + py*py)"");; ~~~. will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; from the names of the variables specified by the user. #### Custom columns as function of slot and entry number. It is po",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:33436,Modifiability,variab,variables,33436,"isted in `columnList`. `f` must return the value that will be; assigned to the temporary column. A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; transformations/actions. Use cases include:; - caching the results of complex calculations for easy and efficient multiple access; - extraction of quantities of interest from complex objects; - branch aliasing, i.e. changing the name of a branch. An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree. It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; `Define(name, expression)`. For example this invocation. ~~~{.cpp}; df.Define(""pt"", ""sqrt(px*px + py*py)"");; ~~~. will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; from the names of the variables specified by the user. #### Custom columns as function of slot and entry number. It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can; be invoked are:; - `DefineSlot(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, T1, T2, ...)`: the; first parameter is the slot number which ranges from 0 to ROOT::GetThreadPoolSize() - 1.; - `DefineSlotEntry(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, ULong64_t,; T1, T2, ...)`: the first parameter is the slot number while the second one the number of the entry being processed. \anchor actions; ## Actions: getting results; ### Instant and lazy actions; Actions can be **instant** or **lazy**. Instant actions are executed as soon as they are called, while lazy actions are; executed whenever the object they return is accessed for the firs",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:38460,Modifiability,config,configuration,38460,"[1,2,3]D; - HistoND; - Max; - Mean; - Min; - Profile[1,2,3]D; - Redefine; - Snapshot; - Stats; - StdDev; - Sum; - Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; - Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; - Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; currently not supported. \note The distributed RDataFrame module requires at least Python version 3.8. ### Connecting to a Spark cluster. In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf). # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:54986,Modifiability,flexible,flexible,54986,"ss, or booking all operations for all different RDataFrame computation graphs before the first event loop is triggered, so that the interpreter is invoked only once for all computation graphs:. ~~~{.cpp}; // assuming df1 and df2 are separate computation graphs, do:; auto h1 = df1.Histo1D(""x"");; auto h2 = df2.Histo1D(""y"");; h1->Draw(); // we just-in-time compile everything needed by df1 and df2 here; h2->Draw(""SAME"");. // do not:; auto h1 = df1.Histo1D(""x"");; h1->Draw(); // we just-in-time compile here; auto h2 = df2.Histo1D(""y"");; h2->Draw(""SAME""); // we just-in-time compile again here, as the second Histo1D call is new; ~~~. \anchor more-features; ## More features; Here is a list of the most important features that have been omitted in the ""Crash course"" for brevity.; You don't need to read all these to start using RDataFrame, but they are useful to save typing time and runtime. \anchor systematics; ### Systematic variations. Starting from ROOT v6.26, RDataFrame provides a flexible syntax to define systematic variations.; This is done in two steps: a) register variations for one or more existing columns using Vary() and b) extract variations; of normal RDataFrame results using \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"". In between these steps, no other change; to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated; through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; explicitly, this is not required for ROOT macros. . An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:. ~~~{.cpp}; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFun",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:59510,Modifiability,evolve,evolve,59510," Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; wh",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:60234,Modifiability,variab,variables,60234,"y() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:71409,Modifiability,variab,variable,71409,"arameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain; out of the desired trees and pass that to RDataFrame. Horizontal concatenations of trees or chains (creating a logical dataset with the same number of rows and the union of the; columns of multiple trees) leverages TTree's ""friend"" mechanism. Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&frien",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:74934,Modifiability,variab,variables,74934,"erfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs (storing and reusing sets of transformations). As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a **computation graph** in which; several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced. RDataFrame detects when several actions use the same filter or the same defined column, and **only evaluates each; filter or defined column once per event**, regardless of how many times that result is used down the computation graph.; Objects read from each column are **built once and never copied**, for maximum efficiency.; When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,; so it might be advisable to put the strictest filters first in the graph. \anchor representgraph; ### Visualizing the computation graph; It is possible to print the computation graph from any node to obtain a [DOT (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) representation e",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:77304,Modifiability,variab,variable,77304,". auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0""); .Filter([](int b1) { return b1 <2; }, {""cut1""}); .Define(""y"", []() { return 1; });. auto count = df2.Count();. // Prints the graph to the rd1.dot file in the current directory; ROOT::RDF::SaveGraph(df, ""./mydot.dot"");; // Prints the graph to standard output; ROOT::RDF::SaveGraph(df);; ~~~. The generated graph can be rendered using one of the graphviz filters, e.g. `dot`. For instance, the image below can be generated with the following command:; ~~~{.sh}; $ dot -Tpng computation_graph.dot -ocomputation_graph.png; ~~~. \image html RDF_Graph2.png. \anchor rdf-logging; ### Activating RDataFrame execution logs. RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; ~~~{.cpp}; #include <ROOT/RLogger.hxx>. // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; ~~~. or in Python:; ~~~{.python}; import ROOT. verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~{.python}; import ROOT. df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ~~~. The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; required sub-keys for e",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:238,Performance,multi-thread,multi-threading,238,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:1037,Performance,multi-thread,multi-thread,1037,"at off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:1742,Performance,Perform,Performance,1742,"g""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections](\ref RDFCollections); - [Executing callbacks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:3191,Performance,perform,performed,3191,"s: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed with RDataFrame. ### Transformations; Transformations are a way to manipulate the data. | **Transformation** | **Description** |; |------------------|--------------------|; | Alias() | Introduce an alias for a particular column name. |; | DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-saf",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:4572,Performance,multi-thread,multi-threaded,4572,"e dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; | FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; | RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6253,Performance,Cache,Cache,6253,"te the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before d",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6263,Performance,Cache,Cache,6263,"te the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before d",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6316,Performance,cache,cached,6316,"SlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-,",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6357,Performance,cache,cached,6357,"SlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-,",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6954,Performance,multi-thread,multi-threading,6954,"iption** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge)",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:7144,Performance,multi-thread,multi-threading,7144,"ion using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature `T(T,T)` where `T` is the type of the column. Return the final result of the reduction o",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:9359,Performance,multi-thread,multi-threading,9359,"tain statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |. | **Instant action** | **Description** |; |---------------------|-----------------|; | Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; | ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame obje",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11106,Performance,concurren,concurrency,11106,"shot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. | **Operation** | **Description** |; |---------------------|-----------------|; | Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](ht",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11467,Performance,perform,performed,11467,"ypes. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filt",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11665,Performance,perform,perform,11665," in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations)",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:12815,Performance,perform,performed,12815,"will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them. The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; [crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; <table>; <tr>; <td>; <b>TTreeReader</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A""",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:18793,Performance,perform,perform,18793,"vector elements for each event. You can use the objects returned by actions as if they were pointers to the desired results. There are many other; possible [actions](\ref cheatsheet), and all their results are wrapped in smart pointers; we'll see why in a minute. ### Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; but it can be any kind of function or even a functor class), together with a list of column names.; This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ~~~. An example of a more complex filter ex",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:19229,Performance,perform,performance,19229,"putations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; but it can be any kind of function or even a functor class), together with a list of column names.; This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ~~~. An example of a more complex filter expressed as a string containing C++ code is shown below. ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; ~~~. The code snippet above defines a column `p` that is a fixed-size array using the component column names and then; filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns; like the one above is currently the only possibility when using PyROO",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:24608,Performance,multi-thread,multi-threading,24608,"oint of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); hanging from another Range(). Here are some commented examples:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; // Here we store a dataframe that loops over only the first 30 entries in a variable; auto d30 = d.Range(30);; // This is how you pick all entries from 15 onwards; auto d15on = d.Range(15, 0);; // We can specify a stride too, in this case we pick an event every 3; auto d15each3 = d.Range(0, 15, 3);; ~~~; Note that ranges are not available when multi-threading is enabled. More information on ranges is available; [here](#ranges). ### Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; the filtered events.; By now, you should be able to easily understand what is happening:; ~~~{.cpp}; RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; ~~~; RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced; simultaneously. ### Properly exploiting RDataFrame ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:28719,Performance,perform,perform,28719,"vectorised fashion, similarly to Python's NumPy arrays. For example, to fill a histogram with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor n",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:28891,Performance,multi-thread,multi-threading,28891,"selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `n",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:29732,Performance,cache,cached,29732,"nt has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant R",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:30733,Performance,multi-thread,multi-thread,30733,"it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant RDataFrame. \anchor ranges; ### Ranges; When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; Range() transformations are available. These act very much like filters but instead of basing their decision on; a filter expression, they rely on `begin`,`end` and `stride` parameters. - `begin`: initial entry number considered for this range.; - `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; - `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0. The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; entries than that are available). Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parame",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:36298,Performance,optimiz,optimized,36298,"s for its computations will request it from a reader, e.g. a column created via `Define` or; available from the input dataset. The action will request values from each column of the list of input columns (either; inferred or specified by the user), in order. For example:. ~~~{.cpp}; ROOT::RDataFrame df{1};; auto df1 = df.Define(""x"", []{ return 11; });; auto df2 = df1.Define(""y"", []{ return 22; });; auto graph = df2.Graph<int, int>(""x"",""y"");; ~~~. The `Graph` action is going to request first the value from column ""x"", then that of column ""y"". Specifically, the order; of execution of the operations of nodes in this branch of the computation graph is guaranteed to be top to bottom. \anchor distrdf; ## Distributed execution. RDataFrame applications can be executed in parallel through distributed computing frameworks on a set of remote machines; thanks to the Python package `ROOT.RDF.Experimental.Distributed`. This experimental, **Python-only** package allows to scale the; optimized performance RDataFrame can achieve on a single machine to multiple nodes at the same time. It is designed so; that different backends can be easily plugged in, currently supporting [Apache Spark](http://spark.apache.org/) and; [Dask](https://dask.org/). To make use of distributed RDataFrame, you only need to switch `ROOT.RDataFrame` with; the backend-specific `RDataFrame` of your choice, for example:. ~~~{.py}; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"", ""myfile.root""). # Continue the application with the traditional RDataFrame API; sum = df.Filter(""x > 10"").Sum(""y""); h = df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""). print(sum.GetValue()); h.Draw(); ~~~. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all; parts of the RDataFrame API curr",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:36308,Performance,perform,performance,36308,"s for its computations will request it from a reader, e.g. a column created via `Define` or; available from the input dataset. The action will request values from each column of the list of input columns (either; inferred or specified by the user), in order. For example:. ~~~{.cpp}; ROOT::RDataFrame df{1};; auto df1 = df.Define(""x"", []{ return 11; });; auto df2 = df1.Define(""y"", []{ return 22; });; auto graph = df2.Graph<int, int>(""x"",""y"");; ~~~. The `Graph` action is going to request first the value from column ""x"", then that of column ""y"". Specifically, the order; of execution of the operations of nodes in this branch of the computation graph is guaranteed to be top to bottom. \anchor distrdf; ## Distributed execution. RDataFrame applications can be executed in parallel through distributed computing frameworks on a set of remote machines; thanks to the Python package `ROOT.RDF.Experimental.Distributed`. This experimental, **Python-only** package allows to scale the; optimized performance RDataFrame can achieve on a single machine to multiple nodes at the same time. It is designed so; that different backends can be easily plugged in, currently supporting [Apache Spark](http://spark.apache.org/) and; [Dask](https://dask.org/). To make use of distributed RDataFrame, you only need to switch `ROOT.RDataFrame` with; the backend-specific `RDataFrame` of your choice, for example:. ~~~{.py}; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"", ""myfile.root""). # Continue the application with the traditional RDataFrame API; sum = df.Filter(""x > 10"").Sum(""y""); h = df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""). print(sum.GetValue()); h.Draw(); ~~~. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all; parts of the RDataFrame API curr",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:43252,Performance,concurren,concurrently,43252,"can be retrieved by typing `rootls -lt myfile.root` at a command line. ### Distributed Snapshot. The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; computations. ### Distributed RunGraphs. Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:. ~~~{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs. # Create 3 different dataframes and book an histogram on each one; histoproxies = [; RDataFrame(100); .Define(""x"", ""rdfentry_""); .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); for _ in range(4); ]. # Execute the 3 computation graphs; RunGraphs(histoproxies); # Retrieve all the histograms in one go; histos = [histoproxy.GetValue() for histoproxy in histoproxies]; ~~~. Every distributed backend supports this feature and graphs belonging to different backends can be still triggered with; a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time). ### Histogram models in distributed mode. When calling a Histo*D operation in distributed mode, remember to pass to the function the model of the histogram to be; computed, e.g. the axis range and the n",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47072,Performance,Perform,Performance,47072,"t.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more control, you can create a dictionary where keys are plots and values are corresponding (optional) callback functions. For example:. ~~~{.py}; plot_callback_dict = {; graph: set_marker,; h_exp: fit_exp,; tprofile_2d: None; }. LiveVisualize(plot_callback_dict); ~~~. - Passing a Dictionary of drawables and callback functions with a global callback function: ; You can also combine a dictionary of plots and callbacks with a global callback function:. ~~~{.py}; LiveVisualize(plot_callback_dict, write_to_tfile); ~~~. \note The allowed operations to pass to LiveVisualize are:; - Histo1D(), Histo2D(), Histo3D(); - Graph(); - Profile1D(), Profile2D(). \warning The Live Visualization feature is only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. Thi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47182,Performance,perform,perform,47182,"t.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more control, you can create a dictionary where keys are plots and values are corresponding (optional) callback functions. For example:. ~~~{.py}; plot_callback_dict = {; graph: set_marker,; h_exp: fit_exp,; tprofile_2d: None; }. LiveVisualize(plot_callback_dict); ~~~. - Passing a Dictionary of drawables and callback functions with a global callback function: ; You can also combine a dictionary of plots and callbacks with a global callback function:. ~~~{.py}; LiveVisualize(plot_callback_dict, write_to_tfile); ~~~. \note The allowed operations to pass to LiveVisualize are:; - Histo1D(), Histo2D(), Histo3D(); - Graph(); - Profile1D(), Profile2D(). \warning The Live Visualization feature is only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. Thi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47190,Performance,multi-thread,multi-threaded,47190,"t.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more control, you can create a dictionary where keys are plots and values are corresponding (optional) callback functions. For example:. ~~~{.py}; plot_callback_dict = {; graph: set_marker,; h_exp: fit_exp,; tprofile_2d: None; }. LiveVisualize(plot_callback_dict); ~~~. - Passing a Dictionary of drawables and callback functions with a global callback function: ; You can also combine a dictionary of plots and callbacks with a global callback function:. ~~~{.py}; LiveVisualize(plot_callback_dict, write_to_tfile); ~~~. \note The allowed operations to pass to LiveVisualize are:; - Histo1D(), Histo2D(), Histo3D(); - Graph(); - Profile1D(), Profile2D(). \warning The Live Visualization feature is only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. Thi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47707,Performance,multi-thread,multi-thread,47707,"{.py}; LiveVisualize(plot_callback_dict, write_to_tfile); ~~~. \note The allowed operations to pass to LiveVisualize are:; - Histo1D(), Histo2D(), Histo3D(); - Graph(); - Profile1D(), Profile2D(). \warning The Live Visualization feature is only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them con",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47999,Performance,multi-thread,multi-thread,47999,"s only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects,",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48546,Performance,multi-thread,multi-thread,48546,"heir partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an u",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48761,Performance,concurren,concurrently,48761,"e order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other wor",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49068,Performance,race condition,race conditions,49068,"to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a singl",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49571,Performance,concurren,concurrently,49571,"(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run d",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:50664,Performance,concurren,concurrently,50664,"ifferent values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time c",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:50775,Performance,concurren,concurrently,50775,"In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51110,Performance,multi-thread,multi-thread,51110,"code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51166,Performance,multi-thread,multi-thread,51166,"code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51288,Performance,concurren,concurrently,51288,"ataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51406,Performance,Perform,Performance,51406,"d results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51456,Performance,perform,performance,51456,"rallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated u",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51963,Performance,perform,performance-critical,51963,"aFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:61410,Performance,perform,performance,61410,"to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:61469,Performance,perform,perform,61469,"ompile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:64516,Performance,Cache,Cache,64516," present.; ~~~{.cpp}; // use ""b1"" and ""b2"" as default columns; RDataFrame d1(""myTree"", ""file.root"", {""b1"",""b2""});; auto h = d1.Filter([](int b1, int b2) { return b1 > b2; }) // will act on ""b1"" and ""b2""; .Histo1D(); // will act on ""b1"". // just one default column this time; RDataFrame d2(""myTree"", ""file.root"", {""b1""});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ~~~. \anchor helper-cols; ### Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called `rdfentry_` and `rdfslot_`. The `rdfentry_`; column is of type `ULong64_t` and it holds the current entry number while `rdfslot_` is an `unsigned int`; holding the index of the current data processing slot.; For backwards compatibility reasons, the names `tdfentry_` and `tdfslot_` are also accepted.; These columns are ignored by operations such as [Cache](classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9); or [Snapshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). \warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. \anchor jitting; ### Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; signature** of the relevant filter function/temporary column expression/action function:; ~~~{.cpp}; // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; ~~~; If we",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:64703,Performance,multi-thread,multi-thread,64703,"yTree"", ""file.root"", {""b1""});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ~~~. \anchor helper-cols; ### Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called `rdfentry_` and `rdfslot_`. The `rdfentry_`; column is of type `ULong64_t` and it holds the current entry number while `rdfslot_` is an `unsigned int`; holding the index of the current data processing slot.; For backwards compatibility reasons, the names `tdfentry_` and `tdfslot_` are also accepted.; These columns are ignored by operations such as [Cache](classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9); or [Snapshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). \warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. \anchor jitting; ### Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; signature** of the relevant filter function/temporary column expression/action function:; ~~~{.cpp}; // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; ~~~; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at; runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; happen if we swapped the order of ""b1"" and ""b2"" in the column",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:66735,Performance,perform,performance,66735," the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter(). Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of; the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; is why we never needed to specify the column types for all actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr t",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:67179,Performance,perform,performed,67179," actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;. MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}. // Called before the event loop to retrieve the",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:67274,Performance,perform,perform,67274,"practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;. MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}. // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }. // Called at the",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69494,Performance,perform,perform,69494,"d of the event loop.; void Finalize(); {; *fFinalResult = std::accumulate(fPerThreadResults.begin(), fPerThreadResults.end(), 0);; }. // Called by RDataFrame to retrieve the name of this action.; std::string GetActionName() const { return ""MyCounter""; }; };. int main() {; ROOT::RDataFrame df(10);; ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; // The GetValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression wit",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69898,Performance,multi-thread,multi-thread,69898,"etValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70036,Performance,concurren,concurrently,70036,"etValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70136,Performance,concurren,concurrent,70136,"ions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; dou",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70560,Performance,concurren,concurrent,70560,"le, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concate",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:72894,Performance,multi-thread,multi-thread,72894,"eating a logical dataset with the same number of rows and the union of the; columns of multiple trees) leverages TTree's ""friend"" mechanism. Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other t",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73127,Performance,perform,perform,73127,"indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource impl",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73241,Performance,load,loaded,73241,"Frame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73288,Performance,load,load,73288,"Frame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73517,Performance,load,loads,73517,"es can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73547,Performance,load,loads,73547,"es can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73831,Performance,multi-thread,multi-thread,73831,"rce of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:77675,Performance,multi-thread,multi-thread,77675,"OOT::RDF::SaveGraph(df);; ~~~. The generated graph can be rendered using one of the graphviz filters, e.g. `dot`. For instance, the image below can be generated with the following command:; ~~~{.sh}; $ dot -Tpng computation_graph.dot -ocomputation_graph.png; ~~~. \image html RDF_Graph2.png. \anchor rdf-logging; ### Activating RDataFrame execution logs. RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; ~~~{.cpp}; #include <ROOT/RLogger.hxx>. // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; ~~~. or in Python:; ~~~{.python}; import ROOT. verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~{.python}; import ROOT. df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ~~~. The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; sample in the ""metadata"" key. A simple example for the formatting of the specification in the JSON file is the following:. ~~~{.cpp}; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""met",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:850,Safety,safe,safe,850,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:4164,Safety,safe,safe,4164,"h can be performed with RDataFrame. ### Transformations; Transformations are a way to manipulate the data. | **Transformation** | **Description** |; |------------------|--------------------|; | Alias() | Introduce an alias for a particular column name. |; | DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; | FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an exi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:9306,Safety,safe,safety,9306,"tain statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |. | **Instant action** | **Description** |; |---------------------|-----------------|; | Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; | ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame obje",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:9650,Safety,safe,safe,9650,"s. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |. | **Instant action** | **Description** |; |---------------------|-----------------|; | Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; | ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. | **Operation** | **Description** |; |---------------------|-----------------|; | Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetC",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48420,Safety,safe,safety,48420,"heir partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an u",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48715,Safety,safe,safe,48715," of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ diffe",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49059,Safety,risk,risks,49059,"to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a singl",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49126,Safety,safe,safe,49126,"ImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event l",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:50070,Safety,safe,safe,50070,"rder to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->D",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51500,Safety,avoid,avoid,51500,"rallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated u",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:65698,Safety,detect,detects,65698,"napshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). \warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. \anchor jitting; ### Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; signature** of the relevant filter function/temporary column expression/action function:; ~~~{.cpp}; // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; ~~~; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at; runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; happen if we swapped the order of ""b1"" and ""b2"" in the column list passed to Filter(). Certain actions, on the other hand, do not take a function as argument (e.g. Histo1D()), so we cannot deduce the type of; the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; is why we never needed to specify the column types for all actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:66870,Safety,avoid,avoids,66870,"isto1D()), so we cannot deduce the type of; the column at compile-time. In this case **RDataFrame infers the type of the column** from the TTree itself. This; is why we never needed to specify the column types for all actions in the above snippets. When the column type is not a common one such as `int`, `double`, `char` or `float` it is nonetheless good practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69954,Safety,safe,safety,69954,"etValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70761,Safety,safe,safe,70761," = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70820,Safety,safe,safe,70820," / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain; out of the desired trees and pass that to RDataFrame. Horizon",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:75204,Safety,detect,detects,75204,".; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs (storing and reusing sets of transformations). As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a **computation graph** in which; several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced. RDataFrame detects when several actions use the same filter or the same defined column, and **only evaluates each; filter or defined column once per event**, regardless of how many times that result is used down the computation graph.; Objects read from each column are **built once and never copied**, for maximum efficiency.; When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,; so it might be advisable to put the strictest filters first in the graph. \anchor representgraph; ### Visualizing the computation graph; It is possible to print the computation graph from any node to obtain a [DOT (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) representation either on the standard output; or in a file. Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; the node belongs to is printed. By using the head node, the entire computation graph is printed. Following there is an example of usage:; ~~~{.cpp}; // First, a sample computational graph is built;",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:779,Security,access,access,779,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:5843,Security,access,accessed,5843," If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; | RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by call",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:13126,Security,access,accessed,13126,"html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them. The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; [crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; <table>; <tr>; <td>; <b>TTreeReader</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ~~~; </td>; ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:13216,Security,access,access,13216,"ot.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them. The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; [crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; <table>; <tr>; <td>; <b>TTreeReader</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ~~~; </td>; </tr>; <tr>; <td>; <b>TTree::Draw</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; aut",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:13354,Security,access,access,13354,"From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them. The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; [crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; <table>; <tr>; <td>; <b>TTreeReader</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ~~~; </td>; </tr>; <tr>; <td>; <b>TTree::Draw</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:18341,Security,access,access,18341,"s an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"". Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be precise) to a TH1D histogram filled; with the `MET` of all events. If the quantity stored in the column is a collection (e.g. a vector or an array), the; histogram is filled with all vector elements for each event. You can use the objects returned by actions as if they were pointers to the desired results. There are many other; possible [actions](\ref cheatsheet), and all their results are wrapped in smart pointers; we'll see why in a minute. ### Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; but it can be any kind of function or even a functo",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:25429,Security,access,accessed,25429,"rds; auto d15on = d.Range(15, 0);; // We can specify a stride too, in this case we pick an event every 3; auto d15each3 = d.Range(0, 15, 3);; ~~~; Note that ranges are not available when multi-threading is enabled. More information on ranges is available; [here](#ranges). ### Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; the filtered events.; By now, you should be able to easily understand what is happening:; ~~~{.cpp}; RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; ~~~; RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced; simultaneously. ### Properly exploiting RDataFrame laziness. For yet another example of the difference between the correct and incorrect running of the event-loop, see the following; two code snippets. We assume our ROOT file has branches a, b and c. The correct way - the dataset is only processed once.; ~~~{.py}; df_correct = ROOT.RDataFrame(treename, filename);. h_a = df_correct.Histo1D(""a""); h_b = df_correct.Histo1D(""b""); h_c = df_correct.Histo1D(""c""). h_a_val = h_a.GetValue(); h_b_val = h_b.GetValue(); h_c_val = h_c.GetValue(). print(f""How many times was the data set processed? {df_wrong.GetNRuns()} time."") # The answer will be 1 time. ; ~~~. An incorrect way - the dataset is processed three times.; ~~~{.py}; df_incorrect = ROOT.RDataFrame(treename, filename);. h_a = df_incorrect.Histo1D(""a""); h_a_val = h_a.GetValue(). h_b = df_incorrect.Histo1D(""b""); h_b_val = h_b.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:26698,Security,access,accessing,26698,"ee the following; two code snippets. We assume our ROOT file has branches a, b and c. The correct way - the dataset is only processed once.; ~~~{.py}; df_correct = ROOT.RDataFrame(treename, filename);. h_a = df_correct.Histo1D(""a""); h_b = df_correct.Histo1D(""b""); h_c = df_correct.Histo1D(""c""). h_a_val = h_a.GetValue(); h_b_val = h_b.GetValue(); h_c_val = h_c.GetValue(). print(f""How many times was the data set processed? {df_wrong.GetNRuns()} time."") # The answer will be 1 time. ; ~~~. An incorrect way - the dataset is processed three times.; ~~~{.py}; df_incorrect = ROOT.RDataFrame(treename, filename);. h_a = df_incorrect.Histo1D(""a""); h_a_val = h_a.GetValue(). h_b = df_incorrect.Histo1D(""b""); h_b_val = h_b.GetValue(). h_c = df_incorrect.Histo1D(""c""); h_c_val = h_c.GetValue(). print(f""How many times was the data set processed? {df_wrong.GetNRuns()} times."") # The answer will be 3 times. ; ~~~. It is therefore good practice to declare all your transformations and actions *before* accessing their results, allowing; RDataFrame to run the loop once and produce all results in one go. ### Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.; The only modification required to the snippets would be the addition of this line *before* constructing the main; dataframe object:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ~~~; Simple as that. More details are given [below](#parallel-execution). \anchor collections; ## Working with collections and object selections. RDataFrame reads collections as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way. RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a ric",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:29706,Security,access,access,29706,"nt has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant R",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:32511,Security,access,accessible,32511,"p the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding filter*. Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. \anchor custom-columns; ### Custom columns; Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; (function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; assigned to the temporary column. A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; transformations/actions. Use cases include:; - caching the results of complex calculations for easy and efficient multiple access; - extraction of quantities of interest from complex objects; - branch aliasing, i.e. changing the name of a branch. An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree. It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; `Define(name, expression)`. For example this invocation. ~~~{.cpp}; df.Define(""pt"", ""sqrt(px*px + py*py)"");; ~~~. will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; from the names of the variables specified by the user. #### Custom columns as function of slot and entry number. It is po",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:32700,Security,access,access,32700,"s a `begin` parameter of 10, that means the range will skip the first 10 entries *that pass the; preceding filter*. Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their `end` value of; processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. \anchor custom-columns; ### Custom columns; Custom columns are created by invoking `Define(name, f, columnList)`. As usual, `f` can be any callable object; (function, lambda expression, functor class...); it takes the values of the columns listed in `columnList` (a list of; strings) as parameters, in the same order as they are listed in `columnList`. `f` must return the value that will be; assigned to the temporary column. A new variable is created called `name`, accessible as if it was contained in the dataset from subsequent; transformations/actions. Use cases include:; - caching the results of complex calculations for easy and efficient multiple access; - extraction of quantities of interest from complex objects; - branch aliasing, i.e. changing the name of a branch. An exception is thrown if the `name` of the new column/branch is already in use for another branch in the TTree. It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method; `Define(name, expression)`. For example this invocation. ~~~{.cpp}; df.Define(""pt"", ""sqrt(px*px + py*py)"");; ~~~. will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system; builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches; from the names of the variables specified by the user. #### Custom columns as function of slot and entry number. It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can; be invoked are:; - `DefineSlot(name, f, column",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:34353,Security,access,accessed,34353,"t-in-time compiled function starting from the expression after having deduced the list of necessary branches; from the names of the variables specified by the user. #### Custom columns as function of slot and entry number. It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can; be invoked are:; - `DefineSlot(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, T1, T2, ...)`: the; first parameter is the slot number which ranges from 0 to ROOT::GetThreadPoolSize() - 1.; - `DefineSlotEntry(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, ULong64_t,; T1, T2, ...)`: the first parameter is the slot number while the second one the number of the entry being processed. \anchor actions; ## Actions: getting results; ### Instant and lazy actions; Actions can be **instant** or **lazy**. Instant actions are executed as soon as they are called, while lazy actions are; executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value; are lazy, the others are instant. ### Return type of a lazy action. When a lazy action is called, it returns a \link ROOT::RDF::RResultPtr ROOT::RDF::RResultPtr<T>\endlink, where T is the; type of the result of the action. The final result will be stored in the `RResultPtr` and can be retrieved by; dereferencing it or via its `GetValue` method. ### Actions that return collections. If the type of the return value of an action is a collection, e.g. `std::vector<int>`, you can iterate its elements; directly through the wrapping `RResultPtr`:. ~~~{.cpp}; ROOT::RDataFrame df{5};; auto df1 = df.Define(""x"", []{ return 42; });; for (const auto &el: df1.Take<int>(""x"")){; std::cout << ""Element: "" << el << ""\n"";; }; ~~~. ~~~{.py}; df = ROOT.RDataFrame(5).Define(""x"", ""42""); for el in df.Take[int](""x""):; print(f""Element: {el}""); ~~~. ### Actions and readers. An action that ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:38162,Security,access,access,38162,"alue()); h.Draw(); ~~~. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all; parts of the RDataFrame API currently work with this package. The subset that is currently available is:; - AsNumpy; - Count; - Define; - DefinePerSample; - Filter; - Graph; - Histo[1,2,3]D; - HistoND; - Max; - Mean; - Min; - Profile[1,2,3]D; - Redefine; - Snapshot; - Stats; - StdDev; - Sum; - Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; - Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; - Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; currently not supported. \note The distributed RDataFrame module requires at least Python version 3.8. ### Connecting to a Spark cluster. In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf). # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:39796,Security,expose,exposes,39796," constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; of the cluster schedulers supported by Dask (more information in the; [Dask distributed docs](http://distributed.dask.org/en/stable/)):. ~~~{.py}; import ROOT; from dask.distributed import Client. # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:41676,Security,access,access,41676," cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame appropriate for the; # backend used in the analysis; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root` at a command line. ### Distributed Snapshot. The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; it should be provided as an absolute path). Another important difference is that `n` separate files wi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:42529,Security,access,accessible,42529,". This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame appropriate for the; # backend used in the analysis; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root` at a command line. ### Distributed Snapshot. The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; computations. ### Distributed RunGraphs. Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:. ~~~{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs. # Create 3 different dataframes and book an histogram on each one; h",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:50988,Security,access,accessing,50988,"code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:56237,Security,access,access,56237,"sFor()"". In between these steps, no other change; to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated; through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; explicitly, this is not required for ROOT macros. . An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:. ~~~{.cpp}; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks similar. Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cu",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:67242,Security,inject,inject,67242,"practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;. MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}. // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }. // Called at the",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:67437,Security,access,access,67437,">(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;. MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}. // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }. // Called at the beginning of the event loop.; void Initialize() {}. // Called at the beginning of each processing task.; void InitTask(TTreeReader *, int) {}. /// Called at every entry.; voi",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69192,Security,Inject,Injecting,69192," fFinalResult; }. // Called at the beginning of the event loop.; void Initialize() {}. // Called at the beginning of each processing task.; void InitTask(TTreeReader *, int) {}. /// Called at every entry.; void Exec(unsigned int slot); {; fPerThreadResults[slot]++;; }. // Called at the end of the event loop.; void Finalize(); {; *fFinalResult = std::accumulate(fPerThreadResults.begin(), fPerThreadResults.end(), 0);; }. // Called by RDataFrame to retrieve the name of this action.; std::string GetActionName() const { return ""MyCounter""; }; };. int main() {; ROOT::RDataFrame df(10);; ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; // The GetValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:79013,Security,access,accessed,79013,"e: . ~~~{.python}; import ROOT. df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ~~~. The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; sample in the ""metadata"" key. A simple example for the formatting of the specification in the JSON file is the following:. ~~~{.cpp}; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; ~~~. The metadata information from the specification file can be then accessed using the DefinePerSample function.; For example, to access luminosity information (stored as a double):. ~~~{.python}; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); ~~~. or sample_category information (stored as a string):. ~~~{.python}; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ~~~. or directly the filename:. ~~~{.python}; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); ~~~. An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; provides a corresponding exemplary JSON file for the dataset specification. \anchor progressbar; ### Adding a progress bar . A progress bar showing the processed event statistics can be added to any RDataFrame program.; The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is re",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:79075,Security,access,access,79075," input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; sample in the ""metadata"" key. A simple example for the formatting of the specification in the JSON file is the following:. ~~~{.cpp}; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; ~~~. The metadata information from the specification file can be then accessed using the DefinePerSample function.; For example, to access luminosity information (stored as a double):. ~~~{.python}; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); ~~~. or sample_category information (stored as a string):. ~~~{.python}; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ~~~. or directly the filename:. ~~~{.python}; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); ~~~. An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; provides a corresponding exemplary JSON file for the dataset specification. \anchor progressbar; ### Adding a progress bar . A progress bar showing the processed event statistics can be added to any RDataFrame program.; The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; n seconds (by default m = 10",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:83266,Security,access,access,83266,"e as input argument the name of a column of the dataset to watch for; missing values. Like Filter, they will either keep or discard an entire entry; based on whether a condition returns true or false. Specifically:. - FilterAvailable: the condition is whether the value of the column is present.; If so, the entry is kept. Otherwise if the value is missing the entry is; discarded.; - FilterMissing: the condition is whether the value of the column is missing. If; so, the entry is kept. Otherwise if the value is present the entry is; discarded. \code{.py}; df = ROOT.RDataFrame(dataset). # Anytime an entry from ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""). # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the inp",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:83894,Security,access,access,83894,"g, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""). # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the input column passed to this function is not; available, the node will provide the default value passed to this function call; instead. Example:. \code{.py}; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.De",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:2685,Testability,log,logs,2685,"g""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections](\ref RDFCollections); - [Executing callbacks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:2700,Testability,log,logging,2700,"g""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections](\ref RDFCollections); - [Executing callbacks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:40474,Testability,log,logic,40474," Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npar",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:40645,Testability,log,logic,40645,"sion don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""). # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:41313,Testability,log,logic,41313,"tations in the local machine; using all cores available. ### Choosing the number of distributed tasks. A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; generically tries to infer how many cores are available in the cluster through the connection object. The number of; tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; a batch system. The client object created at the beginning of the application does not automatically know how many cores; will be available during distributed execution, since the jobs are submitted to the batch system after the creation of; the connection. In such cases, the logic is to default to process the whole dataset in 2 tasks. The number of tasks submitted for distributed execution can be also set programmatically, by providing the optional; keyword argument `npartitions` when creating the RDataFrame object. This parameter is accepted irrespectively of the; backend used:. ~~~{.py}; import ROOT. # Define correct imports and access the distributed RDataFrame appropriate for the; # backend used in the analysis; RDataFrame = ROOT.RDF.Experimental.Distributed.[BACKEND].RDataFrame. if __name__ == ""__main__"":; # The `npartitions` optional argument tells the RDataFrame how many tasks are desired; df = RDataFrame(""mytree"",""myfile.root"", npartitions=NPARTITIONS); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); ~~~. Note that when processing a TTree or TChain dataset, the `npartitions` value should not exceed the number of clusters in; the dataset. The number of clusters in a TTree can be retrieved by typing `rootls -lt myfile.root`",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51680,Testability,log,logic,51680,"oncurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the eve",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:52831,Testability,log,logging,52831,"oat>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53033,Testability,log,logs,53033,"asily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:53048,Testability,log,logging,53048,"asily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitigations include creating and running each RDataFrame event loop in a sub-process, or booking all operations",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:71630,Testability,log,logical,71630,"an take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain; out of the desired trees and pass that to RDataFrame. Horizontal concatenations of trees or chains (creating a logical dataset with the same number of rows and the union of the; columns of multiple trees) leverages TTree's ""friend"" mechanism. Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" co",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:71919,Testability,log,logical,71919,"ctor<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain; out of the desired trees and pass that to RDataFrame. Horizontal concatenations of trees or chains (creating a logical dataset with the same number of rows and the union of the; columns of multiple trees) leverages TTree's ""friend"" mechanism. Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-w",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:76991,Testability,log,logging,76991,"tion ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; the node belongs to is printed. By using the head node, the entire computation graph is printed. Following there is an example of usage:; ~~~{.cpp}; // First, a sample computational graph is built; ROOT::RDataFrame df(""tree"", ""f.root"");. auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0""); .Filter([](int b1) { return b1 <2; }, {""cut1""}); .Define(""y"", []() { return 1; });. auto count = df2.Count();. // Prints the graph to the rd1.dot file in the current directory; ROOT::RDF::SaveGraph(df, ""./mydot.dot"");; // Prints the graph to standard output; ROOT::RDF::SaveGraph(df);; ~~~. The generated graph can be rendered using one of the graphviz filters, e.g. `dot`. For instance, the image below can be generated with the following command:; ~~~{.sh}; $ dot -Tpng computation_graph.dot -ocomputation_graph.png; ~~~. \image html RDF_Graph2.png. \anchor rdf-logging; ### Activating RDataFrame execution logs. RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; ~~~{.cpp}; #include <ROOT/RLogger.hxx>. // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; ~~~. or in Python:; ~~~{.python}; import ROOT. verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:77036,Testability,log,logs,77036,"tion ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; the node belongs to is printed. By using the head node, the entire computation graph is printed. Following there is an example of usage:; ~~~{.cpp}; // First, a sample computational graph is built; ROOT::RDataFrame df(""tree"", ""f.root"");. auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0""); .Filter([](int b1) { return b1 <2; }, {""cut1""}); .Define(""y"", []() { return 1; });. auto count = df2.Count();. // Prints the graph to the rd1.dot file in the current directory; ROOT::RDF::SaveGraph(df, ""./mydot.dot"");; // Prints the graph to standard output; ROOT::RDF::SaveGraph(df);; ~~~. The generated graph can be rendered using one of the graphviz filters, e.g. `dot`. For instance, the image below can be generated with the following command:; ~~~{.sh}; $ dot -Tpng computation_graph.dot -ocomputation_graph.png; ~~~. \image html RDF_Graph2.png. \anchor rdf-logging; ### Activating RDataFrame execution logs. RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; ~~~{.cpp}; #include <ROOT/RLogger.hxx>. // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; ~~~. or in Python:; ~~~{.python}; import ROOT. verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:77090,Testability,log,logging,77090," branch; the node belongs to is printed. By using the head node, the entire computation graph is printed. Following there is an example of usage:; ~~~{.cpp}; // First, a sample computational graph is built; ROOT::RDataFrame df(""tree"", ""f.root"");. auto df2 = df.Define(""x"", []() { return 1; }); .Filter(""col0 % 1 == col0""); .Filter([](int b1) { return b1 <2; }, {""cut1""}); .Define(""y"", []() { return 1; });. auto count = df2.Count();. // Prints the graph to the rd1.dot file in the current directory; ROOT::RDF::SaveGraph(df, ""./mydot.dot"");; // Prints the graph to standard output; ROOT::RDF::SaveGraph(df);; ~~~. The generated graph can be rendered using one of the graphviz filters, e.g. `dot`. For instance, the image below can be generated with the following command:; ~~~{.sh}; $ dot -Tpng computation_graph.dot -ocomputation_graph.png; ~~~. \image html RDF_Graph2.png. \anchor rdf-logging; ### Activating RDataFrame execution logs. RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; ~~~{.cpp}; #include <ROOT/RLogger.hxx>. // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; ~~~. or in Python:; ~~~{.python}; import ROOT. verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~{.python}; import ROOT. df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ~~~. The input datas",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:460,Usability,guid,guide,460,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:2804,Usability,progress bar,progress bar,2804,"g""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections](\ref RDFCollections); - [Executing callbacks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:5594,Usability,guid,guide,5594,"in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; | FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; | RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | P",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:10278,Usability,simpl,simply,10278," Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; | ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. | **Operation** | **Description** |; |---------------------|-----------------|; | Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_descriptio",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:15179,Usability,Simpl,Simply,15179,"~{.cpp}; auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; ~~~; </td>; <td>; ~~~{.cpp}; ROOT::RDataFrame df(""myTree"", file);; auto h = df.Filter(""y > 2"").Histo1D(""x"");; h->Draw(); ~~~; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; tree->Draw(""jet_eta"", ""weight*(event == 1)"");; ~~~; </td>; <td>; ~~~{.cpp}; df.Filter(""event == 1"").Histo1D(""jet_eta"", ""weight"");; // or the fully compiled version:; df.Filter([] (ULong64_t e) { return e == 1; }, {""event""}).Histo1D<RVec<float>>(""jet_eta"", ""weight"");; ~~~; </td>; </tr>; <tr>; <td>; ~~~{cpp}; // object selection: for each event, fill histogram with array of selected pts; tree->Draw('Muon_pt', 'Muon_pt > 100'); ~~~; </td>; <td>; ~~~{cpp}; // with RDF, arrays are read as ROOT::VecOps::RVec objects; df.Define(""good_pt"", ""Muon_pt[Muon_pt > 100]"").Histo1D(""good_pt""); ~~~; </td>; </tr>; </table>. \anchor crash-course; ## Crash course; All snippets of code presented in the crash course can be executed in the ROOT interpreter. Simply precede them with; ~~~{.cpp}; using namespace ROOT; // RDataFrame's namespace; ~~~; which is omitted for brevity. The terms ""column"" and ""branch"" are used interchangeably. ### Creating an RDataFrame; RDataFrame's constructor is where the user specifies the dataset and, optionally, a default set of columns that; operations should work with. Here are the most common methods to construct an RDataFrame object:; ~~~{.cpp}; // single file -- all constructors are equivalent; TFile *f = TFile::Open(""file.root"");; TTree *t = f.Get<TTree>(""treeName"");. RDataFrame d1(""treeName"", ""file.root"");; RDataFrame d2(""treeName"", f); // same as TTreeReader; RDataFrame d3(*t);. // multiple files -- all constructors are equivalent; TChain chain(""myTree"");; chain.Add(""file1.root"");; chain.Add(""file2.root"");. RDataFrame d4(""myTree"", {""file1.root"", ""file2.root""});; std::vector<std::string> files = {""file1.root"", ""file2.root""};; RDataFrame d5(""myTree"", files);; RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:16652,Usability,simpl,simple,16652,"uctors are equivalent; TFile *f = TFile::Open(""file.root"");; TTree *t = f.Get<TTree>(""treeName"");. RDataFrame d1(""treeName"", ""file.root"");; RDataFrame d2(""treeName"", f); // same as TTreeReader; RDataFrame d3(*t);. // multiple files -- all constructors are equivalent; TChain chain(""myTree"");; chain.Add(""file1.root"");; chain.Add(""file2.root"");. RDataFrame d4(""myTree"", {""file1.root"", ""file2.root""});; std::vector<std::string> files = {""file1.root"", ""file2.root""};; RDataFrame d5(""myTree"", files);; RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed as-is to TChain's constructor; RDataFrame d7(chain);; ~~~; Additionally, users can construct an RDataFrame with no data source by passing an integer number. This is the number of rows that; will be generated by this RDataFrame.; ~~~{.cpp}; RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now); d.Foreach([] { static int i = 0; std::cout << i++ << std::endl; }); // silly example usage: count to ten; ~~~; This is useful to generate simple datasets on the fly: the contents of each event can be specified with Define() (explained below). For example, we have used this method to generate [Pythia](https://pythia.org/) events and write them to disk in parallel (with the Snapshot action). For data sources other than TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):. ~~~{.cpp}; auto df = ROOT::RDF::FromCSV(""input.csv"");; // use df as usual; ~~~. ### Filling a histogram; Let's now tackle a very common task, filling a histogram:; ~~~{.cpp}; // Fill a TH1D with the ""MET"" branch; RDataFrame d(""myTree"", ""file.root"");; auto h = d.Histo1D(""MET"");; h->Draw();; ~~~; The first line creates an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"". Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be precise) to a TH1D histogram filled; with the `MET` of all events. If the qua",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:18901,Usability,simpl,simple,18901,"ers; we'll see why in a minute. ### Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; but it can be any kind of function or even a functor class), together with a list of column names.; This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ~~~. An example of a more complex filter expressed as a string containing C++ code is shown below. ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:23013,Usability,simpl,simple,23013,"ypes are inferred automatically. The string must be; valid C++ and it is just-in-time compiled. The process has a small runtime overhead and like with filters it is currently the only possible approach when using PyROOT. Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a; number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define(); transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action.; ~~~{.cpp}; RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ~~~; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a; simple way to make external variables available inside the body of C++ lambdas) to act on the same variable `x` from; both Define() transformations. Second, we have *stored* the transformed dataframe in a variable. This is always; possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more; on this [below](#callgraphs)). You can read more about defining new columns [here](#custom-columns). \image html RDF_Graph.png ""A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:27118,Usability,Simpl,Simple,27118,"e data set processed? {df_wrong.GetNRuns()} time."") # The answer will be 1 time. ; ~~~. An incorrect way - the dataset is processed three times.; ~~~{.py}; df_incorrect = ROOT.RDataFrame(treename, filename);. h_a = df_incorrect.Histo1D(""a""); h_a_val = h_a.GetValue(). h_b = df_incorrect.Histo1D(""b""); h_b_val = h_b.GetValue(). h_c = df_incorrect.Histo1D(""c""); h_c_val = h_c.GetValue(). print(f""How many times was the data set processed? {df_wrong.GetNRuns()} times."") # The answer will be 3 times. ; ~~~. It is therefore good practice to declare all your transformations and actions *before* accessing their results, allowing; RDataFrame to run the loop once and produce all results in one go. ### Going parallel; Let's say we would like to run the previous examples in parallel on several cores, dividing events fairly between cores.; The only modification required to the snippets would be the addition of this line *before* constructing the main; dataframe object:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ~~~; Simple as that. More details are given [below](#parallel-execution). \anchor collections; ## Working with collections and object selections. RDataFrame reads collections as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way. RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a rich interface to operate on the array elements in a vectorised fashion, similarly to Python's NumPy arrays. For example, to fill a histogram with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](cons",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:28271,Usability,Learn,Learn,28271," as the special type [ROOT::RVec](https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html): for example, a column containing an array of floating point numbers can be read as a ROOT::RVecF. C-style arrays (with variable or static size), STL vectors and most other collection types can be read this way. RVec is a container similar to std::vector (and can be used just like a std::vector) but it also offers a rich interface to operate on the array elements in a vectorised fashion, similarly to Python's NumPy arrays. For example, to fill a histogram with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilatio",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:29716,Usability,simpl,simply,29716,"nt has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant R",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:38259,Usability,guid,guide,38259," distributedly. Nonetheless, not all; parts of the RDataFrame API currently work with this package. The subset that is currently available is:; - AsNumpy; - Count; - Define; - DefinePerSample; - Filter; - Graph; - Histo[1,2,3]D; - HistoND; - Max; - Mean; - Min; - Profile[1,2,3]D; - Redefine; - Snapshot; - Stats; - StdDev; - Sum; - Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; - Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; - Information about the dataframe: GetColumnNames. with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; currently not supported. \note The distributed RDataFrame module requires at least Python version 3.8. ### Connecting to a Spark cluster. In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; connection instance to the distributed `RDataFrame` object like so:. ~~~{.py}; import pyspark; import ROOT. # Create a SparkContext object with the right configuration for your Spark cluster; conf = SparkConf().setAppName(appName).setMaster(master); sc = SparkContext(conf=conf). # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); ~~~. If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); is not provided, the default behaviour is to create one in the background for you. ### Connecting to a Dask cluster. Similarly, you can connect to a Dask cluster by creating your own connection objec",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48808,Usability,simpl,simple,48808,"to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a singl",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:52852,Usability,simpl,simplifies,52852,"oat>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging). ### Memory usage. There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage. Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after th",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:57028,Usability,simpl,simply,57028,"D<float>(""x"");. // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);. // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ~~~. A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; ""pt:down"", ""pt:up"" in this example). Python usage looks similar. Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; calls for each variation and fill the histogram with values and cuts that depend on the variation. There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; complex functors. The callable can be applied to zero or more existing columns and it will always receive their; _nominal_ value in input. #### Varying multiple columns in lockstep. In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; ""in lockstep"":. ~~~{.python}; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); ~~~. The expression returns an RVec ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:59543,Usability,feedback,feedback,59543," Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; by applying multiple systematic variations at the same time.; For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; ""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:. ~~~{.cpp}; auto df = _df.Vary(""pt"",; ""ROOT::RVecD{pt*0.9, pt*1.1}"",; {""down"", ""up""}); .Vary(""eta"",; [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; {""eta""},; 2);. auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; auto all_hs = VariationsFor(nom_h);; all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; ~~~. Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1). \note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; programming model will be streamlined in future versions. \note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; wh",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:60800,Usability,simpl,simpler,60800,"re releases. See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis. \anchor rnode; ### RDataFrame objects as function arguments and return values; RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); functions and to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:61639,Usability,simpl,simple,61639,"}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; ~~~. C",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:62263,Usability,progress bar,progress bar,62263,"taFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; ~~~. Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument; and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them; (e.g. a histogram filled with a part of the selected events). Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot(). \anchor default-branches; ### Default column lists; When constructing an RDataFrame object, it is possible to specify a **defaul",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70220,Usability,simpl,simple,70220,"ions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; dou",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:72051,Usability,Simpl,Simple,72051,"x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain; out of the desired trees and pass that to RDataFrame. Horizontal concatenations of trees or chains (creating a logical dataset with the same number of rows and the union of the; columns of multiple trees) leverages TTree's ""friend"" mechanism. Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees ",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73135,Usability,simpl,simple,73135,"indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource impl",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:78480,Usability,simpl,simple,78480,"Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~{.python}; import ROOT. df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ~~~. The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; sample in the ""metadata"" key. A simple example for the formatting of the specification in the JSON file is the following:. ~~~{.cpp}; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; ~~~. The metadata information from the specification file can be then accessed using the DefinePerSample function.; For example, to access luminosity information (stored as a double):. ~~~{.python}; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); ~~~. or sample_category information (stored as a string):. ~~~{.python}; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ~~~. or directly the filename:. ~~~{.python}; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); ~~~. An example implementation of the ""FromSpec"" method is av",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:79696,Usability,progress bar,progress bar,79696,"etadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; ~~~. The metadata information from the specification file can be then accessed using the DefinePerSample function.; For example, to access luminosity information (stored as a double):. ~~~{.python}; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); ~~~. or sample_category information (stored as a string):. ~~~{.python}; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ~~~. or directly the filename:. ~~~{.python}; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); ~~~. An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; provides a corresponding exemplary JSON file for the dataset specification. \anchor progressbar; ### Adding a progress bar . A progress bar showing the processed event statistics can be added to any RDataFrame program.; The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. . ProgressBar is added after creating the dataframe object (df):; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ~~~. Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; For example, it can be called at any computational node, such as Filter or Define, not only the head node,; with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; section for appropriate",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:79713,Usability,progress bar,progress bar,79713,"; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; ~~~. The metadata information from the specification file can be then accessed using the DefinePerSample function.; For example, to access luminosity information (stored as a double):. ~~~{.python}; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); ~~~. or sample_category information (stored as a string):. ~~~{.python}; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ~~~. or directly the filename:. ~~~{.python}; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); ~~~. An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; provides a corresponding exemplary JSON file for the dataset specification. \anchor progressbar; ### Adding a progress bar . A progress bar showing the processed event statistics can be added to any RDataFrame program.; The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. . ProgressBar is added after creating the dataframe object (df):; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ~~~. Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; For example, it can be called at any computational node, such as Filter or Define, not only the head node,; with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; section for appropriate usage in Python): ; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root""",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:80887,Usability,progress bar,progress bars,80887,"tly processed events, the rate of event processing ; and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. . ProgressBar is added after creating the dataframe object (df):; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ~~~. Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; For example, it can be called at any computational node, such as Filter or Define, not only the head node,; with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ; section for appropriate usage in Python): ; ~~~{.cpp}; ROOT::RDataFrame df(""tree"", ""file.root"");; auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ~~~; Examples of implemented progress bars can be seen by running [Higgs to Four Lepton tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html) and [Dimuon tutorial](https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html). . \anchor missing-values; ### Working with missing values in the dataset. In certain situations a dataset might be missing one or more values at one or; more of its entries. For example:. - If the dataset is composed of multiple files and one or more files is; missing one or more columns required by the analysis.; - When joining different datasets horizontally according to some index value; (e.g. the event number), if the index does not find a match in one or more; other datasets for a certain entry. For example, suppose that column ""y"" does not have a value for entry 42:. \code{.unparsed}; +-------+---+---+; | Entry | x | y |; +-------+---+---+; | 42 | 1 | |; +-------+---+---+; \endcode. If the RDataFrame application reads that column, for example if a",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:83248,Usability,clear,clearly,83248,"e as input argument the name of a column of the dataset to watch for; missing values. Like Filter, they will either keep or discard an entire entry; based on whether a condition returns true or false. Specifically:. - FilterAvailable: the condition is whether the value of the column is present.; If so, the entry is kept. Otherwise if the value is missing the entry is; discarded.; - FilterMissing: the condition is whether the value of the column is missing. If; so, the entry is kept. Otherwise if the value is present the entry is; discarded. \code{.py}; df = ROOT.RDataFrame(dataset). # Anytime an entry from ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""). # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the inp",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:83875,Usability,clear,clearly,83875,"g, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""). # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};. // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");. // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; \endcode. #### DefaultValueFor. DefaultValueFor creates a node of the computation graph which just forwards the; values of the columns necessary for other downstream nodes, when they are; available. In case a value of the input column passed to this function is not; available, the node will provide the default value passed to this function call; instead. Example:. \code{.py}; df = ROOT.RDataFrame(dataset); # Anytime an entry from ""col"" is missing, the value will be the default one; default_value = ... # Some sensible default value here; df = df.DefaultValueFor(""col"", default_value) ; df = df.Define(""twice"", ""col * 2""); \endcode. \code{.cpp}; ROOT::RDataFrame df{dataset};; // Anytime an entry from ""col"" is missing, the value will be the default one; constexpr auto default_value = ... // Some sensible default value here; auto df_default = df.De",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:510,Availability,avail,available,510,"////////////////////////////////////////////////////////////////////////////; /// \brief Build the dataframe.; /// \param[in] treeName Name of the tree contained in the directory; /// \param[in] dirPtr TDirectory where the tree is stored, e.g. a TFile.; /// \param[in] defaultColumns Collection of default columns.; ///; /// The default columns are looked at in case no column is specified in the; /// booking of actions or transformations.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:653,Availability,avail,available,653,"////////////////////////////////////////////////////////////////////////////; /// \brief Build the dataframe.; /// \param[in] treeName Name of the tree contained in the directory; /// \param[in] filenameglob TDirectory where the tree is stored, e.g. a TFile.; /// \param[in] defaultColumns Collection of default columns.; ///; /// The filename glob supports the same type of expressions as TChain::Add(), and it is passed as-is to TChain's; /// constructor.; ///; /// The default columns are looked at in case no column is specified in the; /// booking of actions or transformations.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:644,Availability,avail,available,644,"////////////////////////////////////////////////////////////////////////////; /// \brief Build the dataframe.; /// \param[in] treeName Name of the tree contained in the directory; /// \param[in] fileglobs Collection of file names of filename globs; /// \param[in] defaultColumns Collection of default columns.; ///; /// The filename globs support the same type of expressions as TChain::Add(), and each glob is passed as-is; /// to TChain's constructor.; ///; /// The default columns are looked at in case no column is specified in the booking of actions or transformations.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:465,Availability,avail,available,465,"////////////////////////////////////////////////////////////////////////////; /// \brief Build the dataframe.; /// \param[in] tree The tree or chain to be studied.; /// \param[in] defaultColumns Collection of default column names to fall back to when none is specified.; ///; /// The default columns are looked at in case no column is specified in the; /// booking of actions or transformations.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:482,Availability,avail,available,482,"//////////////////////////////////////////////////////////////////////////; /// \brief Build a dataframe that generates numEntries entries.; /// \param[in] numEntries The number of entries to generate.; ///; /// An empty-source dataframe constructed with a number of entries will; /// generate those entries on the fly when some action is triggered,; /// and it will do so for all the previously-defined columns.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:437,Availability,avail,available,437,"//////////////////////////////////////////////////////////////////////////; /// \brief Build dataframe associated to data source.; /// \param[in] ds The data source object.; /// \param[in] defaultColumns Collection of default column names to fall back to when none is specified.; ///; /// A dataframe associated to a data source will query it to access column values.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:346,Security,access,access,346,"//////////////////////////////////////////////////////////////////////////; /// \brief Build dataframe associated to data source.; /// \param[in] ds The data source object.; /// \param[in] defaultColumns Collection of default column names to fall back to when none is specified.; ///; /// A dataframe associated to a data source will query it to access column values.; /// \see ROOT::RDF::RInterface for the documentation of the methods available.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:444,Modifiability,variab,variable,444,"// The loop manager is never null, except when its construction failed.; // This can happen e.g. if the constructor of RLoopManager that expects; // a file name is used and that file doesn't exist. This point is usually; // not even reached in that situation, since the exception thrown by the; // constructor will also stop execution of the program. But it can still; // be reached at the prompt, if the user tries to print the RDataFrame; // variable after an incomplete initialization.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDataFrame.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDefineBase.cxx:3,Availability,redundant,redundant,3,"// redundant (already present in the header), but Windows needs it",MatchSource.CODE_COMMENT,tree/dataframe/src/RDefineBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDefineBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDefineBase.cxx:3,Safety,redund,redundant,3,"// redundant (already present in the header), but Windows needs it",MatchSource.CODE_COMMENT,tree/dataframe/src/RDefineBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDefineBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFActionHelpers.cxx:3,Performance,Cache,CacheLineStep,3,"// CacheLineStep",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFActionHelpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFActionHelpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFActionHelpers.cxx:26,Deployability,update,update,26,"// output file opened in ""update"" mode: must check whether output TTree is already present in file",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFActionHelpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFActionHelpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:273,Availability,avail,available,273,"////////////////////////////////////////////////////////////////////////////; /// \brief Add a new defined column.; /// Registers the pair (columnName, columnReader) with the current RDataFrame,; /// then keeps a reference to the inserted objects to keep track of the; /// available columns for this node. Internally it recreates the collection with; /// the new column, and swaps it with the old one.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:99,Modifiability,variab,variable,99,"// Structured bindings cannot be used in lambda captures (until C++20); // so we explicitly define variable names here",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:3,Performance,Cache,Cache,3,"// Cache column names for this variation and store views for later use",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:320,Integrability,depend,depends,320,"////////////////////////////////////////////////////////////////////////////; /// \brief Get the names of all variations that directly or indirectly affect a given column.; ///; /// This list includes variations applied to the column as well as variations applied to other; /// columns on which the value of this column depends (typically via a Define expression).",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:337,Integrability,depend,depend,337,"////////////////////////////////////////////////////////////////////////////; /// \brief Get the names of all variations that directly or indirectly affect the specified columns.; ///; /// This list includes variations applied to the columns as well as variations applied to other; /// columns on which the value of any of these columns depend (typically via Define expressions).",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:60,Integrability,depend,depend,60,"// For Define'd columns, add the systematic variations they depend on to the set",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:17,Security,validat,validation,17,"// at this point validation of alias and colName has already happened, we trust that; // this is a new, valid alias.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:68,Availability,avail,available,68,"/// Return a RDefineReader or a RVariationReader, or nullptr if not available.; /// If requestedType does not match the actual type of the Define or Variation, an exception is thrown.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:68,Availability,avail,available,68,"/// Return a RDefineReader or a RVariationReader, or nullptr if not available.; /// No type checking is done on the requested reader.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFColumnRegister.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFDisplay.cxx:66,Deployability,update,update,66,"// If the current element is wider than the widest element found, update the width",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFDisplay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFDisplay.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFDisplay.cxx:66,Deployability,update,update,66,"// If the current element is wider than the widest element found, update the width",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFDisplay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFDisplay.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFDisplay.cxx:3,Deployability,Update,Update,3,"// Update the width if this element is the biggest found",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFDisplay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFDisplay.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx:25,Usability,progress bar,progress bar,25,"// Get terminal size for progress bar",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFHelpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx:11,Testability,log,logs,11,"// silence logs from RLoopManager::Jit: RunGraphs does its own logging",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFHelpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx:63,Testability,log,logging,63,"// silence logs from RLoopManager::Jit: RunGraphs does its own logging",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFHelpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx:12,Usability,progress bar,progress bar,12,"/// Print a progress bar of width `ProgressHelper::fBarWidth` if `fGetNEventsOfCurrentFile` is known.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFHelpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHelpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHistoModels.cxx:18,Modifiability,variab,variable,18,"// This histo has variable binning",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFHistoModels.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFHistoModels.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:41,Modifiability,variab,variable,41,"/// The string expression with the dummy variable names in fVarNames in place of the original column names",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:16,Modifiability,variab,variable,16,"/// The list of variable names used in fExpr, with same ordering and size as fUsedCols",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:28,Modifiability,variab,variable,28,"// token is not a potential variable name, skip it",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:128,Modifiability,variab,variable,128,"// when we are done, exprWithVars willl be the same as preProcessedExpr but column names will be substituted with; // the dummy variable names in varNames",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:194,Modifiability,variab,variable,194,"/// Return the static global map of Filter/Define functions that have been jitted.; /// It's used to check whether a given expression has already been jitted, and; /// to look up its associated variable name if it is.; /// Keys in the map are the body of the expression, values are the name of the; /// jitted variable that corresponds to that expression. For example, for:; /// auto f1(){ return 42; }; /// key would be ""(){ return 42; }"" and value would be ""f1"".",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:310,Modifiability,variab,variable,310,"/// Return the static global map of Filter/Define functions that have been jitted.; /// It's used to check whether a given expression has already been jitted, and; /// to look up its associated variable name if it is.; /// Keys in the map are the body of the expression, values are the name of the; /// jitted variable that corresponds to that expression. For example, for:; /// auto f1(){ return 42; }; /// key would be ""(){ return 42; }"" and value would be ""f1"".",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:34,Safety,detect,detect,34,"// pass it by const value to help detect common mistakes such as if(x = 3)",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:27,Safety,avoid,avoid,27,"// We pass by reference to avoid expensive copies; // It can't be const reference in general, as users might want/need to call non-const methods on the values",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:14,Safety,avoid,avoid,14,"// This is to avoid cases where branches called b1, b2, b3 are all matched by expression ""b""",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:279,Availability,avail,available,279,"// else, check if definedColView is in the list of tree branches. This is a bit better than interrogating the TTree; // directly because correct usage of GetBranch, FindBranch, GetLeaf and FindLeaf can be tricky; so let's assume we; // got it right when we collected the list of available branches.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:269,Availability,avail,available,269,"// check if definedCol is in the list of tree branches. This is a bit better than interrogating the TTree; // directly because correct usage of GetBranch, FindBranch, GetLeaf and FindLeaf can be tricky; so let's assume we; // got it right when we collected the list of available branches.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:80,Availability,error,errors,80,"/// Choose between local column names or default column names, throw in case of errors.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:73,Energy Efficiency,allocate,allocated,73,"// remove the last "",; // lifetime of pointees:; // - jittedFilter: heap-allocated weak_ptr to the actual jittedFilter that will be deleted by JitFilterHelper; // - prevNodeOnHeap: heap-allocated shared_ptr to the actual previous node that will be deleted by JitFilterHelper; // - definesOnHeap: heap-allocated, will be deleted by JitFilterHelper",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:186,Energy Efficiency,allocate,allocated,186,"// remove the last "",; // lifetime of pointees:; // - jittedFilter: heap-allocated weak_ptr to the actual jittedFilter that will be deleted by JitFilterHelper; // - prevNodeOnHeap: heap-allocated shared_ptr to the actual previous node that will be deleted by JitFilterHelper; // - definesOnHeap: heap-allocated, will be deleted by JitFilterHelper",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:301,Energy Efficiency,allocate,allocated,301,"// remove the last "",; // lifetime of pointees:; // - jittedFilter: heap-allocated weak_ptr to the actual jittedFilter that will be deleted by JitFilterHelper; // - prevNodeOnHeap: heap-allocated shared_ptr to the actual previous node that will be deleted by JitFilterHelper; // - definesOnHeap: heap-allocated, will be deleted by JitFilterHelper",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:192,Energy Efficiency,allocate,allocated,192,"// remove the last "",; // lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedDefine: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:287,Energy Efficiency,allocate,allocated,287,"// remove the last "",; // lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedDefine: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:169,Energy Efficiency,allocate,allocated,169,"// lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedDefine: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:264,Energy Efficiency,allocate,allocated,264,"// lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedDefine: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:3,Safety,Avoid,Avoid,3,"// Avoid leak",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:275,Energy Efficiency,allocate,allocated,275,"// build invocation to JitVariationHelper; // arrays of strings are passed as const char** plus size.; // lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedVariation: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:370,Energy Efficiency,allocate,allocated,370,"// build invocation to JitVariationHelper; // arrays of strings are passed as const char** plus size.; // lifetime of pointees:; // - lm is the loop manager, and if that goes out of scope jitting does not happen at all (i.e. will always be valid); // - jittedVariation: heap-allocated weak_ptr that will be deleted by JitDefineHelper after usage; // - definesAddr: heap-allocated, will be deleted by JitDefineHelper after usage",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:64,Availability,error,error,64,"// Some columns are still unknown, we need to understand if the error; // should be printed or if the user requested to explicitly disable it.; // Look for a possible overlap between the unknown columns and the; // columns we should ignore for the purpose of the following exception",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:83,Modifiability,variab,variable-sized,83,"/// Return copies of colsWithoutAliases and colsWithAliases with size branches for variable-sized array branches added; /// in the right positions (i.e. before the array branches that need them).",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:24,Modifiability,variab,variable-sized,24,"// this branch is not a variable-sized array, nothing to do",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:9,Modifiability,variab,variable-sized,9,"// not a variable-sized array or the size branch is already there, nothing to do; // otherwise we must insert the size in colsWithoutAliases _and_ colsWithAliases",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFInterfaceUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:103,Availability,failure,failure,103,"/// Returns the name of a type starting from its type_info; /// An empty string is returned in case of failure; /// References and pointers are not supported since those cannot be stored in; /// columns.; /// Note that this function will take a lock and may be a potential source of; /// contention in multithreaded execution.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:13,Modifiability,variab,variable-sized,13,"// this is a variable-sized array",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:64,Modifiability,variab,variable,64,"// this is a fixed-sized array (we do not differentiate between variable- and fixed-sized arrays)",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:178,Modifiability,variab,variable,178,"/// Return the typename of object colName stored in t, if any. Return an empty string if colName is not in t.; /// Supported cases:; /// - leaves corresponding to single values, variable- and fixed-length arrays, with following syntax:; /// - ""leafname"", as long as TTree::GetLeaf resolves it; /// - ""b1.b2...leafname"", as long as TTree::GetLeaf(""b1.b2...."", ""leafname"") resolves it; /// - TBranchElements, as long as TTree::GetBranch resolves their names",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:213,Modifiability,variab,variable-sized,213,"/// Return a string containing the type of the given branch. Works both with real TTree branches and with temporary; /// column created by Define. Throws if type name deduction fails.; /// Note that for fixed- or variable-sized c-style arrays the returned type name will be RVec<T>.; /// vector2RVec specifies whether typename 'std::vector<T>' should be converted to 'RVec<T>' or returned as is",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:88,Integrability,message,message,88,"/// Replace occurrences of '.' with '_' in each string passed as argument.; /// An Info message is printed when this happens. Dots at the end of the string are not replaced.; /// An exception is thrown in case the resulting set of strings would contain duplicates.",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:21,Availability,error,errors,21,"// storage for cling errors",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:45,Safety,avoid,avoid,45,"// Call Calc every 1000 newlines in order to avoid jitting a very large function body, which is slow:; // see https://github.com/root-project/root/issues/9312 and https://github.com/root-project/root/issues/7604",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:137,Availability,avail,available,137,"// TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; // but that is unfortunately not usable outside the already available ROOT mutexes",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:38,Deployability,upgrade,upgrade,38,"// TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; // but that is unfortunately not usable outside the already available ROOT mutexes",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:110,Usability,usab,usable,110,"// TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; // but that is unfortunately not usable outside the already available ROOT mutexes",MatchSource.CODE_COMMENT,tree/dataframe/src/RDFUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:115,Availability,avail,available,115,"/////////////////////////////////////////////////////////////////////////////; /// \brief Returns the names of the available columns.; /// \return the container of column names.; ///; /// This is not an action nor a transformation, just a query to the RDataFrame object.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto colNames = d.GetColumnNames();; /// // Print columns' names; /// for (auto &&colName : colNames) std::cout << colName << std::endl;; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/src/RInterfaceBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:688,Integrability,depend,dependent,688,"/////////////////////////////////////////////////////////////////////////////; /// \brief Return information about the dataframe.; /// \return information about the dataframe as RDFDescription object; ///; /// This convenience function describes the dataframe and combines the following information:; /// - Number of event loops run, see GetNRuns(); /// - Number of total and defined columns, see GetColumnNames() and GetDefinedColumnNames(); /// - Column names, see GetColumnNames(); /// - Column types, see GetColumnType(); /// - Number of processing slots, see GetNSlots(); ///; /// This is not an action nor a transformation, just a query to the RDataFrame object.; /// The result is dependent on the node from which this method is called, e.g. the list of; /// defined columns returned by GetDefinedColumnNames().; ///; /// Please note that this is a convenience feature and the layout of the output can be subject; /// to change and should be parsed via RDFDescription methods.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// RDataFrame df(10);; /// auto df2 = df.Define(""x"", ""1.f"").Define(""s"", ""\""myStr\"""");; /// // Describe the dataframe; /// df2.Describe().Print(); /// df2.Describe().Print(/*shortFormat=*/true); /// std::cout << df2.Describe().AsString() << std::endl;; /// std::cout << df2.Describe().AsString(/*shortFormat=*/true) << std::endl;; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/src/RInterfaceBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:100,Energy Efficiency,efficient,efficiently,100,"// Build set of defined column names to find later in all column names; // the defined columns more efficiently",MatchSource.CODE_COMMENT,tree/dataframe/src/RInterfaceBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:170,Usability,simpl,simple,170,"/// \brief Returns the names of the defined columns.; /// \return the container of the defined column names.; ///; /// This is not an action nor a transformation, just a simple utility to; /// get the columns names that have been defined up to the node.; /// If no column has been defined, e.g. on a root node, it returns an; /// empty collection.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto defColNames = d.GetDefinedColumnNames();; /// // Print defined columns' names; /// for (auto &&defColName : defColNames) std::cout << defColName << std::endl;; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/src/RInterfaceBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:174,Usability,simpl,simple,174,"/// \brief Return a descriptor for the systematic variations registered in this branch of the computation graph.; ///; /// This is not an action nor a transformation, just a simple utility to; /// inspect the systematic variations that have been registered with Vary() up to this node.; /// When called on the root node, it returns an empty descriptor.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// auto variations = d.GetVariations();; /// variations.Print();; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/dataframe/src/RInterfaceBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx:92,Availability,avail,available,92,"/// \brief Checks if a column is present in the dataset.; /// \return true if the column is available, false otherwise; ///; /// This method checks if a column is part of the input ROOT dataset, has; /// been defined or can be provided by the data source.; ///; /// Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame base(1);; /// auto rdf = base.Define(""definedColumn"", [](){return 0;});; /// rdf.HasColumn(""definedColumn""); // true: we defined it; /// rdf.HasColumn(""rdfentry_""); // true: it's always there; /// rdf.HasColumn(""foo""); // false: it is not there; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/src/RInterfaceBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RInterfaceBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx:9,Availability,error,error,9,"// Avoid error: invalid application of ‘sizeof’ to incomplete type in RJittedAction::GetMergeableValue",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedAction.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx:3,Safety,Avoid,Avoid,3,"// Avoid error: invalid application of ‘sizeof’ to incomplete type in RJittedAction::GetMergeableValue",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedAction.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx:16,Integrability,wrap,wrapper,16,/**; Retrieve a wrapper to the result of the action that knows how to merge; with others of the same type.; */,MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedAction.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:783,Availability,redundant,redundant,783,"// Jitted nodes of the computation graph (e.g. RJittedAction, RJittedDefine) usually don't need to register; // themselves with the RLoopManager: the _concrete_ nodes will be registered with the RLoopManager right before; // the event loop, at jitting time, and that is good enough.; // RJittedFilter is an exception: RLoopManager needs to know about what filters have been booked even before; // the event loop in order to return a correct list from RLoopManager::GetFiltersNames().; // So RJittedFilters register themselves with RLoopManager at construction time and deregister themselves; // in SetFilter, i.e. when they are sure that the concrete filter has been instantiated in jitted code and it has; // been registered with RLoopManager, making the RJittedFilter registration redundant.",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedFilter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:783,Safety,redund,redundant,783,"// Jitted nodes of the computation graph (e.g. RJittedAction, RJittedDefine) usually don't need to register; // themselves with the RLoopManager: the _concrete_ nodes will be registered with the RLoopManager right before; // the event loop, at jitting time, and that is good enough.; // RJittedFilter is an exception: RLoopManager needs to know about what filters have been booked even before; // the event loop in order to return a correct list from RLoopManager::GetFiltersNames().; // So RJittedFilters register themselves with RLoopManager at construction time and deregister themselves; // in SetFilter, i.e. when they are sure that the concrete filter has been instantiated in jitted code and it has; // been registered with RLoopManager, making the RJittedFilter registration redundant.",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedFilter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:298,Testability,log,logic,298,"// This should be a no-op in most sane cases: the RJittedFilter should already have been deregistered in SetFilter.; // However, in the edge case in which the branch of the computation graph that included this RJittedFilter went out; // of scope before any event loop ran (e.g. because of bad code logic or a user that changed their mind during; // interactive usage), we need to make sure RJittedFilters get properly deregistered.",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedFilter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:17,Performance,perform,performed,17,"// No event loop performed yet, but the JITTING must be performed.",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedFilter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:56,Performance,perform,performed,56,"// No event loop performed yet, but the JITTING must be performed.",MatchSource.CODE_COMMENT,tree/dataframe/src/RJittedFilter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:66,Energy Efficiency,schedul,scheduled,66,"/// A helper function that returns all RDF code that is currently scheduled for just-in-time compilation.; /// This allows different RLoopManager instances to share these data.; /// We want RLoopManagers to be able to add their code to a global ""code to execute via cling"",; /// so that, lazily, we can jit everything that's needed by all RDFs in one go, which is potentially; /// much faster than jitting each RLoopManager's code separately.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:185,Safety,avoid,avoid,185,"// Getting the branches here triggered the read of the first file of the chain if t is a chain.; // We check if a tree has been successfully read, otherwise we throw (see ROOT-9984) to avoid further; // operations",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:173,Availability,recover,recover,173,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not via GetListOfFriends() directly), otherwise when `t` is a TChain we; // might not recover the list correctly (https://github.com/root-project/root/issues/6741).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:173,Safety,recover,recover,173,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not via GetListOfFriends() directly), otherwise when `t` is a TChain we; // might not recover the list correctly (https://github.com/root-project/root/issues/6741).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:35,Security,access,accessed,35,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not via GetListOfFriends() directly), otherwise when `t` is a TChain we; // might not recover the list correctly (https://github.com/root-project/root/issues/6741).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:151,Security,expose,exposed,151,"// ...but instead we use `<filename>/<treename>` as a sample ID (cannot; // change this easily because of backward compatibility: the sample ID; // is exposed to users via RSampleInfo and DefinePerSample).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:3,Availability,Error,Error,3,"// Error might throw in experiment frameworks like CMSSW",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:518,Safety,abort,aborted,518,"/// Return true on succesful entry read.; ///; /// TTreeReader encodes successful reads in the `kEntryValid` enum value, but; /// there can be other situations where the read is still valid. For now, these; /// are:; /// - If there was no match of the current entry in one or more friend trees; /// according to their respective indexes.; /// - If there was a missing branch at the start of a new tree in the dataset.; ///; /// In such situations, although the entry is not complete, the processing; /// should not be aborted and nodes of the computation graph will take action; /// accordingly.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:114,Performance,multi-thread,multi-thread,114,"// fNStopsReceived < fNChildren is always true at the moment as we don't support event loop early quitting in; // multi-thread runs, but it costs nothing to be safe and future-proof in case we add support for that later.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:160,Safety,safe,safe,160,"// fNStopsReceived < fNChildren is always true at the moment as we don't support event loop early quitting in; // multi-thread runs, but it costs nothing to be safe and future-proof in case we add support for that later.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:130,Availability,error,error,130,"// Apply the range if there is any; // In case of a chain with a total of N entries, calling SetEntriesRange(N + 1, ...) does not error out; // This is a bug, reported here: https://github.com/root-project/root/issues/10774",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:29,Security,access,accessed,29,"/// Run event loop over data accessed through a DataSource, in sequence.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:29,Security,access,accessed,29,"/// Run event loop over data accessed through a DataSource, in parallel.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:130,Testability,log,logic,130,"/// Execute actions and make sure named filters are called for each event.; /// Named filters must be called even if the analysis logic would not require it, lest they report confusing results.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:182,Performance,load,loaded,182,"// Whatever the data source, initially set the ""new data block"" flag:; // - for TChains, this ensures that we don't skip the first data block because; // the correct tree is already loaded; // - for RDataSources and empty sources, which currently don't have data blocks, this; // ensures that we run once per task",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:191,Integrability,depend,depend,191,"/// Initialize all nodes of the functional graph before running the event loop.; /// This method is called once per event-loop and performs generic initialization; /// operations that do not depend on the specific processing slot (i.e. operations; /// that are common for all threads).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:131,Performance,perform,performs,131,"/// Initialize all nodes of the functional graph before running the event loop.; /// This method is called once per event-loop and performs generic initialization; /// operations that do not depend on the specific processing slot (i.e. operations; /// that are common for all threads).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:4,Performance,Perform,Perform,4,"/// Perform clean-up operations. To be called at the end of each event loop.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:4,Performance,Perform,Perform,4,"/// Perform clean-up operations. To be called at the end of each task execution.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:104,Usability,clear,clears,104,"/// Add RDF nodes that require just-in-time compilation to the computation graph.; /// This method also clears the contents of GetCodeToJit().",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:52,Integrability,depend,depending,52,"/// Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.; /// Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...).; /// The jitting phase is skipped if the `jit` parameter is `false` (unsafe, use with care).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:115,Performance,perform,perform,115,"/// Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.; /// Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...).; /// The jitting phase is skipped if the `jit` parameter is `false` (unsafe, use with care).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:296,Safety,unsafe,unsafe,296,"/// Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.; /// Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...).; /// The jitting phase is skipped if the `jit` parameter is `false` (unsafe, use with care).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:186,Usability,clear,clear,186,"/// Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.; /// Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...).; /// The jitting phase is skipped if the `jit` parameter is `false` (unsafe, use with care).",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:89,Performance,concurren,concurrently,89,"// Differently from AddDataSourceColumnReaders, this can be called from multiple threads concurrently; /// \brief Register a new RTreeColumnReader with this RLoopManager.; /// \return A shared pointer to the inserted column reader.",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:3,Safety,Avoid,Avoid,3,"// Avoid changing gDirectory;",MatchSource.CODE_COMMENT,tree/dataframe/src/RLoopManager.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx:70,Availability,error,error,70,"/// @brief Return the metadata value of type int given the key, or an error if the metadata value is of a non-int type.; /// @param[in] key input key for a given RMetaData instance.",MatchSource.CODE_COMMENT,tree/dataframe/src/RMetaData.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx:73,Availability,error,error,73,"/// @brief Return the metadata value of type double given the key, or an error if the metadata value is of a non-double; /// type.; /// @param[in] key input key for a given RMetaData instance.",MatchSource.CODE_COMMENT,tree/dataframe/src/RMetaData.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx:73,Availability,error,error,73,"/// @brief Return the metadata value of type string given the key, or an error if the metadata value is of a non-string; /// type.; /// @param[in] key input key for a given RMetaData instance.",MatchSource.CODE_COMMENT,tree/dataframe/src/RMetaData.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx:129,Availability,error,error,129,"/// @brief Return the metadata value of type int given the key, a default int metadata value if the key is not found, or; /// an error if the metadata value is of a non-int type.; /// @param[in] key input key for a given RMetaData instance.; /// @param[in] defaultVal metadata value of type int which is read as default while a given key cannot be found in the; /// dataset.",MatchSource.CODE_COMMENT,tree/dataframe/src/RMetaData.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx:129,Availability,error,error,129,"/// @brief Return the metadata value of type int given the key, a default int metadata value if the key is not found, or; /// an error if the metadata value is of a non-double type.; /// @param[in] key input key for a given RMetaData instance.; /// @param[in] defaultVal metadata value of type double which is read as default while a given key cannot be found in; /// the dataset.",MatchSource.CODE_COMMENT,tree/dataframe/src/RMetaData.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx:129,Availability,error,error,129,"/// @brief Return the metadata value of type int given the key, a default int metadata value if the key is not found, or; /// an error if the metadata value is of a non-string type.; /// @param[in] key input key for a given RMetaData instance.; /// @param[in] defaultVal metadata value of type string which is read as default while a given key cannot be found in; /// the dataset.",MatchSource.CODE_COMMENT,tree/dataframe/src/RMetaData.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RMetaData.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:283,Usability,Feedback,Feedback,283,"/// \file RNTupleDS.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Enrico Guiraud <enrico.guiraud@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:359,Availability,avail,available,359,"// clang-format off; /**; * \class ROOT::Experimental::RNTupleDS; * \ingroup dataframe; * \brief The RDataSource implementation for RNTuple. It lets RDataFrame read RNTuple data.; *; * An RDataFrame that reads RNTuple data can be constructed using FromRNTuple().; *; * For each column containing an array or a collection, a corresponding column `#colname` is available to access; * `colname.size()` without reading and deserializing the collection values.; *; **/; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:372,Security,access,access,372,"// clang-format off; /**; * \class ROOT::Experimental::RNTupleDS; * \ingroup dataframe; * \brief The RDataSource implementation for RNTuple. It lets RDataFrame read RNTuple data.; *; * An RDataFrame that reads RNTuple data can be constructed using FromRNTuple().; *; * For each column containing an array or a collection, a corresponding column `#colname` is available to access; * `colname.size()` without reading and deserializing the collection values.; *; **/; // clang-format on",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:358,Security,expose,exposes,358,"/// An artificial field that transforms an RNTuple column that contains the offset of collections into; /// collection sizes. It is used to provide the ""number of"" RDF columns for collections, e.g.; /// `R_rdf_sizeof_jets` for a collection named `jets`.; ///; /// This field owns the collection offset field but instead of exposing the collection offsets it exposes; /// the collection sizes (offset(N+1) - offset(N)). For the time being, we offer this functionality only in RDataFrame.; /// TODO(jblomer): consider providing a general set of useful virtual fields as part of RNTuple.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:58,Testability,log,logical,58,"///< Last entry number that was read; /// For chains, the logical entry and the physical entry in any particular file can be different.; /// The entry offset stores the logical entry number (sum of all previous physical entries) when a file of the corresponding; /// data source was opened.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:169,Testability,log,logical,169,"///< Last entry number that was read; /// For chains, the logical entry and the physical entry in any particular file can be different.; /// The entry offset stores the logical entry number (sum of all previous physical entries) when a file of the corresponding; /// data source was opened.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:566,Availability,down,down,566,"// As an example for the mapping of RNTuple fields to RDF columns, let's consider an RNTuple; // using the following types and with a top-level field named ""event"" of type Event:; //; // struct Event {; // int id;; // std::vector<Track> tracks;; // };; // struct Track {; // std::vector<Hit> hits;; // };; // struct Hit {; // float x;; // float y;; // };; //; // AddField() will be called from the constructor with the RNTuple root field (ENTupleStructure::kRecord).; // From there, we recurse into the ""event"" sub field (also ENTupleStructure::kRecord) and further down the; // tree of sub fields and expose the following RDF columns:; //; // ""event"" [Event]; // ""event.id"" [int]; // ""event.tracks"" [RVec<Track>]; // ""R_rdf_sizeof_event.tracks"" [unsigned int]; // ""event.tracks.hits"" [RVec<RVec<Hit>>]; // ""R_rdf_sizeof_event.tracks.hits"" [RVec<unsigned int>]; // ""event.tracks.hits.x"" [RVec<RVec<float>>]; // ""R_rdf_sizeof_event.tracks.hits.x"" [RVec<unsigned int>]; // ""event.tracks.hits.y"" [RVec<RVec<float>>]; // ""R_rdf_sizeof_event.tracks.hits.y"" [RVec<unsigned int>]",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:602,Security,expose,expose,602,"// As an example for the mapping of RNTuple fields to RDF columns, let's consider an RNTuple; // using the following types and with a top-level field named ""event"" of type Event:; //; // struct Event {; // int id;; // std::vector<Track> tracks;; // };; // struct Track {; // std::vector<Hit> hits;; // };; // struct Hit {; // float x;; // float y;; // };; //; // AddField() will be called from the constructor with the RNTuple root field (ENTupleStructure::kRecord).; // From there, we recurse into the ""event"" sub field (also ENTupleStructure::kRecord) and further down the; // tree of sub fields and expose the following RDF columns:; //; // ""event"" [Event]; // ""event.id"" [int]; // ""event.tracks"" [RVec<Track>]; // ""R_rdf_sizeof_event.tracks"" [unsigned int]; // ""event.tracks.hits"" [RVec<RVec<Hit>>]; // ""R_rdf_sizeof_event.tracks.hits"" [RVec<unsigned int>]; // ""event.tracks.hits.x"" [RVec<RVec<float>>]; // ""R_rdf_sizeof_event.tracks.hits.x"" [RVec<unsigned int>]; // ""event.tracks.hits.y"" [RVec<RVec<float>>]; // ""R_rdf_sizeof_event.tracks.hits.y"" [RVec<unsigned int>]",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:26,Testability,log,logic,26,"// Fixed-size array, same logic as ROOT::RVec.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:76,Performance,load,loaded,76,"// The fieldID could be the root field or the class of fieldId might not be loaded.; // In these cases, only the inner fields are exposed as RDF columns.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:130,Security,expose,exposed,130,"// The fieldID could be the root field or the class of fieldId might not be loaded.; // In these cases, only the inner fields are exposed as RDF columns.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:162,Deployability,configurat,configuration,162,"// The setting is for now a global one, must be decided before running the; // program by setting the appropriate environment variable. Make sure that; // option configuration is thread-safe and happens only once.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:126,Modifiability,variab,variable,126,"// The setting is for now a global one, must be decided before running the; // program by setting the appropriate environment variable. Make sure that; // option configuration is thread-safe and happens only once.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:162,Modifiability,config,configuration,162,"// The setting is for now a global one, must be decided before running the; // program by setting the appropriate environment variable. Make sure that; // option configuration is thread-safe and happens only once.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:186,Safety,safe,safe,186,"// The setting is for now a global one, must be decided before running the; // program by setting the appropriate environment variable. Make sure that; // option configuration is thread-safe and happens only once.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:13,Energy Efficiency,schedul,scheduling,13,"// Easy work scheduling: one file per slot. We skip empty files (files without entries).",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:8,Energy Efficiency,schedul,scheduling,8,"// Work scheduling of the tail: multiple slots work on the same file.; // Every slot still has its own page source but these page sources may open the same file.; // Again, we need to skip empty files.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:54,Performance,multi-thread,multi-threaded,54,"// We need to distinguish between single threaded and multi-threaded runs.; // In single threaded mode, InitSlot is only called once and column readers have to be rewired; // to new page sources of the chain in GetEntryRanges. In multi-threaded mode, on the other hand,; // InitSlot is called for every returned range, thus rewiring the column readers takes place in; // InitSlot and FinalizeSlot.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:230,Performance,multi-thread,multi-threaded,230,"// We need to distinguish between single threaded and multi-threaded runs.; // In single threaded mode, InitSlot is only called once and column readers have to be rewired; // to new page sources of the chain in GetEntryRanges. In multi-threaded mode, on the other hand,; // InitSlot is called for every returned range, thus rewiring the column readers takes place in; // InitSlot and FinalizeSlot.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:132,Performance,load,loading,132,"// If we have fewer files than slots and we run multiple event loops, we can reuse fCurrentRanges and don't need; // to worry about loading the fNextRanges. I.e., in this case we don't enter the if block.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:111,Safety,detect,detect,111,"// Several consecutive ranges may operate on the same file (each with their own page source clone).; // We can detect a change of file when the first entry number jumps back to 0.",MatchSource.CODE_COMMENT,tree/dataframe/src/RNTupleDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx:35,Integrability,rout,routine,35,"// TODO: we need to factor out the routine for the branch alone...; // Maybe a cache for the names?",MatchSource.CODE_COMMENT,tree/dataframe/src/RRootDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx:79,Performance,cache,cache,79,"// TODO: we need to factor out the routine for the branch alone...; // Maybe a cache for the names?",MatchSource.CODE_COMMENT,tree/dataframe/src/RRootDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx:23,Performance,load,loaded,23,"// We may not have yet loaded the library where the dictionary of this type is",MatchSource.CODE_COMMENT,tree/dataframe/src/RRootDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx:3,Safety,avoid,avoid,3,"// avoid constructing and destructing the helper TChain here if we don't need to",MatchSource.CODE_COMMENT,tree/dataframe/src/RSample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx:92,Security,access,access,92,"/// @brief Get an instance of the RMetaData class.; ///; /// Once this is done, the further access to the RMetaData information is granted, for example; /// (given the metadata has a key ""sample_name"" that has an associated value of type string):; /// ~~~{.cpp}; /// mySample.GetMetadata().GetS(""sample_name"");; /// ~~~",MatchSource.CODE_COMMENT,tree/dataframe/src/RSample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:491,Availability,avail,available,491,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:281,Integrability,interface,interface,281,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:30,Security,access,access,30,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:167,Security,access,access,167,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:825,Security,access,access,825,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:848,Security,access,access,848,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:276,Modifiability,inherit,inheritance,276,"////////////////////////////////////////////////////////////////////////////; /// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); /// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; /// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; /// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; /// type VfsRootFile.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:366,Modifiability,extend,extended,366,"////////////////////////////////////////////////////////////////////////////; /// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); /// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; /// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; /// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; /// type VfsRootFile.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:159,Deployability,Release,Releases,159,"// The following callbacks implement the I/O operations of an open database; ////////////////////////////////////////////////////////////////////////////; /// Releases the resources associated to a file opened with davix",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:166,Availability,error,error,166,"////////////////////////////////////////////////////////////////////////////; /// We do not write to a database in the RDataSource and therefore can simply return an error for this callback",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:149,Usability,simpl,simply,149,"////////////////////////////////////////////////////////////////////////////; /// We do not write to a database in the RDataSource and therefore can simply return an error for this callback",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:166,Availability,error,error,166,"////////////////////////////////////////////////////////////////////////////; /// We do not write to a database in the RDataSource and therefore can simply return an error for this callback",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:149,Usability,simpl,simply,149,"////////////////////////////////////////////////////////////////////////////; /// We do not write to a database in the RDataSource and therefore can simply return an error for this callback",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:94,Performance,cache,cached,94,"////////////////////////////////////////////////////////////////////////////; /// Returns the cached file size",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:122,Performance,concurren,concurrent,122,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:133,Security,access,access,133,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:122,Performance,concurren,concurrent,122,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:133,Security,access,access,133,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:122,Performance,concurren,concurrent,122,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:133,Security,access,access,133,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:58,Energy Efficiency,allocate,allocated,58,"// Storage for the VfsRootFile structure has been already allocated by sqlite, so we use placement new",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:166,Testability,log,logic,166,"// The following callbacks implement operating system specific functionality. In contrast to the previous callbacks,; // there is no need to implement any customized logic for the following ones. An implementation has to be; // provided nevertheless to have a fully functional VFS module.; ////////////////////////////////////////////////////////////////////////////; /// This VFS module cannot remove files",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:82,Security,Access,Access,82,"////////////////////////////////////////////////////////////////////////////; /// Access control always allows read-only access to databases",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:121,Security,access,access,121,"////////////////////////////////////////////////////////////////////////////; /// Access control always allows read-only access to databases",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:120,Integrability,wrap,wrapper,120,"////////////////////////////////////////////////////////////////////////////; /// Use ROOT's platform independent sleep wrapper",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:82,Integrability,Wrap,Wrapper,82,"////////////////////////////////////////////////////////////////////////////; /// Wrapper around VfsRdOnlyCurrentTimeInt64",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:65,Integrability,Depend,Depending,65,"// Certain complex queries trigger creation of temporary tables. Depending on the build options of sqlite,; // sqlite may try to store such temporary tables on disk, using our custom VFS module to do so.; // Creation of new database files, however, is not supported by the custom VFS module. Thus we set the behavior; // of the database connection to ""temp_store=2"", meaning that temporary tables should always be maintained; // in memory.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:32,Availability,error,error,32,"// sqlite3_finalize returns the error code of the most recent operation on fQuery.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:143,Performance,cache,cached,143,"////////////////////////////////////////////////////////////////////////////; /// Returns the SELECT queries names. The column names have been cached in the constructor.; /// For expressions, the column name is the string of the expression unless the query defines a column name with as; /// like in ""SELECT 1 + 1 as mycolumn FROM table""",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:133,Availability,avail,available,133,"////////////////////////////////////////////////////////////////////////////; /// Returns a range of size 1 as long as more rows are available in the SQL result set.; /// This inherently serialized the RDF independent of the number of slots.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:141,Energy Efficiency,reduce,reduce,141,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:178,Integrability,synchroniz,synchronization,178,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:152,Performance,perform,performance,152,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:167,Availability,error,error,167,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:186,Availability,error,error,186,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.",MatchSource.CODE_COMMENT,tree/dataframe/src/RSqliteDS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RVariationBase.cxx:3,Performance,Cache,CacheLineStep,3,"// CacheLineStep",MatchSource.CODE_COMMENT,tree/dataframe/src/RVariationBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RVariationBase.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:106,Performance,Cache,Cache,106,"// This test verifies that the correct method is called and there is no ambiguity between the JIT call to Cache using; // a column list as a parameter and the JIT call to Cache using the Regexp.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:171,Performance,Cache,Cache,171,"// This test verifies that the correct method is called and there is no ambiguity between the JIT call to Cache using; // a column list as a parameter and the JIT call to Cache using the Regexp.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:8,Testability,test,test,8,"// This test verifies that the correct method is called and there is no ambiguity between the JIT call to Cache using; // a column list as a parameter and the JIT call to Cache using the Regexp.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:182,Performance,cache,cache,182,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:476,Performance,cache,cache,476,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:517,Performance,Cache,Cache,517,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:586,Performance,cache,cached,586,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:639,Performance,Cache,Cache,639,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:840,Performance,cache,cached,840,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:512,Testability,TEST,TEST,512,"/*; // The contiguity has been dropped since now caching is backed up by a TDS; // TODO: we can optimise this. The reason why addresses are not contiguous with; // data sources (now cache is achieved with a data source) is linked to Snapshot.; // Indeed we need to set an address for each branch and keep that constant; // through the entire event loop (this is how the TTree works!).; // We could remove this constraint from data sources if Snapshot offered some; // sort of cache to which the data is copied.; TEST(Cache, Contiguity); {; ROOT::RDataFrame tdf(2);; auto f = 0.f;; auto cached = tdf.Define(""float"", [&f]() { return f++; }).Cache<float>({""float""});; int counter = 0;; float *fPrec = nullptr;; auto count = [&counter, &fPrec](float &ff) {; if (1 == counter++) {; EXPECT_EQ(1, std::distance(fPrec, &ff));; }; fPrec = &ff;; };; cached.Foreach(count, {""float""});; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:22,Performance,cache,cached,22,"// Broken - caching a cached tdf destroys the cache of the cached.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:46,Performance,cache,cache,46,"// Broken - caching a cached tdf destroys the cache of the cached.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx:59,Performance,cache,cached,59,"// Broken - caching a cached tdf destroys the cache of the cached.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.py:364,Testability,test,test,364,"# Necessary because in the new Cppyy if we want to instantiate; # a templated method with a type written as a string (e.g. 'float'); # we need to pass it in square brackets, otherwise it can be; # (mis)interpreted as string parameter and the method itself is; # called with 'float' as a parameter.; # For example the Take() method mentioned multiple times in this test; # has to be called e.g. with:; # Take['float'](); # instead of:; # Take('float')()",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cache.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cache.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:11,Testability,TEST,TESTS,11,/********* TESTS *********/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_callbacks.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce + OnPartialResult",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_callbacks.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:3,Testability,Test,Test,3,"// Test that callbacks are executed in the order they are registered",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_callbacks.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:10,Performance,Multi-thread,Multi-thread,10,/******** Multi-thread tests **********/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_callbacks.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:23,Testability,test,tests,23,/******** Multi-thread tests **********/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_callbacks.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx:3,Integrability,depend,depending,3,"// depending on how tasks are dispatched to worker threads and how quickly threads push and pop slot numbers from; // TSlotStack, the callback might be executed 1 to nSlots times.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_callbacks.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_callbacks.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:3,Security,Access,AccessPathName,3,"// AccessPathName",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:31,Usability,usab,usable,31,"// Check the Snapshot clone is usable",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:30,Availability,error,error,30,"// The next line triggered an error due to a previous faulty implementation; // that was not connecting the cloned varied action to the correct upstream; // varied filters. In particular, this lambda should be run after the `Filter`; // above, which checks that the number of jets that passes the `jet_pt_mask`; // is at least 4.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:54,Availability,fault,faulty,54,"// The next line triggered an error due to a previous faulty implementation; // that was not connecting the cloned varied action to the correct upstream; // varied filters. In particular, this lambda should be run after the `Filter`; // above, which checks that the number of jets that passes the `jet_pt_mask`; // is at least 4.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:800,Availability,down,downstream,800,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:919,Availability,error,error,919,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:182,Integrability,depend,depending,182,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:234,Integrability,depend,depends,234,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:11,Testability,test,test,11,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:68,Testability,log,logic,68,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:266,Testability,log,logic,266,"/*; * This test reproduces a particular issue happening in analysis logic; * including both systematic variations and filters, with the order; *; * 1. Some call to Vary; * 2. Filter depending on the first Vary; * 3. Another Vary that depends on the Filter; *; * The logic that reproduces the problem is shown in the above function; * `dataframe_cloning_vary_with_filters_analysis`. In particular, the; * lambda used in the Vary call (3) calls ROOT::VecOps::Take(vec, 4),; * thus only works if `vec` has at least size `4`.; *; * In a previous implementation of cloning `RVariedAction`, the cloned action; * was connected to the wrong upstream filter (in fact, it was using a varied; * filter from the original action as if it was the nominal filter). This would; * then pass to the lambda used in the downstream Vary call (3) a vector; * `jet_pt` from which only 3 entries pass `jet_pt_mask`, eventually producing; * an error when reaching the `Take(jet_pt[jet_pt_mask], 4)` call.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx:244,Testability,log,logically,244,"// The first specification takes the first two files and reads them both from beginning to end.; // The second specification takes the second and third file, but only reads the third one.; // This simulates two tasks that might be created when logically splitting the input dataset.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_cloning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_cloning.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_compgraph.cxx:36,Testability,Test,Testing,36,"R""(; namespace ROOT::Internal::RDF::Testing{; int myInt{42};; }; )""",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_compgraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_compgraph.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_compgraph.cxx:24,Integrability,interface,interface,24,"// no-op to comply with interface for RInterface::Fill",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_compgraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_compgraph.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx:94,Performance,cache,cached,94,"// first Take triggers the computation of i, then the Filter executes, then Take accesses the cached value of i; // hopefully it won't have changed in the meanwhile!",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_concurrency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx:81,Security,access,accesses,81,"// first Take triggers the computation of i, then the Filter executes, then Take accesses the cached value of i; // hopefully it won't have changed in the meanwhile!",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_concurrency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx:85,Testability,test,test,85,"// Because a parallel snapshot does not preserve ordering of the events, we can just test; // an aggregate such as the sum of all values.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_concurrency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx:87,Performance,cache,cache,87,"// Run the RDF construction and the event loop in parallel; // and use an intermediate cache in the computation graph",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_concurrency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:3,Testability,test,testing,3,"// testing each single tree with hard-coded file names",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:76,Testability,test,testing,76,"// second AddSample overload: 1 tree, many files; files passed as a vector; testing with 1 specTestFile",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:863,Availability,error,error,863,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:938,Availability,error,error,938,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:1009,Availability,error,error,1009,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:1070,Availability,error,error,1070,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:391,Performance,optimiz,optimization,391,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:727,Safety,sanity check,sanity checks,727,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:819,Safety,sanity check,sanity checks,819,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:231,Testability,test,tested,231,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:300,Testability,test,test,300,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:27,Testability,log,logically,27,"// the first 6 ranges, are logically correct",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:12,Availability,error,error,12,"// MT case, error coming from the TTreeProcessorMT",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:3,Availability,error,error,3,"// error coming from the RLoopManager",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:3,Testability,Test,Test,3,"// Test the canonical case: main tree and friend trees have all equal size.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:3,Testability,Test,Test,3,"// Test the case where there are still entries in the friend trees after; // processing of the main tree finishes. This should issue a warning",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:3,Testability,Test,Test,3,"// Test the case where the friend trees are shorter than the main one.; // This should throw an exception.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:9,Modifiability,Enhance,Enhance,9,"// TODO: Enhance how TChains with no names are showed by SaveGraph (and Describe); // see: https://github.com/root-project/root/issues/10928",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:29,Testability,test,tests,29,"// instantiate single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:15,Performance,multi-thread,multi-thread,15,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:28,Testability,test,tests,28,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py:364,Testability,test,test,364,"# Necessary because in the new Cppyy if we want to instantiate; # a templated method with a type written as a string (e.g. 'float'); # we need to pass it in square brackets, otherwise it can be; # (mis)interpreted as string parameter and the method itself is; # called with 'float' as a parameter.; # For example the Take() method mentioned multiple times in this test; # has to be called e.g. with:; # Take['float'](); # instead of:; # Take('float')()",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py:35,Testability,test,tests,35,"# reuse the code from the C++ unit tests to create some files",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py:108,Availability,error,error,108,"# TODO: this emits a warning: Maybe you need to load the corresponding shared library?; # cling JIT session error: Failed to materialize symbols: ... emplace_back; # Despite the warning, the result is correct; # spec.WithGlobalFriends([(""subTree1"", ""PYspecTestFile5.root""),; # (""subTree2"", ""PYspecTestFile6.root""),; # (""subTree"", ""PYspecTestFile4.root"")], ""friendChainN"")",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py:48,Performance,load,load,48,"# TODO: this emits a warning: Maybe you need to load the corresponding shared library?; # cling JIT session error: Failed to materialize symbols: ... emplace_back; # Despite the warning, the result is correct; # spec.WithGlobalFriends([(""subTree1"", ""PYspecTestFile5.root""),; # (""subTree2"", ""PYspecTestFile6.root""),; # (""subTree"", ""PYspecTestFile4.root"")], ""friendChainN"")",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py:7,Testability,assert,assertEqual,7,"# self.assertEqual(fr3[j], expectedRess[i][j])",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_datasetspec.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx:19,Testability,test,tests,19,"// fixture for all tests in this file",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_definepersample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx:14,Testability,test,test,14,"// Regression test for https://github.com/root-project/root/issues/12043",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_definepersample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx:31,Testability,TEST,TEST,31,"/* TODO; // Not supported yet; TEST(DefinePerSample, DataSource); {; ROOT::RDataFrame df(std::make_unique<ROOT::RDF::RTrivialDS>(1));; auto r = df.DefinePerSample(""col0"", [] { return 42; }).Max<int>(""col0"");; EXPECT_EQ(*r, 42);; }; */; // instantiate single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_definepersample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx:265,Testability,test,tests,265,"/* TODO; // Not supported yet; TEST(DefinePerSample, DataSource); {; ROOT::RDataFrame df(std::make_unique<ROOT::RDF::RTrivialDS>(1));; auto r = df.DefinePerSample(""col0"", [] { return 42; }).Max<int>(""col0"");; EXPECT_EQ(*r, 42);; }; */; // instantiate single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_definepersample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx:15,Performance,multi-thread,multi-thread,15,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_definepersample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx:28,Testability,test,tests,28,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_definepersample.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_definepersample.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:23,Testability,test,tests,23,/****** Run RDataFrame tests both with and without IMT enabled *******/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the string returned",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the string returned",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the string returned",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the string returned",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:8,Testability,test,test,8,"// This test verifies that the correct method is called and there is no ambiguity between the JIT call to Display; // using a column list as a parameter and the JIT call to Display using the Regexp.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the string returned",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the string returned",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_display.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_display.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_entrylist.cxx:7,Testability,test,test,7,"// The test might seem contrived, because it is. We want to check:; // - that we read the correct entries from the correct trees, so we need to read different entries per tree; // - that TTreeProcessorMT re-builds TEntryLists correctly for each file/cluster, so we need a different number; // of entries and we need to select, via TEntryList, entries of tree2 that do not exist in tree1",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_entrylist.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_entrylist.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_friends.cxx:76,Testability,test,tests,76,"// ...even if they have the same name as a branch in the main tree; // this tests #7181",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_friends.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_friends.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_friends.cxx:18,Testability,Test,Test,18,"// R__USE_IMT; // Test for https://github.com/root-project/root/issues/6741",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_friends.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_friends.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:8,Testability,test,tests,8,"// this tests https://github.com/root-project/root/issues/8276",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:25,Testability,test,test,25,"// unused, single-thread test",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:12,Availability,error,error,12,"// still no error since lazy action",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:12,Availability,error,error,12,"// still no error since lazy action",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:12,Availability,error,error,12,"// still no error since lazy action",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:12,Availability,error,error,12,"// still no error since lazy action",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:5,Testability,test,test,5,"// A test for #10484",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx:28,Testability,test,test,28,"// The code below is a unit test for a function called `ProgressHelper_Existence_MT` in the `RDFHelpers` class.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_helpers.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_helpers.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_histomodels.cxx:10,Testability,test,tests,10,/*; These tests help us checking that the binning of the final histograms/profiles is correct.; We test construction of models with full blown histos/profiles and also using constructors; that mimick the ones of those very classes.; */,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_histomodels.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_histomodels.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_histomodels.cxx:99,Testability,test,test,99,/*; These tests help us checking that the binning of the final histograms/profiles is correct.; We test construction of models with full blown histos/profiles and also using constructors; that mimick the ones of those very classes.; */,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_histomodels.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_histomodels.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:11,Availability,error,error,11,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:17,Integrability,message,message,17,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:60,Integrability,depend,depending,60,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:11,Availability,error,error,11,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:17,Integrability,message,message,17,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:60,Integrability,depend,depending,60,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:11,Availability,error,error,11,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:17,Integrability,message,message,17,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:60,Integrability,depend,depending,60,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:11,Availability,error,error,11,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:17,Integrability,message,message,17,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:60,Integrability,depend,depending,60,"// Various error message that may be printed by TTreeReader depending on; // whether we are running with IMT or not",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:33,Availability,down,down,33,"// Expected values for variation down",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:21,Testability,test,tests,21,"// run single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:7,Performance,multi-thread,multi-thread,7,"// run multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx:20,Testability,test,tests,20,"// run multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_incomplete_entries.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_incomplete_entries.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx:3,Testability,test,test,3,"// test that it's possible to register the same alias in different branches of the computation graph",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_interface.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_interface.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx:3,Testability,Test,Testing,3,"// Testing the std output printing",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_interface.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx:16,Modifiability,variab,variable,16,"// defined as a variable to exercise passing lvalues into Book",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_interface.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx:25,Testability,test,test,25,"// unused, single-thread test",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_interface.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_interface.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_merge_results.py:11,Testability,test,tests,11,"""""""Various tests for the RMergeableValue family of classes.""""""",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_merge_results.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_merge_results.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_misc.py:2,Performance,load,load,2,"# load all libs and autoparse",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_misc.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_misc.py
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx:17,Testability,TEST,TESTS,17,/**** REGRESSION TESTS ****/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_ranges.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx:14,Testability,test,test,14,"// regression test for ROOT-9232; // reaching stop with multiple actions to be processed, remaining actions must be processed for this last entry",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_ranges.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx:14,Testability,test,test,14,"// regression test for ROOT-9272",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_ranges.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx:23,Testability,TEST,TESTS,23,/****** END REGRESSION TESTS ******/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_ranges.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_ranges.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx:19,Testability,test,tests,19,"// Fixture for all tests in this file. If parameter is true, run with implicit MT, else run sequentially",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_regression.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx:66,Performance,multi-thread,multi-thread,66,"// check that rdfentry_ contains all expected values,; // also in multi-thread runs over multiple ROOT files",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_regression.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx:21,Testability,test,tests,21,"// run single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_regression.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx:7,Performance,multi-thread,multi-thread,7,"// run multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_regression.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx:20,Testability,test,tests,20,"// run multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_regression.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_regression.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx:21,Testability,test,test,21,"// for NullResultPtr test case",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_resptr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx:8,Testability,test,test,8,"// also test move-assignment",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_resptr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx:3,Testability,Test,Test,3,"// Test constructors",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_resptr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx:3,Testability,Test,Test,3,"// Test push_back and emplace_back",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_resptr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx:3,Testability,Test,Test,3,"// Test initializer list",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_resptr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_resptr.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx:19,Testability,test,tests,19,"// fixture for all tests in this file",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_samplecallback.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx:412,Testability,test,tests,412,"/* TODO: data-block IDs for RDataSources are not supported yet; TEST_P(RDFSampleCallback, DataSource) {; auto df = ROOT::RDF::MakeTrivialDataFrame(NENTRIES);; auto result = df.Book<>(CounterHelper(), {});; // RTrivialDS tries to produce NSLOTS tasks; const auto expected = ROOT::IsImplicitMTEnabled() ? std::min(NENTRIES, df.GetNSlots()) : 1u;; EXPECT_EQ(*result, expected);; }; */; // instantiate single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_samplecallback.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx:15,Performance,multi-thread,multi-thread,15,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_samplecallback.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx:28,Testability,test,tests,28,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_samplecallback.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_samplecallback.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:23,Testability,test,tests,23,/****** Run RDataFrame tests both with and without IMT enabled *******/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:19,Testability,test,tests,19,"// Fixture for all tests in this file. If parameter is true, run with implicit MT, else run sequentially",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:39,Testability,test,test,39,"// Create file `filename` containing a test tree `treeName` with `nevents` events",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:440,Safety,detect,detection,440,"// NOTE(gparolini): these TFile and TTree are created on the heap to work around a know bug that can; // cause a TObject to be incorrectly marked as ""on heap"" and attempted to be freed despite; // living on the stack.; // The bug is caused by the magic bit pattern `kObjectAllocMemValue` used by TStorage to; // mark a heap object appearing by chance on the stack.; // This is not a problem with a clear solution and in fact the whole heap detection system relies on UB,; // so for now we are forced to work around the bug rather than fixing it.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:398,Usability,clear,clear,398,"// NOTE(gparolini): these TFile and TTree are created on the heap to work around a know bug that can; // cause a TObject to be incorrectly marked as ""on heap"" and attempted to be freed despite; // living on the stack.; // The bug is caused by the magic bit pattern `kObjectAllocMemValue` used by TStorage to; // mark a heap object appearing by chance on the stack.; // This is not a problem with a clear solution and in fact the whole heap detection system relies on UB,; // so for now we are forced to work around the bug rather than fixing it.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:8,Testability,test,test,8,"// this test case (as all others) is usually run twice, in IMT and non-IMT mode,; // but we only want to create the TRandom object once.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:8,Testability,test,tests,8,"// also tests returning a type convertible to bool",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:6,Performance,perform,perform,6,"// To perform the test, it's easier to sort",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:18,Testability,test,test,18,"// To perform the test, it's easier to sort",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:13,Testability,test,test,13,"/*; /// This test was deactivated because it is not possible to Sum Strings using a Kahan Sum.; /// The reason is that there is no minus operator for that case.; TEST(RDFSimpleTests, SumOfStrings); {; auto df = RDataFrame(2).Define(""str"", []() -> std::string { return ""bla""; });; EXPECT_EQ(*df.Sum<std::string>(""str""), ""blabla"");; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:162,Testability,TEST,TEST,162,"/*; /// This test was deactivated because it is not possible to Sum Strings using a Kahan Sum.; /// The reason is that there is no minus operator for that case.; TEST(RDFSimpleTests, SumOfStrings); {; auto df = RDataFrame(2).Define(""str"", []() -> std::string { return ""bla""; });; EXPECT_EQ(*df.Sum<std::string>(""str""), ""blabla"");; }; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:35,Testability,test,tests,35,"// The leading underscore of ""_hh"" tests against ROOT-10305.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:21,Testability,test,tests,21,"// run single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:7,Performance,multi-thread,multi-thread,7,"// run multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:20,Testability,test,tests,20,"// run multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_simple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:50,Modifiability,variab,variable,50,"// R__USE_IMT; // fixture that provides fixed and variable sized arrays as RDF columns",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:25,Testability,TEST,TESTS,25,/********* SINGLE THREAD TESTS ***********/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,Test,Test,3,"// Test for ROOT-9210",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,Test,Test,3,"// Test for ROOT-9122",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:59,Deployability,UPDATE,UPDATE,59,"// test snapshotting two trees to the same file opened in ""UPDATE"" mode",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees to the same file opened in ""UPDATE"" mode",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees with different names",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees with same name",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees with different names",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:21,Modifiability,variab,variable,21,"// check contents of variable sized arrays",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:9,Testability,test,test,9,"// write test tree",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:18,Testability,test,test,18,"// read and write test tree with RDF",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:15,Testability,test,test,15,"// as an extra test, make sure that the vector reallocates between first and second entry",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:16,Availability,error,error,16,"// Test that we error out gracefully in case the output file specified for a Snapshot cannot be opened",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,Test,Test,3,"// Test that we error out gracefully in case the output file specified for a Snapshot cannot be opened",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:69,Availability,error,error,69,"// Jitted; // If some other test case called EnableThreadSafety, the error printed here is of the form; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:287,Deployability,release,released,287,"// Jitted; // If some other test case called EnableThreadSafety, the error printed here is of the form; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:28,Testability,test,test,28,"// Jitted; // If some other test case called EnableThreadSafety, the error printed here is of the form; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,Test,Test,3,"// Test for https://github.com/root-project/root/issues/10233",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:30,Safety,avoid,avoid,30,"// Pass option to Snapshot to avoid the type conversion",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:24,Testability,TEST,TESTS,24,/********* MULTI THREAD TESTS ***********/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees with different names",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees with same name",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test snapshotting two trees with different names",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:8,Performance,multi-thread,multi-thread,8,"// test multi-thread Snapshotting from many tasks per worker thread",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,test,test,3,"// test multi-thread Snapshotting from many tasks per worker thread",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Performance,multi-thread,multi-thread,3,"// multi-thread execution might have scrambled events w.r.t. the original file, so we just check overall properties",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:9,Testability,test,test,9,"// write test tree",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:18,Testability,test,test,18,"// read and write test tree with RDF (in parallel)",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:9,Testability,test,test,9,"// check test sanity",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:16,Availability,error,error,16,"// Test that we error out gracefully in case the output file specified for a Snapshot cannot be opened",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:3,Testability,Test,Test,3,"// Test that we error out gracefully in case the output file specified for a Snapshot cannot be opened",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:18,Availability,error,error,18,"// Jitted; // the error printed here is; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:224,Deployability,release,released,224,"// Jitted; // the error printed here is; // ""SysError in <TFile::TFile>: file /definitely/not/a/valid/path/f.root can not be opened No such file or; // directory\nError in <TReentrantRWLock::WriteUnLock>: Write lock already released for 0x55f179989378\n"" but the; // address printed changes every time",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:7,Testability,Test,Test,7,"/**; * Test against issue #6523 and #6640; * Try to force `TTree::ChangeFile` behaviour. Within RDataFrame, this should; * not happen and both sequential and multithreaded Snapshot should only create; * one file.; */",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:27,Security,integrity,integrity,27,"// Check the file for data integrity.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_snapshot.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_splitcoll_arrayview.cxx:8,Testability,test,test,8,"// this test was roottest's root/dataframe/test_splitcoll_arrayview.C",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_splitcoll_arrayview.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_splitcoll_arrayview.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:25,Usability,Simpl,SimpleVariation,25,"// now, when evaluating `SimpleVariation`, we should notice that it returns 2 values, not 3, and throw",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:16,Integrability,depend,depend,16,"// `c` does not depend on `x`, so we don't expect any varied action in the output; // (at the moment, `Vary` calls are not displayed)",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:8,Deployability,update,update,8,"// must update this test when https://github.com/root-project/root/issues/9894 is addressed",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:20,Testability,test,test,20,"// must update this test when https://github.com/root-project/root/issues/9894 is addressed",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:3,Testability,TEST,TEST,3,"// TEST instead of TEST_P because Display is single-thread only",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:49,Performance,multi-thread,multi-thread,49,/************ These tests are run in single- and multi-thread mode (they use TEST_P instead of TEST) ************/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:20,Testability,test,tests,20,/************ These tests are run in single- and multi-thread mode (they use TEST_P instead of TEST) ************/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:95,Testability,TEST,TEST,95,/************ These tests are run in single- and multi-thread mode (they use TEST_P instead of TEST) ************/,MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:22,Integrability,depend,depends,22,"// have a Define that depends on a varied column",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:22,Integrability,depend,depends,22,"// have a Define that depends on multiple varied columns",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:29,Integrability,depend,depends,29,"// have a jitted Define that depends on a varied column",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:42,Testability,log,logic,42,"// this is a tricky case for our internal logic as we have to distinguish varying a column of RVec type; // from varying multiple columns: in both cases the Vary expression returns an RVec<RVec<..>>",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:217,Testability,test,test,217,"// If VariationsFor is called after the nominal result has already been produced/filled, the copies; // of the result object used to produced the varied results have to be reset to an empty/initial state.; // Here we test that this is the case for histograms and TStatistic objects.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:24,Testability,test,test,24,"// this is a regression test, we used to read from wrong addresses in this case",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:81,Performance,optimiz,optimization,81,"// this is a regression test for an issue that was hidden by RVec's small buffer optimization; // when the variations don't fit in the smalll buffer and we are varying multiple columns simultaneously,; // RVariation was changing the address of the varied values between entries, resulting in invalid reads; // on the part of the RVariationReader.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:24,Testability,test,test,24,"// this is a regression test for an issue that was hidden by RVec's small buffer optimization; // when the variations don't fit in the smalll buffer and we are varying multiple columns simultaneously,; // RVariation was changing the address of the varied values between entries, resulting in invalid reads; // on the part of the RVariationReader.",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:45,Testability,test,tests,45,"// needs resetting between sequential and MT tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:29,Testability,test,tests,29,"// instantiate single-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:15,Performance,multi-thread,multi-thread,15,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:28,Testability,test,tests,28,"// instantiate multi-thread tests",MatchSource.CODE_COMMENT,tree/dataframe/test/dataframe_vary.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_arrow.cxx:21,Testability,test,testing,21,"// Copied from arrow/testing/builder.h",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_arrow.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_arrow.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_arrow.cxx:37,Security,access,access,37,"// Get the concrete builder class to access its Append() specializations",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_arrow.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_arrow.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_arrow.cxx:37,Security,access,access,37,"// Get the concrete builder class to access its Append() specializations",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_arrow.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_arrow.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_csv.cxx:56,Deployability,upgrade,upgrade,56,"// must use http: we cannot use https on macOS until we upgrade to the newest Davix; // and turn on the macOS SecureTransport layer.",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_csv.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_csv.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_csv.cxx:110,Security,Secur,SecureTransport,110,"// must use http: we cannot use https on macOS until we upgrade to the newest Davix; // and turn on the macOS SecureTransport layer.",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_csv.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_csv.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:34,Performance,perform,performed,34,"// ...and work if the Snapshot is performed via an Alias",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_more.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:3,Performance,Cache,Cache,3,"// Cache must ignore the #var columns",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_more.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:3,Performance,Cache,Cache,3,"// Cache must throw if #var is passed explicitly...",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_more.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx:33,Performance,perform,performed,33,"// ...and work if the caching is performed via an Alias",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_more.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_more.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_ntuple.cxx:9,Testability,test,tests,9,"// These tests use the columns that contain std::array data on disk as RVecs; // reading them into RVecs and checking their values.",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_ntuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_ntuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_ntuple.cxx:9,Testability,test,tests,9,"// These tests use the columns that contain std::array data on disk as RVecs; // passing them as arguments to functions that expect RVecs.",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_ntuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_ntuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_ntuple.cxx:9,Testability,test,tests,9,"// These tests use the columns that contain std::array data on disk as RVecs; // checking the size of the collection with the R_rdf_sizeof_* columns",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_ntuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_ntuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_sqlite.cxx:18,Safety,avoid,avoid,18,"// Use query 3 to avoid storing a void * in the root file",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_sqlite.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_sqlite.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_sqlite.cxx:26,Modifiability,variab,variable,26,"// silence -Wunused-const-variable",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_sqlite.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_sqlite.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_trivial.cxx:3,Testability,Test,Test,3,"// Test for issue #6455, ""RDS does not early-quit event loops when all Ranges are exhausted""",MatchSource.CODE_COMMENT,tree/dataframe/test/datasource_trivial.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_trivial.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/NTupleStruct.hxx:15,Testability,test,test,15,/**; * Used to test serialization and deserialization of classes in RNTuple with TClass; */,MatchSource.CODE_COMMENT,tree/dataframe/test/NTupleStruct.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/NTupleStruct.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/RStreamingDS.hxx:17,Performance,latency,latency,17,"// simulate some latency",MatchSource.CODE_COMMENT,tree/dataframe/test/RStreamingDS.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/RStreamingDS.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:234,Usability,Feedback,Feedback,234,"/// \file ROOT/RCluster.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2020-03-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:300,Modifiability,layers,layers,300,"// clang-format off; /**; \class ROnDiskPage; \ingroup NTuple; \brief A page as being stored on disk, that is packed and compressed. Used by the cluster pool to cache pages from the physical storage. Such pages generally need to be; uncompressed and unpacked before they can be used by RNTuple upper layers.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:161,Performance,cache,cache,161,"// clang-format off; /**; \class ROnDiskPage; \ingroup NTuple; \brief A page as being stored on disk, that is packed and compressed. Used by the cluster pool to cache pages from the physical storage. Such pages generally need to be; uncompressed and unpacked before they can be used by RNTuple upper layers.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:26,Security,hash,hash,26,"// namespace ROOT; // For hash maps ROnDiskPage::Key --> ROnDiskPage",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:34,Security,hash,hash,34,"// TODO(jblomer): quick and dirty hash, likely very sub-optimal, to be revised later.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:178,Energy Efficiency,allocate,allocated,178,"// class ROnDiskPageMap; // clang-format off; /**; \class ROOT::Experimental::Internal::ROnDiskPageMapHeap; \ingroup NTuple; \brief An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:194,Availability,avail,available,194,"/// Marks the column as complete; must be done for all columns, even empty ones without associated pages,; /// before the cluster is given from the page storage to the cluster pool. Marking the available columns is; /// typically the last step of RPageSouce::LoadCluster().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:259,Performance,Load,LoadCluster,259,"/// Marks the column as complete; must be done for all columns, even empty ones without associated pages,; /// before the cluster is given from the page storage to the cluster pool. Marking the available columns is; /// typically the last step of RPageSouce::LoadCluster().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RCluster.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:238,Usability,Feedback,Feedback,238,"/// \file ROOT/RClusterPool.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2020-03-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:249,Deployability,pipeline,pipeline,249,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:350,Deployability,pipeline,pipeline,350,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:703,Deployability,pipeline,pipeline,703,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:742,Integrability,depend,depending,742,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:546,Performance,queue,queues,546,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:671,Performance,load,load,671,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:779,Performance,multi-thread,multi-threading,779,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:435,Testability,log,logic,435,"// clang-format off; /**; \class ROOT::Experimental::Internal::RClusterPool; \ingroup NTuple; \brief Managed a set of clusters containing compressed and packed pages. The cluster pool steers the preloading of (partial) clusters. There is a two-step pipeline: in a first step,; compressed pages are read from clusters into a memory buffer. The second pipeline step decompresses the pages; and pushes them into the page pool. The actual logic of reading and unzipping is implemented by the page source.; The cluster pool only orchestrates the work queues for reading and unzipping. It uses one extra I/O thread for; reading waits for data from storage and generates no CPU load. The unzipping step of the pipeline therefore behaves differently depending on whether or not implicit multi-threading; is turned on. If it is turned off, i.e. in a single-threaded environment, the cluster pool will only read the; compressed pages and the page source has to uncompresses pages at a later point when data from the page is requested.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:15,Performance,load,load,15,"/// Request to load a subset of the columns of a particular cluster.; /// Work items come in groups and are executed by the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:39,Energy Efficiency,schedul,scheduled,39,"/// Items with different bunch ids are scheduled for different vector reads",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:55,Deployability,pipeline,pipeline,55,"/// Clusters that are currently being processed by the pipeline. Every in-flight cluster has a corresponding; /// work item, first a read item and then an unzip item.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:35,Performance,load,loaded,35,"/// By the time a cluster has been loaded, this cluster might not be necessary anymore. This can happen if; /// there are jumps in the access pattern (i.e. the access pattern deviates from linear access).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:135,Security,access,access,135,"/// By the time a cluster has been loaded, this cluster might not be necessary anymore. This can happen if; /// there are jumps in the access pattern (i.e. the access pattern deviates from linear access).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:160,Security,access,access,160,"/// By the time a cluster has been loaded, this cluster might not be necessary anymore. This can happen if; /// there are jumps in the access pattern (i.e. the access pattern deviates from linear access).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:196,Security,access,access,196,"/// By the time a cluster has been loaded, this cluster might not be necessary anymore. This can happen if; /// there are jumps in the access pattern (i.e. the access pattern deviates from linear access).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:80,Performance,load,loading,80,"/// Every cluster pool is responsible for exactly one page source that triggers loading of the clusters; /// (GetCluster()) and is used for implementing the I/O and cluster memory allocation (PageSource::LoadClusters()).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:204,Performance,Load,LoadClusters,204,"/// Every cluster pool is responsible for exactly one page source that triggers loading of the clusters; /// (GetCluster()) and is used for implementing the I/O and cluster memory allocation (PageSource::LoadClusters()).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:8,Performance,cache,cache,8,"/// The cache of clusters around the currently active cluster",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:90,Performance,queue,queue,90,"/// Protects the shared state between the main thread and the I/O thread, namely the work queue and the in-flight; /// clusters vector",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:33,Performance,queue,queue,33,"/// Signals a non-empty I/O work queue",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:38,Performance,Load,LoadClusters,38,"/// The I/O thread calls RPageSource::LoadClusters() asynchronously. The thread is mostly waiting for the; /// data to arrive (blocked by the kernel) and therefore can safely run in addition to the application; /// main threads.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:168,Safety,safe,safely,168,"/// The I/O thread calls RPageSource::LoadClusters() asynchronously. The thread is mostly waiting for the; /// data to arrive (blocked by the kernel) and therefore can safely run in addition to the application; /// main threads.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:19,Integrability,rout,routine,19,"/// The I/O thread routine, there is exactly one I/O thread in-flight for every cluster pool",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:198,Performance,load,load,198,"/// Returns the given cluster from the pool, which needs to contain at least the columns `physicalColumns`.; /// Executed at the end of GetCluster when all missing data pieces have been sent to the load queue.; /// Ideally, the function returns without blocking if the cluster is already in the pool.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:203,Performance,queue,queue,203,"/// Returns the given cluster from the pool, which needs to contain at least the columns `physicalColumns`.; /// Executed at the end of GetCluster when all missing data pieces have been sent to the load queue.; /// Ideally, the function returns without blocking if the cluster is already in the pool.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:72,Performance,cache,cache,72,"/// Returns the requested cluster either from the pool or, in case of a cache miss, lets the I/O thread load; /// the cluster in the pool, blocks until done, and then returns it. Triggers along the way the background loading; /// of the following fWindowPost number of clusters. The returned cluster has at least all the pages of; /// `physicalColumns` and possibly pages of other columns, too. If implicit multi-threading is turned on, the; /// uncompressed pages of the returned cluster are already pushed into the page pool associated with the page source; /// upon return. The cluster remains valid until the next call to GetCluster().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:104,Performance,load,load,104,"/// Returns the requested cluster either from the pool or, in case of a cache miss, lets the I/O thread load; /// the cluster in the pool, blocks until done, and then returns it. Triggers along the way the background loading; /// of the following fWindowPost number of clusters. The returned cluster has at least all the pages of; /// `physicalColumns` and possibly pages of other columns, too. If implicit multi-threading is turned on, the; /// uncompressed pages of the returned cluster are already pushed into the page pool associated with the page source; /// upon return. The cluster remains valid until the next call to GetCluster().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:217,Performance,load,loading,217,"/// Returns the requested cluster either from the pool or, in case of a cache miss, lets the I/O thread load; /// the cluster in the pool, blocks until done, and then returns it. Triggers along the way the background loading; /// of the following fWindowPost number of clusters. The returned cluster has at least all the pages of; /// `physicalColumns` and possibly pages of other columns, too. If implicit multi-threading is turned on, the; /// uncompressed pages of the returned cluster are already pushed into the page pool associated with the page source; /// upon return. The cluster remains valid until the next call to GetCluster().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:407,Performance,multi-thread,multi-threading,407,"/// Returns the requested cluster either from the pool or, in case of a cache miss, lets the I/O thread load; /// the cluster in the pool, blocks until done, and then returns it. Triggers along the way the background loading; /// of the following fWindowPost number of clusters. The returned cluster has at least all the pages of; /// `physicalColumns` and possibly pages of other columns, too. If implicit multi-threading is turned on, the; /// uncompressed pages of the returned cluster are already pushed into the page pool associated with the page source; /// upon return. The cluster remains valid until the next call to GetCluster().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:30,Energy Efficiency,drain,drain,30,"/// Used by the unit tests to drain the queue of clusters to be preloaded",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:40,Performance,queue,queue,40,"/// Used by the unit tests to drain the queue of clusters to be preloaded",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:21,Testability,test,tests,21,"/// Used by the unit tests to drain the queue of clusters to be preloaded",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:233,Usability,Feedback,Feedback,233,"/// \file ROOT/RColumn.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumn.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:136,Usability,simpl,simple,136,"// clang-format off; /**; \class ROOT::Experimental::Internal::RColumn; \ingroup NTuple; \brief A column is a storage-backed array of a simple, fixed-size type, from which pages can be mapped into memory.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumn.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:237,Availability,avail,available,237,"/// The page into which new elements are being written. The page will initially be small; /// (just enough to hold RNTupleWriteOptions::fInitialNElementsPerPage elements) and expand as needed and; /// as memory for page buffers is still available (RNTupleWriteOptions::fPageBufferBudget) or the maximum page; /// size is reached (RNTupleWriteOptions::fMaxUnzippedPageSize).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumn.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:41,Availability,avail,available,41,"/// The number of elements written resp. available in the column",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumn.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:27,Performance,optimiz,optimization,27,"// TODO(jblomer): A future optimization should grow the page in one go, up to the maximum unzipped page size",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumn.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:10,Safety,avoid,avoid,10,"// Try to avoid jumping back to the previous page and jumping back to the previous cluster",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumn.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumnElementBase.hxx:244,Usability,Feedback,Feedback,244,"/// \file ROOT/RColumnElementBase.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RColumnElementBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumnElementBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:237,Usability,Feedback,Feedback,237,"/// \file ROOT/RDaos.hxx; /// \ingroup NTuple ROOT7; /// \author Javier Lopez-Gomez <j.lopez@cern.ch>; /// \date 2020-11-14; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:199,Availability,error,error,199,"/// \brief Sets event barrier for a given parent event and waits for the completion of all children launched before; /// the barrier (must have at least one child).; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:104,Availability,error,error,104,"/// \brief Reserve event in queue, optionally tied to a parent event.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:28,Performance,queue,queue,28,"/// \brief Reserve event in queue, optionally tied to a parent event.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:76,Availability,error,error,76,"/// \brief Release event data from queue.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:11,Deployability,Release,Release,11,"/// \brief Release event data from queue.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:35,Performance,queue,queue,35,"/// \brief Release event data from queue.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:51,Security,access,access,51,/**; \class RDaosPool; \brief A RDaosPool provides access to containers in a specific DAOS pool.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:51,Security,access,access,51,/**; \class RDaosObject; \brief Provides low-level access to DAOS objects in a container.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:11,Integrability,Wrap,Wrap,11,"/// \brief Wrap around a `daos_oclass_id_t`. An object class describes the schema of data distribution; /// and protection.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:124,Energy Efficiency,allocate,allocated,124,"/// This limit is currently not defined in any header and any call to; /// `daos_oclass_id2name()` within DAOS uses a stack-allocated buffer; /// whose length varies from 16 to 50, e.g. `https://github.com/daos-stack/daos/blob/master/src/utils/daos_dfs_hdlr.c#L78`.; /// As discussed with the development team, 64 is a reasonable limit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:60,Deployability,update,update,60,"/// \brief Contains required information for a single fetch/update operation.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:94,Deployability,update,update,94,"/// \brief `fRequests` is a sequential container assumed to remain valid throughout the fetch/update operation,; /// holding a list of `RAkeyRequest`-typed elements.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:65,Deployability,update,update,65,"/// \brief The distribution key, as used by the `daos_obj_{fetch,update}` functions.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:23,Security,access,access,23,"/// Provides low-level access to an object. If `cid` is OC_UNKNOWN, the user is responsible for; /// calling `daos_obj_generate_oid()` to fill the reserved bits in `oid` before calling this constructor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:72,Security,access,access,72,/**; \class RDaosContainer; \brief A RDaosContainer provides read/write access to objects in a given container.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:85,Deployability,update,update,85,"/// \brief A pair of <object ID, distribution key> that can be used to issue a fetch/update request for multiple; /// attribute keys.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:132,Security,hash,hash,132,"/// Implementation borrowed from `boost::hash_combine`. Comparable to initial seeding with `oid.hi` followed; /// by two subsequent hash calls for `oid.lo` and `dkey`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:356,Availability,error,error,356,/**; \brief Perform a vector read/write operation on different objects.; \param map A `MultiObjectRWOperation_t` that describes read/write operations to perform.; \param cid The `daos_oclass_id_t` used to qualify OIDs.; \param fn Either `&RDaosObject::Fetch` (read) or `&RDaosObject::Update` (write).; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:284,Deployability,Update,Update,284,/**; \brief Perform a vector read/write operation on different objects.; \param map A `MultiObjectRWOperation_t` that describes read/write operations to perform.; \param cid The `daos_oclass_id_t` used to qualify OIDs.; \param fn Either `&RDaosObject::Fetch` (read) or `&RDaosObject::Update` (write).; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:12,Performance,Perform,Perform,12,/**; \brief Perform a vector read/write operation on different objects.; \param map A `MultiObjectRWOperation_t` that describes read/write operations to perform.; \param cid The `daos_oclass_id_t` used to qualify OIDs.; \param fn Either `&RDaosObject::Fetch` (read) or `&RDaosObject::Update` (write).; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:153,Performance,perform,perform,153,/**; \brief Perform a vector read/write operation on different objects.; \param map A `MultiObjectRWOperation_t` that describes read/write operations to perform.; \param cid The `daos_oclass_id_t` used to qualify OIDs.; \param fn Either `&RDaosObject::Fetch` (read) or `&RDaosObject::Update` (write).; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:449,Availability,error,error,449,/**; \brief Read data from a single object attribute key to the given buffer.; \param buffer The address of a buffer that has capacity for at least `length` bytes.; \param length Length of the buffer.; \param oid A 128-bit DAOS object identifier.; \param dkey The distribution key used for this operation.; \param akey The attribute key used for this operation.; \param cid An object class ID.; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:403,Availability,error,error,403,/**; \brief Write the given buffer to a single object attribute key.; \param buffer The address of the source buffer.; \param length Length of the buffer.; \param oid A 128-bit DAOS object identifier.; \param dkey The distribution key used for this operation.; \param akey The attribute key used for this operation.; \param cid An object class ID.; \return 0 if the operation succeeded; a negative DAOS error number otherwise.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:12,Performance,Perform,Perform,12,/**; \brief Perform a vector read operation on multiple objects.; \param map A `MultiObjectRWOperation_t` that describes read operations to perform.; \param cid An object class ID.; \return Number of operations that could not complete.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:140,Performance,perform,perform,140,/**; \brief Perform a vector read operation on multiple objects.; \param map A `MultiObjectRWOperation_t` that describes read operations to perform.; \param cid An object class ID.; \return Number of operations that could not complete.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:12,Performance,Perform,Perform,12,/**; \brief Perform a vector write operation on multiple objects.; \param map A `MultiObjectRWOperation_t` that describes write operations to perform.; \param cid An object class ID.; \return Number of operations that could not complete.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:142,Performance,perform,perform,142,/**; \brief Perform a vector write operation on multiple objects.; \param map A `MultiObjectRWOperation_t` that describes write operations to perform.; \param cid An object class ID.; \return Number of operations that could not complete.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/REntry.hxx:232,Usability,Feedback,Feedback,232,"/// \file ROOT/REntry.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-07-19; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/REntry.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/REntry.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/REntry.hxx:5,Safety,Safe,Safety,5,"///< Safety check to prevent tokens from other models being used",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/REntry.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/REntry.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/REntry.hxx:4,Deployability,Update,Update,4,"/// Update the RValue for a field in the entry. To be used when its underlying RFieldBase changes, which typically; /// happens when page source the field values are read from changes.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/REntry.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/REntry.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx:232,Usability,Feedback,Feedback,232,"/// \file ROOT/RField.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx:57,Availability,failure,failures,57,"/// Used in RFieldBase::Check() to record field creation failures.; /// Also used when deserializing a field that contains unknown values that may come from; /// future RNTuple versions (e.g. an unknown Structure)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx:6,Security,access,access,6,"// to access GetCollectionInfo()",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:236,Usability,Feedback,Feedback,236,"/// \file ROOT/RFieldBase.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:680,Modifiability,extend,extended,680,"// namespace Detail; // clang-format off; /**; \class ROOT::Experimental::RFieldBase; \ingroup NTuple; \brief A field translates read and write calls from/to underlying columns to/from tree values. A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its; type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The; mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns.; The field knows based on its type and the field name the type(s) and name(s) of the columns. Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes.; This is and can only be partially enforced through C++.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:309,Safety,safe,safe,309,"// namespace Detail; // clang-format off; /**; \class ROOT::Experimental::RFieldBase; \ingroup NTuple; \brief A field translates read and write calls from/to underlying columns to/from tree values. A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its; type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The; mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns.; The field knows based on its type and the field name the type(s) and name(s) of the columns. Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes.; This is and can only be partially enforced through C++.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:434,Usability,simpl,simple,434,"// namespace Detail; // clang-format off; /**; \class ROOT::Experimental::RFieldBase; \ingroup NTuple; \brief A field translates read and write calls from/to underlying columns to/from tree values. A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its; type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The; mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns.; The field knows based on its type and the field name the type(s) and name(s) of the columns. Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes.; This is and can only be partially enforced through C++.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:17,Testability,test,tests,17,"// used for unit tests",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:17,Testability,test,tests,17,"// used for unit tests",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:17,Deployability,release,release,17,"/// A functor to release the memory acquired by CreateValue (memory and constructor).; /// This implementation works for types with a trivial destructor. More complex fields implement a derived deleter.; /// The deleter is operational without the field object and thus can be used to destruct/release a value after; /// the field has been destructed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:293,Deployability,release,release,293,"/// A functor to release the memory acquired by CreateValue (memory and constructor).; /// This implementation works for types with a trivial destructor. More complex fields implement a derived deleter.; /// The deleter is operational without the field object and thus can be used to destruct/release a value after; /// the field has been destructed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:108,Integrability,wrap,wrapper,108,"// We cannot directly use RFieldBase::RDeleter as a shared pointer deleter due to splicing. We use this; // wrapper class to store a polymorphic pointer to the actual deleter.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:133,Modifiability,polymorphi,polymorphic,133,"// We cannot directly use RFieldBase::RDeleter as a shared pointer deleter due to splicing. We use this; // wrapper class to store a polymorphic pointer to the actual deleter.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:67,Energy Efficiency,allocate,allocated,67,"/// No constructor needs to be called, i.e. any bit pattern in the allocated memory represents a valid type; /// A trivially constructible field has a no-op ConstructValue() implementation",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:75,Performance,perform,performs,75,"/// The type is cleaned up just by freeing its memory. I.e. the destructor performs a no-op.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:15,Security,checksum,checksum,15,"/// The TClass checksum is set and valid",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:25,Usability,simpl,simple,25,"/// A field qualifies as simple if it is both mappable and has no post-read callback",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:513,Integrability,depend,depends,513,"/// Translate an entry index to a column element index of the principal column and viceversa. These functions; /// take into account the role and number of repetitions on each level of the field hierarchy as follows:; /// - Top level fields: element index == entry index; /// - Record fields propagate their principal column index to the principal columns of direct descendant fields; /// - Collection and variant fields set the principal column index of their childs to 0; ///; /// The column element index also depends on the number of repetitions of each field in the hierarchy, e.g., given a; /// field with type `std::array<std::array<float, 4>, 2>`, this function returns 8 for the inner-most field.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:72,Usability,simpl,simple,72,"/// All fields that have columns have a distinct main column. E.g., for simple fields (float, int, ...), the; /// principal column corresponds to the field type. For collection fields except fixed-sized arrays,; /// the main column is the offset field. Class fields have no column of their own.; /// When reading, points to any column of the column team of the active representation. Usually, this is just; /// the first column.; /// When writing, points to the first column index of the currently active (not suppressed) column representation.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:42,Performance,optimiz,optimizations,42,"/// Properties of the type that allow for optimizations of collections of that type",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:21,Performance,cache,cached,21,"/// C++ type version cached from the descriptor after a call to `ConnectPageSource()`",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:20,Performance,cache,cached,20,"/// TClass checksum cached from the descriptor after a call to `ConnectPageSource()`. Only set; /// for classes with dictionaries.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:11,Security,checksum,checksum,11,"/// TClass checksum cached from the descriptor after a call to `ConnectPageSource()`. Only set; /// for classes with dictionaries.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:207,Energy Efficiency,reduce,reduce,207,"/// Helpers for generating columns. We use the fact that most fields have the same C++/memory types; /// for all their column representations.; /// Where possible, we call the helpers not from the header to reduce compilation time.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:185,Usability,simpl,simple,185,"/// Populate a single value with data from the field. The memory location pointed to by to needs to be of the; /// fitting type. The fast path is conditioned by the field qualifying as simple, i.e. maps as-is; /// to a single column and has no read callback.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:185,Usability,simpl,simple,185,"/// Populate a single value with data from the field. The memory location pointed to by to needs to be of the; /// fitting type. The fast path is conditioned by the field qualifying as simple, i.e. maps as-is; /// to a single column and has no read callback.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:169,Performance,optimiz,optimized,169,"/// General implementation of bulk read. Loop over the required range and read values that are required; /// and not already present. Derived classes may implement more optimized versions of this method.; /// See ReadBulk() for the return value.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:32,Availability,avail,available,32,"/// Returns the number of newly available values, that is the number of bools in bulkSpec.fMaskAvail that; /// flipped from false to true. As a special return value, kAllSet can be used if all values are read; /// independent from the masks.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:235,Availability,mask,masks,235,"/// Returns the number of newly available values, that is the number of bools in bulkSpec.fMaskAvail that; /// flipped from false to true. As a special return value, kAllSet can be used if all values are read; /// independent from the masks.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:27,Security,access,access,27,"/// Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:3,Performance,Perform,Perform,3,"// Perform housekeeping tasks for global to cluster-local index translation",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:211,Integrability,depend,depending,211,"// The page sink's callback when the data set gets committed will call this method to get the field's extra; // type information. This has to happen at the end of writing because the type information may change depending; // on the data that's written, e.g. for polymorphic types in the streamer field.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:262,Modifiability,polymorphi,polymorphic,262,"// The page sink's callback when the data set gets committed will call this method to get the field's extra; // type information. This has to happen at the end of writing because the type information may change depending; // on the data that's written, e.g. for polymorphic types in the streamer field.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:38,Availability,error,error,38,"///< Qualified field name causing the error",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:18,Availability,failure,failure,18,"///< Cause of the failure, e.g. unsupported type",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:249,Usability,simpl,simple,249,"/// The constructor creates the underlying column objects and connects them to either a sink or a source.; /// If `isSimple` is `true`, the trait `kTraitMappable` is automatically set on construction. However, the; /// field might be demoted to non-simple if a post-read callback is set.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:129,Availability,error,error,129,"/// Checks if the given type is supported by RNTuple. In case of success, the result vector is empty.; /// Otherwise there is an error record for each failing sub field (sub type).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:464,Availability,error,error,464,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:235,Deployability,release,released,235,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:339,Deployability,release,release,339,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:554,Deployability,release,release,554,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:46,Energy Efficiency,allocate,allocates,46,"/// Generates an object of the field type and allocates new initialized memory according to the type.; /// Implemented at the end of this header because the implementation is using RField<T>::TypeName(); /// The returned object can be released with `delete`, i.e. it is valid to call; /// auto ptr = field->CreateObject();; /// delete ptr.release();; ///; /// Note that CreateObject<void> is supported. The returned unique_ptr has a custom deleter that reports an error; /// if it is called. The intended use of the returned unique_ptr<void> is to call `release()`. In this way, the; /// transfer of pointer ownership is explicit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:46,Integrability,wrap,wraps,46,"/// Generates an object of the field type and wraps the created object in a shared pointer and returns it an RValue; /// connected to the field.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:129,Integrability,depend,depending,129,"/// As a rule of thumb, the alignment is equal to the size of the type. There are, however, various exceptions; /// to this rule depending on OS and CPU architecture. So enforce the alignment to be explicitly spelled out.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:39,Security,checksum,checksum,39,"/// Return the current TClass reported checksum of this class. Only valid if kTraitTypeChecksum is set.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:11,Security,checksum,checksum,11,"/// Return checksum stored in the field descriptor; only valid after a call to `ConnectPageSource()`,; /// if the field stored a type checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:134,Security,checksum,checksum,134,"/// Return checksum stored in the field descriptor; only valid after a call to `ConnectPageSource()`,; /// if the field stored a type checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:44,Availability,down,down,44,"/// The stack of nodes visited when walking down the tree of fields",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:131,Availability,mask,masks,131,"/// As a return value of ReadBulk and ReadBulkImpl(), indicates that the full bulk range was read; /// independent of the provided masks.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:141,Availability,mask,masks,141,"/// Similar to RValue but manages an array of consecutive values. Bulks have to come from the same cluster.; /// Bulk I/O works with two bit masks: the mask of all the available entries in the current bulk and the mask; /// of the required entries in a bulk read. The idea is that a single bulk may serve multiple read operations; /// on the same range, where in each read operation a different subset of values is required.; /// The memory of the value array is managed by the RBulk class.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:152,Availability,mask,mask,152,"/// Similar to RValue but manages an array of consecutive values. Bulks have to come from the same cluster.; /// Bulk I/O works with two bit masks: the mask of all the available entries in the current bulk and the mask; /// of the required entries in a bulk read. The idea is that a single bulk may serve multiple read operations; /// on the same range, where in each read operation a different subset of values is required.; /// The memory of the value array is managed by the RBulk class.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:168,Availability,avail,available,168,"/// Similar to RValue but manages an array of consecutive values. Bulks have to come from the same cluster.; /// Bulk I/O works with two bit masks: the mask of all the available entries in the current bulk and the mask; /// of the required entries in a bulk read. The idea is that a single bulk may serve multiple read operations; /// on the same range, where in each read operation a different subset of values is required.; /// The memory of the value array is managed by the RBulk class.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:214,Availability,mask,mask,214,"/// Similar to RValue but manages an array of consecutive values. Bulks have to come from the same cluster.; /// Bulk I/O works with two bit masks: the mask of all the available entries in the current bulk and the mask; /// of the required entries in a bulk read. The idea is that a single bulk may serve multiple read operations; /// on the same range, where in each read operation a different subset of values is required.; /// The memory of the value array is managed by the RBulk class.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:4,Performance,Cache,Cached,4,"/// Cached deleter of fField",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:5,Performance,Cache,Cached,5,"///< Cached copy of fField->GetValueSize()",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:19,Availability,avail,available,19,"///< The number of available values in the array (provided their mask is set)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:65,Availability,mask,mask,65,"///< The number of available values in the array (provided their mask is set)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:5,Availability,Mask,Masks,5,"///< Masks invalid values in the array",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:128,Energy Efficiency,allocate,allocated,128,"/// Sets a new range for the bulk. If there is enough capacity, the fValues array will be reused.; /// Otherwise a new array is allocated. After reset, fMaskAvail is false for all values.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:170,Availability,avail,available,170,"// Sets fValues and fSize/fCapacity to the given values. The capacity is specified in number of values.; // Once a buffer is adopted, an attempt to read more values then available throws an exception.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:208,Availability,mask,maskReq,208,"/// Reads 'size' values from the associated field, starting from 'firstIndex'. Note that the index is given; /// relative to a certain cluster. The return value points to the array of read objects.; /// The 'maskReq' parameter is a bool array of at least 'size' elements. Only objects for which the mask is; /// true are guaranteed to be read in the returned value array.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:299,Availability,mask,mask,299,"/// Reads 'size' values from the associated field, starting from 'firstIndex'. Note that the index is given; /// relative to a certain cluster. The return value points to the array of read objects.; /// The 'maskReq' parameter is a bool array of at least 'size' elements. Only objects for which the mask is; /// true are guaranteed to be read in the returned value array.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:44,Availability,avail,available,44,"// We may read a sub range of the currently available range",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:139,Integrability,inject,inject,139,"// At some point, RFieldBase::OnClusterCommit() may allow for a user-defined callback to change the; // column representation. For now, we inject this for testing and internal use only.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:139,Security,inject,inject,139,"// At some point, RFieldBase::OnClusterCommit() may allow for a user-defined callback to change the; // column representation. For now, we inject this for testing and internal use only.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:155,Testability,test,testing,155,"// At some point, RFieldBase::OnClusterCommit() may allow for a user-defined callback to change the; // column representation. For now, we inject this for testing and internal use only.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx:263,Usability,Feedback,Feedback,263,"/// \file ROOT/RFieldVisitor.hxx; /// \ingroup NTuple ROOT7; /// \author Simon Leisibach <simon.satoshi.rene.leisibach@cern.ch>; /// \date 2019-06-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx:260,Modifiability,inherit,inherited,260,"// clang-format off; /**; \class ROOT::Experimental::Detail::RFieldVisitor; \ingroup NTuple; \brief Abstract base class for classes implementing the visitor design pattern. RFieldVisitor::VisitField() is invoked by RFieldBase::AcceptVisitor(). VisitField() is inherited for instance; by the RPrintSchemaVisitor class. The RFieldBase class and classes which inherit from it will be visited.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx:357,Modifiability,inherit,inherit,357,"// clang-format off; /**; \class ROOT::Experimental::Detail::RFieldVisitor; \ingroup NTuple; \brief Abstract base class for classes implementing the visitor design pattern. RFieldVisitor::VisitField() is invoked by RFieldBase::AcceptVisitor(). VisitField() is inherited for instance; by the RPrintSchemaVisitor class. The RFieldBase class and classes which inherit from it will be visited.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldVisitor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:235,Usability,Feedback,Feedback,235,"/// \file ROOT/RMiniFile.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-12-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:209,Security,access,access,209,"// clang-format off; /**; \class ROOT::Experimental::Internal::RMiniFileReader; \ingroup NTuple; \brief Read RNTuple data blocks from a TFile container, provided by a RRawFile. A RRawFile is used for the byte access. The class implements a minimal subset of TFile, enough to extract; RNTuple data keys.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:115,Performance,perform,perform,115,"/// Reads a given byte range from the file into the provided memory buffer.; /// If `nbytes > fMaxKeySize` it will perform chunked read from multiple blobs,; /// whose addresses are listed at the end of the first chunk.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:196,Performance,perform,performance,196,"/// Direct I/O requires that all buffers and write lengths are aligned. It seems 512 byte alignment is the minimum; /// for Direct I/O to work, but further testing showed that it results in worse performance than 4kB.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:156,Testability,test,testing,156,"/// Direct I/O requires that all buffers and write lengths are aligned. It seems 512 byte alignment is the minimum; /// for Direct I/O to work, but further testing showed that it results in worse performance than 4kB.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:40,Deployability,update,updates,40,"/// During commit, WriteTFileKeysList() updates fNBytesKeys and fSeekKeys of the RTFFile located at; /// fSeekFileRecord. Given that the TFile key starts at offset 100 and the file name, which is written twice,; /// is shorter than 255 characters, we should need at most ~600 bytes. However, the header also needs to be; /// aligned to kBlockAlign...",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:12,Usability,simpl,simplest,12,"/// For the simplest cases, a C file stream can be used for writing",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:62,Deployability,update,updated,62,"/// Keeps track of TFile control structures, which need to be updated on committing the data set",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:18,Integrability,wrap,wrap,18,"// TODO(jblomer): wrap in an std::variant with C++17; /// For updating existing files and for storing more than just an RNTuple in the file",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:50,Integrability,depend,dependency,50,"/// For simple use cases, survives without libRIO dependency",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:8,Usability,simpl,simple,8,"/// For simple use cases, survives without libRIO dependency",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:6,Usability,simpl,simple,6,"/// A simple file can either be written as TFile container or as NTuple bare file",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:8,Testability,test,testing,8,"/// For testing purposes, RNTuple data can be written into a bare file container instead of a ROOT file",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx:233,Usability,Feedback,Feedback,233,"/// \file ROOT/RNTuple.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2023-09-19; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx:180,Deployability,release,release,180,"/// Changing the major version indicates forward incompatible changes; such changes should correspond to a new; /// bit in the feature flag of the RNTuple header.; /// For the pre-release epoch 0, indicates the release candidate number",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx:211,Deployability,release,release,211,"/// Changing the major version indicates forward incompatible changes; such changes should correspond to a new; /// bit in the feature flag of the RNTuple header.; /// For the pre-release epoch 0, indicates the release candidate number",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx:17,Deployability,patch,patch,17,"/// Changing the patch version indicates new backported features from newer binary format versions",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx:42,Integrability,interface,interface,42,"/// RNTuple implements the hadd MergeFile interface; /// Merge this NTuple with the input list entries",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx:54,Deployability,update,update,54,"/// NOTE: if you change this version you also need to update RTFNTuple::fClassVersion in RMiniFile.cxx",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:304,Usability,Feedback,Feedback,304,"/// \file ROOT/RNTupleDescriptor.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>; /// \date 2018-07-19; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:128,Testability,log,logical,128,"/// The number of columns in the column representations of the field. The column cardinality helps to navigate the; /// list of logical column ids. For example, the second column of the third column representation is; /// fLogicalColumnIds[2 * fColumnCardinality + 1]",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:58,Security,checksum,checksum,58,"/// For custom classes, we store the ROOT TClass reported checksum to facilitate the use of I/O rules that; /// identify types by their checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:136,Security,checksum,checksum,136,"/// For custom classes, we store the ROOT TClass reported checksum to facilitate the use of I/O rules that; /// identify types by their checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:119,Security,access,access,119,"/// In general, we create a field simply from the C++ type name. For untyped fields, however, we potentially need; /// access to sub fields, which is provided by the ntuple descriptor argument.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:34,Usability,simpl,simply,34,"/// In general, we create a field simply from the C++ type name. For untyped fields, however, we potentially need; /// access to sub fields, which is provided by the ntuple descriptor argument.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:194,Availability,avail,available,194,"/// Tells if the field describes a user-defined class rather than a fundamental type, a collection, or one of the; /// natively supported stdlib classes.; /// The dictionary does not need to be available for this method.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:29,Testability,log,logical,29,"/// Usually identical to the logical column ID, except for alias columns where it references the shadowed column",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:138,Modifiability,variab,variable,138,"/// The size in bits of elements of this column. Most columns have the size fixed by their type; /// but low-precision float columns have variable bit widths.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:423,Availability,avail,available,423,"// clang-format off; /**; \class ROOT::Experimental::RClusterDescriptor; \ingroup NTuple; \brief Meta-data for a set of ntuple clusters. The cluster descriptor is built in two phases. In a first phase, the descriptor has only an ID.; In a second phase, the event range, column group, page locations and column ranges are added.; Both phases are populated by the RClusterDescriptorBuilder.; Clusters usually span across all available columns but in some cases they can describe only a subset of the columns,; for instance when describing friend ntuples.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:4,Modifiability,Extend,Extend,4,"/// Extend this RPageRange to fit the given RColumnRange, i.e. prepend as many synthetic RPageInfos as needed to; /// cover the range in `columnRange`. `RPageInfo`s are constructed to contain as many elements of type `element`; /// given a page size limit of `pageSize` (in bytes); the locator for the referenced pages is `kTypePageZero`.; /// This function is used to make up `RPageRange`s for clusters that contain deferred columns.; /// \return The number of column elements covered by the synthesized RPageInfos",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:28,Integrability,depend,depends,28,"/// The meaning of fLocator depends on the storage backend.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:8,Integrability,wrap,wrapped,8,"/// The wrapped map iterator",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:71,Performance,load,loaded,71,"/// The cluster IDs can be empty if the corresponding page list is not loaded.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:23,Performance,load,loaded,23,"/// A cluster group is loaded in two stages. Stage one loads only the summary information.; /// Stage two loads the list of cluster IDs.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:55,Performance,load,loads,55,"/// A cluster group is loaded in two stages. Stage one loads only the summary information.; /// Stage two loads the list of cluster IDs.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:106,Performance,load,loads,106,"/// A cluster group is loaded in two stages. Stage one loads only the summary information.; /// Stage two loads the list of cluster IDs.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:23,Integrability,depend,depends,23,"/// The content format depends on the content ID and may be binary",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:700,Integrability,rout,routines,700,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDescriptor; \ingroup NTuple; \brief The on-storage meta-data of an ntuple. Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or; several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their; relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores; its location and size, and for every column the range of element indexes as well as a list of pages and page; locations. The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines; for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations. The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses; the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the; writte struct. This allows for forward and backward compatibility when the meta-data evolves.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:896,Integrability,depend,depend,896,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDescriptor; \ingroup NTuple; \brief The on-storage meta-data of an ntuple. Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or; several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their; relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores; its location and size, and for every column the range of element indexes as well as a list of pages and page; locations. The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines; for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations. The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses; the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the; writte struct. This allows for forward and backward compatibility when the meta-data evolves.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:1139,Modifiability,evolve,evolves,1139,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDescriptor; \ingroup NTuple; \brief The on-storage meta-data of an ntuple. Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or; several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their; relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores; its location and size, and for every column the range of element indexes as well as a list of pages and page; locations. The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines; for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations. The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses; the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the; writte struct. This allows for forward and backward compatibility when the meta-data evolves.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:774,Usability,usab,usable,774,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDescriptor; \ingroup NTuple; \brief The on-storage meta-data of an ntuple. Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or; several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their; relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores; its location and size, and for every column the range of element indexes as well as a list of pages and page; locations. The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines; for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations. The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses; the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the; writte struct. This allows for forward and backward compatibility when the meta-data evolves.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:5,Deployability,Update,Updated,5,"///< Updated by the descriptor builder when the cluster groups are added",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:5,Deployability,Update,Updated,5,"///< Updated by the descriptor builder when the cluster groups are added",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:5,Deployability,Update,Updated,5,"///< Updated by the descriptor builder when columns are added",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:545,Performance,cache,cache,545,"///< Set by the descriptor builder; /**; * Once constructed by an RNTupleDescriptorBuilder, the descriptor is mostly immutable except for set of; * active the page locations. During the lifetime of the descriptor, page location information for clusters; * can be added or removed. When this happens, the generation should be increased, so that users of the; * descriptor know that the information changed. The generation is increased, e.g., by the page source's; * exclusive lock guard around the descriptor. It is used, e.g., by the descriptor cache in RNTupleReader.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:41,Availability,avail,available,41,"/// May contain only a subset of all the available clusters, e.g. the clusters of the current file; /// from a chain of files",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:42,Testability,test,testing,42,"// Bit reserved for forward-compatibility testing",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:16,Testability,log,logical,16,"/// Returns the logical parent of all top-level NTuple data fields.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:15,Performance,load,load,15,"/// Methods to load and drop cluster group details (cluster IDs and page locations)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:47,Energy Efficiency,efficient,efficient,47,"/// All field IDs of late model extensions for efficient lookup. When a column gets added to the extension; /// header, this enables us to determine if the column belongs to a field of the header extension of if it; /// belongs to a field of the regular header that gets extended by additional column representations.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:271,Modifiability,extend,extended,271,"/// All field IDs of late model extensions for efficient lookup. When a column gets added to the extension; /// header, this enables us to determine if the column belongs to a field of the header extension of if it; /// belongs to a field of the regular header that gets extended by additional column representations.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:43,Modifiability,extend,extend,43,"/// All logical column IDs of columns that extend, with additional column representations, fields of the regular; /// header. During serialization, these columns are not picked up as columns of `fFieldIdsOrder`. But instead; /// these columns need to be serialized in the extension header without re-serializing the field.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:8,Testability,log,logical,8,"/// All logical column IDs of columns that extend, with additional column representations, fields of the regular; /// header. During serialization, these columns are not picked up as columns of `fFieldIdsOrder`. But instead; /// these columns need to be serialized in the extension header without re-serializing the field.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:44,Deployability,update,updated,44,"/// Number of logical and physical columns; updated by the descriptor builder when columns are added",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:14,Testability,log,logical,14,"/// Number of logical and physical columns; updated by the descriptor builder when columns are added",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:58,Availability,avail,available,58,"// The field that the column belongs to has to be already available. For fields with multiple columns,; // the columns need to be added in order of the column index",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:4,Usability,Clear,Clears,4,"/// Clears so-far stored clusters, fields, and columns and return to a pristine ntuple descriptor",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:396,Testability,log,logical,396,"/// If the descriptor is constructed in pieces consisting of physical and alias columns; /// (regular and projected fields), the natural column order would be; /// - Physical and alias columns of piece one; /// - Physical and alias columns of piece two; /// - etc.; /// What we want, however, are first all physical column IDs and then all alias column IDs.; /// This method adds `offset` to the logical column IDs of all alias columns and fixes up the corresponding; /// column IDs in the projected field descriptors. In this way, a new piece of physical and alias columns can; /// first shift the existing alias columns by the number of new physical columns, resulting in the following order; /// - Physical columns of piece one; /// - Physical columns of piece two; /// - ...; // - Logical columns of piece one; /// - Logical columns of piece two; /// - ...",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:785,Testability,Log,Logical,785,"/// If the descriptor is constructed in pieces consisting of physical and alias columns; /// (regular and projected fields), the natural column order would be; /// - Physical and alias columns of piece one; /// - Physical and alias columns of piece two; /// - etc.; /// What we want, however, are first all physical column IDs and then all alias column IDs.; /// This method adds `offset` to the logical column IDs of all alias columns and fixes up the corresponding; /// column IDs in the projected field descriptors. In this way, a new piece of physical and alias columns can; /// first shift the existing alias columns by the number of new physical columns, resulting in the following order; /// - Physical columns of piece one; /// - Physical columns of piece two; /// - ...; // - Logical columns of piece one; /// - Logical columns of piece two; /// - ...",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:821,Testability,Log,Logical,821,"/// If the descriptor is constructed in pieces consisting of physical and alias columns; /// (regular and projected fields), the natural column order would be; /// - Physical and alias columns of piece one; /// - Physical and alias columns of piece two; /// - etc.; /// What we want, however, are first all physical column IDs and then all alias column IDs.; /// This method adds `offset` to the logical column IDs of all alias columns and fixes up the corresponding; /// column IDs in the projected field descriptors. In this way, a new piece of physical and alias columns can; /// first shift the existing alias columns by the number of new physical columns, resulting in the following order; /// - Physical columns of piece one; /// - Physical columns of piece two; /// - ...; // - Logical columns of piece one; /// - Logical columns of piece two; /// - ...",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:110,Performance,load,loaded,110,"/// Get the streamer info records for custom classes. Currently requires the corresponding dictionaries to be loaded.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:244,Usability,Feedback,Feedback,244,"/// \file ROOT/RNTupleFillContext.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:581,Availability,error,errors,581,"// clang-format off; /**; \class ROOT::Experimental::RNTupleFillContext; \ingroup NTuple; \brief A context for filling entries (data) into clusters of an RNTuple. An output cluster can be filled with entries. The caller has to make sure that the data that gets filled into a cluster; is not modified for the time of the Fill() call. The fill call serializes the C++ object into the column format and; writes data into the corresponding column page buffers. Writing of the buffers to storage is deferred and can be; triggered by FlushCluster() or by destructing the context. On I/O errors, an exception is thrown. Instances of this class are not meant to be used in isolation and can be created from an RNTupleParallelWriter. For; sequential writing, please refer to RNTupleWriter.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:108,Testability,log,logically,108,"/// Whether to enable staged cluster committing, where only an explicit call to CommitStagedClusters() will logically; /// append the clusters to the RNTuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:196,Performance,perform,perform,196,"/// Fill an entry into this context, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; /// and check RNTupleFillStatus::ShouldFlushCluster.; ///; /// This method will perform a light check whether the entry comes from the context's own model.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:54,Performance,perform,perform,54,"/// Fill an entry into this context. This method will perform a light check whether the entry comes from the; /// context's own model.; /// \return The number of uncompressed bytes written.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:57,Energy Efficiency,reduce,reduce,57,"/// Flush column data, preparing for CommitCluster or to reduce memory usage. This will trigger compression of pages,; /// but not actually write to storage.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:4,Testability,Log,Logically,4,"/// Logically append staged clusters to the RNTuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillStatus.hxx:252,Usability,Feedback,Feedback,252,"/// \file ROOT/RNTupleFillStatus.hxx; /// \ingroup NTuple ROOT7; /// \author Jonas Hahnfeld <jonas.hahnfeld@cern.ch>; /// \date 2024-04-15; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleFillStatus.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillStatus.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleImtTaskScheduler.hxx:249,Usability,Feedback,Feedback,249,"/// \file ROOT/RNTupleImtTaskScheduler.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-19; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleImtTaskScheduler.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleImtTaskScheduler.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx:249,Usability,Feedback,Feedback,249,"/// \file ROOT/RNTupleIndex.hxx; /// \ingroup NTuple ROOT7; /// \author Florine de Geus <florine.de.geus@cern.ch>; /// \date 2024-04-02; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx:101,Security,hash,hashes,101,"/////////////////////////////////////////////////////////////////////////////; /// Container for the hashes of the indexed fields.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx:83,Security,Hash,Hash,83,"/////////////////////////////////////////////////////////////////////////////; /// Hash combinining the individual index value hashes from RIndexValue. Uses the implementation from; /// `boost::hash_combine` (see; /// https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx:127,Security,hash,hashes,127,"/////////////////////////////////////////////////////////////////////////////; /// Hash combinining the individual index value hashes from RIndexValue. Uses the implementation from; /// `boost::hash_combine` (see; /// https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx:265,Security,hash,hash,265,"/////////////////////////////////////////////////////////////////////////////; /// Hash combinining the individual index value hashes from RIndexValue. Uses the implementation from; /// `boost::hash_combine` (see; /// https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx:65,Security,hash,hashes,65,"/// The fields for which the index is built. Used to compute the hashes for each entry value.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleIndex.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:311,Usability,Feedback,Feedback,311,"/// \file ROOT/RNTupleMerger.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>, Max Orok <maxwellorok@gmail.com>, Alaettin Serhan Mete <amete@anl.gov>; /// \date 2020-07-08; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:20,Deployability,update,update,20,"/// The merger will update the output model to include all columns from all sources. Entries corresponding to columns; /// that are not present in a source will be set to the default value of the type.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:48,Availability,error,error,48,"/// The merger will abort merging as soon as an error is encountered",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:20,Safety,abort,abort,20,"/// The merger will abort merging as soon as an error is encountered",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:9,Availability,error,errors,9,"/// Upon errors, the merger will skip the current source and continue",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:59,Availability,error,errors,59,"/// Determines how the Merge function behaves upon merging errors",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:240,Usability,Feedback,Feedback,240,"/// \file ROOT/RNTupleMetrics.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-08-27; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:107,Performance,perform,performance,107,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTuplePerfCounter; \ingroup NTuple; \brief A performance counter with a name and a unit, which can be activated on demand. Derived classes decide on the counter type and implement printing of the value.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:133,Performance,perform,performance,133,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTuplePlainCounter; \ingroup NTuple; \brief A non thread-safe integral performance counter; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:119,Safety,safe,safe,119,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTuplePlainCounter; \ingroup NTuple; \brief A non thread-safe integral performance counter; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:130,Performance,perform,performance,130,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTupleAtomicCounter; \ingroup NTuple; \brief A thread-safe integral performance counter; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:116,Safety,safe,safe,116,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTupleAtomicCounter; \ingroup NTuple; \brief A thread-safe integral performance counter; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:122,Safety,safe,safe,122,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTupleTickCounter; \ingroup NTuple; \brief An either thread-safe or non thread safe counter for CPU ticks. On print, the value is converted from ticks to ns.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:141,Safety,safe,safe,141,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTupleTickCounter; \ingroup NTuple; \brief An either thread-safe or non thread safe counter for CPU ticks. On print, the value is converted from ticks to ns.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:238,Usability,Feedback,Feedback,238,"/// \file ROOT/RNTupleModel.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:4,Testability,Assert,Asserts,4,"/// Asserts that the passed field is a valid target of the source field provided in the field map.; /// Checks the field without looking into sub fields.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:332,Deployability,update,updates,332,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleModelChangeset; \ingroup NTuple; \brief The incremental changes to a `RNTupleModel`. Represents a set of alterations to a `RNTupleModel` that happened after the model is used to initialize a `RPageSink`; instance. This object can be used to communicate metadata updates to a `RPageSink`.; You will not normally use this directly; see `RNTupleModel::RUpdater` instead.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:65,Deployability,update,updater,65,"/// Points to the fields in fModel that were added as part of an updater transaction",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:75,Deployability,update,updater,75,"/// Points to the projected fields in fModel that were added as part of an updater transaction",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:6,Integrability,wrap,wrapper,6,"/// A wrapper over a field name and an optional description; used in `AddField()` and `RUpdater::AddField()`",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:211,Deployability,update,updates,211,"/// A model is usually immutable after passing it to an `RNTupleWriter`. However, for the rare; /// cases that require changing the model after the fact, `RUpdater` provides limited support for; /// incremental updates, e.g. addition of new fields.; ///; /// See `RNTupleWriter::CreateModelUpdater()` for an example.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:38,Usability,simpl,simple,38,"/// Hierarchy of fields consisting of simple types and collections (sub trees)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:37,Security,access,accessed,37,"/// Register a subfield so it can be accessed directly from entries belonging to the model. Because registering a; /// subfield does not fundamentally change the model, previously created entries will not be invalidated, nor; /// modified in any way; a registered subfield is merely an accessor added to the default entry (if present) and any; /// entries created afterwards.; ///; /// Using models with registered subfields for writing is not allowed. Attempting to do so will result in an; /// exception.; ///; /// Throws an exception if the provided subfield could not be found in the model.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:286,Security,access,accessor,286,"/// Register a subfield so it can be accessed directly from entries belonging to the model. Because registering a; /// subfield does not fundamentally change the model, previously created entries will not be invalidated, nor; /// modified in any way; a registered subfield is merely an accessor added to the default entry (if present) and any; /// entries created afterwards.; ///; /// Using models with registered subfields for writing is not allowed. Attempting to do so will result in an; /// exception.; ///; /// Throws an exception if the provided subfield could not be found in the model.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx:12,Security,access,access,12,"/// Mutable access to the root field is used to make adjustments to the fields.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleModel.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:256,Usability,Feedback,Feedback,256,"/// \file ROOT/RNTupleParallelWriter.hxx; /// \ingroup NTuple ROOT7; /// \author Jonas Hahnfeld <jonas.hahnfeld@cern.ch>; /// \date 2024-02-01; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:1659,Deployability,update,updates,1659,"/**; \class ROOT::Experimental::RNTupleParallelWriter; \ingroup NTuple; \brief A writer to fill an RNTuple from multiple contexts. Compared to the sequential RNTupleWriter, a parallel writer enables the creation of multiple RNTupleFillContext (see; RNTupleParallelWriter::CreateFillContext). Each fill context prepares independent clusters that are appended to the; common ntuple with internal synchronization. Before destruction, all fill contexts must have flushed their data and; been destroyed (or data could be lost!). For user convenience, RNTupleParallelWriter::CreateFillContext is thread-safe and may be called from multiple threads; in parallel at any time, also after some data has already been written. Internally, the original model is cloned and; ownership is passed to a newly created RNTupleFillContext. For that reason, it is recommended to use; RNTupleModel::CreateBare when creating the model for parallel writing and avoid the allocation of a useless default; REntry per context. Note that the sequence of independently prepared clusters is indeterminate and therefore entries are only partially; ordered: Entries from one context are totally ordered as they were filled. However, there is no orderering with other; contexts and the entries may be appended to the ntuple either before or after other entries written in parallel into; other contexts. In addition, two consecutive entries in one fill context can end up separated in the final ntuple, if; they happen to fall onto a cluster boundary and other contexts append more entries before the next cluster is full. At the moment, the parallel writer does not (yet) support incremental updates of the underlying model. Please refer to; RNTupleWriter::CreateModelUpdater if required for your use case.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:394,Integrability,synchroniz,synchronization,394,"/**; \class ROOT::Experimental::RNTupleParallelWriter; \ingroup NTuple; \brief A writer to fill an RNTuple from multiple contexts. Compared to the sequential RNTupleWriter, a parallel writer enables the creation of multiple RNTupleFillContext (see; RNTupleParallelWriter::CreateFillContext). Each fill context prepares independent clusters that are appended to the; common ntuple with internal synchronization. Before destruction, all fill contexts must have flushed their data and; been destroyed (or data could be lost!). For user convenience, RNTupleParallelWriter::CreateFillContext is thread-safe and may be called from multiple threads; in parallel at any time, also after some data has already been written. Internally, the original model is cloned and; ownership is passed to a newly created RNTupleFillContext. For that reason, it is recommended to use; RNTupleModel::CreateBare when creating the model for parallel writing and avoid the allocation of a useless default; REntry per context. Note that the sequence of independently prepared clusters is indeterminate and therefore entries are only partially; ordered: Entries from one context are totally ordered as they were filled. However, there is no orderering with other; contexts and the entries may be appended to the ntuple either before or after other entries written in parallel into; other contexts. In addition, two consecutive entries in one fill context can end up separated in the final ntuple, if; they happen to fall onto a cluster boundary and other contexts append more entries before the next cluster is full. At the moment, the parallel writer does not (yet) support incremental updates of the underlying model. Please refer to; RNTupleWriter::CreateModelUpdater if required for your use case.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:597,Safety,safe,safe,597,"/**; \class ROOT::Experimental::RNTupleParallelWriter; \ingroup NTuple; \brief A writer to fill an RNTuple from multiple contexts. Compared to the sequential RNTupleWriter, a parallel writer enables the creation of multiple RNTupleFillContext (see; RNTupleParallelWriter::CreateFillContext). Each fill context prepares independent clusters that are appended to the; common ntuple with internal synchronization. Before destruction, all fill contexts must have flushed their data and; been destroyed (or data could be lost!). For user convenience, RNTupleParallelWriter::CreateFillContext is thread-safe and may be called from multiple threads; in parallel at any time, also after some data has already been written. Internally, the original model is cloned and; ownership is passed to a newly created RNTupleFillContext. For that reason, it is recommended to use; RNTupleModel::CreateBare when creating the model for parallel writing and avoid the allocation of a useless default; REntry per context. Note that the sequence of independently prepared clusters is indeterminate and therefore entries are only partially; ordered: Entries from one context are totally ordered as they were filled. However, there is no orderering with other; contexts and the entries may be appended to the ntuple either before or after other entries written in parallel into; other contexts. In addition, two consecutive entries in one fill context can end up separated in the final ntuple, if; they happen to fall onto a cluster boundary and other contexts append more entries before the next cluster is full. At the moment, the parallel writer does not (yet) support incremental updates of the underlying model. Please refer to; RNTupleWriter::CreateModelUpdater if required for your use case.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:937,Safety,avoid,avoid,937,"/**; \class ROOT::Experimental::RNTupleParallelWriter; \ingroup NTuple; \brief A writer to fill an RNTuple from multiple contexts. Compared to the sequential RNTupleWriter, a parallel writer enables the creation of multiple RNTupleFillContext (see; RNTupleParallelWriter::CreateFillContext). Each fill context prepares independent clusters that are appended to the; common ntuple with internal synchronization. Before destruction, all fill contexts must have flushed their data and; been destroyed (or data could be lost!). For user convenience, RNTupleParallelWriter::CreateFillContext is thread-safe and may be called from multiple threads; in parallel at any time, also after some data has already been written. Internally, the original model is cloned and; ownership is passed to a newly created RNTupleFillContext. For that reason, it is recommended to use; RNTupleModel::CreateBare when creating the model for parallel writing and avoid the allocation of a useless default; REntry per context. Note that the sequence of independently prepared clusters is indeterminate and therefore entries are only partially; ordered: Entries from one context are totally ordered as they were filled. However, there is no orderering with other; contexts and the entries may be appended to the ntuple either before or after other entries written in parallel into; other contexts. In addition, two consecutive entries in one fill context can end up separated in the final ntuple, if; they happen to fall onto a cluster boundary and other contexts append more entries before the next cluster is full. At the moment, the parallel writer does not (yet) support incremental updates of the underlying model. Please refer to; RNTupleWriter::CreateModelUpdater if required for your use case.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:15,Integrability,synchroniz,synchronize,15,"/// A mutex to synchronize the final page sink.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:44,Integrability,synchroniz,synchronization,44,"/// The final RPageSink that represents the synchronization point.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:61,Security,access,accessed,61,"/// Append an ntuple to the existing file, which must not be accessed while data is filled into any created context.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:130,Safety,safe,safe,130,"/// Create a new RNTupleFillContext that can be used to fill entries and prepare clusters in parallel. This method is; /// thread-safe and may be called from multiple threads in parallel at any time, also after some data has already; /// been written.; ///; /// Note that all fill contexts must be destroyed before the RNTupleParallelWriter is destructed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:253,Usability,Feedback,Feedback,253,"/// \file ROOT/RNTupleProcessor.hxx; /// \ingroup NTuple ROOT7; /// \author Florine de Geus <florine.de.geus@cern.ch>; /// \date 2024-03-26; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:1199,Availability,error,error,1199,"// clang-format off; /**; \class ROOT::Experimental::RNTupleProcessor; \ingroup NTuple; \brief Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). Example usage (see ntpl012_processor.C for a full example):. ~~~{.cpp}; #include <ROOT/RNTupleProcessor.hxx>; using ROOT::Experimental::RNTupleProcessor;; using ROOT::Experimental::RNTupleOpenSpec;. std::vector<RNTupleOpenSpec> ntuples = {{""ntuple1"", ""ntuple1.root""}, {""ntuple2"", ""ntuple2.root""}};; auto processor = RNTupleProcessor::CreateChain(ntuples);. for (const auto &entry : processor) {; std::cout << ""pt = "" << *entry.GetPtr<float>(""pt"") << std::endl;; }; ~~~. An RNTupleProcessor is created by providing one or more RNTupleOpenSpecs, each of which contains the name and storage; location of a single RNTuple. The RNTuples are processed in the order in which they were provided. The RNTupleProcessor constructor also (optionally) accepts an RNTupleModel, which determines which fields should be; read. If no model is provided, a default model based on the descriptor of the first specified RNTuple will be used.; If a field that was present in the first RNTuple is not found in a subsequent one, an error will be thrown. The RNTupleProcessor provides an iterator which gives access to the REntry containing the field data for the current; entry. Additional bookkeeping information can be obtained through the RNTupleProcessor itself.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:95,Integrability,Interface,Interface,95,"// clang-format off; /**; \class ROOT::Experimental::RNTupleProcessor; \ingroup NTuple; \brief Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). Example usage (see ntpl012_processor.C for a full example):. ~~~{.cpp}; #include <ROOT/RNTupleProcessor.hxx>; using ROOT::Experimental::RNTupleProcessor;; using ROOT::Experimental::RNTupleOpenSpec;. std::vector<RNTupleOpenSpec> ntuples = {{""ntuple1"", ""ntuple1.root""}, {""ntuple2"", ""ntuple2.root""}};; auto processor = RNTupleProcessor::CreateChain(ntuples);. for (const auto &entry : processor) {; std::cout << ""pt = "" << *entry.GetPtr<float>(""pt"") << std::endl;; }; ~~~. An RNTupleProcessor is created by providing one or more RNTupleOpenSpecs, each of which contains the name and storage; location of a single RNTuple. The RNTuples are processed in the order in which they were provided. The RNTupleProcessor constructor also (optionally) accepts an RNTupleModel, which determines which fields should be; read. If no model is provided, a default model based on the descriptor of the first specified RNTuple will be used.; If a field that was present in the first RNTuple is not found in a subsequent one, an error will be thrown. The RNTupleProcessor provides an iterator which gives access to the REntry containing the field data for the current; entry. Additional bookkeeping information can be obtained through the RNTupleProcessor itself.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:1275,Security,access,access,1275,"// clang-format off; /**; \class ROOT::Experimental::RNTupleProcessor; \ingroup NTuple; \brief Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). Example usage (see ntpl012_processor.C for a full example):. ~~~{.cpp}; #include <ROOT/RNTupleProcessor.hxx>; using ROOT::Experimental::RNTupleProcessor;; using ROOT::Experimental::RNTupleOpenSpec;. std::vector<RNTupleOpenSpec> ntuples = {{""ntuple1"", ""ntuple1.root""}, {""ntuple2"", ""ntuple2.root""}};; auto processor = RNTupleProcessor::CreateChain(ntuples);. for (const auto &entry : processor) {; std::cout << ""pt = "" << *entry.GetPtr<float>(""pt"") << std::endl;; }; ~~~. An RNTupleProcessor is created by providing one or more RNTupleOpenSpecs, each of which contains the name and storage; location of a single RNTuple. The RNTuples are processed in the order in which they were provided. The RNTupleProcessor constructor also (optionally) accepts an RNTupleModel, which determines which fields should be; read. If no model is provided, a default model based on the descriptor of the first specified RNTuple will be used.; If a field that was present in the first RNTuple is not found in a subsequent one, an error will be thrown. The RNTupleProcessor provides an iterator which gives access to the REntry containing the field data for the current; entry. Additional bookkeeping information can be obtained through the RNTupleProcessor itself.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:121,Availability,avail,available,121,"//////////////////////////////////////////////////////////////////////////; /// \brief Advance the processor to the next available entry.; ///; /// \return The new (global) entry number of after advancing, or kInvalidNTupleIndex if the last entry has been; /// processed.; ///; /// Checks if the end of the currently connected RNTuple is reached. If this is the case, either the next RNTuple; /// is connected or the iterator has reached the end.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:402,Security,access,access,402,"/////////////////////////////////////////////////////////////////////////////; /// \brief Constructs a new RNTupleChainProcessor.; ///; /// \param[in] ntuples The source specification (name and storage location) for each RNTuple to process.; /// \param[in] model The model that specifies which fields should be read by the processor. The pointer returned by; /// RNTupleModel::MakeField can be used to access a field's value during the processor iteration. When no model is; /// specified, it is created from the descriptor of the first RNTuple specified in `ntuples`.; ///; /// RNTuples are processed in the order in which they are specified.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:239,Usability,Feedback,Feedback,239,"/// \file ROOT/RNTupleReader.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-20; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:13,Performance,perform,performance,13,"// internals performance counters, requires that EnableMetrics() was called",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:29,Energy Efficiency,schedul,scheduler,29,"/// Set as the page source's scheduler for parallel page decompression if IMT is on; /// Needs to be destructed after the pages source is destructed (an thus be declared before)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:287,Performance,cache,cached,287,"/// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; /// not on a hot code path.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:89,Security,expose,expose,89,"/// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; /// not on a hot code path.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:391,Testability,test,testing,391,"/// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; /// not on a hot code path.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:14,Performance,cache,cached,14,"/// Returns a cached copy of the page source descriptor. The returned pointer remains valid until the next call; /// to LoadEntry or to any of the views returned from the reader.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:120,Performance,Load,LoadEntry,120,"/// Returns a cached copy of the page source descriptor. The returned pointer remains valid until the next call; /// to LoadEntry or to any of the views returned from the reader.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:115,Availability,error,errors,115,"/// Analogous to Fill(), fills the default entry of the model. Returns false at the end of the ntuple.; /// On I/O errors, raises an exception.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:35,Integrability,depend,depending,35,"// TODO(jblomer): can be templated depending on the factory method / constructor",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:13,Security,access,access,13,"/// Provides access to an individual field that can contain either a scalar value or a collection, e.g.; /// GetView<double>(""particles.pt"") or GetView<std::vector<double>>(""particle""). It can as well be the index; /// field of a collection itself, like GetView<NTupleSize_t>(""particle"").; ///; /// Raises an exception if there is no field with the given name.; ///; /// **Example: iterate over a field named ""pt"" of type `float`**; /// ~~~ {.cpp}; /// #include <ROOT/RNTupleReader.hxx>; /// using ROOT::Experimental::RNTupleReader;; ///; /// #include <iostream>; ///; /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; /// auto pt = ntuple->GetView<float>(""pt"");; ///; /// for (auto i : ntuple->GetEntryRange()) {; /// std::cout << i << "": "" << pt(i) << ""\n"";; /// }; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:11,Performance,perform,performance,11,"/// Enable performance measurements (decompression time, bytes read from storage, etc.); ///; /// **Example: inspect the reader metrics after loading every entry**; /// ~~~ {.cpp}; /// #include <ROOT/RNTupleReader.hxx>; /// using ROOT::Experimental::ENTupleInfo;; /// using ROOT::Experimental::RNTupleReader;; ///; /// #include <iostream>; ///; /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; /// // metrics must be turned on beforehand; /// ntuple->EnableMetrics();; ///; /// for (auto i : ntuple->GetEntryRange()) {; /// ntuple->LoadEntry(i);; /// }; /// ntuple->PrintInfo(ENTupleInfo::kMetrics);; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:142,Performance,load,loading,142,"/// Enable performance measurements (decompression time, bytes read from storage, etc.); ///; /// **Example: inspect the reader metrics after loading every entry**; /// ~~~ {.cpp}; /// #include <ROOT/RNTupleReader.hxx>; /// using ROOT::Experimental::ENTupleInfo;; /// using ROOT::Experimental::RNTupleReader;; ///; /// #include <iostream>; ///; /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; /// // metrics must be turned on beforehand; /// ntuple->EnableMetrics();; ///; /// for (auto i : ntuple->GetEntryRange()) {; /// ntuple->LoadEntry(i);; /// }; /// ntuple->PrintInfo(ENTupleInfo::kMetrics);; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:553,Performance,Load,LoadEntry,553,"/// Enable performance measurements (decompression time, bytes read from storage, etc.); ///; /// **Example: inspect the reader metrics after loading every entry**; /// ~~~ {.cpp}; /// #include <ROOT/RNTupleReader.hxx>; /// using ROOT::Experimental::ENTupleInfo;; /// using ROOT::Experimental::RNTupleReader;; ///; /// #include <iostream>; ///; /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; /// // metrics must be turned on beforehand; /// ntuple->EnableMetrics();; ///; /// for (auto i : ntuple->GetEntryRange()) {; /// ntuple->LoadEntry(i);; /// }; /// ntuple->PrintInfo(ENTupleInfo::kMetrics);; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReadOptions.hxx:244,Usability,Feedback,Feedback,244,"/// \file ROOT/RNTupleReadOptions.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleReadOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReadOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:303,Usability,Feedback,Feedback,303,"/// \file ROOT/RNTupleSerialize.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>; /// \date 2021-08-02; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:530,Availability,error,errors,530,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleSerializer; \ingroup NTuple; \brief A helper class for serializing and deserialization of the RNTuple binary format. All serialization and deserialization routines return the number of bytes processed (written or read). The serialization routines can be called with a nullptr buffer, in which case only the size required to perform; a serialization is returned. Deserialization routines must be called with a buffer that is sufficiently large. Deserialization errors throw exceptions. Only when indicated or when passed as a parameter is the buffer size checked.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:225,Integrability,rout,routines,225,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleSerializer; \ingroup NTuple; \brief A helper class for serializing and deserialization of the RNTuple binary format. All serialization and deserialization routines return the number of bytes processed (written or read). The serialization routines can be called with a nullptr buffer, in which case only the size required to perform; a serialization is returned. Deserialization routines must be called with a buffer that is sufficiently large. Deserialization errors throw exceptions. Only when indicated or when passed as a parameter is the buffer size checked.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:308,Integrability,rout,routines,308,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleSerializer; \ingroup NTuple; \brief A helper class for serializing and deserialization of the RNTuple binary format. All serialization and deserialization routines return the number of bytes processed (written or read). The serialization routines can be called with a nullptr buffer, in which case only the size required to perform; a serialization is returned. Deserialization routines must be called with a buffer that is sufficiently large. Deserialization errors throw exceptions. Only when indicated or when passed as a parameter is the buffer size checked.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:448,Integrability,rout,routines,448,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleSerializer; \ingroup NTuple; \brief A helper class for serializing and deserialization of the RNTuple binary format. All serialization and deserialization routines return the number of bytes processed (written or read). The serialization routines can be called with a nullptr buffer, in which case only the size required to perform; a serialization is returned. Deserialization routines must be called with a buffer that is sufficiently large. Deserialization errors throw exceptions. Only when indicated or when passed as a parameter is the buffer size checked.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:394,Performance,perform,perform,394,"// clang-format off; /**; \class ROOT::Experimental::Internal::RNTupleSerializer; \ingroup NTuple; \brief A helper class for serializing and deserialization of the RNTuple binary format. All serialization and deserialization routines return the number of bytes processed (written or read). The serialization routines can be called with a nullptr buffer, in which case only the size required to perform; a serialization is returned. Deserialization routines must be called with a buffer that is sufficiently large. Deserialization errors throw exceptions. Only when indicated or when passed as a parameter is the buffer size checked.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:262,Testability,Log,Logical,262,"/// Map an in-memory column ID to its on-disk counterpart. It is allowed to call this function multiple times for; /// the same `memId`, in which case the return value is the on-disk ID assigned on the first call.; /// Note that we only map physical column IDs. Logical column IDs of alias columns are shifted before the; /// serialization of the extension header. Also, we only need to query physical column IDs for the page list; /// serialization.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:210,Deployability,update,update,210,"/// Map in-memory field and column IDs to their on-disk counterparts. This function is unconditionally called; /// during header serialization. This function must be manually called after an incremental schema update as page; /// list serialization requires all columns to be mapped.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:28,Security,checksum,checksum,28,"/// Writes a XxHash-3 64bit checksum of the byte range given by data and length.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:23,Security,checksum,checksum,23,"/// Expects an xxhash3 checksum in the 8 bytes following data + length and verifies it.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:103,Safety,avoid,avoid,103,"/// While we could just interpret the enums as ints, we make the translation explicit; /// in order to avoid accidentally changing the on-disk numbers when adjusting the enum classes.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:62,Security,checksum,checksum,62,"// The bufSize must include the 8 bytes for the final xxhash3 checksum.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:237,Usability,Feedback,Feedback,237,"/// \file ROOT/RNTupleUtil.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:4,Testability,Log,Log,4,"/// Log channel for RNTuple diagnostics.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:94,Availability,avail,available,94,"// clang-format off; /**; \class ROOT::Experimental::EColumnType; \ingroup NTuple; \brief The available trivial, native content types of a column. More complex types, such as classes, get translated into columns of such simple types by the RField.; When changed, remember to update; - RColumnElement::Generate(); - RColumnElement::GetTypeName(); - RColumnElement::GetValidBitRange(); - RColumnElement template specializations / packing & unpacking; - If necessary, endianess handling for the packing + unit test in ntuple_endian; - RNTupleSerializer::[Des|S]erializeColumnType; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:275,Deployability,update,update,275,"// clang-format off; /**; \class ROOT::Experimental::EColumnType; \ingroup NTuple; \brief The available trivial, native content types of a column. More complex types, such as classes, get translated into columns of such simple types by the RField.; When changed, remember to update; - RColumnElement::Generate(); - RColumnElement::GetTypeName(); - RColumnElement::GetValidBitRange(); - RColumnElement template specializations / packing & unpacking; - If necessary, endianess handling for the packing + unit test in ntuple_endian; - RNTupleSerializer::[Des|S]erializeColumnType; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:507,Testability,test,test,507,"// clang-format off; /**; \class ROOT::Experimental::EColumnType; \ingroup NTuple; \brief The available trivial, native content types of a column. More complex types, such as classes, get translated into columns of such simple types by the RField.; When changed, remember to update; - RColumnElement::Generate(); - RColumnElement::GetTypeName(); - RColumnElement::GetValidBitRange(); - RColumnElement template specializations / packing & unpacking; - If necessary, endianess handling for the packing + unit test in ntuple_endian; - RNTupleSerializer::[Des|S]erializeColumnType; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:220,Usability,simpl,simple,220,"// clang-format off; /**; \class ROOT::Experimental::EColumnType; \ingroup NTuple; \brief The available trivial, native content types of a column. More complex types, such as classes, get translated into columns of such simple types by the RField.; When changed, remember to update; - RColumnElement::Generate(); - RColumnElement::GetTypeName(); - RColumnElement::GetValidBitRange(); - RColumnElement template specializations / packing & unpacking; - If necessary, endianess handling for the packing + unit test in ntuple_endian; - RNTupleSerializer::[Des|S]erializeColumnType; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:4,Integrability,Wrap,Wrap,4,"/// Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:45,Safety,avoid,avoid,45,"/// Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:68,Integrability,depend,depend,68,"/// Generic information about the physical location of data. Values depend on the concrete storage type. E.g.,; /// for a local file `fPosition` might be a 64bit file offset. Referenced objects on storage can be compressed; /// and therefore we need to store their actual size.; /// TODO(jblomer): consider moving this to `RNTupleDescriptor`",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:87,Modifiability,extend,extended,87,"/// Simple on-disk locators consisting of a 64-bit offset use variant type `uint64_t`; extended locators have; /// `fPosition.index()` > 0",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:4,Usability,Simpl,Simple,4,"/// Simple on-disk locators consisting of a 64-bit offset use variant type `uint64_t`; extended locators have; /// `fPosition.index()` > 0",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx:237,Usability,Feedback,Feedback,237,"/// \file ROOT/RNTupleView.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-05; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx:151,Security,access,access,151,"// namespace Internal; // clang-format off; /**; \class ROOT::Experimental::RNTupleViewBase; \ingroup NTuple; \brief An RNTupleView provides read-only access to a single field of the ntuple. \tparam T The type of the object that will be read by the view; can be void if unknown at compile time. The view owns a field and its underlying columns in order to fill an RField::RValue object with data. Data can be; accessed by index. For top-level fields, the index refers to the entry number. Fields that are part of; nested collections have global index numbers that are derived from their parent indexes. View can only be created by a reader or by a collection view.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx:410,Security,access,accessed,410,"// namespace Internal; // clang-format off; /**; \class ROOT::Experimental::RNTupleViewBase; \ingroup NTuple; \brief An RNTupleView provides read-only access to a single field of the ntuple. \tparam T The type of the object that will be read by the view; can be void if unknown at compile time. The view owns a field and its underlying columns in order to fill an RField::RValue object with data. Data can be; accessed by index. For top-level fields, the index refers to the entry number. Fields that are part of; nested collections have global index numbers that are derived from their parent indexes. View can only be created by a reader or by a collection view.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx:138,Security,access,access,138,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDirectAccessView; \ingroup NTuple; \brief A view variant that provides direct access to the I/O buffers. Only works for mappable fields.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:245,Usability,Feedback,Feedback,245,"/// \file ROOT/RNTupleWriteOptions.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:538,Performance,tune,tuned,538,"/// The maximum size that the sum of all page buffers used for writing into a persistent sink are allowed to use.; /// If set to zero, RNTuple will auto-adjust the budget based on the value of fApproxZippedClusterSize.; /// If set manually, the size needs to be large enough to hold all initial page buffers.; /// The total amount of memory for writing is larger, e.g. for the additional compressed buffers etc.; /// Use RNTupleModel::EstimateWriteMemoryUsage() for the total estimated memory use for writing.; /// The default values are tuned for a total write memory of around 300 MB per fill context.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:175,Energy Efficiency,consumption,consumption,175,"/// Buffer size to use for writing to files, must be a multiple of 4096 bytes. Testing suggests that 4MiB gives best; /// performance (with Direct I/O) at a reasonable memory consumption.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:122,Performance,perform,performance,122,"/// Buffer size to use for writing to files, must be a multiple of 4096 bytes. Testing suggests that 4MiB gives best; /// performance (with Direct I/O) at a reasonable memory consumption.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:79,Testability,Test,Testing,79,"/// Buffer size to use for writing to files, must be a multiple of 4096 bytes. Testing suggests that 4MiB gives best; /// performance (with Direct I/O) at a reasonable memory consumption.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:28,Performance,multi-thread,multi-threading,28,"/// Whether to use implicit multi-threading to compress pages. Only has an effect if buffered writing is turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:12,Security,checksum,checksums,12,"/// If set, checksums will be calculated and written for every page.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:82,Performance,optimiz,optimization,82,"/// Note that turning off page checksums will also turn off the same page merging optimization (see tuning.md)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:31,Security,checksum,checksums,31,"/// Note that turning off page checksums will also turn off the same page merging optimization (see tuning.md)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptionsDaos.hxx:249,Usability,Feedback,Feedback,249,"/// \file ROOT/RNTupleWriteOptionsDaos.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptionsDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptionsDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:239,Usability,Feedback,Feedback,239,"/// \file ROOT/RNTupleWriter.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-20; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:607,Availability,error,errors,607,"// namespace Internal; // clang-format off; /**; \class ROOT::Experimental::RNTupleWriter; \ingroup NTuple; \brief An RNTuple that gets filled with entries (data) and writes them to storage. An output ntuple can be filled with entries. The caller has to make sure that the data that gets filled into an ntuple; is not modified for the time of the Fill() call. The fill call serializes the C++ object into the column format and; writes data into the corresponding column page buffers. Writing of the buffers to storage is deferred and can be; triggered by FlushCluster() or by destructing the writer. On I/O errors, an exception is thrown.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:46,Energy Efficiency,schedul,scheduler,46,"/// The page sink's parallel page compression scheduler if IMT is on.; /// Needs to be destructed after the page sink (in the fill context) is destructed and so declared before.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:33,Integrability,wrap,wrapping,33,"/// Create a writer, potentially wrapping the sink in a RPageSinkBuf.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:22,Integrability,interface,interface,22,"/// The simplest user interface if the default entry that comes with the ntuple model is used.; /// \return The number of uncompressed bytes written.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:8,Usability,simpl,simplest,8,"/// The simplest user interface if the default entry that comes with the ntuple model is used.; /// \return The number of uncompressed bytes written.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:88,Performance,perform,perform,88,"/// Multiple entries can have been instantiated from the ntuple model. This method will perform; /// a light check whether the entry comes from the ntuple's own model.; /// \return The number of uncompressed bytes written.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:57,Energy Efficiency,reduce,reduce,57,"/// Flush column data, preparing for CommitCluster or to reduce memory usage. This will trigger compression of pages,; /// but not actually write to storage (unless buffered writing is turned off).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:81,Deployability,update,updates,81,"/// Get a `RNTupleModel::RUpdater` that provides limited support for incremental updates to the underlying; /// model, e.g. addition of new fields.; ///; /// **Example: add a new field after the model has been used to construct a `RNTupleWriter` object**; /// ~~~ {.cpp}; /// #include <ROOT/RNTuple.hxx>; /// using ROOT::Experimental::RNTupleModel;; /// using ROOT::Experimental::RNTupleWriter;; ///; /// auto model = RNTupleModel::Create();; /// auto fldFloat = model->MakeField<float>(""fldFloat"");; /// auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""some/file.root"");; /// auto updater = writer->CreateModelUpdater();; /// updater->BeginUpdate();; /// updater->AddField(std::make_unique<RField<float>>(""pt""));; /// updater->CommitUpdate();; ///; /// // ...; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:602,Deployability,update,updater,602,"/// Get a `RNTupleModel::RUpdater` that provides limited support for incremental updates to the underlying; /// model, e.g. addition of new fields.; ///; /// **Example: add a new field after the model has been used to construct a `RNTupleWriter` object**; /// ~~~ {.cpp}; /// #include <ROOT/RNTuple.hxx>; /// using ROOT::Experimental::RNTupleModel;; /// using ROOT::Experimental::RNTupleWriter;; ///; /// auto model = RNTupleModel::Create();; /// auto fldFloat = model->MakeField<float>(""fldFloat"");; /// auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""some/file.root"");; /// auto updater = writer->CreateModelUpdater();; /// updater->BeginUpdate();; /// updater->AddField(std::make_unique<RField<float>>(""pt""));; /// updater->CommitUpdate();; ///; /// // ...; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:647,Deployability,update,updater,647,"/// Get a `RNTupleModel::RUpdater` that provides limited support for incremental updates to the underlying; /// model, e.g. addition of new fields.; ///; /// **Example: add a new field after the model has been used to construct a `RNTupleWriter` object**; /// ~~~ {.cpp}; /// #include <ROOT/RNTuple.hxx>; /// using ROOT::Experimental::RNTupleModel;; /// using ROOT::Experimental::RNTupleWriter;; ///; /// auto model = RNTupleModel::Create();; /// auto fldFloat = model->MakeField<float>(""fldFloat"");; /// auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""some/file.root"");; /// auto updater = writer->CreateModelUpdater();; /// updater->BeginUpdate();; /// updater->AddField(std::make_unique<RField<float>>(""pt""));; /// updater->CommitUpdate();; ///; /// // ...; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:676,Deployability,update,updater,676,"/// Get a `RNTupleModel::RUpdater` that provides limited support for incremental updates to the underlying; /// model, e.g. addition of new fields.; ///; /// **Example: add a new field after the model has been used to construct a `RNTupleWriter` object**; /// ~~~ {.cpp}; /// #include <ROOT/RNTuple.hxx>; /// using ROOT::Experimental::RNTupleModel;; /// using ROOT::Experimental::RNTupleWriter;; ///; /// auto model = RNTupleModel::Create();; /// auto fldFloat = model->MakeField<float>(""fldFloat"");; /// auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""some/file.root"");; /// auto updater = writer->CreateModelUpdater();; /// updater->BeginUpdate();; /// updater->AddField(std::make_unique<RField<float>>(""pt""));; /// updater->CommitUpdate();; ///; /// // ...; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:739,Deployability,update,updater,739,"/// Get a `RNTupleModel::RUpdater` that provides limited support for incremental updates to the underlying; /// model, e.g. addition of new fields.; ///; /// **Example: add a new field after the model has been used to construct a `RNTupleWriter` object**; /// ~~~ {.cpp}; /// #include <ROOT/RNTuple.hxx>; /// using ROOT::Experimental::RNTupleModel;; /// using ROOT::Experimental::RNTupleWriter;; ///; /// auto model = RNTupleModel::Create();; /// auto fldFloat = model->MakeField<float>(""fldFloat"");; /// auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""some/file.root"");; /// auto updater = writer->CreateModelUpdater();; /// updater->BeginUpdate();; /// updater->AddField(std::make_unique<RField<float>>(""pt""));; /// updater->CommitUpdate();; ///; /// // ...; /// ~~~",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleZip.hxx:236,Usability,Feedback,Feedback,236,"/// \file ROOT/RNTupleZip.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-11-21; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RNTupleZip.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleZip.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx:231,Usability,Feedback,Feedback,231,"/// \file ROOT/RPage.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx:653,Deployability,release,release,653,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPage; \ingroup NTuple; \brief A page is a slice of a column that is mapped into memory. The page provides an opaque memory buffer for uncompressed, unpacked data. It does not interpret; the contents but it does now about the size (and thus the number) of the elements inside as well as the element; number range within the backing column/cluster.; For reading, pages are allocated and filled by the page source and then registered with the page pool.; For writing, the page sink allocates uninitialized pages of a given size.; The page has a pointer to its memory allocator so that it can release itself.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx:435,Energy Efficiency,allocate,allocated,435,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPage; \ingroup NTuple; \brief A page is a slice of a column that is mapped into memory. The page provides an opaque memory buffer for uncompressed, unpacked data. It does not interpret; the contents but it does now about the size (and thus the number) of the elements inside as well as the element; number range within the backing column/cluster.; For reading, pages are allocated and filled by the page source and then registered with the page pool.; For writing, the page sink allocates uninitialized pages of a given size.; The page has a pointer to its memory allocator so that it can release itself.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx:543,Energy Efficiency,allocate,allocates,543,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPage; \ingroup NTuple; \brief A page is a slice of a column that is mapped into memory. The page provides an opaque memory buffer for uncompressed, unpacked data. It does not interpret; the contents but it does now about the size (and thus the number) of the elements inside as well as the element; number range within the backing column/cluster.; For reading, pages are allocated and filled by the page source and then registered with the page pool.; For writing, the page sink allocates uninitialized pages of a given size.; The page has a pointer to its memory allocator so that it can release itself.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx:26,Energy Efficiency,allocate,allocate,26,"/// The allocator used to allocate fBuffer. Can be null if the buffer doesn't need to be freed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:240,Usability,Feedback,Feedback,240,"/// \file ROOT/RPageAllocator.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-06-25; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:138,Deployability,release,release,138,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:185,Deployability,release,releases,185,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:125,Energy Efficiency,allocate,allocate,125,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:112,Integrability,interface,interface,112,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:224,Performance,load,load,224,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:390,Safety,safe,safe,390,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:4,Deployability,Release,Releases,4,"/// Releases the memory pointed to by page and resets the page's information. Note that the memory of the; /// zero page must not be deleted. Called by the RPage destructor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageNullSink.hxx:248,Usability,Feedback,Feedback,248,"/// \file ROOT/RPageNullSink.hxx; /// \ingroup NTuple ROOT7; /// \author Jonas Hahnfeld <jonas.hahnfeld@cern.ch>; /// \date 2024-01-31; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageNullSink.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageNullSink.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageNullSink.hxx:157,Testability,test,testing,157,"/**; \class ROOT::Experimental::Internal::RPageNullSink; \ingroup NTuple; \brief Dummy sink that discards all pages. The RPageNullSink class is for internal testing only and can be used to measure the software overhead of serializing; elements into pages, without actually writing them onto disk or even serializing the RNTuple headers and footers.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageNullSink.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageNullSink.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:235,Usability,Feedback,Feedback,235,"/// \file ROOT/RPagePool.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:112,Performance,cache,cache,112,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:127,Performance,load,loaded,127,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:183,Performance,cache,cache,183,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:199,Performance,load,loaded,199,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:296,Performance,load,loaded,296,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:107,Safety,safe,safe,107,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:32,Energy Efficiency,efficient,efficient,32,"/// TODO(jblomer): should be an efficient index structure that allows; /// - random insert; /// - random delete; /// - searching by page",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:68,Performance,cache,cache,68,"/// Tries to find the page corresponding to column and index in the cache. If the page is found, its reference; /// counter is increased",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:345,Usability,Feedback,Feedback,345,"/// \file ROOT/RPageSinkBuf.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Max Orok <maxwellorok@gmail.com>; /// \author Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>; /// \date 2021-03-17; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:101,Integrability,Wrap,Wrapper,101,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageSinkBuf; \ingroup NTuple; \brief Wrapper sink that coalesces cluster column page writes; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:3,Safety,Safe,Safety,3,"// Safety: Insertion at the end of a deque never invalidates references; // to existing elements.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:45,Performance,concurren,concurrent,45,"/// Pages that have been already sealed by a concurrent task. A vector commit can be issued if all; /// buffered pages have been sealed.; /// Note that each RSealedPage refers to the same buffer as `fBufferedPages[i].fBuf` for some value of `i`, and; /// thus owned by RPageZipItem",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:8,Performance,perform,performance,8,"/// I/O performance counters that get registered in fMetrics",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:45,Performance,perform,performing,45,"/// The inner sink, responsible for actually performing I/O.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx:244,Usability,Feedback,Feedback,244,"/// \file ROOT/RPageSourceFriends.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2020-08-10; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx:281,Deployability,patch,patch,281,"/// TODO(jblomer): Not only the columns, but actually all the different objects of the descriptor would need; /// their own maps to avoid descriptor ID clashes. The need for the distinct column map was triggered by adding; /// support for multi-column representations. A follow-up patch should either fix the friend page source properly; /// or remove it in favor of the RNTupleProcessor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx:132,Safety,avoid,avoid,132,"/// TODO(jblomer): Not only the columns, but actually all the different objects of the descriptor would need; /// their own maps to avoid descriptor ID clashes. The need for the distinct column map was triggered by adding; /// support for multi-column representations. A follow-up patch should either fix the friend page source properly; /// or remove it in favor of the RNTupleProcessor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx:31,Performance,Load,LoadPage,31,"// Unused because we overwrite LoadPage()",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:238,Usability,Feedback,Feedback,238,"/// \file ROOT/RPageStorage.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-07-19; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:197,Security,access,access,197,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageStorage; \ingroup NTuple; \brief Common functionality of an ntuple storage for both reading and writing. The RPageStore provides access to a storage container that keeps the bits of pages and clusters comprising; an ntuple. Concrete implementations can use a TFile, a raw file, an object store, and so on.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:13,Security,checksum,checksum,13,"/// The page checksum is a 64bit xxhash3",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:28,Energy Efficiency,schedul,scheduler,28,"/// The interface of a task scheduler to schedule page (de)compression tasks",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:41,Energy Efficiency,schedul,schedule,41,"/// The interface of a task scheduler to schedule page (de)compression tasks",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:8,Integrability,interface,interface,8,"/// The interface of a task scheduler to schedule page (de)compression tasks",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:21,Energy Efficiency,schedul,scheduled,21,"/// Blocks until all scheduled tasks finished",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:60,Availability,avail,available,60,"///< Size of the page payload and the trailing checksum (if available)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:47,Security,checksum,checksum,47,"///< Size of the page payload and the trailing checksum (if available)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:14,Availability,failure,failure,14,"/// Returns a failure if the sealed page has no checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:48,Security,checksum,checksum,48,"/// Returns a failure if the sealed page has no checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:30,Energy Efficiency,allocate,allocated,30,"/// Flush columns in order of allocated write page size until the sum of all write page allocations; /// leaves space for at least targetAvailableSize bytes. Only use columns with a write page size larger; /// than pageSizeLimit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:143,Availability,avail,available,143,"/// Try to register the new write page size for the given column. Flush large columns to make space, if necessary.; /// If not enough space is available after all (sum of write pages would be larger than fMaxAllocatedBytes),; /// return false.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:107,Integrability,interface,interface,107,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageSink; \ingroup NTuple; \brief Abstract interface to write data into an ntuple. The page sink takes the list of columns and afterwards a series of page commits and cluster commits.; The user is responsible to commit clusters at a consistent point, i.e. when all pages corresponding to data; up to the given entry number are committed. An object of this class may either be a wrapper (for example a RPageSinkBuf) or a ""persistent"" sink,; inheriting from RPagePersistentSink.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:442,Integrability,wrap,wrapper,442,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageSink; \ingroup NTuple; \brief Abstract interface to write data into an ntuple. The page sink takes the list of columns and afterwards a series of page commits and cluster commits.; The user is responsible to commit clusters at a consistent point, i.e. when all pages corresponding to data; up to the given entry number are committed. An object of this class may either be a wrapper (for example a RPageSinkBuf) or a ""persistent"" sink,; inheriting from RPagePersistentSink.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:504,Modifiability,inherit,inheriting,504,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageSink; \ingroup NTuple; \brief Abstract interface to write data into an ntuple. The page sink takes the list of columns and afterwards a series of page commits and cluster commits.; The user is responsible to commit clusters at a consistent point, i.e. when all pages corresponding to data; up to the given entry number are committed. An object of this class may either be a wrapper (for example a RPageSinkBuf) or a ""persistent"" sink,; inheriting from RPagePersistentSink.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:41,Testability,log,logically,41,"/// Cluster that was staged, but not yet logically appended to the RNTuple",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:178,Security,checksum,checksummed,178,"/// Helper for streaming a page. This is commonly used in derived, concrete page sinks. Note that if; /// compressionSetting is 0 (uncompressed) and the page is mappable and not checksummed, the returned sealed page; /// will point directly to the input page buffer. Otherwise, the sealed page references an internal buffer; /// of fCompressor. Thus, the buffer pointed to by the RSealedPage should never be freed.; /// Usage of this method requires construction of fCompressor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:39,Usability,simpl,simple,39,"///< Used as destination buffer in the simple SealPage overload; /// Used in ReservePage to maintain the page buffer budget",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:87,Security,checksum,checksum,87,"///< Compression algorithm and level to apply; /// Adds a 8 byte little-endian xxhash3 checksum to the page payload. The buffer has to be large enough to; /// to store the additional 8 bytes.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:146,Testability,log,logically,146,"/// Stage the current cluster and create a new one for the following data.; /// Returns the object that must be passed to CommitStagedClusters to logically append the staged cluster to the; /// ntuple descriptor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:28,Testability,log,logically,28,"/// Commit staged clusters, logically appending them to the ntuple descriptor.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:12,Integrability,wrap,wrapper,12,"/// An RAII wrapper used to synchronize a page sink. See GetSinkGuard().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:28,Integrability,synchroniz,synchronize,28,"/// An RAII wrapper used to synchronize a page sink. See GetSinkGuard().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:16,Performance,perform,performance,16,"/// Default I/O performance counters that get registered in fMetrics",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:382,Availability,mask,mask,382,"/// Vector commit of preprocessed pages. The `ranges` array specifies a range of sealed pages to be; /// committed for each column. The returned vector contains, in order, the RNTupleLocator for each; /// page on each range in `ranges`, i.e. the first N entries refer to the N pages in `ranges[0]`,; /// followed by M entries that refer to the M pages in `ranges[1]`, etc.; /// The mask allows to skip writing out certain pages. The vector has the size of all the pages.; /// For every `false` value in the mask, the corresponding locator is skipped (missing) in the output vector.; /// The default is to call `CommitSealedPageImpl` for each page; derived classes may provide an; /// optimized implementation though.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:507,Availability,mask,mask,507,"/// Vector commit of preprocessed pages. The `ranges` array specifies a range of sealed pages to be; /// committed for each column. The returned vector contains, in order, the RNTupleLocator for each; /// page on each range in `ranges`, i.e. the first N entries refer to the N pages in `ranges[0]`,; /// followed by M entries that refer to the M pages in `ranges[1]`, etc.; /// The mask allows to skip writing out certain pages. The vector has the size of all the pages.; /// For every `false` value in the mask, the corresponding locator is skipped (missing) in the output vector.; /// The default is to call `CommitSealedPageImpl` for each page; derived classes may provide an; /// optimized implementation though.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:684,Performance,optimiz,optimized,684,"/// Vector commit of preprocessed pages. The `ranges` array specifies a range of sealed pages to be; /// committed for each column. The returned vector contains, in order, the RNTupleLocator for each; /// page on each range in `ranges`, i.e. the first N entries refer to the N pages in `ranges[0]`,; /// followed by M entries that refer to the M pages in `ranges[1]`, etc.; /// The mask allows to skip writing out certain pages. The vector has the size of all the pages.; /// For every `false` value in the mask, the corresponding locator is skipped (missing) in the output vector.; /// The default is to call `CommitSealedPageImpl` for each page; derived classes may provide an; /// optimized implementation though.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:203,Modifiability,extend,extended,203,"/// Enables the default set of metrics provided by RPageSink. `prefix` will be used as the prefix for; /// the counters registered in the internal RNTupleMetrics object.; /// This set of counters can be extended by a subclass by calling `fMetrics.MakeCounter<...>()`.; ///; /// A subclass using the default set of metrics is always responsible for updating the counters; /// appropriately, e.g. `fCounters->fNPageCommited.Inc()`",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:4,Deployability,Update,Updates,4,"/// Updates the descriptor and calls InitImpl() that handles the backend-specific details (file, DAOS, etc.)",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:139,Integrability,interface,interface,139,"// class RPagePersistentSink; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSource; \ingroup NTuple; \brief Abstract interface to read data from an ntuple. The page source is initialized with the columns of interest. Alias columns from projected fields are mapped to the; corresponding physical columns. Pages from the columns of interest can then be mapped into memory.; The page source also gives access to the ntuple's meta-data.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:421,Security,access,access,421,"// class RPagePersistentSink; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSource; \ingroup NTuple; \brief Abstract interface to read data from an ntuple. The page source is initialized with the columns of interest. Alias columns from projected fields are mapped to the; corresponding physical columns. Pages from the columns of interest can then be mapped into memory.; The page source also gives access to the ntuple's meta-data.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:12,Integrability,wrap,wrapper,12,"/// An RAII wrapper used for the read-only access to `RPageSource::fDescriptor`. See `GetExclDescriptorGuard()``.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:43,Security,access,access,43,"/// An RAII wrapper used for the read-only access to `RPageSource::fDescriptor`. See `GetExclDescriptorGuard()``.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:12,Integrability,wrap,wrapper,12,"/// An RAII wrapper used for the writable access to `RPageSource::fDescriptor`. See `GetSharedDescriptorGuard()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:42,Security,access,access,42,"/// An RAII wrapper used for the writable access to `RPageSource::fDescriptor`. See `GetSharedDescriptorGuard()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:23,Performance,Load,LoadStructure,23,"///< Set to true once `LoadStructure()` is called",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:16,Performance,perform,performance,16,"/// Default I/O performance counters that get registered in `fMetrics`",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:63,Performance,load,load,63,"/// Summarizes cluster-level information that are necessary to load a certain page.; /// Used by LoadPageImpl().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:97,Performance,Load,LoadPageImpl,97,"/// Summarizes cluster-level information that are necessary to load a certain page.; /// Used by LoadPageImpl().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:5,Performance,Load,LoadStructureImpl,5,"/// `LoadStructureImpl()` has been called before `AttachImpl()` is called",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:25,Energy Efficiency,schedul,scheduler,25,"// Only called if a task scheduler is set. No-op be default.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:249,Performance,Load,LoadClusters,249,"/// Prepare a page range read for the column set in `clusterKey`. Specifically, pages referencing the; /// `kTypePageZero` locator are filled in `pageZeroMap`; otherwise, `perPageFunc` is called for each page. This is; /// commonly used as part of `LoadClusters()` in derived classes.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:235,Performance,optimiz,optimization,235,"/// Helper for unstreaming a page. This is commonly used in derived, concrete page sources. The implementation; /// currently always makes a memory copy, even if the sealed page is uncompressed and in the final memory layout.; /// The optimization of directly mapping pages is left to the concrete page source implementations.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:79,Performance,concurren,concurrently,79,"/// Takes the read lock for the descriptor. Multiple threads can take the lock concurrently.; /// The underlying `std::shared_mutex`, however, is neither read nor write recursive:; /// within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special; /// care in sections protected by `GetSharedDescriptorGuard()` and `GetExclDescriptorGuard()` especially to avoid; /// that the locks are acquired indirectly (e.g. by a call to `GetNEntries()`). As a general guideline, no other; /// method of the page source should be called (directly or indirectly) in a guarded section.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:406,Safety,avoid,avoid,406,"/// Takes the read lock for the descriptor. Multiple threads can take the lock concurrently.; /// The underlying `std::shared_mutex`, however, is neither read nor write recursive:; /// within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special; /// care in sections protected by `GetSharedDescriptorGuard()` and `GetExclDescriptorGuard()` especially to avoid; /// that the locks are acquired indirectly (e.g. by a call to `GetNEntries()`). As a general guideline, no other; /// method of the page source should be called (directly or indirectly) in a guarded section.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:506,Usability,guid,guideline,506,"/// Takes the read lock for the descriptor. Multiple threads can take the lock concurrently.; /// The underlying `std::shared_mutex`, however, is neither read nor write recursive:; /// within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special; /// care in sections protected by `GetSharedDescriptorGuard()` and `GetExclDescriptorGuard()` especially to avoid; /// that the locks are acquired indirectly (e.g. by a call to `GetNEntries()`). As a general guideline, no other; /// method of the page source should be called (directly or indirectly) in a guarded section.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:4,Performance,Load,Loads,4,"/// Loads header and footer without decompressing or deserializing them. This can be used to asynchronously open; /// a file in the background. The method is idempotent and it is called as a first step in `Attach()`.; /// Pages sources may or may not make use of splitting loading and processing meta-data.; /// Therefore, `LoadStructure()` may do nothing and defer loading the meta-data to `Attach()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:273,Performance,load,loading,273,"/// Loads header and footer without decompressing or deserializing them. This can be used to asynchronously open; /// a file in the background. The method is idempotent and it is called as a first step in `Attach()`.; /// Pages sources may or may not make use of splitting loading and processing meta-data.; /// Therefore, `LoadStructure()` may do nothing and defer loading the meta-data to `Attach()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:324,Performance,Load,LoadStructure,324,"/// Loads header and footer without decompressing or deserializing them. This can be used to asynchronously open; /// a file in the background. The method is idempotent and it is called as a first step in `Attach()`.; /// Pages sources may or may not make use of splitting loading and processing meta-data.; /// Therefore, `LoadStructure()` may do nothing and defer loading the meta-data to `Attach()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:366,Performance,load,loading,366,"/// Loads header and footer without decompressing or deserializing them. This can be used to asynchronously open; /// a file in the background. The method is idempotent and it is called as a first step in `Attach()`.; /// Pages sources may or may not make use of splitting loading and processing meta-data.; /// Therefore, `LoadStructure()` may do nothing and defer loading the meta-data to `Attach()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:4,Energy Efficiency,Allocate,Allocates,4,"/// Allocates and fills a page that contains the index-th element. The default implementation searches; /// the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:127,Performance,Load,LoadPageImpl,127,"/// Allocates and fills a page that contains the index-th element. The default implementation searches; /// the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:24,Performance,Load,LoadPage,24,"/// Another version of `LoadPage` that allows to specify cluster-relative indexes.; /// Returns a default-constructed RPage for suppressed columns.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:405,Energy Efficiency,allocate,allocate,405,"/// Read the packed and compressed bytes of a page into the memory buffer provided by `sealedPage`. The sealed page; /// can be used subsequently in a call to `RPageSink::CommitSealedPage`.; /// The `fSize` and `fNElements` member of the sealedPage parameters are always set. If `sealedPage.fBuffer` is; /// `nullptr`, no data will be copied but the returned size information can be used by the caller to allocate a large; /// enough buffer and call `LoadSealedPage` again.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:451,Performance,Load,LoadSealedPage,451,"/// Read the packed and compressed bytes of a page into the memory buffer provided by `sealedPage`. The sealed page; /// can be used subsequently in a call to `RPageSink::CommitSealedPage`.; /// The `fSize` and `fNElements` member of the sealedPage parameters are always set. If `sealedPage.fBuffer` is; /// `nullptr`, no data will be copied but the returned size information can be used by the caller to allocate a large; /// enough buffer and call `LoadSealedPage` again.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:150,Performance,load,load,150,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:256,Performance,load,loaded,256,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:265,Performance,Load,LoadClusters,265,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:494,Performance,load,loading,494,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:515,Performance,Load,LoadClusters,515,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:616,Performance,concurren,concurrently,616,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:369,Energy Efficiency,schedul,scheduler,369,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:407,Energy Efficiency,schedul,scheduler,407,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:251,Performance,optimiz,optimization,251,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:441,Performance,multi-thread,multi-threading,441,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:280,Safety,safe,safely,280,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:248,Usability,Feedback,Feedback,248,"/// \file ROOT/RPageStorageDaos.hxx; /// \ingroup NTuple ROOT7; /// \author Javier Lopez-Gomez <j.lopez@cern.ch>; /// \date 2020-11-03; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:223,Energy Efficiency,allocate,allocated,223,"// struct RDaosNTupleAnchor; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSinkDaos; \ingroup NTuple; \brief Storage provider that writes ntuple pages to into a DAOS container. Currently, an object is allocated for ntuple metadata (anchor/header/footer).; Objects can correspond to pages or clusters of pages depending on the RNTuple-DAOS mapping strategy.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:331,Integrability,depend,depending,331,"// struct RDaosNTupleAnchor; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSinkDaos; \ingroup NTuple; \brief Storage provider that writes ntuple pages to into a DAOS container. Currently, an object is allocated for ntuple metadata (anchor/header/footer).; Objects can correspond to pages or clusters of pages depending on the RNTuple-DAOS mapping strategy.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:93,Availability,alive,alive,93,"/// \brief Underlying DAOS container. An internal `std::shared_ptr` keep the pool connection alive.; /// ISO C++ ensures the correct destruction order, i.e., `~RDaosContainer` is invoked first; /// (which calls `daos_cont_close()`; the destructor for the `std::shared_ptr<RDaosPool>` is invoked; /// after (which calls `daos_pool_disconect()`).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:43,Performance,load,loaded,43,"/// The last cluster from which a page got loaded. Points into fClusterPool->fPool",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:242,Usability,Feedback,Feedback,242,"/// \file ROOT/RPageStorageFile.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-11-21; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:217,Deployability,update,updates,217,"/// Subroutine of CommitSealedPageVImpl, used to perform a vector write of the (multi-)range of pages; /// contained in `batch`. The locators for the written pages are appended to `locators`.; /// This procedure also updates some internal metrics of the page sink, hence it's not const.; /// `batch` gets reset to size 0 after the writing is done (but its begin and end are not updated).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:378,Deployability,update,updated,378,"/// Subroutine of CommitSealedPageVImpl, used to perform a vector write of the (multi-)range of pages; /// contained in `batch`. The locators for the written pages are appended to `locators`.; /// This procedure also updates some internal metrics of the page sink, hence it's not const.; /// `batch` gets reset to size 0 after the writing is done (but its begin and end are not updated).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:49,Performance,perform,perform,49,"/// Subroutine of CommitSealedPageVImpl, used to perform a vector write of the (multi-)range of pages; /// contained in `batch`. The locators for the written pages are appended to `locators`.; /// This procedure also updates some internal metrics of the page sink, hence it's not const.; /// `batch` gets reset to size 0 after the writing is done (but its begin and end are not updated).",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:43,Performance,load,loaded,43,"/// The last cluster from which a page got loaded. Points into fClusterPool->fPool",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:17,Performance,Load,LoadStructureImpl,17,"/// Populated by LoadStructureImpl(), reset at the end of Attach()",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:24,Performance,Load,LoadClusters,24,"/// Helper function for LoadClusters: it prepares the memory buffer (page map) and the; /// read requests for a given cluster and columns. The reead requests are appended to; /// the provided vector. This way, requests can be collected for multiple clusters before; /// sending them to RRawFile::ReadV().",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:79,Availability,avail,available,79,"/// Used from the RNTuple class to build a datasource if the anchor is already available.; /// Requires the RNTuple object to be streamed from a file.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:642,Energy Efficiency,reduce,reduced,642,"/*; * (C) Copyright 2016-2018 Intel Corporation.; *; * Licensed under the Apache License, Version 2.0 (the ""License"");; * you may not use this file except in compliance with the License.; * You may obtain a copy of the License at; *; * http://www.apache.org/licenses/LICENSE-2.0; *; * Unless required by applicable law or agreed to in writing, software; * distributed under the License is distributed on an ""AS IS"" BASIS,; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.; * See the License for the specific language governing permissions and; * limitations under the License.; */; /**; * \file; *; * This file is a reduced version of `daos_xxx.h` headers that provides (simplified) declarations for use in; * libdaos_mock.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:697,Usability,simpl,simplified,697,"/*; * (C) Copyright 2016-2018 Intel Corporation.; *; * Licensed under the Apache License, Version 2.0 (the ""License"");; * you may not use this file except in compliance with the License.; * You may obtain a copy of the License at; *; * http://www.apache.org/licenses/LICENSE-2.0; *; * Unless required by applicable law or agreed to in writing, software; * distributed under the License is distributed on an ""AS IS"" BASIS,; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.; * See the License for the specific language governing permissions and; * limitations under the License.; */; /**; * \file; *; * This file is a reduced version of `daos_xxx.h` headers that provides (simplified) declarations for use in; * libdaos_mock.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:20,Performance,queue,queue,20,/** Event and event queue */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:47,Performance,scalab,scalable,47,/** Replicated object class which is extremely scalable for fetch. */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:32,Security,hash,hashed,32,"// default: multi-level KV with hashed [ad]keys",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:22,Security,access,accessed,22,/** Type of the value accessed in an IOD */,MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:6,Safety,Redund,Redundancy,6,"// OC Redundancy flags",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx:244,Usability,Feedback,Feedback,244,"/// \file ROOT/RField/Fundamental.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx:77,Availability,error,error,77,"// Instantiating this base template definition should never happen and is an error!",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldFundamental.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:250,Usability,Feedback,Feedback,250,"/// \file ROOT/RField/ProxiedCollection.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:176,Security,access,accessed,176,"// namespace Detail; /// The field for a class representing a collection of elements via `TVirtualCollectionProxy`.; /// Objects of such type behave as collections that can be accessed through the corresponding member functions in; /// `TVirtualCollectionProxy`. For STL collections, these proxies are provided. Custom classes need to implement the; /// corresponding member functions in `TVirtualCollectionProxy`. At a bare minimum, the user is required to provide an; /// implementation for the following functions in `TVirtualCollectionProxy`: `HasPointers()`, `GetProperties()`,; /// `GetValueClass()`, `GetType()`, `PushProxy()`, `PopProxy()`, `GetFunctionCreateIterators()`, `GetFunctionNext()`,; /// and `GetFunctionDeleteTwoIterators()`.; ///; /// The collection proxy for a given class can be set via `TClass::CopyCollectionProxy()`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:92,Safety,avoid,avoids,92,"/// Allows for iterating over the elements of a proxied collection. RCollectionIterableOnce avoids an additional; /// iterator copy (see `TVirtualCollectionProxy::GetFunctionCopyIterator`) and thus can only be iterated once.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:62,Integrability,depend,depending,62,"/// Two sets of functions to operate on iterators, to be used depending on the access type. The direction preserves; /// the meaning from TVirtualCollectionProxy, i.e. read from disk / write to disk, respectively",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:79,Security,access,access,79,"/// Two sets of functions to operate on iterators, to be used depending on the access type. The direction preserves; /// the meaning from TVirtualCollectionProxy, i.e. read from disk / write to disk, respectively",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:975,Integrability,wrap,wrapper,975,"/// The point here is that we can only tell at run time if a class has an associated collection proxy.; /// For compile time, in the first iteration of this PR we had an extra template argument that acted as a ""tag"" to; /// differentiate the RField specialization for classes with an associated collection proxy (inherits; /// `RProxiedCollectionField`) from the RField primary template definition (`RClassField`-derived), as in:; /// ```; /// auto field = std::make_unique<RField<MyClass>>(""klass"");; /// // vs; /// auto otherField = std::make_unique<RField<MyClass, ROOT::Experimental::TagIsCollectionProxy>>(""klass"");; /// ```; ///; /// That is convenient only for non-nested types, i.e. it doesn't work with, e.g. `RField<std::vector<MyClass>,; /// ROOT::Experimental::TagIsCollectionProxy>`, as the tag is not forwarded to the instantiation of the inner RField; /// (that for the value type of the vector). The following two possible solutions were considered:; /// - A wrapper type (much like `ntuple/v7/inc/ROOT/RNTupleUtil.hxx:49`), that helps to differentiate both cases.; /// There we would have:; /// ```; /// auto field = std::make_unique<RField<RProxiedCollection<MyClass>>>(""klass""); // Using collection proxy; /// ```; /// - A helper `IsCollectionProxy<T>` type, that can be used in a similar way to those in the `<type_traits>` header.; /// We found this more convenient and is the implemented thing below. Here, classes can be marked as a; /// collection proxy with either of the following two forms (whichever is more convenient for the user):; /// ```; /// template <>; /// struct IsCollectionProxy<MyClass> : std::true_type {};; /// ```; /// or by adding a member type to the class as follows:; /// ```; /// class MyClass {; /// public:; /// using IsCollectionProxy = std::true_type;; /// };; /// ```; ///; /// Of course, there is another possible solution which is to have a single `RClassField` that implements both; /// the regular-class and the collection-proxy behaviors, and ",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:313,Modifiability,inherit,inherits,313,"/// The point here is that we can only tell at run time if a class has an associated collection proxy.; /// For compile time, in the first iteration of this PR we had an extra template argument that acted as a ""tag"" to; /// differentiate the RField specialization for classes with an associated collection proxy (inherits; /// `RProxiedCollectionField`) from the RField primary template definition (`RClassField`-derived), as in:; /// ```; /// auto field = std::make_unique<RField<MyClass>>(""klass"");; /// // vs; /// auto otherField = std::make_unique<RField<MyClass, ROOT::Experimental::TagIsCollectionProxy>>(""klass"");; /// ```; ///; /// That is convenient only for non-nested types, i.e. it doesn't work with, e.g. `RField<std::vector<MyClass>,; /// ROOT::Experimental::TagIsCollectionProxy>`, as the tag is not forwarded to the instantiation of the inner RField; /// (that for the value type of the vector). The following two possible solutions were considered:; /// - A wrapper type (much like `ntuple/v7/inc/ROOT/RNTupleUtil.hxx:49`), that helps to differentiate both cases.; /// There we would have:; /// ```; /// auto field = std::make_unique<RField<RProxiedCollection<MyClass>>>(""klass""); // Using collection proxy; /// ```; /// - A helper `IsCollectionProxy<T>` type, that can be used in a similar way to those in the `<type_traits>` header.; /// We found this more convenient and is the implemented thing below. Here, classes can be marked as a; /// collection proxy with either of the following two forms (whichever is more convenient for the user):; /// ```; /// template <>; /// struct IsCollectionProxy<MyClass> : std::true_type {};; /// ```; /// or by adding a member type to the class as follows:; /// ```; /// class MyClass {; /// public:; /// using IsCollectionProxy = std::true_type;; /// };; /// ```; ///; /// Of course, there is another possible solution which is to have a single `RClassField` that implements both; /// the regular-class and the collection-proxy behaviors, and ",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:103,Integrability,interface,interface,103,"/// Classes behaving as a collection of elements that can be queried via the `TVirtualCollectionProxy` interface; /// The use of a collection proxy for a particular class can be enabled via:; /// ```; /// namespace ROOT::Experimental {; /// template <> struct IsCollectionProxy<Classname> : std::true_type {};; /// }; /// ```; /// Alternatively, this can be achieved by adding a member type to the class definition as follows:; /// ```; /// class Classname {; /// public:; /// using IsCollectionProxy = std::true_type;; /// };; /// ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx:244,Usability,Feedback,Feedback,244,"/// \file ROOT/RField/Fundamental.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx:53,Integrability,depend,dependent,53,"// Trailing padding: although this is implementation-dependent, most add enough padding to comply with the; // requirements of the type with strictest alignment",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldRecord.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSequenceContainer.hxx:250,Usability,Feedback,Feedback,250,"/// \file ROOT/RField/SequenceContainer.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldSequenceContainer.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSequenceContainer.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSequenceContainer.hxx:37,Usability,simpl,simple,37,"/// Sub field deleter or nullptr for simple fields",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldSequenceContainer.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSequenceContainer.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx:240,Usability,Feedback,Feedback,240,"/// \file ROOT/RField/STLMisc.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx:641,Availability,avail,available,641,"////////////////////////////////////////////////////////////////////////////////; /// Template specializations for C++ std::optional and std::unique_ptr; ////////////////////////////////////////////////////////////////////////////////; /// The field for values that may or may not be present in an entry. Parent class for unique pointer field and; /// optional field. A nullable field cannot be instantiated itself but only its descendants.; /// The RNullableField takes care of the on-disk representation. Child classes are responsible for the in-memory; /// representation. Nullable fields use a (Split)Index[64|32] column to point to the available items.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx:322,Usability,simpl,simplicity,322,"// Most compilers support at least 255 variants (256 - 1 value for the empty variant).; // Some compilers switch to a two-byte tag field already with 254 variants.; // MSVC only supports 163 variants in older versions, 250 in newer ones. It switches to a 2 byte; // tag as of 128 variants (at least in debug mode), so for simplicity we set the limit to 125 variants.",MatchSource.CODE_COMMENT,tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RCluster.cxx:229,Usability,Feedback,Feedback,229,"/// \file RCluster.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2020-03-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RCluster.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RCluster.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:233,Usability,Feedback,Feedback,233,"/// \file RClusterPool.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2020-03-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:150,Performance,queue,queue,150,"// `kInvalidDescriptorId` is used as a marker for thread cancellation. Such item causes the; // thread to terminate; thus, it must appear last in the queue.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:148,Usability,simpl,simply,148,"// Meanwhile, the user might have requested clusters outside the look-ahead window, so that we don't; // need the cluster anymore, in which case we simply discard it right away, before moving it to the pool",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:69,Performance,load,loaded,69,"/// Helper class for the (cluster, column list) pairs that should be loaded in the background",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:75,Availability,avail,available,75,"// Determine following cluster ids and the column ids that we want to make available",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:33,Performance,cache,cache,33,"// descriptorGuard; // Clear the cache from clusters not the in the look-ahead or the look-back window",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:23,Usability,Clear,Clear,23,"// descriptorGuard; // Clear the cache from clusters not the in the look-ahead or the look-back window",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:45,Performance,cache,cache,45,"// Move clusters that meanwhile arrived into cache pool",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:130,Performance,cache,cached,130,"// This lock is held during iteration over several data structures: the collection of in-flight clusters,; // the current pool of cached clusters, and the set of cluster ids to be preloaded.; // All three collections are expected to be small (certainly < 100, more likely < 10). All operations; // are non-blocking and moving around small items (pointers, ids, etc). Thus the overall locking time should; // still be reasonably small and the lock is rarely taken (usually once per cluster).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:46,Energy Efficiency,schedul,scheduled,46,"// Remove the set of columns that are already scheduled for being loaded",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:66,Performance,load,loaded,66,"// Remove the set of columns that are already scheduled for being loaded",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:62,Deployability,release,released,62,"// If cptr is nullptr, the cluster expired previously and was released by the I/O thread",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:42,Energy Efficiency,schedul,scheduler,42,"// Noop unless the page source has a task scheduler",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:57,Performance,load,loading,57,"// Determine clusters which get triggered for background loading",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:3,Deployability,Update,Update,3,"// Update the work queue and the in-flight cluster list with new requests. We already hold the work queue; // mutex; // TODO(jblomer): we should ensure that clusterId is given first to the I/O thread. That is usually the; // case but it's not ensured by the code",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:19,Performance,queue,queue,19,"// Update the work queue and the in-flight cluster list with new requests. We already hold the work queue; // mutex; // TODO(jblomer): we should ensure that clusterId is given first to the I/O thread. That is usually the; // case but it's not ensured by the code",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:100,Performance,queue,queue,100,"// Update the work queue and the in-flight cluster list with new requests. We already hold the work queue; // mutex; // TODO(jblomer): we should ensure that clusterId is given first to the I/O thread. That is usually the; // case but it's not ensured by the code",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:8,Performance,queue,queue,8,"// work queue lock guard",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:63,Performance,cache,cache,63,"// Fast exit: the cluster happens to be already present in the cache pool",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:59,Performance,load,loading,59,"// Otherwise the missing data must have been triggered for loading by now, so block and wait",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:312,Deployability,release,released,312,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:333,Deployability,release,release,333,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:47,Performance,concurren,concurrently,47,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:229,Safety,safe,safe,229,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:38,Security,access,accessed,38,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:237,Security,access,access,237,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:42,Energy Efficiency,schedul,scheduler,42,"// Noop unless the page source has a task scheduler",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RClusterPool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumn.cxx:228,Usability,Feedback,Feedback,228,"/// \file RColumn.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumn.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:235,Usability,Feedback,Feedback,235,"/// \file RColumnElement.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-08-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:54,Availability,avail,available,54,"// TODO: Change to std::float16_t in-memory type once available (from C++23).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:59,Performance,load,loaded,59,"// bit offset of the next packed item inside the currently loaded word",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:3,Performance,load,load,3,"// load the next word, containing some packed items",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:28,Performance,load,loaded,28,"// isolate each item in the loaded word",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx:23,Performance,load,load,23,"// Check if we need to load a split item or a full one",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:520,Integrability,interface,interface,520,"// RColumnElement concrete implementations; //; // Note that this file is in the src directory and not in the inc directory because we need the ability; // to override R__LITTLE_ENDIAN for testing purposes.; // This is not a particularly clean or correct solution, as the tests that do this will end up with two different; // definitions of some RColumnElements, so we might want to change this mechanism in the future. In any case, these; // definitions are implementation details and should not be exposed to a public interface.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:500,Security,expose,exposed,500,"// RColumnElement concrete implementations; //; // Note that this file is in the src directory and not in the inc directory because we need the ability; // to override R__LITTLE_ENDIAN for testing purposes.; // This is not a particularly clean or correct solution, as the tests that do this will end up with two different; // definitions of some RColumnElements, so we might want to change this mechanism in the future. In any case, these; // definitions are implementation details and should not be exposed to a public interface.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:189,Testability,test,testing,189,"// RColumnElement concrete implementations; //; // Note that this file is in the src directory and not in the inc directory because we need the ability; // to override R__LITTLE_ENDIAN for testing purposes.; // This is not a particularly clean or correct solution, as the tests that do this will end up with two different; // definitions of some RColumnElements, so we might want to change this mechanism in the future. In any case, these; // definitions are implementation details and should not be exposed to a public interface.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:272,Testability,test,tests,272,"// RColumnElement concrete implementations; //; // Note that this file is in the src directory and not in the inc directory because we need the ability; // to override R__LITTLE_ENDIAN for testing purposes.; // This is not a particularly clean or correct solution, as the tests that do this will end up with two different; // definitions of some RColumnElements, so we might want to change this mechanism in the future. In any case, these; // definitions are implementation details and should not be exposed to a public interface.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:14,Testability,test,tests,14,"// NOTE: some tests might define R__LITTLE_ENDIAN to simulate a different-endianness machine",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:24,Safety,safe,safe,24,"/// Returns the minimum safe size (in bytes) of a buffer that is intended to be used as a destination for PackBits; /// or a source for UnpackBits.; /// Passing a buffer that's less than this size will cause invalid memory reads and writes.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:4,Usability,Undo,Undoes,4,"/// Undoes the effect of `PackBits`. The bits that were truncated in the packed representation; /// are filled with zeroes.; /// `src` must be at least `MinBufSize(count, nDstBits)` bytes long.; /// `dst` must be at least `count * sizeofDst` bytes long.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:29,Integrability,rout,routines,29,"// In this namespace, common routines are defined for element packing and unpacking of ints and floats.; // The following conversions and encodings exist:; //; // - Byteswap: on big endian machines, ints and floats are byte-swapped to the little endian on-disk format; // - Cast: in-memory values can be stored in narrower on-disk columns. Currently without bounds checks.; // For instance, for Double32_t, an in-memory double value is stored as a float on disk.; // - Split: rearranges the bytes of an array of elements such that all the first bytes are stored first,; // followed by all the second bytes, etc. This often clusters similar values, e.g. all the zero bytes; // for arrays of small integers.; // - Delta: Delta encoding stores on disk the delta to the previous element. This is useful for offsets,; // because it transforms potentially large offset values into small deltas, which are then better; // suited for split encoding.; // - Zigzag: Zigzag encoding is used on signed integers only. It maps x to 2x if x is positive and to -(2x+1) if; // x is negative. For series of positive and negative values of small absolute value, it will produce; // a bit pattern that is favorable for split encoding.; //; // Encodings/conversions can be fused:; //; // - Delta/Zigzag + Splitting (there is no only-delta/zigzag encoding); // - (Delta/Zigzag + ) Splitting + Casting; // - Everything + Byteswap; /// \brief Copy and byteswap `count` elements of size `N` from `source` to `destination`.; ///; /// Used on big-endian architectures for packing/unpacking elements whose column type requires; /// a little-endian on-disk representation.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:3,Testability,test,testing,3,"// testing value for an unknown future column type",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:260,Availability,down,down,260,"// class RColumnElementCastLE; /**; * Base class for split columns whose on-storage representation is little-endian.; * The implementation of `Pack` and `Unpack` takes care of splitting and, if necessary, byteswap.; * As part of the splitting, can also narrow down the type to NarrowT.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:284,Availability,down,down,284,"// class RColumnElementSplitLE; /**; * Base class for delta + split columns (index columns) whose on-storage representation is little-endian.; * The implementation of `Pack` and `Unpack` takes care of splitting and, if necessary, byteswap.; * As part of the encoding, can also narrow down the type to NarrowT.; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:68,Performance,perform,perform,68,"// TODO(gparolini): to avoid this extra allocation we might want to perform byte swapping; // directly in the Pack/UnpackBits functions.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:23,Safety,avoid,avoid,23,"// TODO(gparolini): to avoid this extra allocation we might want to perform byte swapping; // directly in the Pack/UnpackBits functions.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:66,Safety,avoid,avoid,66,"// Cast doubles to float before packing them; // TODO(gparolini): avoid this allocation",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:68,Performance,perform,perform,68,"// TODO(gparolini): to avoid this extra allocation we might want to perform byte swapping; // directly in the Pack/UnpackBits functions.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:23,Safety,avoid,avoid,23,"// TODO(gparolini): to avoid this extra allocation we might want to perform byte swapping; // directly in the Pack/UnpackBits functions.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:20,Safety,avoid,avoid,20,"// TODO(gparolini): avoid this allocation",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:30,Performance,perform,performed,30,"/// Undoes the transformation performed by QuantizeReals() (assuming the same `count`, `min`, `max` and `nQuantBits`).; /// \return The number of unpacked values that were found to be out of range (0 means all values were in range).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:4,Usability,Undo,Undoes,4,"/// Undoes the transformation performed by QuantizeReals() (assuming the same `count`, `min`, `max` and `nQuantBits`).; /// \return The number of unpacked values that were found to be out of range (0 means all values were in range).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:33,Performance,perform,performed,33,"// Undo the LSB-preserving shift performed by QuantizeReals",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:3,Usability,Undo,Undo,3,"// Undo the LSB-preserving shift performed by QuantizeReals",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:34,Safety,avoid,avoid,34,"// TODO(gparolini): see if we can avoid this allocation",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:34,Safety,avoid,avoid,34,"// TODO(gparolini): see if we can avoid this allocation",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RColumnElement.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RDaos.cxx:232,Usability,Feedback,Feedback,232,"/// \file RDaos.cxx; /// \ingroup NTuple ROOT7; /// \author Javier Lopez-Gomez <j.lopez@cern.ch>; /// \date 2020-11-14; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RDaos.cxx:10,Availability,error,error,10,"// Ignore error for re-creating existing container.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:227,Usability,Feedback,Feedback,227,"/// \file RField.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-15; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:407,Availability,error,error,407,"/// Parse a type name of the form `T[n][m]...` and return the base type `T` and a vector that contains,; /// in order, the declared size for each dimension, e.g. for `unsigned char[1][2][3]` it returns the tuple; /// `{""unsigned char"", {1, 2, 3}}`. Extra whitespace in `typeName` should be removed before calling this function.; ///; /// If `typeName` is not an array type, it returns a tuple `{T, {}}`. On error, it returns a default-constructed tuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:71,Performance,perform,perform,71,"// The following types are asummed to be canonical names; thus, do not perform `typedef` resolution on those",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:61,Availability,error,error,61,"/// If set to true, Create() will create an RInvalidField on error instead of throwing an exception.; /// This is used in RFieldBase::Check() to identify unsupported sub fields.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:13,Testability,log,logic,13,"// mimic the logic of RVecInlineStorageSize, but at runtime",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:3,Integrability,Depend,Depending,3,"// Depending on the compiler, the variant tag is stored either in a trailing char or in a trailing unsigned int",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:137,Availability,Error,Error,137,"// try-catch block to intercept any exception that may be thrown by Unwrap() so that this; // function never throws but returns RResult::Error instead.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:28,Deployability,update,update,28,"// Note that during a model update, new fields will be attached to the zero field. The zero field, however,; // does not change its inital state because only its sub fields get connected by RPageSink::UpdateSchema.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:201,Deployability,Update,UpdateSchema,201,"// Note that during a model update, new fields will be attached to the zero field. The zero field, however,; // does not change its inital state because only its sub fields get connected by RPageSink::UpdateSchema.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:33,Availability,mask,mask,33,"/// For simple types, ignore the mask and memcopy the values into the destination",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:8,Usability,simpl,simple,8,"/// For simple types, ignore the mask and memcopy the values into the destination",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:3,Safety,Avoid,Avoid,3,"// Avoid accidentally supporting std types through TClass.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:3,Safety,Avoid,Avoid,3,"// Avoid accidentally supporting std types through TEnum.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:53,Integrability,depend,dependent,53,"// Trailing padding: although this is implementation-dependent, most add enough padding to comply with the; // requirements of the type with strictest alignment",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:53,Integrability,depend,dependent,53,"// Trailing padding: although this is implementation-dependent, most add enough padding to comply with the; // requirements of the type with strictest alignment",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:13,Performance,perform,performance,13,"// TODO as a performance optimization, we could assign values to elements of the inline buffer:; // if size < inline buffer size: we save one allocation here and usage of the RVec skips a pointer indirection",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:25,Performance,optimiz,optimization,25,"// TODO as a performance optimization, we could assign values to elements of the inline buffer:; // if size < inline buffer size: we save one allocation here and usage of the RVec skips a pointer indirection",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:152,Deployability,release,release,152,"// must reallocate; // Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:124,Energy Efficiency,allocate,allocates,124,"// must reallocate; // Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:171,Safety,avoid,avoid,171,"// must reallocate; // Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:49,Energy Efficiency,allocate,allocated,49,"// *beginPtr points to the array of item values (allocated in an earlier call by the following malloc())",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:73,Energy Efficiency,allocate,allocated,73,"// for pointer arithmetics; // Early return if the RVec has already been allocated.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:11,Energy Efficiency,allocate,allocate,11,"// Need to allocate the RVec if it is the first time the value is being created.; // See ""semantics of reading non-trivial objects"" in RNTuple's Architecture.md for details; // on the element construction.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:132,Deployability,release,release,132,"// Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:104,Energy Efficiency,allocate,allocates,104,"// Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:151,Safety,avoid,avoid,151,"// Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:49,Energy Efficiency,allocate,allocated,49,"// *beginPtr points to the array of item values (allocated in an earlier call by the following malloc())",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:381,Testability,assert,assertion,381,"// ISO C++ does not guarantee neither specific layout nor member names for `std::tuple`. However, most; // implementations including libstdc++ (gcc), libc++ (llvm), and MSVC name members as `_0`, `_1`, ..., `_N-1`,; // following the order of the type list.; // Use TClass to get their offsets; in case a particular `std::tuple` implementation does not define such; // members, the assertion below will fail.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RField.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RFieldVisitor.cxx:247,Usability,Feedback,Feedback,247,"/// \file RFieldVisitor.cxx; /// \ingroup NTuple ROOT7; /// \author Simon Leisibach <simon.leisibach@gmail.com>; /// \date 2019-06-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RFieldVisitor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RFieldVisitor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:230,Usability,Feedback,Feedback,230,"/// \file RMiniFile.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-12-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:52,Security,checksum,checksummed,52,"// The byte count and class version members are not checksummed",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:137,Deployability,update,updated,137,"/// If a TFile container is written by a C stream (simple file), on dataset commit, the file header; /// and the TFile record need to be updated",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:51,Usability,simpl,simple,51,"/// If a TFile container is written by a C stream (simple file), on dataset commit, the file header; /// and the TFile record need to be updated",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:75,Security,checksum,checksum,75,"// We require that future class versions only append members and store the checksum in the last 8 bytes; // Checksum calculation: strip byte count, class version, fChecksum member",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:108,Security,Checksum,Checksum,108,"// We require that future class versions only append members and store the checksum in the last 8 bytes; // Checksum calculation: strip byte count, class version, fChecksum member",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:54,Security,checksum,checksum,54,"// For version 4 there is no maxKeySize (there is the checksum instead)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:211,Safety,avoid,avoid,211,"// NOTE: we read the entire chunk in `bufCur`, but we only advance the pointer by `nbytesFirstChunk`,; // since the last part of `bufCur` will later be overwritten by the next chunk's payload.; // We do this to avoid a second ReadAt to read in the chunk offsets.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:139,Deployability,update,updated,139,"// Write the last partially filled block, which may still need appropriate alignment for Direct I/O.; // If it is the first block, get the updated header block.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:14,Deployability,update,updated,14,"// Write the (updated) header block, unless it was part of the write above.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:15,Security,checksum,checksum,15,"// Compute the checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:3,Deployability,Update,Update,3,"// Update header and TFile record",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:67,Testability,log,logically,67,"// Write the first key, with part of the data and the pointers to (logically) following keys appended.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:43,Security,checksum,checksum,43,"// concatenate the RNTuple anchor with its checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RMiniFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx:228,Usability,Feedback,Feedback,228,"/// \file RNTuple.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2023-09-19; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx:28,Security,checksum,checksum,28,"// Strip class version from checksum calculation",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx:32,Security,checksum,checksum,32,"// TEMP(version4): In version 4 checksum is embedded in the on disk representation,; // so we need to strip that as well from the byte count.; // Support for version 4 will be dropped before the class moves out of experimental.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:299,Usability,Feedback,Feedback,299,"/// \file RNTupleDescriptor.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:3,Modifiability,Extend,Extended,3,"// Extended columns can only be part of the header extension",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:99,Modifiability,Extend,Extended,99,"// Ensure that all columns in the header extension have their associated `R(Column|Page)Range`; // Extended columns can be attached both to fields of the regular header and to fields of the extension header",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:218,Modifiability,extend,extended,218,"// Initialize a RColumnRange for `physicalId` if it was not there. Columns that were created during model; // extension won't have on-disk metadata for the clusters that were already committed before the model; // was extended. Therefore, these need to be synthetically initialized upon reading.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:198,Modifiability,Extend,ExtendToFitColumnRange,198,"// Fixup the RColumnRange and RPageRange in deferred columns. We know what the first element index and; // number of elements should have been if the column was not deferred; fix those and let; // `ExtendToFitColumnRange()` synthesize RPageInfos accordingly.; // Note that a deferred column (i.e, whose first element index is > 0) already met the criteria of; // `RFieldBase::EntryToColumnElementIndex()`, i.e. it is a principal column reachable from the field zero; // excluding subfields of collection and variant fields.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:321,Availability,error,error,321,"// NOTE: if the column type is unknown we don't want to fail, as we might be reading an RNTuple; // created with a future version of ROOT. In this case we just skip the valid bit range check,; // as we have no idea what the valid range is.; // In general, reading the metadata of an unknown column is fine, it becomes an error only when; // we try to read the actual data contained in it.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:74,Modifiability,polymorphi,polymorphism,74,"// Add the streamer info records from streamer fields: because of runtime polymorphism we may need to add additional; // types not covered by the type names stored in the field headers",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:21,Safety,avoid,avoid,21,"// Ideally, we would avoid deserializing the streamer info records of the streamer fields that we just serialized.; // However, this happens only once at the end of writing and only when streamer fields are used, so the; // preference here is for code simplicity.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:252,Usability,simpl,simplicity,252,"// Ideally, we would avoid deserializing the streamer info records of the streamer fields that we just serialized.; // However, this happens only once at the end of writing and only when streamer fields are used, so the; // preference here is for code simplicity.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx:241,Usability,Feedback,Feedback,241,"/// \file RNTupleDescriptorFmt.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-08-25; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx:79,Energy Efficiency,consumption,consumption,79,"// Alias columns (columns of projected fields) don't contribute to the storage consumption. Count them; // but don't add the the page sizes to the overall volume.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptorFmt.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleFillContext.cxx:239,Usability,Feedback,Feedback,239,"/// \file RNTupleFillContext.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleFillContext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleFillContext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleIndex.cxx:244,Usability,Feedback,Feedback,244,"/// \file RNTupleIndex.cxx; /// \ingroup NTuple ROOT7; /// \author Florine de Geus <florine.de.geus@cern.ch>; /// \date 2024-04-02; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleIndex.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleIndex.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:361,Usability,Feedback,Feedback,361,"/// \file RNTupleMerger.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>, Max Orok <maxwellorok@gmail.com>, Alaettin Serhan Mete <amete@anl.gov>,; /// Giacomo Parolini <giacomo.parolini@cern.ch>; /// \date 2020-07-08; /// \warning This is part of the ROOT 7 prototype! It will; /// change without notice. It might trigger earthquakes. Feedback is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:71,Safety,unsafe,unsafe,71,"// IMPORTANT: this function must not throw, as it is used in exception-unsafe code (TFileMerger).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:3,Integrability,Interface,Interface,3,"// Interface conversion",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:110,Integrability,interface,interface,110,"// namespace; // These structs cannot be in the anon namespace becase they're used in RNTupleMerger's private interface.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:91,Security,validat,validated,91,"// we expect the cluster pool to contain the requested set of columns, since they were; // validated by CompareDescriptorStructures().",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:64,Energy Efficiency,allocate,allocate,64,"// If the column range is already uncompressed we don't need to allocate any new buffer, so we don't; // bother reserving memory for them.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:34,Availability,error,error,34,"// TODO(gparolini): more graceful error handling (skip the page?)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:263,Usability,simpl,simply,263,"// Iterates over all clusters of `source` and merges their pages into `destination`.; // It is assumed that all columns in `commonColumns` are present (and compatible) in both the source and; // the destination's schemas.; // The pages may be ""fast-merged"" (i.e. simply copied with no decompression/recompression) if the target; // compression is unspecified or matches the original compression settings.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:450,Usability,simpl,simply,450,"// TODO(gparolini): when we get serious about huge file support (>~ 100GB) we might want to check here; // the size of the running page list and commit a cluster group when it exceeds some threshold,; // which would prevent the page list from getting too large.; // However, as of today, we aren't really handling such huge files, and even relatively big ones; // such as the CMS dataset have a page list size of about only 2 MB.; // So currently we simply merge all cluster groups into one.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:77,Availability,error,error,77,"// If the current source is missing some fields and we're not in Union mode, error; // (if we are in Union mode, MergeSourceClusters will fill the missing fields with default values).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:68,Availability,error,error,68,"// If the current source has extra fields and we're in Strict mode, error",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMerger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMetrics.cxx:235,Usability,Feedback,Feedback,235,"/// \file RNTupleMetrics.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-08-27; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleMetrics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMetrics.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx:233,Usability,Feedback,Feedback,233,"/// \file RNTupleModel.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-15; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleModel.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx:63,Availability,error,error,63,"// If source or target has a variant or reference as a parent, error out",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleModel.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx:119,Deployability,update,updates,119,"// We set the model ID to zero until CommitUpdate(). That prevents calls to RNTupleWriter::Fill() in the middle; // of updates",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleModel.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleModel.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:251,Usability,Feedback,Feedback,251,"/// \file RNTupleParallelWriter.cxx; /// \ingroup NTuple ROOT7; /// \author Jonas Hahnfeld <jonas.hahnfeld@cern.ch>; /// \date 2024-02-01; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:568,Integrability,synchroniz,synchronizing,568,"/// An internal RPageSink that enables multiple RNTupleFillContext to write into a single common RPageSink.; ///; /// The setup with two contexts looks as follows:; ///; /// +------ owned by RNTupleFillContext ------+; /// | |; /// RPageSinkBuf --- forwards to ---> RPageSynchronizingSink ---+; /// (and owns) |; /// (via raw fInnerSink ptr) +-- RPageSink (usually a persistent sink); /// |; /// RPageSinkBuf --- forwards to ---> RPageSynchronizingSink ---+; /// | (and owns) |; /// | |; /// +------ owned by RNTupleFillContext ------+; ///; /// The mutex used by the synchronizing sinks is owned by the RNTupleParallelWriter that also owns the original model,; /// the ""final"" sink (usually a persistent sink) and keeps weak_ptr's of the contexts (to make sure they are destroyed; /// before the writer is destructed).",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:8,Integrability,wrap,wrapped,8,"/// The wrapped inner sink, not owned by this class.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:93,Integrability,synchroniz,synchronization,93,"// TODO: Think about honoring RNTupleWriteOptions::SetUseBufferedWrite(false); this requires synchronization on every; // call to CommitPage() *and* preparing multiple cluster descriptors in parallel!",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:200,Usability,clear,cleared,200,"// Cannot use std::make_shared because the constructor of RNTupleFillContext is private. Also it would mean that the; // (direct) memory of all contexts stays around until the vector of weak_ptr's is cleared.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleProcessor.cxx:248,Usability,Feedback,Feedback,248,"/// \file RNTupleProcessor.cxx; /// \ingroup NTuple ROOT7; /// \author Florine de Geus <florine.de.geus@cern.ch>; /// \date 2024-03-26; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleProcessor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleProcessor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleProcessor.cxx:218,Security,access,access,218,"// If the model has a default entry, use the value pointers from the entry in the entry managed by the; // processor. This way, the pointers returned by RNTupleModel::MakeField can be used in the processor loop to; // access the corresponding field values.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleProcessor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleProcessor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleReader.cxx:234,Usability,Feedback,Feedback,234,"/// \file RNTupleReader.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-20; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleReader.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleReader.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleReader.cxx:44,Modifiability,variab,variables,44,"// TODO(lesimon): In a later version, these variables may be defined by the user or the ideal width may be read out; // from the terminal.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleReader.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleReader.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleReader.cxx:28,Availability,error,error,28,"// Unhandled case, internal error",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleReader.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleReader.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx:298,Usability,Feedback,Feedback,298,"/// \file RNTupleSerialize.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>; /// \date 2021-08-02; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleSerialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx:11,Testability,test,testing,11,"// For the testing locator, use the same payload as Object64. We're not gonna really read it back anyway.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleSerialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx:55,Modifiability,extend,extend,55,"// Create physical IDs for column representations that extend fields of the regular header.; // First the physical columns then the alias columns.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleSerialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx:155,Testability,test,tests,155,"// A call to `RNTupleDescriptorBuilder::BeginHeaderExtension()` is not strictly required after serializing the; // header, which may happen, e.g., in unit tests. Ensure an empty schema extension is serialized in this case",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleSerialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleSerialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleUtil.cxx:267,Usability,Feedback,Feedback,267,"/// \file RNTupleUtil.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch> & Max Orok <maxwellorok@gmail.com>; /// \date 2020-07-14; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleUtil.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleUtil.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleView.cxx:232,Usability,Feedback,Feedback,232,"/// \file RNTupleView.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-10-28; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleView.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleView.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriteOptions.cxx:240,Usability,Feedback,Feedback,240,"/// \file RNTupleWriteOptions.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleWriteOptions.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriteOptions.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriter.cxx:234,Usability,Feedback,Feedback,234,"/// \file RNTupleReader.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2024-02-20; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2024, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriter.cxx:42,Safety,avoid,avoid,42,"// Observe directly the sink's metrics to avoid an additional prefix from the fill context.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RNTupleWriter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPage.cxx:226,Usability,Feedback,Feedback,226,"/// \file RPage.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageAllocator.cxx:235,Usability,Feedback,Feedback,235,"/// \file RPageAllocator.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-06-25; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageAllocator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageAllocator.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPagePool.cxx:230,Usability,Feedback,Feedback,230,"/// \file RPagePool.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPagePool.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPagePool.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:340,Usability,Feedback,Feedback,340,"/// \file RPageSinkBuf.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \author Max Orok <maxwellorok@gmail.com>; /// \author Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>; /// \date 2021-03-17; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:165,Usability,simpl,simplify,165,"// The buffered page sink maintains a copy of the RNTupleModel for the inner sink; replicate the changes there; // TODO(jalopezg): we should be able, in general, to simplify the buffered sink.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:3,Safety,Safe,Safety,3,"// Safety: References are guaranteed to be valid until the element is destroyed. In other words, all buffered page; // elements are valid until DropBufferedPages().",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:10,Energy Efficiency,allocate,allocate,10,"// Do not allocate the buffer yet, in case of IMT we only need it once the task is started.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:75,Energy Efficiency,allocate,allocate,75,"// If the sealed page is smaller than the maximum size (with compression), allocate what is needed and copy the; // sealed page content to save memory.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:28,Safety,avoid,avoiding,28,"// Seal the page right now, avoiding the allocation and copy, but making sure that the page buffer is not aliased.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:56,Energy Efficiency,allocate,allocated,56,"// TODO avoid frequent (de)allocations by holding on to allocated buffers in RColumnBuf",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:8,Safety,avoid,avoid,8,"// TODO avoid frequent (de)allocations by holding on to allocated buffers in RColumnBuf",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:10,Safety,safe,safety,10,"// Thread safety: Each thread works on a distinct zipItem which owns its; // compression buffer.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:3,Deployability,Release,Release,3,"// Release the uncompressed page. This works because the ""page allocator must be thread-safe.""",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:88,Safety,safe,safe,88,"// Release the uncompressed page. This works because the ""page allocator must be thread-safe.""",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:119,Energy Efficiency,efficient,efficiently,119,"// We implement both StageCluster() and CommitCluster() because we can call CommitCluster() on the inner sink more; // efficiently in a single critical section. For parallel writing, it also guarantees that we produce a fully sequential; // file.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSinkBuf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSourceFriends.cxx:239,Usability,Feedback,Feedback,239,"/// \file RPageSourceFriends.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-08-10; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSourceFriends.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSourceFriends.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSourceFriends.cxx:48,Performance,load,load,48,"// The virtual friends page source does not pre-load any clusters itself. However, the underlying page sources; // that are combined may well do it.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageSourceFriends.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSourceFriends.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:233,Usability,Feedback,Feedback,233,"/// \file RPageStorage.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2018-10-04; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:50,Modifiability,Extend,ExtendToFitColumnRange,50,"// Unsealing a page zero is a no-op. `RPageRange::ExtendToFitColumnRange()` guarantees that the page zero buffer is; // large enough to hold `sealedPage.fNElements`",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:13,Usability,simpl,simply,13,"// We cannot simply map the sealed page as we don't know its life time. Specialized page sources; // may decide to implement to not use UnsealPage but to custom mapping / decompression code.; // Note that usually pages are compressed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:46,Availability,avail,available,46,"// Page got larger, we may need to make space available",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:138,Safety,avoid,avoiding,138,"// Don't change anything, let the calling column flush itself; // TODO(jblomer): we may consider skipping the column in TryEvict and thus avoiding erase+insert",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:62,Security,checksum,checksum,62,"///< Points to the first occurrence of a page with a specific checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:13,Security,checksum,checksums,13,"// Maps page checksums to the first sealed page with that checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:58,Security,checksum,checksum,58,"// Maps page checksums to the first sealed page with that checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:243,Usability,Feedback,Feedback,243,"/// \file RPageStorageDaos.cxx; /// \ingroup NTuple ROOT7; /// \author Javier Lopez-Gomez <j.lopez@cern.ch>; /// \date 2020-11-03; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:194,Security,access,access,194,"/// \brief Unpacks a 64-bit RNTuple page locator address for object stores into a pair of 32-bit values:; /// the attribute key under which the cage is stored and the offset within that cage to access the page.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:133,Security,hash,hashing,133,"/// \brief Helper structure concentrating the functionality required to locate an ntuple within a DAOS container.; /// It includes a hashing function that converts the RNTuple's name into a 32-bit identifier; this value is used to; /// index the subspace for the ntuple among all objects in the container. A zero-value hash value is reserved for; /// storing any future metadata related to container-wide management; a zero-index ntuple is thus disallowed and; /// remapped to ""1"". Once the index is computed, `InitNTupleDescriptorBuilder()` can be called to return a; /// partially-filled builder with the ntuple's anchor, header and footer, lacking only pagelists. Upon that call,; /// a copy of the anchor is stored in `fAnchor`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:319,Security,hash,hash,319,"/// \brief Helper structure concentrating the functionality required to locate an ntuple within a DAOS container.; /// It includes a hashing function that converts the RNTuple's name into a 32-bit identifier; this value is used to; /// index the subspace for the ntuple among all objects in the container. A zero-value hash value is reserved for; /// storing any future metadata related to container-wide management; a zero-index ntuple is thus disallowed and; /// remapped to ""1"". Once the index is computed, `InitNTupleDescriptorBuilder()` can be called to return a; /// partially-filled builder with the ntuple's anchor, header and footer, lacking only pagelists. Upon that call,; /// a copy of the anchor is stored in `fAnchor`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:54,Security,hash,hash,54,"// Convert string to numeric representation via `std::hash`.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:12,Security,hash,hash,12,"// Fold the hash into 32-bit using `boost::hash_combine()` algorithm and magic number.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:3,Security,Hash,Hash,3,"// Hash already taken by a differently-named ntuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:45,Performance,load,load,45,"// Suboptimal but hard to do differently: we load the full cage up to and including the requested page.; // In practice, individual LoadSealedPage calls are rare and usually full clusters are buffered.; // The support for extracting individual pages from a cage makes testing easier, however.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:132,Performance,Load,LoadSealedPage,132,"// Suboptimal but hard to do differently: we load the full cage up to and including the requested page.; // In practice, individual LoadSealedPage calls are rare and usually full clusters are buffered.; // The support for extracting individual pages from a cage makes testing easier, however.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:268,Testability,test,testing,268,"// Suboptimal but hard to do differently: we load the full cage up to and including the requested page.; // In practice, individual LoadSealedPage calls are rare and usually full clusters are buffered.; // The support for extracting individual pages from a cage makes testing easier, however.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:31,Availability,avail,available,31,"// page payload + checksum (if available)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:18,Security,checksum,checksum,18,"// page payload + checksum (if available)",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:171,Performance,load,loaded,171,"// Group page locators by their position in the object store; with caging enabled, this facilitates the; // processing of cages' requests together into a single IOV to be loaded.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageDaos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:237,Usability,Feedback,Feedback,237,"/// \file RPageStorageFile.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2019-11-25; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:173,Modifiability,inherit,inheriting,173,"// For local TFiles, TDavixFile, and TNetXNGFile, we want to open a new RRawFile to take advantage of the faster; // reading. We check the exact class name to avoid classes inheriting in ROOT (for example TMemFile) or in; // experiment frameworks.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:159,Safety,avoid,avoid,159,"// For local TFiles, TDavixFile, and TNetXNGFile, we want to open a new RRawFile to take advantage of the faster; // reading. We check the exact class name to avoid classes inheriting in ROOT (for example TMemFile) or in; // experiment frameworks.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:42,Energy Efficiency,schedul,scheduler,42,"// For the page reads, we rely on the I/O scheduler to define the read requests",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:190,Availability,toler,tolerate,190,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:419,Availability,toler,tolerable,419,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:324,Energy Efficiency,reduce,reduce,324,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:372,Energy Efficiency,schedul,schedule,372,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:583,Energy Efficiency,consumption,consumption,583,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:553,Performance,latency,latency,553,"// In order to coalesce close-by pages, we collect the sizes of the gaps between pages on disk. We then order; // the gaps by size, sum them up and find a cutoff for the largest gap that we tolerate when coalescing pages.; // The size of the cutoff is given by the fraction of extra bytes we are willing to read in order to reduce; // the number of read requests. We thus schedule the lowest number of requests given a tolerable fraction; // of extra bytes.; // TODO(jblomer): Eventually we may want to select the parameter at runtime according to link latency and speed,; // memory consumption, device block size.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:196,Energy Efficiency,allocate,allocated,196,"// In a first step, we coalesce the read requests and calculate the cluster buffer size.; // In a second step, we'll fix-up the memory destinations for the read calls given the; // address of the allocated buffer. We must not touch, however, the read requests from previous; // calls to PrepareSingleCluster()",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:6,Usability,simpl,simplify,6,"// To simplify the first loop iteration, pretend an empty request starting at the first page's fOffset.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/RPageStorageFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:239,Usability,Feedback,Feedback,239,"/// \file libdaos_mock.cxx; /// \ingroup NTuple ROOT7; /// \author Javier Lopez-Gomez <j.lopez@cern.ch>; /// \date 2021-01-20; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:24,Safety,safe,safely,24,"/* In principle, we can safely assume that each attribute key is associated to a single value,; * i.e. one extent per I/O descriptor; and that the corresponding data is copied to exactly one; * I/O vector. */",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:108,Deployability,update,updated,108,/* We assume each attribute key is associated to a single value whose corresponding data is; * sequentially updated from one or more I/O vectors. */,MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:393,Safety,detect,detect,393,"// clang-format off; /**; \class RDaosHandle; \brief Translates a `daos_handle_t` to a pointer to object and viceversa. A `daos_handle_t` is used by some API functions (in particular, those that work; with pools, containers, or objects) to reference an entity. This type (aka; `uint64_t`) is large enough for a pointer in all architectures. However, an; indirection layer is added in order to detect the use of invalidated handles.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:11,Integrability,Wrap,Wrapper,11,"/// \brief Wrapper over a `void *` that may help to detect the use of invalid handles.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:52,Safety,detect,detect,52,"/// \brief Wrapper over a `void *` that may help to detect the use of invalid handles.",MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:2,Safety,timeout,timeout,2,/*timeout*/,MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:2,Safety,timeout,timeout,2,/*timeout*/,MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:3,Security,Validat,Validate,3,/* Validate user-specified bits are not reserved by DAOS */,MatchSource.CODE_COMMENT,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx:32,Security,checksum,checksum,32,"//! transient member, edited by checksum based rule",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStruct.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx:33,Security,checksum,checksum,33,"//! transient member, skipped by checksum based rule due to checksum mismatch",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStruct.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx:60,Security,checksum,checksum,60,"//! transient member, skipped by checksum based rule due to checksum mismatch",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStruct.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:131,Testability,test,test,131,"// Including a non-transient member in `target` should issue a warning and ignore the rule; thus, `a` remains unchanged; // in the test",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStructLinkDef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:440,Modifiability,variab,variable,440,"// Note: This rule has been modified to work around ROOT bug #15877.; // The original rule was `str = std::string{onfile.chars, 4};`; //; // This bug is triggered by the TClassReadRules unit test (in rfield_class.cxx) in the following way:; // 1. Upon write, RNTuple calls TClass::GetStreamerInfo() to store the streamer info of StructWithTransientString; // 2. The read rule calls TClass::GetDataMemberOffset(""chars"") to fill the `onfile` variable; // 3. The class doesn't find ""chars"" among its real data members (it's ""chars[4]"" in this list); // 4. The class therefore tries to get the offset from the streamer info; the streamer info exists in; // GetCurrentStreamerInfo() because we called TClass::GetStreamerInfo() in step 1.; // Otherwise GetDataMemberOffset() would return 0 which happens to be correct.; // 5. Now we enter the bug:; // - The streamer info has two elements for ""chars"", one with the correct offset (0),; // one cached, with a wrong one (8); // - The streamer info returns the offset of the wrong data member",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStructLinkDef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:937,Performance,cache,cached,937,"// Note: This rule has been modified to work around ROOT bug #15877.; // The original rule was `str = std::string{onfile.chars, 4};`; //; // This bug is triggered by the TClassReadRules unit test (in rfield_class.cxx) in the following way:; // 1. Upon write, RNTuple calls TClass::GetStreamerInfo() to store the streamer info of StructWithTransientString; // 2. The read rule calls TClass::GetDataMemberOffset(""chars"") to fill the `onfile` variable; // 3. The class doesn't find ""chars"" among its real data members (it's ""chars[4]"" in this list); // 4. The class therefore tries to get the offset from the streamer info; the streamer info exists in; // GetCurrentStreamerInfo() because we called TClass::GetStreamerInfo() in step 1.; // Otherwise GetDataMemberOffset() would return 0 which happens to be correct.; // 5. Now we enter the bug:; // - The streamer info has two elements for ""chars"", one with the correct offset (0),; // one cached, with a wrong one (8); // - The streamer info returns the offset of the wrong data member",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStructLinkDef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:191,Testability,test,test,191,"// Note: This rule has been modified to work around ROOT bug #15877.; // The original rule was `str = std::string{onfile.chars, 4};`; //; // This bug is triggered by the TClassReadRules unit test (in rfield_class.cxx) in the following way:; // 1. Upon write, RNTuple calls TClass::GetStreamerInfo() to store the streamer info of StructWithTransientString; // 2. The read rule calls TClass::GetDataMemberOffset(""chars"") to fill the `onfile` variable; // 3. The class doesn't find ""chars"" among its real data members (it's ""chars[4]"" in this list); // 4. The class therefore tries to get the offset from the streamer info; the streamer info exists in; // GetCurrentStreamerInfo() because we called TClass::GetStreamerInfo() in step 1.; // Otherwise GetDataMemberOffset() would return 0 which happens to be correct.; // 5. Now we enter the bug:; // - The streamer info has two elements for ""chars"", one with the correct offset (0),; // one cached, with a wrong one (8); // - The streamer info returns the offset of the wrong data member",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStructLinkDef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:20,Security,checksum,checksum,20,"// This rule uses a checksum to identify the source class",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStructLinkDef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:38,Security,checksum,checksum,38,"// This rule will be ignored due to a checksum mismatch",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/CustomStructLinkDef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx:27,Testability,test,test,27,"// TODO(jalopezg): improve test coverage by adding other field types",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_basics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx:9,Deployability,release,release,9,"// avoid release",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_basics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx:3,Safety,avoid,avoid,3,"// avoid release",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_basics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:56,Availability,mask,mask,56,/* the cardinality field optimization should ignore the mask */,MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_bulk.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:25,Performance,optimiz,optimization,25,/* the cardinality field optimization should ignore the mask */,MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_bulk.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:62,Availability,mask,mask,62,"// the RVec<simple type> field optimization should ignore the mask",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_bulk.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:31,Performance,optimiz,optimization,31,"// the RVec<simple type> field optimization should ignore the mask",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_bulk.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:12,Usability,simpl,simple,12,"// the RVec<simple type> field optimization should ignore the mask",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_bulk.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx:21,Performance,Load,LoadClusters,21,/**; * Used to track LoadClusters calls triggered by ClusterPool::GetCluster; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_cluster.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx:40,Performance,Load,LoadClusters,40,"/// Records the cluster IDs requests by LoadClusters() calls",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_cluster.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx:78,Deployability,patch,patching,78,"// The file is supposed to be small enough to allow for quick scanning by the patching done later.; // Let's put 4KB as a safe limit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_compat.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx:122,Safety,safe,safe,122,"// The file is supposed to be small enough to allow for quick scanning by the patching done later.; // Let's put 4KB as a safe limit.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_compat.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx:3,Deployability,Patch,Patch,3,"// Patch all instances of 'RXTuple' -> 'RNTuple'.; // We do this by just scanning the whole file and replacing all occurrences.; // This is not the optimal way to go about it, but since the file is small (~1KB); // it is fast enough to not matter.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_compat.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx:23,Performance,cache,cache,23,"// disable the cluster cache so we can catch the exception that happens on LoadEntry",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_compat.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx:75,Performance,Load,LoadEntry,75,"// disable the cluster cache so we can catch the exception that happens on LoadEntry",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_compat.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_descriptor.cxx:82,Availability,error,error,82,"// MakeDescriptor() returns an RResult<RFieldDescriptor>; // -- here we check the error cases; // must set field id",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_descriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_descriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_descriptor.cxx:11,Testability,test,test,11,"// In this test, we only support field hierarchies up to 2 levels",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_descriptor.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_descriptor.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_endian.cxx:23,Safety,detect,detection,23,"// Override endianness detection in RColumnElement.hxx; assume big-endian machine; // These tests are simulating a big endian machine; we will turn them off on an actual big endian node.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_endian.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_endian.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_endian.cxx:92,Testability,test,tests,92,"// Override endianness detection in RColumnElement.hxx; assume big-endian machine; // These tests are simulating a big endian machine; we will turn them off on an actual big endian node.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_endian.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_endian.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_evolution.cxx:95,Availability,failure,failures,95,"// These helpers are split into an *Impl function and a macro to check for and propagate fatal failures to the caller.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_evolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_evolution.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx:59,Testability,benchmark,benchmark,59,"// See https://github.com/olifre/root-io-bench/blob/master/benchmark.cpp",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_extended.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx:125,Security,checksum,checksums,125,"// The floating point arithmetic should have been executed in the same order for reading and writing,; // thus we expect the checksums to be bitwise identical",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_extended.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx:10,Testability,test,test,10,"// Stress test the asynchronous cluster pool by a deliberately unfavourable read pattern",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_extended.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx:3,Deployability,Update,Update,3,"// Update the file with another object",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_extended.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:459,Safety,avoid,avoid,459,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:8,Testability,test,test,8,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:292,Testability,test,test,292,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:364,Testability,test,tests,364,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:435,Testability,test,tests,435,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:653,Testability,test,test,653,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:684,Testability,test,test,684,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:783,Testability,test,test,783,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_limits.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged; // These files are practically identical except that filed indices are interchanged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged; // These files are practically identical except that filed indices are interchanged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged; // These files are practically identical except that filed indices are interchanged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged; // These files are practically identical except that filed indices are interchanged",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx:13,Testability,test,test,13,"// Write two test ntuples to be merged, with different models.; // Use EMergingMode::kUnion so the output ntuple has all the fields of its inputs.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_merger.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx:9,Testability,test,tests,9,"// Death tests must run single-threaded:; // https://github.com/google/googletest/blob/main/docs/advanced.md#death-tests-and-threads",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_minifile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx:115,Testability,test,tests-and-threads,115,"// Death tests must run single-threaded:; // https://github.com/google/googletest/blob/main/docs/advanced.md#death-tests-and-threads",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_minifile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx:18,Availability,failure,failures,18,"// TODO(jblomer): failures should be exceptions",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_minifile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_minifile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx:12,Availability,failure,failures,12,"// Previous failures to create 'pt' should not block the name",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_model.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx:13,Performance,optimiz,optimization,13,"// Tail page optimization and buffered writing on, IMT not disabled.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_model.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx:3,Safety,sanity check,sanity check,3,"// sanity check",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_model.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.py:11,Testability,test,tests,11,"""""""Various tests for the RNTupleModel class""""""",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_model.py
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:255,Availability,error,error,255,"// Check that the column ranges for model-extended subfields are properly constructed by iterating over their view.; // For improper column ranges, the global field range would go until the value of kInvalidClusterIndex and result in; // an out-of-bounds error.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:42,Modifiability,extend,extended,42,"// Check that the column ranges for model-extended subfields are properly constructed by iterating over their view.; // For improper column ranges, the global field range would go until the value of kInvalidClusterIndex and result in; // an out-of-bounds error.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:27,Testability,test,test,27,"// Based on the RealWorld1 test in `ntuple_extended.cxx`, but here some fields are added after the fact",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:59,Testability,benchmark,benchmark,59,"// See https://github.com/olifre/root-io-bench/blob/master/benchmark.cpp",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:125,Security,checksum,checksums,125,"// The floating point arithmetic should have been executed in the same order for reading and writing,; // thus we expect the checksums to be bitwise identical",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:22,Modifiability,extend,extended,22,"// The model is to be extended below with new fields every 10000 entries",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:72,Modifiability,extend,extended,72,"// Force the serialization of a page list which will not know about the extended columns coming later.; // `RClusterDescriptorBuilder::AddExtendedColumnRanges()` should thus make up page ranges for the missing columns",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx:125,Security,checksum,checksums,125,"// The floating point arithmetic should have been executed in the same order for reading and writing,; // thus we expect the checksums to be bitwise identical",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_modelext.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_modelext.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx:3,Testability,Test,Test,3,"// Test writing index32/64 columns",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_packing.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx:16,Testability,test,test,16,"// Exhaustively test, for all valid bit widths, packing and unpacking of 0 to N random floats.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_packing.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx:16,Testability,test,test,16,"// Exhaustively test, for all valid bit widths, packing and unpacking of 0 to N random doubles.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_packing.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx:16,Testability,test,test,16,"// Exhaustively test, for all valid bit widths, packing and unpacking of 0 to N random floats.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_packing.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx:16,Testability,test,test,16,"// Exhaustively test, for all valid bit widths, packing and unpacking of 0 to N random doubles.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_packing.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_packing.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_parallel_writer.cxx:3,Deployability,Release,Release,3,"// Release the contexts (in reverse order) and the writer.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_parallel_writer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_parallel_writer.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_parallel_writer.cxx:40,Testability,log,logically,40,"// Turn on staged cluster committing to logically append staged clusters with an explicit call.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_parallel_writer.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_parallel_writer.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx:57,Testability,test,test,57,"/* Currently the width can't be set by PrintInfo(). This test will be enabled when this feature is added.; TEST(RNTuplePrint, TooShort); {; FileRaii fileGuard(""test.root"");; {; auto model = RNTupleModel::Create();; auto fieldPt = model->MakeField<float>(""pt"");; auto ntuple = RNTupleWriter::Recreate(std::move(model), ""Staff"", ""test.root"");; }; auto ntuple2 = RNTupleReader::Open(""Staff"", ""test.root"");; std::ostringstream os;; ntuple2->PrintInfo(ROOT::Experimental::ENTupleInfo::kSummary, os, '+', 29);; std::string fString{""The width is too small! Should be at least 30.\n""};; EXPECT_EQ(fString, os.str());; }; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_print.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx:107,Testability,TEST,TEST,107,"/* Currently the width can't be set by PrintInfo(). This test will be enabled when this feature is added.; TEST(RNTuplePrint, TooShort); {; FileRaii fileGuard(""test.root"");; {; auto model = RNTupleModel::Create();; auto fieldPt = model->MakeField<float>(""pt"");; auto ntuple = RNTupleWriter::Recreate(std::move(model), ""Staff"", ""test.root"");; }; auto ntuple2 = RNTupleReader::Open(""Staff"", ""test.root"");; std::ostringstream os;; ntuple2->PrintInfo(ROOT::Experimental::ENTupleInfo::kSummary, os, '+', 29);; std::string fString{""The width is too small! Should be at least 30.\n""};; EXPECT_EQ(fString, os.str());; }; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_print.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx:160,Testability,test,test,160,"/* Currently the width can't be set by PrintInfo(). This test will be enabled when this feature is added.; TEST(RNTuplePrint, TooShort); {; FileRaii fileGuard(""test.root"");; {; auto model = RNTupleModel::Create();; auto fieldPt = model->MakeField<float>(""pt"");; auto ntuple = RNTupleWriter::Recreate(std::move(model), ""Staff"", ""test.root"");; }; auto ntuple2 = RNTupleReader::Open(""Staff"", ""test.root"");; std::ostringstream os;; ntuple2->PrintInfo(ROOT::Experimental::ENTupleInfo::kSummary, os, '+', 29);; std::string fString{""The width is too small! Should be at least 30.\n""};; EXPECT_EQ(fString, os.str());; }; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_print.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx:328,Testability,test,test,328,"/* Currently the width can't be set by PrintInfo(). This test will be enabled when this feature is added.; TEST(RNTuplePrint, TooShort); {; FileRaii fileGuard(""test.root"");; {; auto model = RNTupleModel::Create();; auto fieldPt = model->MakeField<float>(""pt"");; auto ntuple = RNTupleWriter::Recreate(std::move(model), ""Staff"", ""test.root"");; }; auto ntuple2 = RNTupleReader::Open(""Staff"", ""test.root"");; std::ostringstream os;; ntuple2->PrintInfo(ROOT::Experimental::ENTupleInfo::kSummary, os, '+', 29);; std::string fString{""The width is too small! Should be at least 30.\n""};; EXPECT_EQ(fString, os.str());; }; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_print.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx:390,Testability,test,test,390,"/* Currently the width can't be set by PrintInfo(). This test will be enabled when this feature is added.; TEST(RNTuplePrint, TooShort); {; FileRaii fileGuard(""test.root"");; {; auto model = RNTupleModel::Create();; auto fieldPt = model->MakeField<float>(""pt"");; auto ntuple = RNTupleWriter::Recreate(std::move(model), ""Staff"", ""test.root"");; }; auto ntuple2 = RNTupleReader::Open(""Staff"", ""test.root"");; std::ostringstream os;; ntuple2->PrintInfo(ROOT::Experimental::ENTupleInfo::kSummary, os, '+', 29);; std::string fString{""The width is too small! Should be at least 30.\n""};; EXPECT_EQ(fString, os.str());; }; */",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_print.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_print.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx:3,Testability,Test,Test,3,"// Test frame evolution",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_serialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx:49,Security,checksum,checksum,49,"// Two pages adding up to 100 elements, one with checksum one without",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_serialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx:134,Modifiability,extend,extended,134,"// Construct an RNTuple with a single float field ""pt"". The field has a single representation for the; // first cluster and then gets extended by another representation that is active in the second cluster.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_serialize.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx:83,Testability,test,test,83,"/// An RPageSink that keeps counters of (vector) commit of (sealed) pages; used to test RPageSinkBuf",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx:15,Integrability,wrap,wraps,15,"// PageSinkBuf wraps a concrete page source",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx:12,Testability,test,test,12,"// For this test, ensure at least some columns have multiple pages",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx:20,Availability,avail,available,20,"// Parallel zip not available, but pages are still vector-commited",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:22,Testability,test,test,22,"/// \brief Stores the test label in a class-wide collection and returns the DAOS URI (""daos://{pool}/{container}"").; /// The test label serves as the container identifier.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:125,Testability,test,test,125,"/// \brief Stores the test label in a class-wide collection and returns the DAOS URI (""daos://{pool}/{container}"").; /// The test label serves as the container identifier.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:62,Integrability,message,messages,62,"// Initialized at the start of each test to expect diagnostic messages from TestSupport",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:36,Testability,test,test,36,"// Initialized at the start of each test to expect diagnostic messages from TestSupport",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:76,Testability,Test,TestSupport,76,"// Initialized at the start of each test to expect diagnostic messages from TestSupport",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:16,Integrability,depend,depends,16,"// This feature depends on RPageSinkBuf and the ability to issue a single `CommitSealedPageV()` call; thus, disable if; // ROOT was built with `-Dimt=OFF`",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:78,Performance,cache,cache,78,"// Attempt to read all the entries written above as caged pages, with cluster cache turned on.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:50,Performance,cache,cache,50,"// Attempt to read a caged page data when cluster cache is disabled.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:12,Performance,load,loading,12,"// However, loading a single sealed page should work",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_storage_daos.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.cxx:3,Performance,Load,Load,3,"// Load sealed pages to memory",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.cxx:28,Security,checksum,checksum,28,"// Corrupt px sealed page's checksum",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.cxx:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite RNTuple with valid pz page and corrupted px, py page",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx:15,Integrability,wrap,wrapper,15,/**; * An RAII wrapper around an open temporary file on disk. It cleans up the guarded file when the wrapper object; * goes out of scope.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx:101,Integrability,wrap,wrapper,101,/**; * An RAII wrapper around an open temporary file on disk. It cleans up the guarded file when the wrapper object; * goes out of scope.; */,MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx:32,Testability,test,test,32,"// Useful if you want to keep a test file after the test has finished running; // for debugging purposes. Should only be used locally and never pushed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx:52,Testability,test,test,52,"// Useful if you want to keep a test file after the test has finished running; // for debugging purposes. Should only be used locally and never pushed.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx:140,Security,checksum,checksum,140,"/// Creates an uncompressed RNTuple called ""ntpl"" with three float fields, px, py, pz, with a single entry.; /// The page of px has a wrong checksum. The page of py has corrupted data. The page of pz is valid.; /// The function is backend agnostic (file, DAOS, ...).",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx:37,Availability,avail,available,37,"// TODO: Add std::float16 tests once available (from C++23)",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_types.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx:26,Testability,test,tests,26,"// TODO: Add std::float16 tests once available (from C++23)",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_types.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx:14,Performance,optimiz,optimization,14,"// Empty base optimization is required for standard layout types (since C++11)",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_types.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_types.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_view.cxx:3,Testability,Test,Test,3,"// Test views that cast to a different type.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_view.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_view.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_view.cxx:249,Performance,Load,LoadCluster,249,"// Ensure that cluster prefetching and smearing of read requests works; // Note that ""nClusterLoaded"" is the number of _partial_ clusters preloaded from storage. Because we read; // from the first cluster first px and then py, we'll call two times `LoadCluster()` on the first cluster.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/ntuple_view.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_view.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:77,Modifiability,inherit,inherits,77,"// The choice of TRotation is arbitrary; it is a simple, existing class that inherits from TObject; // and is supported by RNTuple",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_class.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:49,Usability,simpl,simple,49,"// The choice of TRotation is arbitrary; it is a simple, existing class that inherits from TObject; // and is supported by RNTuple",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_class.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:36,Security,checksum,checksum,36,"// The following member is set by a checksum based rule",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_class.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:58,Security,checksum,checksum,58,"// The following member is not touched by a rule due to a checksum mismatch",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_class.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_string.cxx:3,Testability,Test,Tests,3,"// Tests ReadV() in RColumn.hxx (the case where a std::string overflows to the next page)",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_string.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_string.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_vector.cxx:106,Testability,test,tests,106,"// A layer of indirection to hide std::vector's second template parameter.; // This way we can generalize tests over RVec and std::vector using a template template parameter (see below).",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_vector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_vector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_vector.cxx:9,Testability,test,test,9,"// TODO: test reading of ""klassVec.v1""",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/rfield_vector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_vector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx:249,Deployability,patch,patch,249,"// A mock of the RNTuple class, used to write a ""future version"" of RNTuple to a file.; // The idea is:; // 1. we write a ""RXTuple"" to a file, with a schema identical to RNTuple + some; // hypothetical future fields; // 2. we read back the file and patch the name to transmute the on-disk; // binary to a serialized RNTuple with some additional fields; // 3. we read back the patched file to ensure the current version of RNTuple can handle; // schema evolution in a fwd-compatible way.; // For ease of patching, the name of this struct has the same length as that of RNTuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/RXTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx:376,Deployability,patch,patched,376,"// A mock of the RNTuple class, used to write a ""future version"" of RNTuple to a file.; // The idea is:; // 1. we write a ""RXTuple"" to a file, with a schema identical to RNTuple + some; // hypothetical future fields; // 2. we read back the file and patch the name to transmute the on-disk; // binary to a serialized RNTuple with some additional fields; // 3. we read back the patched file to ensure the current version of RNTuple can handle; // schema evolution in a fwd-compatible way.; // For ease of patching, the name of this struct has the same length as that of RNTuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/RXTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx:503,Deployability,patch,patching,503,"// A mock of the RNTuple class, used to write a ""future version"" of RNTuple to a file.; // The idea is:; // 1. we write a ""RXTuple"" to a file, with a schema identical to RNTuple + some; // hypothetical future fields; // 2. we read back the file and patch the name to transmute the on-disk; // binary to a serialized RNTuple with some additional fields; // 3. we read back the patched file to ensure the current version of RNTuple can handle; // schema evolution in a fwd-compatible way.; // For ease of patching, the name of this struct has the same length as that of RNTuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/RXTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx:5,Testability,mock,mock,5,"// A mock of the RNTuple class, used to write a ""future version"" of RNTuple to a file.; // The idea is:; // 1. we write a ""RXTuple"" to a file, with a schema identical to RNTuple + some; // hypothetical future fields; // 2. we read back the file and patch the name to transmute the on-disk; // binary to a serialized RNTuple with some additional fields; // 3. we read back the patched file to ensure the current version of RNTuple can handle; // schema evolution in a fwd-compatible way.; // For ease of patching, the name of this struct has the same length as that of RNTuple.",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/RXTuple.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/RXTuple.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/SimpleCollectionProxy.hxx:4,Usability,Simpl,Simple,4,"/// Simple collection proxy for `StructUsingCollectionProxy<T>`",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/SimpleCollectionProxy.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/SimpleCollectionProxy.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/SimpleCollectionProxy.hxx:69,Testability,test,test,69,"/// The internal representation of an iterator, which in this simple test only contains a pointer to an element",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/SimpleCollectionProxy.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/SimpleCollectionProxy.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/SimpleCollectionProxy.hxx:62,Usability,simpl,simple,62,"/// The internal representation of an iterator, which in this simple test only contains a pointer to an element",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/SimpleCollectionProxy.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/SimpleCollectionProxy.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/StreamerField.hxx:15,Testability,test,test,15,"// in the unit test, we set the ""rntuple.streamerMode"" class attribute of CyclicMember",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/StreamerField.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/StreamerField.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/StreamerField.hxx:28,Modifiability,polymorphi,polymorphic,28,"// Test streamer field with polymorphic type",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/StreamerField.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/StreamerField.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/StreamerField.hxx:3,Testability,Test,Test,3,"// Test streamer field with polymorphic type",MatchSource.CODE_COMMENT,tree/ntuple/v7/test/StreamerField.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/StreamerField.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:241,Usability,Feedback,Feedback,241,"/// \file ROOT/RNTupleImporter.hxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2022-11-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2022, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:2439,Availability,avail,available,2439,"ferent name than the tree; (use `SetNTupleName()`). By default, the RNTuple is compressed with zstd, independent of the input compression. The compression settings; (and other output parameters) can be changed by `SetWriteOptions()`. For example, to compress the imported RNTuple; using lz4 (with compression level 4) instead:. ~~~ {.cpp}; auto writeOptions = importer->GetWriteOptions();; writeOptions.SetCompression(404);; importer->SetWriteOptions(writeOptions);; ~~~. Most RNTuple fields have a type identical to the corresponding TTree input branch. Exceptions are; - C string branches are translated to `std::string` fields; - C style arrays are translated to `std::array<...>` fields; - Leaf lists are translated to untyped records; - Leaf count arrays are translated to anonymous collections with generic names (`_collection0`, `_collection1`, etc.).; In order to keep field names and branch names aligned, RNTuple projects the members of these collections and; its collection counter to the input branch names. For instance, the following input leafs:; ~~~; Int_t njets; float jet_pt[njets]; float jet_eta[njets]; ~~~; will be converted to the following RNTuple schema:; ~~~; _collection0 (untyped collection); |- float jet_pt; |- float jet_eta; std::size_t (RNTupleCardinality) njets (projected from _collection0 without subfields); ROOT::RVec<float> jet_pt (projected from _collection0.jet_pt); ROOT::RVec<float> jet_eta (projected from _collection0.jet_eta); ~~~; These projections are meta-data only operations and don't involve duplicating the data. Current limitations of the importer:; - No support for trees containing TClonesArray collections; - Due to RNTuple currently storing data fully split, ""don't split"" markers are ignored; - Some types are not available in RNTuple. Please refer to the; [RNTuple specification](https://github.com/root-project/root/blob/master/tree/ntuple/v7/doc/specifications.md) for; an overview of all types currently supported.; */; // clang-format on",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:18,Performance,perform,perform,18,"/// Base class to perform data transformations from TTree branches to RNTuple fields if necessary",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:38,Performance,perform,performed,38,"/// The list of transformations to be performed for every entry",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:70,Deployability,update,update,70,"/// Opens the input file for reading and the output file for writing (update).",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:75,Deployability,update,update,75,"/// Directly uses the provided tree and opens the output file for writing (update).",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx:253,Usability,Feedback,Feedback,253,"/// \file ROOT/RNTupleInspector.hxx; /// \ingroup NTuple ROOT7; /// \author Florine de Geus <florine.de.geus@cern.ch>; /// \date 2023-01-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx:341,Security,access,accessed,341,"/////////////////////////////////////////////////////////////////////////////; /// \brief Provides column-level storage information.; ///; /// The RColumnInspector class provides storage information for an individual column. This information is partly; /// collected during the construction of the RNTupleInspector object, and can partly be accessed using the; /// RColumnInspector that belongs to this field.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx:352,Security,access,accessed,352,"/////////////////////////////////////////////////////////////////////////////; /// \brief Provides field-level storage information.; ///; /// The RFieldTreeInspector class provides storage information for a field **and** its subfields. This information is; /// partly collected during the construction of the RNTupleInspector object, and can partly be accessed using; /// the RFieldDescriptor that belongs to this field.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx:358,Safety,detect,detected,358,"/////////////////////////////////////////////////////////////////////////////; /// \brief Gather column-level and RNTuple-level information.; ///; /// \note This method is called when the RNTupleInspector is initially created. This means that anything unexpected; /// about the RNTuple itself (e.g. inconsistent compression settings across clusters) will be detected here.; /// Therefore, any related exceptions will be thrown on creation of the inspector.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx:275,Testability,log,logical,275,"/////////////////////////////////////////////////////////////////////////////; /// \brief Recursively gather field-level information.; ///; /// \param[in] fieldId The ID of the field from which to start the recursive traversal. Typically this is the ""zero; /// ID"", i.e. the logical parent of all top-level fields.; ///; /// \return The RFieldTreeInspector for the provided field ID.; ///; /// This method is called when the RNTupleInspector is initially created.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx:566,Availability,error,error,566,"/////////////////////////////////////////////////////////////////////////////; /// \brief Create a new RNTupleInspector.; ///; /// \param[in] sourceNTuple A pointer to the RNTuple to be inspected.; ///; /// \return A pointer to the newly created RNTupleInspector.; ///; /// \note When this factory method is called, all required static information is collected from the RNTuple's fields; /// and underlying columns are collected at ones. This means that when any inconsistencies are encountered (e.g.; /// inconsistent compression across clusters), it will throw an error here.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleInspector.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx:236,Usability,Feedback,Feedback,236,"/// \file RNTupleImporter.cxx; /// \ingroup NTuple ROOT7; /// \author Jakob Blomer <jblomer@cern.ch>; /// \date 2022-11-22; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2022, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/src/RNTupleImporter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx:79,Deployability,update,update,79,"// Report if more than 100 MB (compressed) where written since the last status update",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/src/RNTupleImporter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx:27,Modifiability,variab,variable,27,"// We want to capture this variable, which is not possible with a; // structured binding in C++17. Explicitly defining a variable works.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/src/RNTupleImporter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx:121,Modifiability,variab,variable,121,"// We want to capture this variable, which is not possible with a; // structured binding in C++17. Explicitly defining a variable works.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/src/RNTupleImporter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleImporter.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleInspector.cxx:258,Usability,Feedback,Feedback,258,"/// \file RNTupleInspector.cxx; /// \ingroup NTuple ROOT7; /// \author Florine de Geus <florine.willemijn.de.geus@cern.ch>; /// \date 2023-01-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2023, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/src/RNTupleInspector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleInspector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleInspector.cxx:21,Safety,avoid,avoid,21,"// NOTE: outlined to avoid including RPageStorage in the header",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/src/RNTupleInspector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleInspector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntupleutil_test.hxx:15,Integrability,wrap,wrapper,15,/**; * An RAII wrapper around an open temporary file on disk. It cleans up the; * guarded file when the wrapper object goes out of scope.; */,MatchSource.CODE_COMMENT,tree/ntupleutil/v7/test/ntupleutil_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntupleutil_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntupleutil_test.hxx:104,Integrability,wrap,wrapper,104,/**; * An RAII wrapper around an open temporary file on disk. It cleans up the; * guarded file when the wrapper object goes out of scope.; */,MatchSource.CODE_COMMENT,tree/ntupleutil/v7/test/ntupleutil_test.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntupleutil_test.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx:48,Testability,test,test,48,"// Store the data in ten clusters to be able to test that the size is correctly computed in this way.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/test/ntuple_inspector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx:35,Availability,toler,tolerance,35,"// Check the target size with a 5% tolerance to account for small fluctuations across different platforms.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/test/ntuple_inspector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx:48,Testability,test,test,48,"// Store the data in ten clusters to be able to test that the size is correctly computed in this way.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/test/ntuple_inspector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx:35,Availability,toler,tolerance,35,"// Check the target size with a 5% tolerance to account for small fluctuations across different platforms.",MatchSource.CODE_COMMENT,tree/ntupleutil/v7/test/ntuple_inspector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/test/ntuple_inspector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:34,Performance,multi-thread,multi-thread,34,"/// Real time spent preparing the multi-thread workload.",MatchSource.CODE_COMMENT,tree/readspeed/inc/ReadSpeed.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:33,Performance,multi-thread,multi-thread,33,"/// CPU time spent preparing the multi-thread workload.",MatchSource.CODE_COMMENT,tree/readspeed/inc/ReadSpeed.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:206,Security,expose,expose,206,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,tree/readspeed/inc/ReadSpeed.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:13,Testability,log,logic,13,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,tree/readspeed/inc/ReadSpeed.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:239,Testability,log,logic,239,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,tree/readspeed/inc/ReadSpeed.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeed.cxx:206,Security,expose,expose,206,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,tree/readspeed/src/ReadSpeed.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeed.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeed.cxx:13,Testability,log,logic,13,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,tree/readspeed/src/ReadSpeed.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeed.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeed.cxx:239,Testability,log,logic,239,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,tree/readspeed/src/ReadSpeed.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeed.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeedCLI.cxx:14,Integrability,message,message,14,"// Print help message and exit if ""--help""",MatchSource.CODE_COMMENT,tree/readspeed/src/ReadSpeedCLI.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeedCLI.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/test/readspeed_general.cxx:67,Testability,test,testing,67,"// Creates all of our needed .root files and deletes them once the testing is over.",MatchSource.CODE_COMMENT,tree/readspeed/test/readspeed_general.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/test/readspeed_general.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:19,Testability,log,logic,19,"// Handles special logic around deleting / reseting the entry offset pointer.",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:67,Safety,avoid,avoid,67,"///<!IO feature flags. Serialized in custom portion of streamer to avoid forward compat issues unless needed.",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:144,Performance,perform,performed,144,"///<[fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. Special value; /// of `-1` indicates that the offset generation MUST be performed on first read.",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:28,Energy Efficiency,allocate,allocated,28,"///<! True if last reset re-allocated the memory",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:419,Integrability,interface,interfaces,419,"// The IO bits flag is to provide improved forward-compatibility detection.; // Any new non-forward compatibility flags related serialization should be; // added here. When a new flag is added, set it in the kSupported field;; //; // The values and names of this (and EUnsupportedIOBits) enum need not be aligned; // with the values of the various TIOFeatures enums, as there's a clean separation; // between these two interfaces. Practically, it is reasonable to keep them as aligned; // as possible in order to avoid confusion.; //; // If (fIOBits & ~kSupported) is non-zero -- i.e., an unknown IO flag is set; // in the fIOBits -- then the zombie flag will be set for this object.; //",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:65,Safety,detect,detection,65,"// The IO bits flag is to provide improved forward-compatibility detection.; // Any new non-forward compatibility flags related serialization should be; // added here. When a new flag is added, set it in the kSupported field;; //; // The values and names of this (and EUnsupportedIOBits) enum need not be aligned; // with the values of the various TIOFeatures enums, as there's a clean separation; // between these two interfaces. Practically, it is reasonable to keep them as aligned; // as possible in order to avoid confusion.; //; // If (fIOBits & ~kSupported) is non-zero -- i.e., an unknown IO flag is set; // in the fIOBits -- then the zombie flag will be set for this object.; //",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:513,Safety,avoid,avoid,513,"// The IO bits flag is to provide improved forward-compatibility detection.; // Any new non-forward compatibility flags related serialization should be; // added here. When a new flag is added, set it in the kSupported field;; //; // The values and names of this (and EUnsupportedIOBits) enum need not be aligned; // with the values of the various TIOFeatures enums, as there's a clean separation; // between these two interfaces. Practically, it is reasonable to keep them as aligned; // as possible in order to avoid confusion.; //; // If (fIOBits & ~kSupported) is non-zero -- i.e., an unknown IO flag is set; // in the fIOBits -- then the zombie flag will be set for this object.; //",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:55,Deployability,release,release,55,"// This enum covers IOBits that are known to this ROOT release but; // not supported; provides a mechanism for us to have experimental; // changes that are not going go into a supported release.; //; // (kUnsupported | kSupported) should result in the '|' of all IOBits.",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:186,Deployability,release,release,186,"// This enum covers IOBits that are known to this ROOT release but; // not supported; provides a mechanism for us to have experimental; // changes that are not going go into a supported release.; //; // (kUnsupported | kSupported) should result in the '|' of all IOBits.",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:19,Performance,perform,performed,19,"// Count of resets performed of basket size.",MatchSource.CODE_COMMENT,tree/tree/inc/TBasket.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:87,Performance,optimiz,optimize,87,"///\class TBulkBranchRead; /// Helper class for reading many branch entries at once to optimize throughput.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:96,Performance,throughput,throughput,96,"///\class TBulkBranchRead; /// Helper class for reading many branch entries at once to optimize throughput.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:59,Integrability,interface,interfaces,59,"/// Return true if the branch can be read through the bulk interfaces.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:6,Energy Efficiency,Allocate,Allocated,6,"///<! Allocated basket not currently holding any data.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:27,Modifiability,variab,variable,27,"///<! Address of 1st leaf (variable or object)",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:17,Performance,perform,performing,17,"///<! Helper for performing bulk IO",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:46,Performance,cache,cache,46,"///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:93,Performance,cache,cache,93,"///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:157,Performance,cache,cache,157,"//////////////////////////////////////////////////////////////////////////; // //; // TBranchCacheInfo //; // //; // Hold info about which basket are in the cache and if they //; // have been retrieved from the cache. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:211,Performance,cache,cache,211,"//////////////////////////////////////////////////////////////////////////; // //; // TBranchCacheInfo //; // //; // Hold info about which basket are in the cache and if they //; // have been retrieved from the cache. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:54,Deployability,Update,Update,54,"// kSize bits per baskets (loaded, used, vetoed); /// Update the pedestal to be less or equal to basketNumber, shift the bits if needed.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:27,Performance,load,loaded,27,"// kSize bits per baskets (loaded, used, vetoed); /// Update the pedestal to be less or equal to basketNumber, shift the bits if needed.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:50,Performance,cache,cache,50,"/// Return true if the basket is currently in the cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:43,Performance,cache,cache,43,"/// Mark if the basket is currently in the cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:97,Performance,load,loaded,97,"/// Mark if the basket should be vetoed in the next round.; /// This happens when the basket was loaded in the previous round; /// and was not used and is overlapping to the next round/cluster",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:51,Performance,load,loaded,51,"/// Return true if all the baskets that are marked loaded are also; /// mark as used.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:7,Performance,load,loaded,7,"// Not loaded or (loaded and used)",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:18,Performance,load,loaded,18,"// Not loaded or (loaded and used)",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchCacheInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:17,Integrability,interface,interface,17,"///<! collection interface (if any)",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:5,Security,CheckSum,CheckSum,5,"///< CheckSum of class",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:192,Usability,simpl,simple,192,"///< Branch type; ///<; ///< Note on fType values:; ///< * -1 unsplit object with custom streamer at time of writing; ///< * 0 unsplit object with default streamer at time of writing; ///< OR simple data member of split object (fID==-1 for the former); ///< * 1 base class of a split object.; ///< * 2 class typed data member of a split object; ///< * 3 branch count of a split TClonesArray; ///< * 31 data member of the content of a split TClonesArray; ///< * 4 branch count of a split STL Collection.; ///< * 41 data member of the content of a split STL collection",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:43,Modifiability,variab,variable,43,"///< Maximum entries for a TClonesArray or variable array",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:10,Integrability,Interface,Interface,10,"// Public Interface.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:272,Integrability,interface,interface,272,"// The semantics of fAddress and fObject are violated.; // Assume the user changed the pointer on us.; // Note: The cast is here because we want to be able to; // be called from the constant get functions.; // FIXME: Disable the check/warning TTree until we add a missing interface.",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchSTL.h:11,Security,checksum,checksum,11,"///< Class checksum",MatchSource.CODE_COMMENT,tree/tree/inc/TBranchSTL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchSTL.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBufferSQL.h:32,Performance,load,load,32,"// Implementation of TBuffer to load and write to a SQL database",MatchSource.CODE_COMMENT,tree/tree/inc/TBufferSQL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBufferSQL.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChain.h:30,Modifiability,variab,variables,30,"///<[fTreeOffsetLen] Array of variables",MatchSource.CODE_COMMENT,tree/tree/inc/TChain.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChain.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h:41,Deployability,update,updated,41,"///<! Address of user branch pointer (to updated upon loading a file)",MatchSource.CODE_COMMENT,tree/tree/inc/TChainElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h:54,Performance,load,loading,54,"///<! Address of user branch pointer (to updated upon loading a file)",MatchSource.CODE_COMMENT,tree/tree/inc/TChainElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h:30,Performance,Load,LoadTree,30,"///<! Return value of TChain::LoadTree(); 0 means success",MatchSource.CODE_COMMENT,tree/tree/inc/TChainElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h:6,Security,Hash,Hash,6,"///<! Hash value of a string of treename and filename",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h:14,Performance,optimiz,optimize,14,"///<! used to optimize GetEntry() function from a loop",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h:14,Performance,optimiz,optimize,14,"///<! used to optimize GetEntry() function from a loop",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h:4,Deployability,TOGGLE,TOGGLE,4,"// *TOGGLE* *GETTER=GetReapplyCut",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:951,Performance,Optimiz,OptimizeStorage,951,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // TEntryListBlock; //; // Used internally in TEntryList to store the entry numbers.; //; // There are 2 ways to represent entry numbers in a TEntryListBlock:; // 1) as bits, where passing entry numbers are assigned 1, not passing - 0; // 2) as a simple array of entry numbers; // In both cases, a UShort_t* is used. The second option is better in case; // less than 1/16 of entries passes the selection, and the representation can be; // changed by calling OptimizeStorage() function.; // When the block is being filled, it's always stored as bits, and the OptimizeStorage(); // function is called by TEntryList when it starts filling the next block. If; // Enter() or Remove() is called after OptimizeStorage(), representation is; // again changed to 1).; //; // Operations on blocks (see also function comments):; // - Merge() - adds all entries from one block to the other. If the first block; // uses array representation, it's changed to bits representation only; // if the total number of passing entries is still less than kBlockSize; // - GetEntry(n) - returns n-th non-zero entry.; // - Next() - return next non-zero entry. In case of representation 1), Next(); // is faster than GetEntry(); //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:1051,Performance,Optimiz,OptimizeStorage,1051,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // TEntryListBlock; //; // Used internally in TEntryList to store the entry numbers.; //; // There are 2 ways to represent entry numbers in a TEntryListBlock:; // 1) as bits, where passing entry numbers are assigned 1, not passing - 0; // 2) as a simple array of entry numbers; // In both cases, a UShort_t* is used. The second option is better in case; // less than 1/16 of entries passes the selection, and the representation can be; // changed by calling OptimizeStorage() function.; // When the block is being filled, it's always stored as bits, and the OptimizeStorage(); // function is called by TEntryList when it starts filling the next block. If; // Enter() or Remove() is called after OptimizeStorage(), representation is; // again changed to 1).; //; // Operations on blocks (see also function comments):; // - Merge() - adds all entries from one block to the other. If the first block; // uses array representation, it's changed to bits representation only; // if the total number of passing entries is still less than kBlockSize; // - GetEntry(n) - returns n-th non-zero entry.; // - Next() - return next non-zero entry. In case of representation 1), Next(); // is faster than GetEntry(); //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:1188,Performance,Optimiz,OptimizeStorage,1188,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // TEntryListBlock; //; // Used internally in TEntryList to store the entry numbers.; //; // There are 2 ways to represent entry numbers in a TEntryListBlock:; // 1) as bits, where passing entry numbers are assigned 1, not passing - 0; // 2) as a simple array of entry numbers; // In both cases, a UShort_t* is used. The second option is better in case; // less than 1/16 of entries passes the selection, and the representation can be; // changed by calling OptimizeStorage() function.; // When the block is being filled, it's always stored as bits, and the OptimizeStorage(); // function is called by TEntryList when it starts filling the next block. If; // Enter() or Remove() is called after OptimizeStorage(), representation is; // again changed to 1).; //; // Operations on blocks (see also function comments):; // - Merge() - adds all entries from one block to the other. If the first block; // uses array representation, it's changed to bits representation only; // if the total number of passing entries is still less than kBlockSize; // - GetEntry(n) - returns n-th non-zero entry.; // - Next() - return next non-zero entry. In case of representation 1), Next(); // is faster than GetEntry(); //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:740,Usability,simpl,simple,740,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // TEntryListBlock; //; // Used internally in TEntryList to store the entry numbers.; //; // There are 2 ways to represent entry numbers in a TEntryListBlock:; // 1) as bits, where passing entry numbers are assigned 1, not passing - 0; // 2) as a simple array of entry numbers; // In both cases, a UShort_t* is used. The second option is better in case; // less than 1/16 of entries passes the selection, and the representation can be; // changed by calling OptimizeStorage() function.; // When the block is being filled, it's always stored as bits, and the OptimizeStorage(); // function is called by TEntryList when it starts filling the next block. If; // Enter() or Remove() is called after OptimizeStorage(), representation is; // again changed to 1).; //; // Operations on blocks (see also function comments):; // - Merge() - adds all entries from one block to the other. If the first block; // uses array representation, it's changed to bits representation only; // if the total number of passing entries is still less than kBlockSize; // - GetEntry(n) - returns n-th non-zero entry.; // - Next() - return next non-zero entry. In case of representation 1), Next(); // is faster than GetEntry(); //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:9,Performance,optimiz,optimize,9,"///<! to optimize GetEntry() in a loop",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:9,Performance,optimiz,optimize,9,"///<! to optimize GetEntry() in a loop",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListFromFile.h:878,Availability,error,error,878,"//////////////////////////////////////////////////////////////////////////; // TEntryListFromFile; //; // Manages entry lists from different files, when they are not loaded; // in memory at the same time.; //; // This entry list should only be used when processing a TChain (see; // TChain::SetEntryList() function). File naming convention:; // - by default, filename_elist.root is used, where filename is the; // name of the chain element.; // - xxx$xxx.root - $ sign is replaced by the name of the chain element; // If the list name is not specified (by passing filename_elist.root/listname to; // the TChain::SetEntryList() function, the first object of class TEntryList; // in the file is taken.; // It is assumed that there are as many lists, as there are chain elements,; // and they are in the same order.; //; // If one of the list files can't be opened, or there is an error reading a list; // from the file, this list is skipped and the entry loop continues on the next; // list.",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListFromFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListFromFile.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListFromFile.h:166,Performance,load,loaded,166,"//////////////////////////////////////////////////////////////////////////; // TEntryListFromFile; //; // Manages entry lists from different files, when they are not loaded; // in memory at the same time.; //; // This entry list should only be used when processing a TChain (see; // TChain::SetEntryList() function). File naming convention:; // - by default, filename_elist.root is used, where filename is the; // name of the chain element.; // - xxx$xxx.root - $ sign is replaced by the name of the chain element; // If the list name is not specified (by passing filename_elist.root/listname to; // the TChain::SetEntryList() function, the first object of class TEntryList; // in the file is taken.; // It is assumed that there are as many lists, as there are chain elements,; // and they are in the same order.; //; // If one of the list files can't be opened, or there is an error reading a list; // from the file, this list is skipped and the entry loop continues on the next; // list.",MatchSource.CODE_COMMENT,tree/tree/inc/TEntryListFromFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListFromFile.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEventList.h:4,Deployability,TOGGLE,TOGGLE,4,"// *TOGGLE*",MatchSource.CODE_COMMENT,tree/tree/inc/TEventList.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEventList.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TFriendElement.h:273,Modifiability,variab,variable,273,"//////////////////////////////////////////////////////////////////////////; // //; // TFriendElement //; // //; // A TFriendElement TF describes a TTree object TF in a file. //; // When a TFriendElement TF is added to the list of friends of an //; // existing TTree T, any variable from TF can be referenced in a query //; // to T. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TFriendElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TFriendElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TFriendElement.h:51,Performance,Load,LoadTree,51,"// Indicates that the chain 'fTree' went through a LoadTree",MatchSource.CODE_COMMENT,tree/tree/inc/TFriendElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TFriendElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:1012,Integrability,depend,depending,1012,"//////////////////////////////////////////////////////////////////////////; // //; // TLeaf //; // //; // A TTree object is a list of TBranch. //; // A TBranch object is a list of TLeaf. In most cases, the TBranch //; // will have one TLeaf. //; // A TLeaf describes the branch data types and holds the data. //; // //; // A few notes about the data held by the leaf. It can contain: //; // 1 a single object or primitive (e.g., one float), //; // 2 a fixed-number of objects (e.g., each entry has two floats). //; // The number of elements per entry is saved in `fLen`. //; // 3 a dynamic number of primitives. The number of objects in each //; // entry is saved in the `fLeafCount` branch. //; // //; // Note options (2) and (3) can combined - if fLeafCount says an entry //; // has 3 elements and fLen is 2, then there will be 6 objects in that //; // entry. //; // //; // Additionally, `fNdata` is transient and generated on read to //; // determine the necessary size of a buffer to hold event data; //; // depending on the call-site, it may be sized larger than the number //; // of elements //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:30,Modifiability,variab,variable,30,"///< Pointer to Leaf count if variable length (we do not own the counter)",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:6,Performance,Cache,Cache,6,"///<! Cache of collection/array sizes",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:52,Modifiability,polymorphi,polymorphism,52,"// For leaves containing fixed-size objects (no; // polymorphism!), this will generate an appropriate; // offset array.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:26,Modifiability,variab,variable-sized,26,"/// If this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has variable size,; /// return a pointer to the TLeaf that stores such size. Return a nullptr otherwise.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:101,Modifiability,variab,variable,101,"/// If this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has variable size,; /// return a pointer to the TLeaf that stores such size. Return a nullptr otherwise.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:160,Modifiability,variab,variable-sized,160,"/// Return the fixed length of this leaf.; /// If the leaf stores a fixed-length array, this is the size of the array.; /// If the leaf stores a non-array or a variable-sized array, this method returns 1.; /// If the leaf stores an array with 2 or more dimensions, this method returns the total number of elements in the; /// dimensions with static length: for example for float[3][2][] it would return 6.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeaf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafB.h:145,Modifiability,variab,variable-length,145,"// Deserialize N events from an input buffer. Since chars are stored unchanged, there; // is nothing to do here but return true if we don't have variable-length arrays.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafB.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafB.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafC.h:121,Modifiability,variab,variable,121,"//////////////////////////////////////////////////////////////////////////; // //; // TLeafC //; // //; // A TLeaf for a variable length string. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafC.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafC.h:16,Modifiability,variab,variable,16,"//A TLeaf for a variable length string.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafC.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafD.h:16,Usability,simpl,simple,16,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafD.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafD.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafD32.h:16,Usability,simpl,simple,16,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafD32.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafD32.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h:6,Performance,Cache,Cache,6,"///<! Cache of the type of deserialization.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h:6,Performance,Cache,Cache,6,"///<! Cache of the EDataType of deserialization.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafElement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafF.h:16,Usability,simpl,simple,16,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafF.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafF16.h:16,Usability,simpl,simple,16,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafF16.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafF16.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafG.h:16,Usability,simpl,simple,16,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafG.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafL.h:16,Usability,simpl,simple,16,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafL.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafL.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafO.h:145,Modifiability,variab,variable-length,145,"// Deserialize N events from an input buffer. Since chars are stored unchanged, there; // is nothing to do here but return true if we don't have variable-length arrays.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafO.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafObject.h:17,Modifiability,polymorphi,polymorphism,17,"///< Support for polymorphism, when set classname is written with object.",MatchSource.CODE_COMMENT,tree/tree/inc/TLeafObject.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafObject.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtuple.h:110,Usability,simpl,simple,110,"//////////////////////////////////////////////////////////////////////////; // //; // TNtuple //; // //; // A simple tree with branches of floats. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TNtuple.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtuple.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtuple.h:23,Modifiability,variab,variables,23,"///<! [fNvar] Array of variables",MatchSource.CODE_COMMENT,tree/tree/inc/TNtuple.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtuple.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtuple.h:4,Usability,simpl,simple,4,"//A simple tree with branches of floats.",MatchSource.CODE_COMMENT,tree/tree/inc/TNtuple.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtuple.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtupleD.h:111,Usability,simpl,simple,111,"//////////////////////////////////////////////////////////////////////////; // //; // TNtupleD //; // //; // A simple tree with branches of doubles. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TNtupleD.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtupleD.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtupleD.h:23,Modifiability,variab,variables,23,"///<! [fNvar] Array of variables",MatchSource.CODE_COMMENT,tree/tree/inc/TNtupleD.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtupleD.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtupleD.h:4,Usability,simpl,simple,4,"//A simple tree with branches of floats.",MatchSource.CODE_COMMENT,tree/tree/inc/TNtupleD.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TNtupleD.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TreeUtils.h:59,Usability,simpl,simple,59,"/// Function to fill tuples (TNtuple/TNtupleD) from; /// a simple ASCII data file. With auto and decltype - we can; /// get rid of DataType parameter :) (or with a simple typedef inside ntuple class).; /// An input file consists of non-empty lines (separated by newline-characters), possibly empty lines,; /// and comments (treated as empty lines). Each non-empty line should contain N numbers - entry for a tuple.; /// Non-strict mode lets you to have newline-characters inside a tuple's row (as it worked; /// in ROOT prior to v5.3xxx).",MatchSource.CODE_COMMENT,tree/tree/inc/TreeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TreeUtils.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TreeUtils.h:164,Usability,simpl,simple,164,"/// Function to fill tuples (TNtuple/TNtupleD) from; /// a simple ASCII data file. With auto and decltype - we can; /// get rid of DataType parameter :) (or with a simple typedef inside ntuple class).; /// An input file consists of non-empty lines (separated by newline-characters), possibly empty lines,; /// and comments (treated as empty lines). Each non-empty line should contain N numbers - entry for a tuple.; /// Non-strict mode lets you to have newline-characters inside a tuple's row (as it worked; /// in ROOT prior to v5.3xxx).",MatchSource.CODE_COMMENT,tree/tree/inc/TreeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TreeUtils.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TSelector.h:5,Safety,Abort,Abort,5,"///< Abort status",MatchSource.CODE_COMMENT,tree/tree/inc/TSelector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TSelector.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TSelector.h:21,Availability,avail,available,21,"///< List of objects available during processing",MatchSource.CODE_COMMENT,tree/tree/inc/TSelector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TSelector.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:5,Deployability,Update,Update,5,"///< Update frequency for EntryLoop",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:13,Energy Efficiency,allocate,allocated,13,"///<! Memory allocated for the cluster range.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:79,Performance,load,loading,79,"///<! current file number (if file extensions); /// Object to be notified when loading a Tree.; /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; /// Usually points to a TNotifyLink if this is a TChain.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:107,Performance,Load,LoadTree,107,"///<! current file number (if file extensions); /// Object to be notified when loading a Tree.; /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; /// Usually points to a TNotifyLink if this is a TChain.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:130,Performance,Load,LoadTree,130,"///<! current file number (if file extensions); /// Object to be notified when loading a Tree.; /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; /// Usually points to a TNotifyLink if this is a TChain.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:72,Performance,Load,LoadTree,72,"///<! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:14,Performance,cache,cache,14,"///<! true if cache auto creation or resize check is needed",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:14,Performance,cache,cache,14,"///<! true if cache is prefetching whole clusters",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:18,Performance,cache,cache,18,"///<! true if the cache setting was explicitly given by user",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:23,Performance,multi-thread,multi-threading,23,"///<! true if implicit multi-threading is enabled for this tree",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:7,Usability,simpl,simplicity,7,"// For simplicity, although fIMTFlush is always disabled in non-IMT builds, we don't #ifdef it out.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:52,Integrability,interface,interfaces,52,"// So that the TTreeCloner can access the protected interfaces",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:31,Security,access,access,31,"// So that the TTreeCloner can access the protected interfaces",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:10,Deployability,update,update,10,"// use to update fFriendLockStatus",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:157,Safety,safe,safety,157,"/// If set, signals that this TTree is the output of the processing of another TTree, and; /// the entries are reshuffled w.r.t. to the original TTree. As a safety measure, a TTree; /// with this bit set cannot add friends nor can be added as a friend. If you know what; /// you are doing, you can manually unset this bit with `ResetBit(EStatusBits::kEntriesReshuffled)`.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:81,Deployability,update,updates,81,"// As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; // manner only when we are flushing multiple baskets in parallel.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:101,Safety,safe,safe,101,"// As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; // manner only when we are flushing multiple baskets in parallel.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:38,Safety,safe,safe,38,"// NOTE: these counters aren't thread safe like the ones above.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:941,Security,access,accessed,941,"/// Add a new branch, and infer the data type from the type of `obj` being passed.; ///; /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; /// possible, unless e.g. type conversions are needed.; ///; /// \param[in] name Name of the branch to be created.; /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved.; /// \param[in] bufsize The buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; /// \return Pointer to the TBranch that was created. The branch is owned by the tree.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:763,Usability,simpl,simple,763,"/// Add a new branch, and infer the data type from the type of `obj` being passed.; ///; /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; /// possible, unless e.g. type conversions are needed.; ///; /// \param[in] name Name of the branch to be created.; /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved.; /// \param[in] bufsize The buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; /// \return Pointer to the TBranch that was created. The branch is owned by the tree.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:824,Security,access,accessed,824,"/// Add a new branch, and infer the data type from the array `addobj` being passed.; ///; /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; /// possible, unless e.g. type conversions are needed.; ///; /// \param[in] name Name of the branch to be created.; /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/object will be saved.; /// \param[in] bufsize he buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; /// \return Pointer to the TBranch that was created. The branch is owned by the tree.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:646,Usability,simpl,simple,646,"/// Add a new branch, and infer the data type from the array `addobj` being passed.; ///; /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; /// possible, unless e.g. type conversions are needed.; ///; /// \param[in] name Name of the branch to be created.; /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/object will be saved.; /// \param[in] bufsize he buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; /// \return Pointer to the TBranch that was created. The branch is owned by the tree.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:15,Safety,avoid,avoid,15,"// Overload to avoid confusion between this signature and the template instance.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:15,Safety,avoid,avoid,15,"// Overload to avoid confusion between this signature and the template instance.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:15,Safety,avoid,avoid,15,"// Overload to avoid confusion between this signature and the template instance.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:2104,Deployability,update,update,2104," opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first time LoadTree is called with an entry number that belongs to the; /// last file of the chain, this will update the internal data member of the; /// class so that the next call to GetEntriesFast returns the total number; /// of entries in the dataset.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:464,Integrability,depend,depends,464,"/// Return a number greater or equal to the total number of entries in the; /// dataset.; ///; /// \note If you are interested in the total number of entries in a TChain,; /// this function will give that number once the last file of the chain; /// is opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first t",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:630,Integrability,depend,depends,630,"/// Return a number greater or equal to the total number of entries in the; /// dataset.; ///; /// \note If you are interested in the total number of entries in a TChain,; /// this function will give that number once the last file of the chain; /// is opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first t",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:1712,Performance,Load,LoadTree,1712," opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first time LoadTree is called with an entry number that belongs to the; /// last file of the chain, this will update the internal data member of the; /// class so that the next call to GetEntriesFast returns the total number; /// of entries in the dataset.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:1743,Performance,Load,LoadTree,1743," opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first time LoadTree is called with an entry number that belongs to the; /// last file of the chain, this will update the internal data member of the; /// class so that the next call to GetEntriesFast returns the total number; /// of entries in the dataset.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:2005,Performance,Load,LoadTree,2005," opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first time LoadTree is called with an entry number that belongs to the; /// last file of the chain, this will update the internal data member of the; /// class so that the next call to GetEntriesFast returns the total number; /// of entries in the dataset.",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:310,Safety,avoid,avoid,310,"/// Return a number greater or equal to the total number of entries in the; /// dataset.; ///; /// \note If you are interested in the total number of entries in a TChain,; /// this function will give that number once the last file of the chain; /// is opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first t",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:458,Testability,log,logic,458,"/// Return a number greater or equal to the total number of entries in the; /// dataset.; ///; /// \note If you are interested in the total number of entries in a TChain,; /// this function will give that number once the last file of the chain; /// is opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first t",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:546,Usability,simpl,simply,546,"/// Return a number greater or equal to the total number of entries in the; /// dataset.; ///; /// \note If you are interested in the total number of entries in a TChain,; /// this function will give that number once the last file of the chain; /// is opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first t",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:93,Performance,perform,performance,93,"// GetMakeClass is left non-virtual for efficiency reason.; // Making it virtual affects the performance of the I/O",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:88,Performance,load,loaded,88,"// *MENU*; /**; * @brief Sets the address of the object to be notified when the tree is loaded.; *; * The method TObject::Notify is called for the given object when the tree; * is loaded. Specifically this occurs in the TTree::LoadTree method. To; * remove the notification call this method with nullptr:; * @code tree->SetNotify(nullptr); @endcode; *; * If this is a TChain, `obj` is most often going to be a TNotifyLink.; *; * @param[in] obj Pointer to a TObject to be notified.; */",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:180,Performance,load,loaded,180,"// *MENU*; /**; * @brief Sets the address of the object to be notified when the tree is loaded.; *; * The method TObject::Notify is called for the given object when the tree; * is loaded. Specifically this occurs in the TTree::LoadTree method. To; * remove the notification call this method with nullptr:; * @code tree->SetNotify(nullptr); @endcode; *; * If this is a TChain, `obj` is most often going to be a TNotifyLink.; *; * @param[in] obj Pointer to a TObject to be notified.; */",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:227,Performance,Load,LoadTree,227,"// *MENU*; /**; * @brief Sets the address of the object to be notified when the tree is loaded.; *; * The method TObject::Notify is called for the given object when the tree; * is loaded. Specifically this occurs in the TTree::LoadTree method. To; * remove the notification call this method with nullptr:; * @code tree->SetNotify(nullptr); @endcode; *; * If this is a TChain, `obj` is most often going to be a TNotifyLink.; *; * @param[in] obj Pointer to a TObject to be notified.; */",MatchSource.CODE_COMMENT,tree/tree/inc/TTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:25,Performance,cache,cache,25,"///<! first entry in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:24,Performance,cache,cache,24,"///<! last entry in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:41,Performance,cache,cache,41,"///<! current lowest entry number in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:30,Performance,cache,cache,30,"///<! next entry number where cache must be filled",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:32,Performance,cache,cache,32,"///<! Number of branches in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:44,Performance,cache,cache,44,"///< Number of blocks read and found in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:53,Performance,cache,cache,53,"///< Number of blocks read, not found in the primary cache, and found in the secondary cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:87,Performance,cache,cache,87,"///< Number of blocks read, not found in the primary cache, and found in the secondary cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:48,Performance,cache,cache,48,"///< Number of blocks read and not found in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:51,Performance,cache,cache,51,"///< Number of blocks read and not found in either cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:55,Performance,cache,cache,55,"///< Number of blocks read into the secondary (""miss"") cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:43,Performance,cache,cache,43,"///<! List of branches to be stored in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:34,Performance,cache,cache,34,"///<! list of branch names in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,Performance,cache,cache,14,"///<! true if cache is in learning mode",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:26,Usability,learn,learning,26,"///<! true if cache is in learning mode",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,Performance,cache,cache,14,"///<! true if cache is StopLearningPhase was used",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:18,Usability,learn,learning,18,"///<! used in the learning phase",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:6,Performance,cache,cache,6,"///<! cache enabled for cached reading",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:24,Performance,cache,cached,24,"///<! cache enabled for cached reading",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:32,Usability,learn,learning,32,"///< number of entries used for learning mode",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,Performance,cache,cache,14,"///<! true if cache was automatically created",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:85,Performance,cache,cached,85,"///<! true if we are in the process of executing LearnPrefill; // These members hold cached data for missed branches when miss optimization; // is enabled. Pointers are only initialized if the miss cache is enabled.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:127,Performance,optimiz,optimization,127,"///<! true if we are in the process of executing LearnPrefill; // These members hold cached data for missed branches when miss optimization; // is enabled. Pointers are only initialized if the miss cache is enabled.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:198,Performance,cache,cache,198,"///<! true if we are in the process of executing LearnPrefill; // These members hold cached data for missed branches when miss optimization; // is enabled. Pointers are only initialized if the miss cache is enabled.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:49,Usability,Learn,LearnPrefill,49,"///<! true if we are in the process of executing LearnPrefill; // These members hold cached data for missed branches when miss optimization; // is enabled. Pointers are only initialized if the miss cache is enabled.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:24,Performance,optimiz,optimize,24,"///<! true if we should optimize cache misses.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:33,Performance,cache,cache,33,"///<! true if we should optimize cache misses.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:24,Performance,cache,cache,24,"//! Position in file of cache entry.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,Performance,cache,cache,14,"//! Length of cache entry.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:41,Performance,cache,cache,41,"///<! Description of buffers in the miss cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:25,Performance,cache,cache,25,"///<! Actual data in the cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:6,Performance,Cache,Cache,6,"///<! Cache contents for misses",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:48,Performance,cache,cache,48,"// These are all functions related to the ""miss cache"": this attempts to; // optimize ROOT's behavior when the TTreeCache has a cache miss. In this; // case, we try to read several branches for the event with the miss.; //; // The miss cache is more CPU-intensive than the rest of the TTreeCache code;; // for local work (i.e., laptop with SSD), this CPU cost may outweight the; // benefit.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:77,Performance,optimiz,optimize,77,"// These are all functions related to the ""miss cache"": this attempts to; // optimize ROOT's behavior when the TTreeCache has a cache miss. In this; // case, we try to read several branches for the event with the miss.; //; // The miss cache is more CPU-intensive than the rest of the TTreeCache code;; // for local work (i.e., laptop with SSD), this CPU cost may outweight the; // benefit.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:128,Performance,cache,cache,128,"// These are all functions related to the ""miss cache"": this attempts to; // optimize ROOT's behavior when the TTreeCache has a cache miss. In this; // case, we try to read several branches for the event with the miss.; //; // The miss cache is more CPU-intensive than the rest of the TTreeCache code;; // for local work (i.e., laptop with SSD), this CPU cost may outweight the; // benefit.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:236,Performance,cache,cache,236,"// These are all functions related to the ""miss cache"": this attempts to; // optimize ROOT's behavior when the TTreeCache has a cache miss. In this; // case, we try to read several branches for the event with the miss.; //; // The miss cache is more CPU-intensive than the rest of the TTreeCache code;; // for local work (i.e., laptop with SSD), this CPU cost may outweight the; // benefit.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:20,Performance,cache,cache,20,"///< Check the miss cache for a particular buffer, fetching if deemed necessary.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:19,Performance,cache,cache,19,"///< Fill the miss cache from the current set of active branches.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:36,Performance,cache,cache,36,"///< Calculate the appropriate miss cache to fetch; helper function for FillMissCache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:40,Performance,cache,cache,40,"///<! Given a file read not in the miss cache, handle (possibly) loading the data.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:65,Performance,load,loading,65,"///<! Given a file read not in the miss cache, handle (possibly) loading the data.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:18,Performance,cache,cache,18,"// Reset the miss cache.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h:183,Deployability,upgrade,upgrade,183,"// Note: we cannot use std::unique_ptr<std::unique_ptr<char[]>[]> or vector of unique_ptr; // for fUnzipChunks since std::unique_ptr is not copy constructable.; // However, in future upgrade we cannot use make_vector in C++14.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCacheUnzip.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h:46,Performance,cache,cache,46,"///<! number of blocks that were found in the cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCacheUnzip.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h:50,Performance,cache,cache,50,"///<! number of blocks that were not found in the cache and were unzipped",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCacheUnzip.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:17,Availability,error,error,17,"///< Text of the error message lead to an 'invalid' state",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:23,Integrability,message,message,23,"///< Text of the error message lead to an 'invalid' state",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:32,Performance,cache,cache,32,"///< Requested size of the file cache",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:24,Energy Efficiency,reduce,reduce,24,"///< File Cache used to reduce the number of individual reads",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:10,Performance,Cache,Cache,10,"///< File Cache used to reduce the number of individual reads",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:5,Performance,Cache,Cache,5,"///< Cache that set before the TTreeCloner ctor for the 'from' TTree if any.",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeCloner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeResult.h:127,Integrability,interface,interface,127,"//////////////////////////////////////////////////////////////////////////; // //; // TTreeResult //; // //; // Class defining interface to a TTree query result with the same //; // interface as for SQL databases. A TTreeResult is returned by //; // TTree::Query() (actually TTreePlayer::Query()). //; // //; // Related classes are TTreeRow. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeResult.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeResult.h:182,Integrability,interface,interface,182,"//////////////////////////////////////////////////////////////////////////; // //; // TTreeResult //; // //; // Class defining interface to a TTree query result with the same //; // interface as for SQL databases. A TTreeResult is returned by //; // TTree::Query() (actually TTreePlayer::Query()). //; // //; // Related classes are TTreeRow. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeResult.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeRow.h:124,Integrability,interface,interface,124,"//////////////////////////////////////////////////////////////////////////; // //; // TTreeRow //; // //; // Class defining interface to a row of a TTree query result. //; // Objects of this class are created by TTreeResult methods. //; // //; // Related classes are TTreeResult. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TTreeRow.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeRow.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TVirtualIndex.h:123,Integrability,interface,interface,123,"//////////////////////////////////////////////////////////////////////////; // //; // TVirtualIndex //; // //; // Abstract interface for Tree Index //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,tree/tree/inc/TVirtualIndex.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TVirtualIndex.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TVirtualIndex.h:11,Integrability,interface,interface,11,"//Abstract interface for Tree Index",MatchSource.CODE_COMMENT,tree/tree/inc/TVirtualIndex.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TVirtualIndex.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TVirtualTreePlayer.h:11,Integrability,interface,interface,11,"//Abstract interface for Tree players",MatchSource.CODE_COMMENT,tree/tree/inc/TVirtualTreePlayer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TVirtualTreePlayer.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx:125,Energy Efficiency,efficient,efficient,125,"// These methods allow access to the raw bitset underlying; // this object, breaking type safety. They are necessary for; // efficient interaction with TTree / TBranch / TBasket, but left; // private to prevent users from interacting with the raw bits.",MatchSource.CODE_COMMENT,tree/tree/inc/ROOT/TIOFeatures.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx:90,Safety,safe,safety,90,"// These methods allow access to the raw bitset underlying; // this object, breaking type safety. They are necessary for; // efficient interaction with TTree / TBranch / TBasket, but left; // private to prevent users from interacting with the raw bits.",MatchSource.CODE_COMMENT,tree/tree/inc/ROOT/TIOFeatures.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx:23,Security,access,access,23,"// These methods allow access to the raw bitset underlying; // this object, breaking type safety. They are necessary for; // efficient interaction with TTree / TBranch / TBasket, but left; // private to prevent users from interacting with the raw bits.",MatchSource.CODE_COMMENT,tree/tree/inc/ROOT/TIOFeatures.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:23,Usability,Clear,ClearMustCleanupBits,23,"// Usage of TBranch in ClearMustCleanupBits",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:19,Modifiability,variab,variable,19,"// Store this in a variable so it can be later used in `filenames.reserve`; // if it passes the check.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:863,Integrability,depend,depending,863,"////////////////////////////////////////////////////////////////////////////////; /// \fn RFriendInfo GetFriendInfo(const TTree &tree); /// \ingroup tree; /// \brief Get and store the names, aliases and file names of the direct friends of the tree.; /// \param[in] tree The tree from which friends information will be gathered.; /// \param[in] retrieveEntries Whether to also retrieve the number of entries in; /// each tree of each friend: one if the friend is a TTree, more if; /// the friend is a TChain. In the latter case, this function; /// triggers the opening of all files in the chain.; /// \throws std::runtime_error If the input tree has a list of friends, but any; /// of them could not be associated with any file.; ///; /// Calls TTree::GetListOfFriends and parses its result for the names, aliases; /// and file names, with different methodologies depending on whether the; /// parameter is a TTree or a TChain.; ///; /// \note This function only retrieves information about <b>direct friends</b>; /// of the input tree. It will not recurse through friends of friends and; /// does not take into account circular references in the list of friends; /// of the input tree.; ///; /// \returns An RFriendInfo struct, containing the information parsed from the; /// list of friends. The struct will contain four vectors, which elements at; /// position `i` represent the `i`-th friend of the input tree. If this friend; /// is a TTree, the `i`-th element of each of the three vectors will contain; /// respectively:; ///; /// - A pair with the name and alias of the tree (the alias might not be; /// present, in which case it will be just an empty string).; /// - A vector with a single string representing the path to current file where; /// the tree is stored.; /// - An empty vector.; /// - A vector with a single element, the number of entries in the tree.; ///; /// If the `i`-th friend is a TChain instead, the `i`-th element of each of the; /// three vectors will contain respectively",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:2407,Integrability,depend,depending,2407,"nd is a TTree, more if; /// the friend is a TChain. In the latter case, this function; /// triggers the opening of all files in the chain.; /// \throws std::runtime_error If the input tree has a list of friends, but any; /// of them could not be associated with any file.; ///; /// Calls TTree::GetListOfFriends and parses its result for the names, aliases; /// and file names, with different methodologies depending on whether the; /// parameter is a TTree or a TChain.; ///; /// \note This function only retrieves information about <b>direct friends</b>; /// of the input tree. It will not recurse through friends of friends and; /// does not take into account circular references in the list of friends; /// of the input tree.; ///; /// \returns An RFriendInfo struct, containing the information parsed from the; /// list of friends. The struct will contain four vectors, which elements at; /// position `i` represent the `i`-th friend of the input tree. If this friend; /// is a TTree, the `i`-th element of each of the three vectors will contain; /// respectively:; ///; /// - A pair with the name and alias of the tree (the alias might not be; /// present, in which case it will be just an empty string).; /// - A vector with a single string representing the path to current file where; /// the tree is stored.; /// - An empty vector.; /// - A vector with a single element, the number of entries in the tree.; ///; /// If the `i`-th friend is a TChain instead, the `i`-th element of each of the; /// three vectors will contain respectively:; /// - A pair with the name and alias of the chain (if present, both might be; /// empty strings).; /// - A vector with all the paths to the files contained in the chain.; /// - A vector with all the names of the trees making up the chain,; /// associated with the file names of the previous vector.; /// - A vector with the number of entries of each tree in the previous vector or; /// an empty vector, depending on whether \p retrieveEntries is true.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:443,Performance,load,loaded,443,"// Typically, the correct way to call GetListOfFriends would be `tree.GetTree()->GetListOfFriends()`; // (see e.g. the discussion at https://github.com/root-project/root/issues/6741).; // However, in this case, in case we are dealing with a TChain we really only care about the TChain's; // list of friends (which will need to be rebuilt in each processing task) while friends of the TChain's; // internal TTree, if any, will be automatically loaded in each task just like they would be automatically; // loaded here if we used tree.GetTree()->GetListOfFriends().",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:505,Performance,load,loaded,505,"// Typically, the correct way to call GetListOfFriends would be `tree.GetTree()->GetListOfFriends()`; // (see e.g. the discussion at https://github.com/root-project/root/issues/6741).; // However, in this case, in case we are dealing with a TChain we really only care about the TChain's; // list of friends (which will need to be rebuilt in each processing task) while friends of the TChain's; // internal TTree, if any, will be automatically loaded in each task just like they would be automatically; // loaded here if we used tree.GetTree()->GetListOfFriends().",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:159,Security,Access,Accessing,159,"// Note that each TChainElement returned by TChain::GetListOfFiles has a name; // equal to the tree name of this TChain and a title equal to the filename.; // Accessing the information like this ensures that we get the correct; // filenames and treenames if the treename is given as part of the filename; // via chain.AddFile(file.root/myTree) and as well if the tree name is given; // in the constructor via TChain(myTree) and a file is added later by chain.AddFile(file.root).; // Caveat: The chain may be made of sub-trees with different names. All; // tree names need to be retrieved separately, see below.; // Get filelist of the current chain",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:3,Safety,Avoid,Avoid,3,"// Avoid odr-using TTree::kMaxEntries which would require a; // definition in C++14. In C++17, all constexpr static data; // members are implicitly inline.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:31,Usability,simpl,simple,31,"// frTree is not a chain but a simple TTree; // Get name of the tree",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:267,Performance,concurren,concurrent,267,"/// Reset the kMustCleanup bit of a TObjArray of TBranch objects (e.g. returned by TTree::GetListOfBranches).; ///; /// In some rare cases, all branches in a TTree can have their kMustCleanup bit set, which causes a large amount; /// of contention at teardown due to concurrent calls to RecursiveRemove (which needs to take the global lock).; /// This helper function checks the first branch of the array and if it has the kMustCleanup bit set, it resets; /// it for all branches in the array, recursively going through sub-branches and leaves.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:52,Safety,avoid,avoid,52,"/// \brief Create a TChain object with options that avoid common causes of thread contention.; ///; /// In particular, set its kWithoutGlobalRegistration mode and reset its kMustCleanup bit.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:31,Safety,safe,safe,31,"// The friend is a TTree. It's safe to add to the chain the filename directly.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:168,Performance,Load,LoadTree,168,"// The call to TChain::BuildIndex does much more than just copying; // the indices that may have been already present in the trees of the; // chain. Notably, it calls `LoadTree` for every tree in the chain; // making sure that all branches, indices and relationships are; // properly set. In order to avoid unexpected behaviours, we always; // let the task-local friend chain rebuild its index.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:301,Safety,avoid,avoid,301,"// The call to TChain::BuildIndex does much more than just copying; // the indices that may have been already present in the trees of the; // chain. Notably, it calls `LoadTree` for every tree in the chain; // making sure that all branches, indices and relationships are; // properly set. In order to avoid unexpected behaviours, we always; // let the task-local friend chain rebuild its index.",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:3,Safety,Avoid,Avoid,3,"// Avoid changing gDirectory;",MatchSource.CODE_COMMENT,tree/tree/src/InternalTreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:154,Performance,cache,cached,154,"////////////////////////////////////////////////////////////////////////////////; /// Calculates the entry offset array, if possible.; ///; /// Result is cached, meaning that this should only be invoked once per basket.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:240,Availability,error,error,240,"////////////////////////////////////////////////////////////////////////////////; /// Load basket buffers in memory without unziping.; /// This function is called by TTreeCloner.; /// The function returns 0 in case of success, 1 in case of error.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:86,Performance,Load,Load,86,"////////////////////////////////////////////////////////////////////////////////; /// Load basket buffers in memory without unziping.; /// This function is called by TTreeCloner.; /// The function returns 0 in case of success, 1 in case of error.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:66,Performance,cache,cache,66,"// If we are using a TTreeCache, disable reading from the default cache; // temporarily, to force reading directly from file",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:2,Availability,error,error,2,"//error while reading",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:162,Performance,cache,cache,162,"////////////////////////////////////////////////////////////////////////////////; /// We always create the TBuffer for the basket but it hold the buffer from the cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:354,Availability,error,error,354,"////////////////////////////////////////////////////////////////////////////////; /// Read basket buffers in memory and cleanup.; ///; /// Read a basket buffer. Check if buffers of previous ReadBasket; /// should not be dropped. Remember, we keep buffers in memory up to; /// fMaxVirtualSize.; /// The function returns 0 in case of success, 1 in case of error; /// This function was modified with the addition of the parallel; /// unzipping, it will try to get the unzipped file from the cache; /// receiving only a pointer to that buffer (so we shall not; /// delete that pointer), although we get a new buffer in case; /// it's not found in the cache.; /// There is a lot of code duplication but it was necessary to assure; /// the expected behavior when there is no cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:488,Performance,cache,cache,488,"////////////////////////////////////////////////////////////////////////////////; /// Read basket buffers in memory and cleanup.; ///; /// Read a basket buffer. Check if buffers of previous ReadBasket; /// should not be dropped. Remember, we keep buffers in memory up to; /// fMaxVirtualSize.; /// The function returns 0 in case of success, 1 in case of error; /// This function was modified with the addition of the parallel; /// unzipping, it will try to get the unzipped file from the cache; /// receiving only a pointer to that buffer (so we shall not; /// delete that pointer), although we get a new buffer in case; /// it's not found in the cache.; /// There is a lot of code duplication but it was necessary to assure; /// the expected behavior when there is no cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:647,Performance,cache,cache,647,"////////////////////////////////////////////////////////////////////////////////; /// Read basket buffers in memory and cleanup.; ///; /// Read a basket buffer. Check if buffers of previous ReadBasket; /// should not be dropped. Remember, we keep buffers in memory up to; /// fMaxVirtualSize.; /// The function returns 0 in case of success, 1 in case of error; /// This function was modified with the addition of the parallel; /// unzipping, it will try to get the unzipped file from the cache; /// receiving only a pointer to that buffer (so we shall not; /// delete that pointer), although we get a new buffer in case; /// it's not found in the cache.; /// There is a lot of code duplication but it was necessary to assure; /// the expected behavior when there is no cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:769,Performance,cache,cache,769,"////////////////////////////////////////////////////////////////////////////////; /// Read basket buffers in memory and cleanup.; ///; /// Read a basket buffer. Check if buffers of previous ReadBasket; /// should not be dropped. Remember, we keep buffers in memory up to; /// fMaxVirtualSize.; /// The function returns 0 in case of success, 1 in case of error; /// This function was modified with the addition of the parallel; /// unzipping, it will try to get the unzipped file from the cache; /// receiving only a pointer to that buffer (so we shall not; /// delete that pointer), although we get a new buffer in case; /// it's not found in the cache.; /// There is a lot of code duplication but it was necessary to assure; /// the expected behavior when there is no cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:14,Performance,cache,cache,14,"// See if the cache has already unzipped the buffer for us.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:49,Safety,avoid,avoid,49,"// Determine which buffer to use, so that we can avoid a memcpy in case of; // the basket was not compressed.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:41,Performance,cache,cache,41,"// Read directly from file, not from the cache; // If we are using a TTreeCache, disable reading from the default cache; // temporarily, to force reading directly from file",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:114,Performance,cache,cache,114,"// Read directly from file, not from the cache; // If we are using a TTreeCache, disable reading from the default cache; // temporarily, to force reading directly from file",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:96,Energy Efficiency,allocate,allocate,96,"// Initialize buffer to hold the uncompressed data; // Note that in previous versions we didn't allocate buffers until we verified; // the zip headers; this is no longer beforehand as the buffer lifetime is scoped; // to the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:12,Energy Efficiency,monitor,monitor,12,"// Optional monitor for zip time profiling.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:24,Availability,error,errors,24,"// Check the header for errors.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:160,Testability,log,logical,160,"////////////////////////////////////////////////////////////////////////////////; /// Read basket buffers in memory and cleanup; ///; /// Read first bytes of a logical record starting at position pos; /// return record length (first 4 bytes of record).",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:170,Energy Efficiency,reduce,reduce,170,"////////////////////////////////////////////////////////////////////////////////; /// Reset the read basket TBuffer memory allocation if needed.; ///; /// This allows to reduce the number of memory allocation while avoiding to; /// always use the maximum size.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:215,Safety,avoid,avoiding,215,"////////////////////////////////////////////////////////////////////////////////; /// Reset the read basket TBuffer memory allocation if needed.; ///; /// This allows to reduce the number of memory allocation while avoiding to; /// always use the maximum size.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:3,Availability,Down,Downsize,3,"// Downsize the buffer if needed.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:9,Energy Efficiency,reduce,reduce,9,"/// Only reduce the size if significant enough?",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:226,Energy Efficiency,Reduce,Reduce,226,"////////////////////////////////////////////////////////////////////////////////; /// Reset the write basket to the starting state. i.e. as it was after calling; /// the constructor (and potentially attaching a TBuffer.); /// Reduce memory used by fEntryOffset and the TBuffer if needed ..",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:59,Availability,Down,Downsize,59,"// Name, Title, fClassName, fBranch; // stay the same.; // Downsize the buffer if needed.; // See if our current buffer size is significantly larger (>2x) than the historical average.; // If so, try decreasing it at this flush boundary to closer to the size from OptimizeBaskets; // (or this historical average).",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:263,Performance,Optimiz,OptimizeBaskets,263,"// Name, Title, fClassName, fBranch; // stay the same.; // Downsize the buffer if needed.; // See if our current buffer size is significantly larger (>2x) than the historical average.; // If so, try decreasing it at this flush boundary to closer to the size from OptimizeBaskets; // (or this historical average).",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:48,Performance,Optimiz,OptimizeBaskets,48,"// Wiggle room and alignment (512 is same as in OptimizeBaskets)",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:184,Modifiability,variab,variability,184,"// If fBufferRef grew since we last saw it, shrink it to ""target memory ratio"" of the occupied size; // This discourages us from having poorly-occupied buffers on branches with little variability.; //; // Does not help protect against a burst in event sizes, but does help in the cases where the basket; // size jumps from 4MB to 8MB while filling the basket, but we only end up utilizing 4.1MB.; //; // The above code block is meant to protect against extremely large events.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:88,Availability,error,error,88,"// As in TBranch::GetBasket, this is used as a half-hearted measure to suppress; // the error reporting when many failures occur.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:114,Availability,failure,failures,114,"// As in TBranch::GetBasket, this is used as a half-hearted measure to suppress; // the error reporting when many failures occur.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:525,Energy Efficiency,allocate,allocate,525,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:200,Safety,safe,safeguard,200,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:487,Safety,safe,safeguard,487,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:602,Safety,avoid,avoid,602,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:332,Testability,test,tested,332,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:351,Testability,test,tests,351,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:3,Testability,Test,Test,3,"// Test if we can skip writing out the offset map.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update basket header and EntryOffset table.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:2,Deployability,Update,Update,2,"//Update branch only for the first 10 baskets",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:227,Availability,error,error,227,"////////////////////////////////////////////////////////////////////////////////; /// Write buffer of this basket on the current file.; ///; /// The function returns the number of bytes committed to the memory.; /// If a write error occurs, the number of bytes returned is -1.; /// If no data are written, the number of bytes returned is 0.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:187,Safety,safe,safe,187,"// fBranch->GetDirectory();; // This mutex prevents multiple TBasket::WriteBuffer invocations from interacting; // with the underlying TFile at once - TFile is assumed to *not* be thread-safe.; //; // The only parallelism we'd like to exploit (right now!) is the compression; // step - everything else should be serialized at the TFile level.",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:18,Testability,test,test,18,"// R__USE_IMT; // test if buffer has really been compressed. In case of small buffers; // when the buffer contains random data, it may happen that the compressed; // buffer is larger than the input. In this case, we write the original uncompressed buffer",MatchSource.CODE_COMMENT,tree/tree/src/TBasket.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasketSQL.cxx:99,Deployability,Update,Update,99,"////////////////////////////////////////////////////////////////////////////////; /// See TBasket::Update.",MatchSource.CODE_COMMENT,tree/tree/src/TBasketSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasketSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1683,Integrability,depend,dependent,1683,"e are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values are supported with the following syntax:; /// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; /// if nelem is a leaf name, it is used",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1961,Integrability,depend,dependent,1961,"character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values are supported with the following syntax:; /// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; /// if nelem is a leaf name, it is used as the variable size of the array,; /// otherwise return 0.; /// The leaf referred to by nelem **MUST** be an int (/I),; /// - If leaf name has the form var[nelem], where nelem is a non-negative integers, then; /// it is used as the fixed size of the array.; /// - If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); /// where nelem and nelem2 are non-negative integers) then; /// it is used as a 2 dimensional array of fixed size.; /// - In case of the truncated floating point types (Float16_t and Double32_t) you can; /// furthermore specify t",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:313,Modifiability,variab,variable,313,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:385,Modifiability,variab,variable,385,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:407,Modifiability,variab,variable,407,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:460,Modifiability,variab,variable,460,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:660,Modifiability,variab,variable,660,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:716,Modifiability,variab,variable,716,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:739,Modifiability,variab,variable,739,"////////////////////////////////////////////////////////////////////////////////; /// Create a Branch as a child of a Tree; ///; /// * address is the address of the first item of a structure; /// or the address of a pointer to an object (see example in TTree.cxx).; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a; /// slash (/). The variable type must be 1 character. (Characters; /// after the first are legal and will be appended to the visible; /// name of the leaf, but have no effect.) If no type is given, the; /// type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is; /// assumed of type F by default. The list of currently supported; /// types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned ",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:2428,Modifiability,variab,variable,2428,"- `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values are supported with the following syntax:; /// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; /// if nelem is a leaf name, it is used as the variable size of the array,; /// otherwise return 0.; /// The leaf referred to by nelem **MUST** be an int (/I),; /// - If leaf name has the form var[nelem], where nelem is a non-negative integers, then; /// it is used as the fixed size of the array.; /// - If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); /// where nelem and nelem2 are non-negative integers) then; /// it is used as a 2 dimensional array of fixed size.; /// - In case of the truncated floating point types (Float16_t and Double32_t) you can; /// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; /// the type character. See `TStreamerElement::GetRange()` for further information.; /// - Any of other form is not supported.; ///; /// Note that the TTree will assume that all the item are contiguous in memory.; /// On some platform, this is not always true of the me",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:3812,Security,access,access,3812,", this data type is **not cross-platform**.; /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values are supported with the following syntax:; /// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; /// if nelem is a leaf name, it is used as the variable size of the array,; /// otherwise return 0.; /// The leaf referred to by nelem **MUST** be an int (/I),; /// - If leaf name has the form var[nelem], where nelem is a non-negative integers, then; /// it is used as the fixed size of the array.; /// - If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); /// where nelem and nelem2 are non-negative integers) then; /// it is used as a 2 dimensional array of fixed size.; /// - In case of the truncated floating point types (Float16_t and Double32_t) you can; /// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; /// the type character. See `TStreamerElement::GetRange()` for further information.; /// - Any of other form is not supported.; ///; /// Note that the TTree will assume that all the item are contiguous in memory.; /// On some platform, this is not always true of the member of a struct or a class,; /// due to padding and alignment. Sorting your data member in order of decreasing; /// sizeof usually leads to their being contiguous in memory.; ///; /// * bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entries in the Tree randomly and your Tree is in split mode.; ///; /// See an example of a Branch definition in the TTree constructor.; ///; /// Note that in case the data type is an object, this branch can contain; /// only this object.; ///; /// Note that this function is invoked by TTree::Branch",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:18,Integrability,rout,routine,18,"// Initialization routine called from the constructor. This should NOT be made virtual.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:244,Availability,down,down,244,"////////////////////////////////////////////////////////////////////////////////; /// Add the basket to this branch.; ///; /// Warning: if the basket are not 'flushed/copied' in the same; /// order as they were created, this will induce a slow down in; /// the insert (since we'll need to move all the record that are; /// entere 'too early').; /// Warning we also assume that the __current__ write basket is; /// not present (aka has been removed) or is empty (no entries).",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:70,Deployability,update,update,70,"// The first basket (should) always start at zero. If we are asked to update; // it, this likely to be from merging 'empty' branches (base class node and the likes)",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:554,Availability,error,error,554,"////////////////////////////////////////////////////////////////////////////////; /// Loop on all leaves of this branch to back fill Basket buffer.; ///; /// Use this routine instead of TBranch::Fill when filling a branch individually; /// to catch up with the number of entries already in the TTree.; ///; /// First it calls TBranch::Fill and then if the number of entries of the branch; /// reach one of TTree cluster's boundary, the basket is flushed.; ///; /// The function returns the number of bytes committed to the memory basket.; /// If a write error occurs, the number of bytes returned is -1.; /// If no data are written, because e.g. the branch is disabled,; /// the number of bytes returned is 0.; ///; /// To insure that the baskets of each cluster are located close by in the; /// file, when back-filling multiple branches make sure to call BackFill; /// for the same entry for all the branches consecutively; /// ~~~ {.cpp}; /// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; /// for( auto branch : branchCollection) {; /// ... Make change to the data associated with the branch ...; /// branch->BackFill();; /// }; /// }; /// // Since we loop over all the branches for each new entry; /// // all the baskets for a cluster are consecutive in the file.; /// ~~~; /// rather than doing all the entries of one branch at a time.; /// ~~~ {.cpp}; /// // Do NOT do things in the following order, it will lead to; /// // poorly clustered files.; /// for(auto branch : branchCollection) {; /// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; /// ... Make change to the data associated with the branch ...; /// branch->BackFill();; /// }; /// }; /// // Since we loop over all the entries for one branch; /// // all the baskets for that branch are consecutive.; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:167,Integrability,rout,routine,167,"////////////////////////////////////////////////////////////////////////////////; /// Loop on all leaves of this branch to back fill Basket buffer.; ///; /// Use this routine instead of TBranch::Fill when filling a branch individually; /// to catch up with the number of entries already in the TTree.; ///; /// First it calls TBranch::Fill and then if the number of entries of the branch; /// reach one of TTree cluster's boundary, the basket is flushed.; ///; /// The function returns the number of bytes committed to the memory basket.; /// If a write error occurs, the number of bytes returned is -1.; /// If no data are written, because e.g. the branch is disabled,; /// the number of bytes returned is 0.; ///; /// To insure that the baskets of each cluster are located close by in the; /// file, when back-filling multiple branches make sure to call BackFill; /// for the same entry for all the branches consecutively; /// ~~~ {.cpp}; /// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; /// for( auto branch : branchCollection) {; /// ... Make change to the data associated with the branch ...; /// branch->BackFill();; /// }; /// }; /// // Since we loop over all the branches for each new entry; /// // all the baskets for a cluster are consecutive in the file.; /// ~~~; /// rather than doing all the entries of one branch at a time.; /// ~~~ {.cpp}; /// // Do NOT do things in the following order, it will lead to; /// // poorly clustered files.; /// for(auto branch : branchCollection) {; /// for( auto e = 0; e < tree->GetEntries(); ++e ) { // loop over entries.; /// ... Make change to the data associated with the branch ...; /// branch->BackFill();; /// }; /// }; /// // Since we loop over all the entries for one branch; /// // all the baskets for that branch are consecutive.; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:94,Integrability,interface,interface,94,"////////////////////////////////////////////////////////////////////////////////; /// Browser interface.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:88,Safety,avoid,avoid,88,"// if the basket is not yet on file but already has event in it; // we must continue to avoid dropping the basket (and thus losing data)",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:366,Availability,error,error,366,"////////////////////////////////////////////////////////////////////////////////; /// Loop on all leaves of this branch to fill Basket buffer.; ///; /// If TBranchIMTHelper is non-null and it is time to WriteBasket, then we will; /// use TBB to compress in parallel.; ///; /// The function returns the number of bytes committed to the memory basket.; /// If a write error occurs, the number of bytes returned is -1.; /// If no data are written, because e.g. the branch is disabled,; /// the number of bytes returned is 0.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:218,Availability,error,error,218,"////////////////////////////////////////////////////////////////////////////////; /// Flush to disk all the baskets of this branch and any of subbranches.; /// Return the number of bytes written or -1 in case of write error.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:48,Availability,error,errors,48,"// This counter in the sequential case collects errors coming also from; // different files (suppose to have a program reading f1.root, f2.root ...); // In the mt case, it is made atomic: it safely collects errors from; // different files processed simultaneously.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:207,Availability,error,errors,207,"// This counter in the sequential case collects errors coming also from; // different files (suppose to have a program reading f1.root, f2.root ...); // In the mt case, it is made atomic: it safely collects errors from; // different files processed simultaneously.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:191,Safety,safe,safely,191,"// This counter in the sequential case collects errors coming also from; // different files (suppose to have a program reading f1.root, f2.root ...); // In the mt case, it is made atomic: it safely collects errors from; // different files processed simultaneously.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:16,Performance,cache,cache,16,"//add branch to cache (if any)",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:103,Integrability,depend,depending,103,"////////////////////////////////////////////////////////////////////////////////; /// Return icon name depending on type of branch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:579,Availability,error,error,579,"////////////////////////////////////////////////////////////////////////////////; /// A helper function to locate the correct basket - and its first entry.; /// Extracted to a common private function because it is needed by both GetEntry; /// and GetBulkEntries. It should not be called directly.; ///; /// If a new basket must be constructed and the user_buffer is provided, then; /// the user_buffer will back the memory of the newly-constructed basket.; ///; /// Assumes that this branch is enabled.; ///; /// Returns -1 if the entry does not exist; /// Returns -2 in case of error; /// Returns the index of the basket in case of success.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:329,Integrability,depend,depending,329,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if this branch supports bulk IO, false otherwise.; ///; /// This will return true if all the various preconditions necessary hold true; /// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; /// still fail, depending on the contents of the individual TBaskets loaded.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:242,Performance,perform,perform,242,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if this branch supports bulk IO, false otherwise.; ///; /// This will return true if all the various preconditions necessary hold true; /// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; /// still fail, depending on the contents of the individual TBaskets loaded.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:382,Performance,load,loaded,382,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if this branch supports bulk IO, false otherwise.; ///; /// This will return true if all the various preconditions necessary hold true; /// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; /// still fail, depending on the contents of the individual TBaskets loaded.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:290,Availability,failure,failure,290,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1194,Integrability,interface,interface,1194,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1274,Integrability,wrap,wrapped,1274,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1298,Integrability,interface,interfaces,1298,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1400,Performance,perform,perform,1400,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:350,Security,access,access,350,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1223,Security,expose,exposed,1223,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:3,Testability,Test,Test,3,"// Test for very old ROOT files.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:3,Testability,Test,Test,3,"// Test for displacements, which aren't supported in fast mode.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:293,Availability,failure,failure,293,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1430,Integrability,interface,interface,1430,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1510,Integrability,wrap,wrapped,1510,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1534,Integrability,interface,interfaces,1534,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1621,Performance,perform,performs,1621,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1459,Security,expose,exposed,1459,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:3,Testability,Test,Test,3,"// Test for very old ROOT files.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:3,Testability,Test,Test,3,"// Test for displacements, which aren't supported in fast mode.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:641,Availability,error,error,641,"////////////////////////////////////////////////////////////////////////////////; /// Read all leaves of entry and return total number of bytes read.; ///; /// The input argument ""entry"" is the entry number in the current tree.; /// In case of a TChain, the entry number in the current Tree must be found; /// before calling this function. For example:; ///; ///~~~ {.cpp}; /// TChain* chain = ...;; /// Long64_t localEntry = chain->LoadTree(entry);; /// branch->GetEntry(localEntry);; ///~~~; ///; /// The function returns the number of bytes read from the input buffer.; /// If entry does not exist, the function returns 0.; /// If an I/O error occurs, the function returns -1.; ///; /// See IMPORTANT REMARKS in TTree::GetEntry.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:433,Performance,Load,LoadTree,433,"////////////////////////////////////////////////////////////////////////////////; /// Read all leaves of entry and return total number of bytes read.; ///; /// The input argument ""entry"" is the entry number in the current tree.; /// In case of a TChain, the entry number in the current Tree must be found; /// before calling this function. For example:; ///; ///~~~ {.cpp}; /// TChain* chain = ...;; /// Long64_t localEntry = chain->LoadTree(entry);; /// branch->GetEntry(localEntry);; ///~~~; ///; /// The function returns the number of bytes read from the input buffer.; /// If entry does not exist, the function returns 0.; /// If an I/O error occurs, the function returns -1.; ///; /// See IMPORTANT REMARKS in TTree::GetEntry.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:8,Testability,test,test,8,"// This test necessary to read very old Root files (NvE).",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:339,Availability,failure,failure,339,"////////////////////////////////////////////////////////////////////////////////; /// Fill expectedClass and expectedType with information on the data type of the; /// object/values contained in this branch (and thus the type of pointers; /// expected to be passed to Set[Branch]Address; /// return 0 in case of success and > 0 in case of failure.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:458,Performance,optimiz,optimize,458,"////////////////////////////////////////////////////////////////////////////////; /// Return a fresh basket by either reusing an existing basket that needs; /// to be drop (according to TTree::MemoryFull) or create a new one.; ///; /// If the user_buffer argument is non-null, then the memory in the; /// user-provided buffer will be utilized by the underlying basket.; ///; /// The basket number is used to estimate the required buffer size; /// and try to optimize memory usage and number of memory allocation.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:257,Performance,perform,perform,257,"// Clear the rest of the baskets. While it would be ideal to reuse these baskets; // for other baskets in the new cluster. It would require the function to go; // beyond its current scope. In the ideal case when each cluster only has 1 basket; // this will perform well",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:3,Usability,Clear,Clear,3,"// Clear the rest of the baskets. While it would be ideal to reuse these baskets; // for other baskets in the new cluster. It would require the function to go; // beyond its current scope. In the ideal case when each cluster only has 1 basket; // this will perform well",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:29,Safety,avoid,avoid,29,"// Reserve the final size to avoid allocations",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:10,Availability,error,error,10,"// Handle error condition, if the parameter is us, we cannot find the parent.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:565,Performance,Load,LoadBaskets,565,"////////////////////////////////////////////////////////////////////////////////; /// Baskets associated to this branch are forced to be in memory.; /// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; /// the system that the total size of the imported baskets does not; /// exceed maxmemory bytes.; ///; /// The function returns the number of baskets that have been put in memory.; /// This method may be called to force all baskets of one or more branches; /// in memory when random access to entries in this branch is required.; /// See also TTree::LoadBaskets to load all baskets of all branches in memory.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:580,Performance,load,load,580,"////////////////////////////////////////////////////////////////////////////////; /// Baskets associated to this branch are forced to be in memory.; /// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; /// the system that the total size of the imported baskets does not; /// exceed maxmemory bytes.; ///; /// The function returns the number of baskets that have been put in memory.; /// This method may be called to force all baskets of one or more branches; /// in memory when random access to entries in this branch is required.; /// See also TTree::LoadBaskets to load all baskets of all branches in memory.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:498,Security,access,access,498,"////////////////////////////////////////////////////////////////////////////////; /// Baskets associated to this branch are forced to be in memory.; /// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; /// the system that the total size of the imported baskets does not; /// exceed maxmemory bytes.; ///; /// The function returns the number of baskets that have been put in memory.; /// This method may be called to force all baskets of one or more branches; /// in memory when random access to entries in this branch is required.; /// See also TTree::LoadBaskets to load all baskets of all branches in memory.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:148,Performance,cache,cached,148,"////////////////////////////////////////////////////////////////////////////////; /// Print the information we have about which basket is currently cached and; /// whether they have been 'used'/'read' from the cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:210,Performance,cache,cache,210,"////////////////////////////////////////////////////////////////////////////////; /// Print the information we have about which basket is currently cached and; /// whether they have been 'used'/'read' from the cache.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:140,Safety,avoid,avoid,140,"////////////////////////////////////////////////////////////////////////////////; /// Set address of this branch directly from a TBuffer to avoid streaming.; ///; /// Note: We do not take ownership of the buffer.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the default value for the branch's fEntryOffsetLen if and only if; /// it was already non zero (and the new value is not zero); /// If updateExisting is true, also update all the existing branches.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:228,Deployability,update,updateExisting,228,"////////////////////////////////////////////////////////////////////////////////; /// Update the default value for the branch's fEntryOffsetLen if and only if; /// it was already non zero (and the new value is not zero); /// If updateExisting is true, also update all the existing branches.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:257,Deployability,update,update,257,"////////////////////////////////////////////////////////////////////////////////; /// Update the default value for the branch's fEntryOffsetLen if and only if; /// it was already non zero (and the new value is not zero); /// If updateExisting is true, also update all the existing branches.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:961,Deployability,update,update,961,"////////////////////////////////////////////////////////////////////////////////; /// Set file where this branch writes/reads its buffers.; /// By default the branch buffers reside in the file where the; /// Tree was created.; /// If the file name where the tree was created is an absolute; /// path name or an URL (e.g. or root://host/...); /// and if the fname is not an absolute path name or an URL then; /// the path of the tree file is prepended to fname to make the; /// branch file relative to the tree file. In this case one can; /// move the tree + all branch files to a different location in; /// the file system and still access the branch files.; /// The ROOT file will be connected only when necessary.; /// If called by TBranch::Fill (via TBasket::WriteFile), the file; /// will be created with the option ""recreate"".; /// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; /// will be opened in read mode.; /// To open a file in ""update"" mode or with a certain compression; /// level, use TBranch::SetFile(TFile *file).",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:633,Security,access,access,633,"////////////////////////////////////////////////////////////////////////////////; /// Set file where this branch writes/reads its buffers.; /// By default the branch buffers reside in the file where the; /// Tree was created.; /// If the file name where the tree was created is an absolute; /// path name or an URL (e.g. or root://host/...); /// and if the fname is not an absolute path name or an URL then; /// the path of the tree file is prepended to fname to make the; /// branch file relative to the tree file. In this case one can; /// move the tree + all branch files to a different location in; /// the file system and still access the branch files.; /// The ROOT file will be connected only when necessary.; /// If called by TBranch::Fill (via TBasket::WriteFile), the file; /// will be created with the option ""recreate"".; /// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; /// will be opened in read mode.; /// To open a file in ""update"" mode or with a certain compression; /// level, use TBranch::SetFile(TFile *file).",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:958,Deployability,update,update,958,"////////////////////////////////////////////////////////////////////////////////; /// Set file where this branch writes/reads its buffers.; /// By default the branch buffers reside in the file where the; /// Tree was created.; /// If the file name where the tree was created is an absolute; /// path name or an URL (e.g. root://host/...); /// and if the fname is not an absolute path name or an URL then; /// the path of the tree file is prepended to fname to make the; /// branch file relative to the tree file. In this case one can; /// move the tree + all branch files to a different location in; /// the file system and still access the branch files.; /// The ROOT file will be connected only when necessary.; /// If called by TBranch::Fill (via TBasket::WriteFile), the file; /// will be created with the option ""recreate"".; /// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; /// will be opened in read mode.; /// To open a file in ""update"" mode or with a certain compression; /// level, use TBranch::SetFile(TFile *file).",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:630,Security,access,access,630,"////////////////////////////////////////////////////////////////////////////////; /// Set file where this branch writes/reads its buffers.; /// By default the branch buffers reside in the file where the; /// Tree was created.; /// If the file name where the tree was created is an absolute; /// path name or an URL (e.g. root://host/...); /// and if the fname is not an absolute path name or an URL then; /// the path of the tree file is prepended to fname to make the; /// branch file relative to the tree file. In this case one can; /// move the tree + all branch files to a different location in; /// the file system and still access the branch files.; /// The ROOT file will be connected only when necessary.; /// If called by TBranch::Fill (via TBasket::WriteFile), the file; /// will be created with the option ""recreate"".; /// If called by TBranch::GetEntry (via TBranch::GetBasket), the file; /// will be opened in read mode.; /// To open a file in ""update"" mode or with a certain compression; /// level, use TBranch::SetFile(TFile *file).",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:40,Safety,safe,safely,40,"// The Basket was written so we can now safely reuse it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:291,Deployability,update,update,291,"////////////////////////////////////////////////////////////////////////////////; /// Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); /// with the current value of fTree->GetCurrentFile unless this branch has been; /// redirected to a different file. Also update the sub-branches.",MatchSource.CODE_COMMENT,tree/tree/src/TBranch.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:161,Modifiability,extend,extend,161,"/** \class TVirtualBranchBrowsable; \ingroup tree. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; ~~~ {.cpp}; TMethodBrowsable::Unregister(); ~~~; will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and their generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; ~~~ {.cpp}; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; ~~~; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; ~~~ {.cpp}; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; ~~~. It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:905,Performance,cache,cached,905,"/** \class TVirtualBranchBrowsable; \ingroup tree. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; ~~~ {.cpp}; TMethodBrowsable::Unregister(); ~~~; will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and their generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; ~~~ {.cpp}; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; ~~~; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; ~~~ {.cpp}; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; ~~~. It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:966,Performance,cache,cached,966,"/** \class TVirtualBranchBrowsable; \ingroup tree. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; ~~~ {.cpp}; TMethodBrowsable::Unregister(); ~~~; will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and their generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; ~~~ {.cpp}; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; ~~~; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; ~~~ {.cpp}; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; ~~~. It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:1153,Usability,simpl,simple,1153,"/** \class TVirtualBranchBrowsable; \ingroup tree. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; ~~~ {.cpp}; TMethodBrowsable::Unregister(); ~~~; will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and their generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; ~~~ {.cpp}; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; ~~~; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; ~~~ {.cpp}; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; ~~~. It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:269,Availability,down,down,269,"////////////////////////////////////////////////////////////////////////////////; /// Askes all registered generators to fill their browsables into; /// the list. The browsables are generated for a given parent,; /// or (if 0), for a given branch. The branch is passed down to; /// leaves of TVirtualBranchBrowsable, too, as we need to access; /// the branch's TTree to be able to traw.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:336,Security,access,access,336,"////////////////////////////////////////////////////////////////////////////////; /// Askes all registered generators to fill their browsables into; /// the list. The browsables are generated for a given parent,; /// or (if 0), for a given branch. The branch is passed down to; /// leaves of TVirtualBranchBrowsable, too, as we need to access; /// the branch's TTree to be able to traw.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:448,Integrability,depend,depending,448,"////////////////////////////////////////////////////////////////////////////////; /// Check whether the branch (or the parent) contains a collection.; /// If it does, set ""contained"" to the contained type (if we can; /// retrieve it) and return the TClass for the collection. Set; /// ""contained"" to the branch's (or parent's) contained object's; /// class for non-collections, returning 0.; ///; /// Only one of ""branch"" or ""parent"" can ge given (depending on whether; /// we are creating browsable objects for a branch or for another; /// browsable object)",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:3,Performance,load,load,3,"// load first entry of the branch. Yes, this is bad, and might have; // unexpected side effects for the user, esp as already looking at; // (and not just drawing) a branch triggers it.; // To prove just how ugly it is, we'll also have to const_cast the; // branch...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:703,Deployability,update,update,703,"// load first entry of the branch. Yes, this is bad, and might have; // unexpected side effects for the user, esp as already looking at; // (and not just drawing) a branch triggers it.; // To prove just how ugly it is, we'll also have to const_cast the; // branch...; //if (branch->GetReadEntry()==-1) branchNonCost->GetEntry(0);; // now get element; //TLeafObject* lo=(TLeafElement*)branchNonCost->GetListOfLeaves()->First();; //TObject* objContainer=(TObject*)((TBranchElement*)branch)->GetValuePointer();; //if (objContainer && objContainer->IsA()==TClonesArray::Class()); // contained=((TClonesArray*)objContainer)->GetClass();; // Currently we can peer into the nested TClonesArray, we need; // to update TBranchElement::GetValuePointer.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:3,Performance,load,load,3,"// load first entry of the branch. Yes, this is bad, and might have; // unexpected side effects for the user, esp as already looking at; // (and not just drawing) a branch triggers it.; // To prove just how ugly it is, we'll also have to const_cast the; // branch...; //if (branch->GetReadEntry()==-1) branchNonCost->GetEntry(0);; // now get element; //TLeafObject* lo=(TLeafElement*)branchNonCost->GetListOfLeaves()->First();; //TObject* objContainer=(TObject*)((TBranchElement*)branch)->GetValuePointer();; //if (objContainer && objContainer->IsA()==TClonesArray::Class()); // contained=((TClonesArray*)objContainer)->GetClass();; // Currently we can peer into the nested TClonesArray, we need; // to update TBranchElement::GetValuePointer.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:270,Integrability,depend,depending,270,"////////////////////////////////////////////////////////////////////////////////; /// Returns the full name for TTree::Draw to draw *this.; /// Recursively appends, starting at the top TBranch,; /// all method / object names with proper reference operators (->, .); /// depending on fTypeIsPointer.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:515,Availability,avail,available,515,"////////////////////////////////////////////////////////////////////////////////; /// \class TMethodBrowsable; /// \ingroup tree; ///; /// This helper object allows the browsing of methods of objects stored in; /// branches. They will be depicted by a leaf (or a branch, in case the method; /// returns an object) with a red exclamation mark. Only a subset of all; /// methods will be shown in the browser (see IsMethodBrowsable for the; /// criteria a method has to satisfy).; ///; /// Obviously, methods are only available if the library is loaded which; /// contains the dictionary for the class to be browsed!; ///; /// If a branch contains a collection, TMethodBrowsable tries to find out; /// what the contained element is (it will only create methods for the; /// contained elements, but never for the collection). If it fails to extract; /// the type of the contained elements, or if there is no guarantee that the; /// type has any other common denominator than TObject (e.g. in the case of; /// a TObjArray, which can hold any object deriving from TObject) no methods; /// will be added.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor.; /// Links a TBranchElement to a TMethod, allowing the TBrowser to; /// browse simple methods.; ///; /// The c'tor sets the name for a method ""Class::Method(params) const""; /// to ""Method(params)"", title to TMethod::GetPrototype",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:543,Performance,load,loaded,543,"////////////////////////////////////////////////////////////////////////////////; /// \class TMethodBrowsable; /// \ingroup tree; ///; /// This helper object allows the browsing of methods of objects stored in; /// branches. They will be depicted by a leaf (or a branch, in case the method; /// returns an object) with a red exclamation mark. Only a subset of all; /// methods will be shown in the browser (see IsMethodBrowsable for the; /// criteria a method has to satisfy).; ///; /// Obviously, methods are only available if the library is loaded which; /// contains the dictionary for the class to be browsed!; ///; /// If a branch contains a collection, TMethodBrowsable tries to find out; /// what the contained element is (it will only create methods for the; /// contained elements, but never for the collection). If it fails to extract; /// the type of the contained elements, or if there is no guarantee that the; /// type has any other common denominator than TObject (e.g. in the case of; /// a TObjArray, which can hold any object deriving from TObject) no methods; /// will be added.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor.; /// Links a TBranchElement to a TMethod, allowing the TBrowser to; /// browse simple methods.; ///; /// The c'tor sets the name for a method ""Class::Method(params) const""; /// to ""Method(params)"", title to TMethod::GetPrototype",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:1277,Usability,simpl,simple,1277,"////////////////////////////////////////////////////////////////////////////////; /// \class TMethodBrowsable; /// \ingroup tree; ///; /// This helper object allows the browsing of methods of objects stored in; /// branches. They will be depicted by a leaf (or a branch, in case the method; /// returns an object) with a red exclamation mark. Only a subset of all; /// methods will be shown in the browser (see IsMethodBrowsable for the; /// criteria a method has to satisfy).; ///; /// Obviously, methods are only available if the library is loaded which; /// contains the dictionary for the class to be browsed!; ///; /// If a branch contains a collection, TMethodBrowsable tries to find out; /// what the contained element is (it will only create methods for the; /// contained elements, but never for the collection). If it fails to extract; /// the type of the contained elements, or if there is no guarantee that the; /// type has any other common denominator than TObject (e.g. in the case of; /// a TObjArray, which can hold any object deriving from TObject) no methods; /// will be added.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor.; /// Links a TBranchElement to a TMethod, allowing the TBrowser to; /// browse simple methods.; ///; /// The c'tor sets the name for a method ""Class::Method(params) const""; /// to ""Method(params)"", title to TMethod::GetPrototype",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:398,Security,access,access,398,"////////////////////////////////////////////////////////////////////////////////; /// A TMethod is browsable if it is const, public and not pure virtual,; /// if does not have any parameter without default value, and if it has; /// a (non-void) return value.; /// A method called *, Get*, or get* will not be browsable if there is a; /// persistent data member called f*, _*, or m*, as data member access is; /// faster than method access. Examples: if one of fX, _X, or mX is a; /// persistent data member, the methods GetX(), getX(), and X() will not; /// be browsable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:432,Security,access,access,432,"////////////////////////////////////////////////////////////////////////////////; /// A TMethod is browsable if it is const, public and not pure virtual,; /// if does not have any parameter without default value, and if it has; /// a (non-void) return value.; /// A method called *, Get*, or get* will not be browsable if there is a; /// persistent data member called f*, _*, or m*, as data member access is; /// faster than method access. Examples: if one of fX, _X, or mX is a; /// persistent data member, the methods GetX(), getX(), and X() will not; /// be browsable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:386,Performance,load,loaded,386,"////////////////////////////////////////////////////////////////////////////////; /// \class TNonSplitBrowsable; /// \ingroup tree; ///; /// Allows a TBrowser to browse non-split branches as if they were split. The; /// generator extracts the necessary information from the streamer info in; /// memory (which does not have to be the same as the one on file, in case; /// a library was loaded containing the dictionary for this type), i.e. it; /// also works without loading the class's library.; ///; /// Just as with TMethodBrowsables, if the generator finds a collection it; /// only takes the contained objects into account, not the collections. If; /// it identifies a collection, but cannot extract the contained type, or the; /// contained type can be anything deriving from a TObject (like for TObjArray); /// or is not limited at all, no browser helper objects are created.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor. Creates a TNonSplitBrowsable from a TStreamerElement, containing branch; /// and (if applicable) parent TVirtualBranchBrowsable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:467,Performance,load,loading,467,"////////////////////////////////////////////////////////////////////////////////; /// \class TNonSplitBrowsable; /// \ingroup tree; ///; /// Allows a TBrowser to browse non-split branches as if they were split. The; /// generator extracts the necessary information from the streamer info in; /// memory (which does not have to be the same as the one on file, in case; /// a library was loaded containing the dictionary for this type), i.e. it; /// also works without loading the class's library.; ///; /// Just as with TMethodBrowsables, if the generator finds a collection it; /// only takes the contained objects into account, not the collections. If; /// it identifies a collection, but cannot extract the contained type, or the; /// contained type can be anything deriving from a TObject (like for TObjArray); /// or is not limited at all, no browser helper objects are created.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor. Creates a TNonSplitBrowsable from a TStreamerElement, containing branch; /// and (if applicable) parent TVirtualBranchBrowsable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:6,Usability,simpl,simply,6,"// we simply add all of our and the bases' members into one big list",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:472,Security,access,access,472,"////////////////////////////////////////////////////////////////////////////////; /// \class TCollectionPropertyBrowsable; /// \ingroup tree; ///; /// A tiny browser helper object (and its generator) for adding a virtual; /// (as in ""not actually part of the class"", not in C++ virtual) ""@size()""; /// method to a collection. For all collections that derive from; /// TCollection, or have a TVirtualCollectionProxy associated with them,; /// a leaf is created that allows access to the number of elements in the; /// collection. For TClonesArrays and types with an associated; /// TVirtualCollectionProxy, this forwards to TTreeFormula's; /// ""@branch.size()"" functionality. For all other collections, a method call; /// to the appropriate collection's member function is executed when drawing.; ///; /// These objects are of course only created for elements containing a; /// collection; the generator has no effect on any other elements.; ////////////////////////////////////////////////////////////////////////////////; /// Browses a TCollectionPropertyBrowsable. The only difference to; /// the generic TVirtualBranchBrowsable::Browse is our fDraw",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:477,Usability,simpl,simply,477,"////////////////////////////////////////////////////////////////////////////////; /// If the element to browse (given by either parent of branch) contains; /// a collection (TClonesArray or something for which a TVirtualCollectionProxy; /// exists), we will add some special objects to the browser. For now there is; /// just one object ""@size"", returning the size of the collection (as in; /// std::list::size(), or TClonesArray::GetEntries()).; /// The objects we create are simply used to forward strings (like ""@size"") to; /// TTreeFormula via our Browse method. These strings are stored in fName.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:60,Security,access,access,60,"// now prepend ""@"" to the last element of the scope,; // to access the collection and not its containees",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:279,Availability,avail,available,279,"////////////////////////////////////////////////////////////////////////////////; /// \class TCollectionMethodBrowsable; /// \ingroup tree; ///; /// TCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing; /// all methods of the collection itself. If none are available - e.g. for STL; /// classes like std::list, a TVirtualBranchBrowsable object is created instead.; /// The methods' names will have a ""@"" prepended, to distinguish them from the; /// contained elements' methods.; ///; /// This browser helper object is not part of the default list of registered; /// generators (see TVirtualBranchBrowsable::RegisterDefaultGenerators()).; /// If you want to use it, you should call; /// TCollectionMethodBrowsable::Register();; /// As it extends the functionality of TVirtualBranchBrowsable, one might want; /// to unregister the generator of the ""@size()"" method by calling; /// TCollectionPropertyBrowsable::Unregister();; ////////////////////////////////////////////////////////////////////////////////; /// Constructor, see TMethodBrowsable's constructor.; /// Prepends ""@"" to the name to make this method work on the container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:176,Modifiability,extend,extends,176,"////////////////////////////////////////////////////////////////////////////////; /// \class TCollectionMethodBrowsable; /// \ingroup tree; ///; /// TCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing; /// all methods of the collection itself. If none are available - e.g. for STL; /// classes like std::list, a TVirtualBranchBrowsable object is created instead.; /// The methods' names will have a ""@"" prepended, to distinguish them from the; /// contained elements' methods.; ///; /// This browser helper object is not part of the default list of registered; /// generators (see TVirtualBranchBrowsable::RegisterDefaultGenerators()).; /// If you want to use it, you should call; /// TCollectionMethodBrowsable::Register();; /// As it extends the functionality of TVirtualBranchBrowsable, one might want; /// to unregister the generator of the ""@size()"" method by calling; /// TCollectionPropertyBrowsable::Unregister();; ////////////////////////////////////////////////////////////////////////////////; /// Constructor, see TMethodBrowsable's constructor.; /// Prepends ""@"" to the name to make this method work on the container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:759,Modifiability,extend,extends,759,"////////////////////////////////////////////////////////////////////////////////; /// \class TCollectionMethodBrowsable; /// \ingroup tree; ///; /// TCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing; /// all methods of the collection itself. If none are available - e.g. for STL; /// classes like std::list, a TVirtualBranchBrowsable object is created instead.; /// The methods' names will have a ""@"" prepended, to distinguish them from the; /// contained elements' methods.; ///; /// This browser helper object is not part of the default list of registered; /// generators (see TVirtualBranchBrowsable::RegisterDefaultGenerators()).; /// If you want to use it, you should call; /// TCollectionMethodBrowsable::Register();; /// As it extends the functionality of TVirtualBranchBrowsable, one might want; /// to unregister the generator of the ""@size()"" method by calling; /// TCollectionPropertyBrowsable::Unregister();; ////////////////////////////////////////////////////////////////////////////////; /// Constructor, see TMethodBrowsable's constructor.; /// Prepends ""@"" to the name to make this method work on the container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:86,Integrability,Wrap,Wrapper,86,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:199,Integrability,depend,depending,199,"////////////////////////////////////////////////////////////////////////////////; /// Wrapper for the registration method. Needed against MSVC, which; /// assigned different addr to the same method, depending on what; /// translation unit you're in...",MatchSource.CODE_COMMENT,tree/tree/src/TBranchBrowsable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchClones.cxx:23,Energy Efficiency,allocate,allocate,23,"// We've been asked to allocate an object for the user.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchClones.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchClones.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchClones.cxx:291,Deployability,update,update,291,"////////////////////////////////////////////////////////////////////////////////; /// Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); /// with the current value of fTree->GetCurrentFile unless this branch has been; /// redirected to a different file. Also update the sub-branches.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchClones.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchClones.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:3,Usability,Clear,Clear,3,"// Clear the bit kAutoDelete to specify that when reading; // the object should not be deleted before calling Streamer.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:7,Energy Efficiency,Allocate,Allocate,7,"//; // Allocate and initialize the basket control arrays.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:44,Modifiability,inherit,inherits,44,"// -- If we are an object data member which inherits from TObject,; // flag it so that later during i/o we will register the object; // with the buffer so that pointers are handled correctly.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:361,Availability,down,downwards,361,"// -- If the branch's name is the same as the base class name,; // which happens when we are a child branch of a top-level; // branch whose name does not end in a dot and also has no; // internal dots, elide the branch name, and keep the branch; // hierarchy rooted at the ultimate parent, this keeps the base; // class part of the branch name from propagating downwards.; // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:534,Safety,detect,detection,534,"// -- If the branch's name is the same as the base class name,; // which happens when we are a child branch of a top-level; // branch whose name does not end in a dot and also has no; // internal dots, elide the branch name, and keep the branch; // hierarchy rooted at the ultimate parent, this keeps the base; // class part of the branch name from propagating downwards.; // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:268,Availability,avail,available,268,"// ===> create sub branches for each data member of a TClonesArray; //check that the contained objects class name is part of the element title; //This name is mandatory when reading the Tree later on and; //the parent class with the pointer to the TClonesArray is not available.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:111,Modifiability,extend,extending,111,"// -- A collection was stored in a collection, we choose not to split it.; // Note: Splitting it would require extending TTreeFormula; // to understand how to access it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:159,Security,access,access,159,"// -- A collection was stored in a collection, we choose not to split it.; // Note: Splitting it would require extending TTreeFormula; // to understand how to access it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:205,Availability,avail,available,205,"// Check that the contained objects class name is part of the element title.; // This name is mandatory when reading the tree later on and; // the parent class with the pointer to the STL container is not available.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:44,Availability,error,error,44,"// Return on success.; // FIXME: Why not on error too?",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:3,Deployability,Release,Release,3,"// Release any allocated I/O buffers.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:15,Energy Efficiency,allocate,allocated,15,"// Release any allocated I/O buffers.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:62,Performance,optimiz,optimizer,62,"//; // This function is located here to allow inlining by the optimizer.; //; ////////////////////////////////////////////////////////////////////////////////; /// Get streamer info for the branch class.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:34,Energy Efficiency,reduce,reduce,34,"// Note: we need to find a way to reduce the complexity of; // this often executed condition.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:99,Deployability,update,updated,99,"// this works both for top level branches and for sub-branches,; // as GetClonesName() is properly updated for sub-branches",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:252,Availability,error,error,252,"////////////////////////////////////////////////////////////////////////////////; /// Loop on all leaves of this branch to fill the basket buffer.; ///; /// The function returns the number of bytes committed to the; /// individual branches. If a write error occurs, the number of; /// bytes returned is -1. If no data are written, because, e.g.,; /// the branch is disabled, the number of bytes returned is 0.; ///; /// Note: We not not use any member functions from TLeafElement!",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:37,Deployability,update,update,37,"//; // If we are a top-level branch, update addresses.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:140,Modifiability,extend,extended,140,"//; // If the tree has a TRefTable, set the current branch if; // branch is not a basic type.; //; // FIXME: This test probably needs to be extended past 10.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:114,Testability,test,test,114,"//; // If the tree has a TRefTable, set the current branch if; // branch is not a basic type.; //; // FIXME: This test probably needs to be extended past 10.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:34,Availability,Error,Error,34,"// FIXME: Enable this message.; //Error(""FillLeaves"", ""Branch address not set for branch '%s'!"", GetName());",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:22,Integrability,message,message,22,"// FIXME: Enable this message.; //Error(""FillLeaves"", ""Branch address not set for branch '%s'!"", GetName());",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:60,Modifiability,variab,variable,60,"// FIXME: This is wrong!!! TVirtualStreamerInfo::kBits is a variable length type.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:256,Safety,avoid,avoid,256,"//NOTE: this does not work for not vectors since the CreateIterators expects a TGenCollectionProxy::TStaging as its argument!; //NOTE: and those not work in general yet, since the TStaging object is neither created nor passed.; // We need to review how to avoid the need for a TStaging during the writing.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:4,Security,Validat,ValidateAddress,4,/*; ValidateAddress();. //; // Silently do nothing if we have no user i/o buffer.; //. if (!fObject) {; return;; }; */,MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:101,Performance,load,loaded,101,"// We are in the case where the branch holds a custom collection; // proxy but the dictionary is not loaded, calling; // GetCollectionProxy had the side effect of creating the TClass; // corresponding to this emulated collection.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:45,Security,checksum,checksum,45,"// FIXME: Check that the found streamer info checksum matches our branch class checksum here.; // Check to see if the class code was unloaded/reloaded; // since we were created.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:79,Security,checksum,checksum,79,"// FIXME: Check that the found streamer info checksum matches our branch class checksum here.; // Check to see if the class code was unloaded/reloaded; // since we were created.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:99,Security,checksum,checksum,99,"// Try to compensate for a class that got unloaded on us.; // Search through the streamer infos by checksum; // and take the first match.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:13,Performance,cache,cached,13,"//; // Fixup cached streamer info if necessary.; //; // FIXME: What if the class code was unloaded/reloaded since we were cached?",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:122,Performance,cache,cached,122,"//; // Fixup cached streamer info if necessary.; //; // FIXME: What if the class code was unloaded/reloaded since we were cached?",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:33,Modifiability,variab,variable,33,"// Mod fullname and 'rename' the variable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:33,Modifiability,variab,variable,33,"// Mod fullname and 'rename' the variable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:74,Performance,cache,cache,74,"// If the TStreamerElement we found is storing the information in the; // cache and is a repeater, we need to use the real one (the next one).; // (At least until the cache/repeat mechanism is properly handle by; // ReadLeaves).; // fID = i+1;",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:167,Performance,cache,cache,167,"// If the TStreamerElement we found is storing the information in the; // cache and is a repeater, we need to use the real one (the next one).; // (At least until the cache/repeat mechanism is properly handle by; // ReadLeaves).; // fID = i+1;",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:72,Usability,clear,clear,72,"// We have not even found the element .. this is strange :(; // fNewIDs.clear();; // fID = -3;; // SetBit(kDoNotProcess);",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:27,Performance,load,loaded,27,"// Either the class is not loaded or the data member is gone",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:400,Availability,error,error,400,"////////////////////////////////////////////////////////////////////////////////; /// Read all branches of a BranchElement and return total number of bytes.; ///; /// - If entry = 0, then use current entry number + 1.; /// - If entry < 0, then reset entry number to 0.; ///; /// Returns the number of bytes read from the input buffer.; /// - If entry does not exist, then returns 0.; /// - If an I/O error occurs, then returns -1.; ///; /// See IMPORTANT REMARKS in TTree::GetEntry.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:162,Usability,clear,cleared,162,"// -- Branch has daughters.; // One must always read the branch counter.; // In the case when one reads consecutively twice the same entry,; // the user may have cleared the TClonesArray between the GetEntry calls.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:61,Security,validat,validation,61,"// There is no ReadLeave for this node, so we need to do the validation here.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:339,Availability,failure,failure,339,"////////////////////////////////////////////////////////////////////////////////; /// Fill expectedClass and expectedType with information on the data type of the; /// object/values contained in this branch (and thus the type of pointers; /// expected to be passed to Set[Branch]Address; /// return 0 in case of success and > 0 in case of failure.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:60,Modifiability,variab,variable,60,"// Case of an object data member. Here we allow for the; // variable name to be omitted. Eg, for Event.root with split; // level 1 or above Draw(""GetXaxis"") is the same as Draw(""fH.GetXaxis()"")",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:103,Integrability,depend,depending,103,"////////////////////////////////////////////////////////////////////////////////; /// Return icon name depending on type of branch element.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:11,Testability,Test,TestBit,11,"// Same as TestBit(kMakeClass)",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:77,Performance,load,load,77,"// Since reloading the index, will reset the ClonesArray, let's; // skip the load if we already read this entry.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:165,Availability,failure,failure,165,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:290,Availability,failure,failure,290,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:447,Availability,failure,failure,447,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:184,Testability,test,test,184,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:189,Testability,test,testSetAddress,189,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:301,Testability,test,test,301,"// See https://sft.its.cern.ch/jira/browse/ROOT-8742; // and https://sft.its.cern.ch/jira/browse/ROOT-9253; // As of commit e21b4f1a3b, removing this lock lead to a failure; // in the test testSetAddress[Loop].; // As of commit 4f8b237849, removing this lock does not lead to; // a visible failure in test. This might be due to the underlying; // problem (missing lock or ?) being solved somewhere else or some; // other perturbation reducing the failure rate.; // Having the lock here is not too costly as InitializeOffsets is; // one called once in the lifetime of the TBranch.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space for the new sub-branch offsets.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:54,Availability,avail,available,54,"// Note: We tested to make sure the streamer info was available previously.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:12,Testability,test,tested,12,"// Note: We tested to make sure the streamer info was available previously.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:59,Safety,avoid,avoid,59,"// We may ourself contain the 'Mother' branch name.; // To avoid code duplication, we delegate the removal; // of the mother's name to the first sub-branch loop.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:13,Performance,cache,cached,13,"// We have a cached item which is not a repeated but we might still; // have some Actions triggered by a rule that affect real; // data member(s).",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:311,Integrability,rout,routine,311,"// -- Remove the top-level branch name from our name, folder case.; //; // Note: We are in the case where our mother was created; // by the branch constructor which takes a folder; // as an argument. The mother branch has internal; // dots in its name to represent the folder hierarchy.; // The TTree::Bronch() routine has handled us as a; // special case, we must compensate.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:60,Testability,test,test,60,"// -- Our name is the mother name, remove it.; // Note: The test is our parent is a top-level branch; // and our streamer is the base class streamer,; // this matches the exact test in TTree::Bronch().",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:177,Testability,test,test,177,"// -- Our name is the mother name, remove it.; // Note: The test is our parent is a top-level branch; // and our streamer is the base class streamer,; // this matches the exact test in TTree::Bronch().",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:320,Integrability,rout,routine,320,"// -- Remove the top-level branch name from our parent's name, folder case.; //; // Note: We are in the case where our mother was created; // by the branch constructor which takes a folder; // as an argument. The mother branch has internal; // dots in its name to represent the folder hierarchy.; // The TTree::Bronch() routine has handled us as a; // special case, we must compensate.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:69,Testability,test,test,69,"// -- Our parent's name is the mother name, remove it.; // Note: The test is our parent's parent is a top-level branch; // and our parent's streamer is the base class streamer,; // this matches the exact test in TTree::Bronch().",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:204,Testability,test,test,204,"// -- Our parent's name is the mother name, remove it.; // Note: The test is our parent's parent is a top-level branch; // and our parent's streamer is the base class streamer,; // this matches the exact test in TTree::Bronch().",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:38,Testability,test,tests,38,"// FIXME: Do we need to use the other tests for a base class here?",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:55,Performance,cache,cache,55,"// First check whether this sub-branch is part of the 'cache' (because the data member it; // represents is no longer in the current class layout.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:28,Testability,Test,TestBit,28,"//if (subInfo && subBranch->TestBit(kCache)) { // subInfo->GetElements()->At(subBranch->GetID())->TestBit(TStreamerElement::kCache)) {",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:98,Testability,Test,TestBit,98,"//if (subInfo && subBranch->TestBit(kCache)) { // subInfo->GetElements()->At(subBranch->GetID())->TestBit(TStreamerElement::kCache)) {",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:42,Testability,test,tests,42,"// FIXME: Do we need the other base class tests here?",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:75,Availability,error,error,75,"// ... unless we creating the branch in which case; // we have an internal error.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:67,Availability,error,error,67,"// We are probably missing the ShowMember, let's; // just issue an error.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:301,Integrability,rout,routines,301,"// -- Container data members set fOffset instead of fBranchOffset.; // The fOffset is what should be added to the start of the entry; // in the collection (i.e., its current absolute address) to find; // the beginning of the data member described by the current branch.; //; // Compensate for the i/o routines adding our local offset later.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:76,Integrability,rout,routines,76,"// We are not split, so our local offset will be; // added later by the i/o routines.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:40,Integrability,rout,routines,40,"// Compensate for the fact that the i/o routines; // are going to add my local offset later.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:86,Safety,Detect,Detect,86,"////////////////////////////////////////////////////////////////////////////////; /// Detect a collection written using a zero pointer in old versions of root.; /// In versions of ROOT older than 4.00/03, if a collection (TClonesArray; /// or STL container) was split but the pointer to the collection was zeroed; /// out, nothing was saved. Hence there is no __easy__ way to detect the; /// case. In newer versions, a zero is written so that a 'missing' collection; /// appears to be an empty collection.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:376,Safety,detect,detect,376,"////////////////////////////////////////////////////////////////////////////////; /// Detect a collection written using a zero pointer in old versions of root.; /// In versions of ROOT older than 4.00/03, if a collection (TClonesArray; /// or STL container) was split but the pointer to the collection was zeroed; /// out, nothing was saved. Hence there is no __easy__ way to detect the; /// case. In newer versions, a zero is written so that a 'missing' collection; /// appears to be an empty collection.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:15,Testability,log,logic,15,"// FIXME: More logic required here (like in ReadLeaves)",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:43,Availability,recover,recover,43,"// Missing fBranchCount. let's attempts to recover.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:43,Safety,recover,recover,43,"// Missing fBranchCount. let's attempts to recover.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:198,Energy Efficiency,Allocate,Allocate,198,"// Note: Proxy-helper needs to ""embrace"" the entire; // streaming of this STL container if the container; // is a set/multiset/map/multimap (what we do not; // know here).; // For vector/list/deque Allocate == Resize; // and Commit == noop.; // TODO: Exception safety a la TPushPop",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:261,Safety,safe,safety,261,"// Note: Proxy-helper needs to ""embrace"" the entire; // streaming of this STL container if the container; // is a set/multiset/map/multimap (what we do not; // know here).; // For vector/list/deque Allocate == Resize; // and Commit == noop.; // TODO: Exception safety a la TPushPop",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:18,Availability,failure,failure,18,"// Give up on i/o failure.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:49,Availability,error,error,49,"// Give up on i/o failure.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:55,Integrability,message,message,55,"// Give up on i/o failure.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:23,Usability,Clear,Clear,23,"// The salient part of Clear is now 'duplicated in ExpandCreateFast (i.e. the; // setting to zero of the unused slots), so we no longer need to call Clear explicitly; // clones->Clear();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:149,Usability,Clear,Clear,149,"// The salient part of Clear is now 'duplicated in ExpandCreateFast (i.e. the; // setting to zero of the unused slots), so we no longer need to call Clear explicitly; // clones->Clear();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:178,Usability,Clear,Clear,178,"// The salient part of Clear is now 'duplicated in ExpandCreateFast (i.e. the; // setting to zero of the unused slots), so we no longer need to call Clear explicitly; // clones->Clear();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:14,Security,validat,validate,14,"// No need to validate the address here, if we are a member of a split ClonesArray,; // fID is positive; // ValidateAddress();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:108,Security,Validat,ValidateAddress,108,"// No need to validate the address here, if we are a member of a split ClonesArray,; // fID is positive; // ValidateAddress();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:116,Modifiability,config,configuring,116,"// Since info is not null, fReadActionSequence is not null either.; // Note, we could (possibly) save some more, by configuring the action; // based on the value of fOnfileObject rather than pushing in on a stack.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:85,Modifiability,inherit,inherits,85,"// If not a TClonesArray or STL container master branch; // or sub-branch and branch inherits from tobject,; // then register with the buffer so that pointers are; // handled properly.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:85,Modifiability,inherit,inherits,85,"// If not a TClonesArray or STL container master branch; // or sub-branch and branch inherits from tobject,; // then register with the buffer so that pointers are; // handled properly.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:48,Modifiability,variab,variable,48,"// Here we have a single object that contains a variable size C-style array.; // Since info is not null, fReadActionSequence is not null either.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:85,Modifiability,inherit,inherits,85,"// If not a TClonesArray or STL container master branch; // or sub-branch and branch inherits from tobject,; // then register with the buffer so that pointers are; // handled properly.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:116,Energy Efficiency,allocate,allocated,116,"////////////////////////////////////////////////////////////////////////////////; /// Delete any object we may have allocated on a previous call to SetAddress.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:126,Energy Efficiency,allocate,allocated,126,"////////////////////////////////////////////////////////////////////////////////; /// Set branch address to zero and free all allocated memory.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:27,Energy Efficiency,allocate,allocated,27,"//; // SetAddress may have allocated an object.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:86,Deployability,Release,Release,86,"////////////////////////////////////////////////////////////////////////////////; /// Release ownership of any allocated objects.; ///; /// Note: This interface was added so that clone trees could; /// be told they do not own the allocated objects.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:111,Energy Efficiency,allocate,allocated,111,"////////////////////////////////////////////////////////////////////////////////; /// Release ownership of any allocated objects.; ///; /// Note: This interface was added so that clone trees could; /// be told they do not own the allocated objects.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:230,Energy Efficiency,allocate,allocated,230,"////////////////////////////////////////////////////////////////////////////////; /// Release ownership of any allocated objects.; ///; /// Note: This interface was added so that clone trees could; /// be told they do not own the allocated objects.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:151,Integrability,interface,interface,151,"////////////////////////////////////////////////////////////////////////////////; /// Release ownership of any allocated objects.; ///; /// Note: This interface was added so that clone trees could; /// be told they do not own the allocated objects.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:289,Energy Efficiency,allocate,allocate,289,"////////////////////////////////////////////////////////////////////////////////; /// Point this branch at an object.; ///; /// For a sub-branch, addr is a pointer to the branch object.; ///; /// For a top-level branch the meaning of addr is as follows:; ///; /// If addr is zero, then we allocate a branch object; /// internally and the branch is the owner of the allocated; /// object, not the caller. However the caller may obtain; /// a pointer to the branch object with GetObject().; /// The pointer is reset to zero (nullptr) when the relevant; /// branch object is destroyed.; ///; /// Example:; /// ~~~ {.cpp}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:365,Energy Efficiency,allocate,allocated,365,"////////////////////////////////////////////////////////////////////////////////; /// Point this branch at an object.; ///; /// For a sub-branch, addr is a pointer to the branch object.; ///; /// For a top-level branch the meaning of addr is as follows:; ///; /// If addr is zero, then we allocate a branch object; /// internally and the branch is the owner of the allocated; /// object, not the caller. However the caller may obtain; /// a pointer to the branch object with GetObject().; /// The pointer is reset to zero (nullptr) when the relevant; /// branch object is destroyed.; ///; /// Example:; /// ~~~ {.cpp}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:798,Energy Efficiency,allocate,allocate,798,"////////////////////////////////////////////////////////////////////////////////; /// Point this branch at an object.; ///; /// For a sub-branch, addr is a pointer to the branch object.; ///; /// For a top-level branch the meaning of addr is as follows:; ///; /// If addr is zero, then we allocate a branch object; /// internally and the branch is the owner of the allocated; /// object, not the caller. However the caller may obtain; /// a pointer to the branch object with GetObject().; /// The pointer is reset to zero (nullptr) when the relevant; /// branch object is destroyed.; ///; /// Example:; /// ~~~ {.cpp}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:871,Energy Efficiency,allocate,allocated,871,"////////////////////////////////////////////////////////////////////////////////; /// Point this branch at an object.; ///; /// For a sub-branch, addr is a pointer to the branch object.; ///; /// For a top-level branch the meaning of addr is as follows:; ///; /// If addr is zero, then we allocate a branch object; /// internally and the branch is the owner of the allocated; /// object, not the caller. However the caller may obtain; /// a pointer to the branch object with GetObject().; /// The pointer is reset to zero (nullptr) when the relevant; /// branch object is destroyed.; ///; /// Example:; /// ~~~ {.cpp}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:914,Energy Efficiency,allocate,allocated,914,"////////////////////////////////////////////////////////////////////////////////; /// Point this branch at an object.; ///; /// For a sub-branch, addr is a pointer to the branch object.; ///; /// For a top-level branch the meaning of addr is as follows:; ///; /// If addr is zero, then we allocate a branch object; /// internally and the branch is the owner of the allocated; /// object, not the caller. However the caller may obtain; /// a pointer to the branch object with GetObject().; /// The pointer is reset to zero (nullptr) when the relevant; /// branch object is destroyed.; ///; /// Example:; /// ~~~ {.cpp}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:1257,Energy Efficiency,allocate,allocated,1257,"anch the meaning of addr is as follows:; ///; /// If addr is zero, then we allocate a branch object; /// internally and the branch is the owner of the allocated; /// object, not the caller. However the caller may obtain; /// a pointer to the branch object with GetObject().; /// The pointer is reset to zero (nullptr) when the relevant; /// branch object is destroyed.; ///; /// Example:; /// ~~~ {.cpp}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with ",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:1778,Energy Efficiency,allocate,allocated,1778,"ts at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// Notice that the only difference between this example; /// and the following example is that the ",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:2224,Energy Efficiency,allocate,allocated,2224,"ete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// Notice that the only difference between this example; /// and the following example is that the event pointer; /// is zero when the branch is created.; ///; /// An example of a branch with an object allocated and; /// owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = new Event();; /// TBranchElement* br = t->Branch(""event."", &event);; ///",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:2873,Energy Efficiency,allocate,allocated,2873,".; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// Notice that the only difference between this example; /// and the following example is that the event pointer; /// is zero when the branch is created.; ///; /// An example of a branch with an object allocated and; /// owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = new Event();; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// If AutoDelete is on (see TBranch::SetAutoDelete),; /// the top level objet will be deleted and recreate; /// each time an entry is read, whether or not the; /// TTree owns the object.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:1696,Integrability,rout,routines,1696,"p}; /// branch->SetAddress(0);; /// Event* event = branch->GetObject();; /// ... Do some work.; /// ~~~; /// If addr is not zero, but the pointer addr points at is; /// zero, then we allocate a branch object and set the passed; /// pointer to point at the allocated object. The caller; /// owns the allocated object and is responsible for deleting; /// it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = 0;; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// If addr is not zero and the pointer addr points at is; /// also not zero, then the caller has allocated a branch; /// object and is asking us to use it. The caller owns it; /// and must delete it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:2375,Testability,test,test,2375,"te it when it is no longer needed.; ///; /// Example:; /// ~~~ {.cpp}; /// Event* event = new Event();; /// branch->SetAddress(&event);; /// ... Do some work.; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// Notice that the only difference between this example; /// and the following example is that the event pointer; /// is zero when the branch is created.; ///; /// An example of a branch with an object allocated and; /// owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = new Event();; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// If AutoDelete is on (see TB",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:3017,Testability,test,test,3017,".; /// delete event;; /// event = 0;; /// ~~~; /// These rules affect users of TTree::Branch(),; /// TTree::SetBranchAddress(), and TChain::SetBranchAddress(); /// as well because those routines call this one.; ///; /// An example of a tree with branches with objects allocated; /// and owned by us:; /// ~~~ {.cpp}; /// TFile* f1 = new TFile(""myfile_original.root"");; /// TTree* t1 = (TTree*) f->Get(""MyTree"");; /// TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; /// TTree* t2 = t1->Clone(0);; /// for (Int_t i = 0; i < 10; ++i) {; /// t1->GetEntry(i);; /// t2->Fill();; /// }; /// t2->Write(); /// delete f2;; /// f2 = 0;; /// delete f1;; /// f1 = 0;; /// ~~~; /// An example of a branch with an object allocated by us,; /// but owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = 0;; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// Notice that the only difference between this example; /// and the following example is that the event pointer; /// is zero when the branch is created.; ///; /// An example of a branch with an object allocated and; /// owned by the caller:; /// ~~~ {.cpp}; /// TFile* f = new TFile(""myfile.root"", ""recreate"");; /// TTree* t = new TTree(""t"", ""A test tree.""); /// Event* event = new Event();; /// TBranchElement* br = t->Branch(""event."", &event);; /// for (Int_t i = 0; i < 10; ++i) {; /// ... Fill event with meaningful data in some way.; /// t->Fill();; /// }; /// t->Write();; /// delete event;; /// event = 0;; /// delete f;; /// f = 0;; /// ~~~; /// If AutoDelete is on (see TBranch::SetAutoDelete),; /// the top level objet will be deleted and recreate; /// each time an entry is read, whether or not the; /// TTree owns the object.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:24,Deployability,release,release,24,"// FIXME: Do we have to release an object here?; // ReleaseObject();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:52,Deployability,Release,ReleaseObject,52,"// FIXME: Do we have to release an object here?; // ReleaseObject();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:21,Availability,failure,failure,21,"// FIXME: Warn about failure to get the streamer info here?; //; // We may have allocated an object last time we were called.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:80,Energy Efficiency,allocate,allocated,80,"// FIXME: Warn about failure to get the streamer info here?; //; // We may have allocated an object last time we were called.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:59,Availability,error,error,59,"// No streamer info, give up.; // FIXME: We should have an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:65,Integrability,message,message,65,"// No streamer info, give up.; // FIXME: We should have an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:40,Integrability,rout,routines,40,"// Compensate for the fact that the i/o routines; // will add the streamer offset to the address.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:167,Performance,load,loaded,167,"//; // Check whether the container type is still the same; // to support schema evolution; what is written on the file; // may no longer match the class code which is loaded.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:378,Energy Efficiency,allocate,allocate,378,"//; // Establish the semantics of fObject and fAddress.; //; // Top-level branch:; // fObject is a ptr to the object,; // fAddress is a ptr to a pointer to the object.; //; // Sub-branch:; // fObject is a ptr to the object,; // fAddress is the same as fObject.; //; //; // There are special cases for TClonesArray and STL containers.; // If there is no user-provided object, we allocate one. We must; // also initialize any STL container proxy.; //",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:45,Energy Efficiency,allocate,allocate,45,"// -- We have been given a non-zero address, allocate if necessary.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,Energy Efficiency,allocate,allocate,25,"// -- Caller wants us to allocate the clones array, but they will own it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,Energy Efficiency,allocate,allocate,25,"// -- Caller wants us to allocate the clones array, but they will own it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:41,Energy Efficiency,allocate,allocate,41,"// -- We have been given a zero address, allocate for top-level only.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:78,Energy Efficiency,allocate,allocate,78,"// -- We are a top-level branch.; // Idea: Consider making a zero address not allocate.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:45,Energy Efficiency,allocate,allocate,45,"// -- We have been given a non-zero address, allocate if necessary.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:209,Modifiability,inherit,inheriting,209,"// We are *not* a top-level branch and we are *not* a pointer to an STL container.; // Case of an embedded STL container.; // Note: We test for the kObject and kAny types to support; // the (unwise) choice of inheriting from an STL container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:135,Testability,test,test,135,"// We are *not* a top-level branch and we are *not* a pointer to an STL container.; // Case of an embedded STL container.; // Note: We test for the kObject and kAny types to support; // the (unwise) choice of inheriting from an STL container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,Energy Efficiency,allocate,allocate,25,"// -- Caller wants us to allocate the STL container, but they will own it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,Energy Efficiency,allocate,allocate,25,"// -- Caller wants us to allocate the STL container, but they will own it.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:41,Energy Efficiency,allocate,allocate,41,"// -- We have been given a zero address, allocate for top-level only.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:209,Modifiability,inherit,inheriting,209,"// We are *not* a top-level branch and we are *not* a pointer to an STL container.; // Case of an embedded STL container.; // Note: We test for the kObject and kAny types to support; // the (unwise) choice of inheriting from an STL container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:135,Testability,test,test,135,"// We are *not* a top-level branch and we are *not* a pointer to an STL container.; // Case of an embedded STL container.; // Note: We test for the kObject and kAny types to support; // the (unwise) choice of inheriting from an STL container.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:33,Energy Efficiency,allocate,allocate,33,"// -- We are a top-level branch, allocate.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:22,Availability,error,error,22,"// FIXME: We need and error message here, no streamer info, so cannot set offsets.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:28,Integrability,message,message,28,"// FIXME: We need and error message here, no streamer info, so cannot set offsets.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:35,Integrability,depend,depends,35,"// We do this only once because it depends only on; // the type of our object, not on its address.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:25,Availability,down,down,25,"// We are split, recurse down to our sub-branches.; //; // FIXME: This is a tail recursion, we burn stack.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:109,Availability,error,error,109,"// When the member is missing, just leave the address alone; // (since setting explicitly to 0 would trigger error/warning; // messages).; // abranch->SetAddress(0);",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:127,Integrability,message,messages,127,"// When the member is missing, just leave the address alone; // (since setting explicitly to 0 would trigger error/warning; // messages).; // abranch->SetAddress(0);",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:57,Deployability,configurat,configuration,57,"// We need to make sure that the Read and Write action's configuration; // properly reflect this value.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:57,Modifiability,config,configuration,57,"// We need to make sure that the Read and Write action's configuration; // properly reflect this value.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:57,Deployability,configurat,configuration,57,"// We need to make sure that the Read and Write action's configuration; // properly reflect this value.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:57,Modifiability,config,configuration,57,"// We need to make sure that the Read and Write action's configuration; // properly reflect this value.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:63,Performance,optimiz,optimized,63,"// Note: this still requires the ObjectWise sequence to not be optimized!",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:63,Performance,optimiz,optimized,63,"// Note: this still requires the ObjectWise sequence to not be optimized!",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:166,Performance,load,loaded,166,"////////////////////////////////////////////////////////////////////////////////; /// Set the name of the class of the in-memory object into which the data will; /// loaded.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:138,Deployability,update,updated,138,"// Since the top level changes, the StreamerInfo (in particular for split collection); // may still need to change (and the info might be updated else (see for example SetAddress for the; // the case fType 4/41)",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:33,Performance,load,loaded,33,"// Make sure the StreamerInfo is loaded and initialized.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:33,Performance,load,loaded,33,"// Make sure the StreamerInfo is loaded and initialized.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:19,Energy Efficiency,allocate,allocate,19,"// Note: This will allocate an object.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:108,Usability,clear,clear,108,"// The fAddress and fObject data members are not persistent,; // therefore we do not own anything.; // Also clear the bit possibly set by the schema evolution.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:6,Safety,avoid,avoid,6,"// to avoid recursive calls",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:19,Usability,clear,clear,19,"// TODO: Should we clear the kDeleteObject bit before writing?; // If we did we would have to remember the old value and; // put it back, we wouldn't want to forget that we owned; // something just because we got written to disk.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:79,Testability,test,test,79,"// FIXME: This is not good enough, an STL container can be; // a base, and the test will fail.; // See TBranchElement::InitializeOffsets() for the; // correct test.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:159,Testability,test,test,159,"// FIXME: This is not good enough, an STL container can be; // a base, and the test will fail.; // See TBranchElement::InitializeOffsets() for the; // correct test.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:69,Performance,optimiz,optimized,69,"// Note: TStreamerInfo::Compile() leaves this element; // out of the optimized info, although it does; // exists in the non-compiled and non-optimized info.; // FIXME: The test that TStreamerInfo::Compile() uses; // is element->GetType() < 0, so that is what; // we should do as well.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:141,Performance,optimiz,optimized,141,"// Note: TStreamerInfo::Compile() leaves this element; // out of the optimized info, although it does; // exists in the non-compiled and non-optimized info.; // FIXME: The test that TStreamerInfo::Compile() uses; // is element->GetType() < 0, so that is what; // we should do as well.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:172,Testability,test,test,172,"// Note: TStreamerInfo::Compile() leaves this element; // out of the optimized info, although it does; // exists in the non-compiled and non-optimized info.; // FIXME: The test that TStreamerInfo::Compile() uses; // is element->GetType() < 0, so that is what; // we should do as well.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:83,Testability,test,test,83,"// FIXME: An STL container as a base class gets TStreamerSTL as its class, so this test is not enough.; // See InitializeOffsets() for the proper test.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:146,Testability,test,test,146,"// FIXME: An STL container as a base class gets TStreamerSTL as its class, so this test is not enough.; // See InitializeOffsets() for the proper test.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:451,Safety,detect,detection,451,"// -- Elide the base-class sub-branches of a split TClonesArray or STL container.; //; // Note: We are eliding the base class here, that is, we never; // create a branch for it, so the branch hierarchy is not; // complete.; // Note: The clParent parameter is the value class of the; // container which we are splitting. It does not; // appear in the branch hierarchy either.; // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:248,Modifiability,inherit,inherited,248,"// Elide the base class name when creating the sub-branches.; // Note: The branch names for sub-branches of a base class branch; // do not represent the full class hierarchy because we do; // this, however it does keep the branch names for the; // inherited data members simple.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:271,Usability,simpl,simple,271,"// Elide the base class name when creating the sub-branches.; // Note: The branch names for sub-branches of a base class branch; // do not represent the full class hierarchy because we do; // this, however it does keep the branch names for the; // inherited data members simple.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:47,Modifiability,inherit,inherit,47,"// -- We are splitting a non-TClonesArray (may inherit from TClonesArray though), non-STL container object.; //; // Ignore an abstract class.; // FIXME: How could an abstract class get here?; // Partial answer: It is a base class. But this is a data member!",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:379,Safety,detect,detection,379,"// Splitting a normal class.; // FIXME: We are eliding the class we are splitting here,; // i.e., we do not create a branch for it, so the; // branch hierarchy does not match the class hierarchy.; // Note: clParent is the class which contains a data member of; // the class type which we are splitting.; // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:291,Deployability,update,update,291,"////////////////////////////////////////////////////////////////////////////////; /// Refresh the value of fDirectory (i.e. where this branch writes/reads its buffers); /// with the current value of fTree->GetCurrentFile unless this branch has been; /// redirected to a different file. Also update the sub-branches.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:129,Deployability,Update,UpdateFile,129,"// The BranchCount and BranchCount2 are part of higher level branches' list of; // branches.; // if (fBranchCount) fBranchCount->UpdateFile();; // if (fBranchCount2) fBranchCount2->UpdateFile();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:181,Deployability,Update,UpdateFile,181,"// The BranchCount and BranchCount2 are part of higher level branches' list of; // branches.; // if (fBranchCount) fBranchCount->UpdateFile();; // if (fBranchCount2) fBranchCount2->UpdateFile();",MatchSource.CODE_COMMENT,tree/tree/src/TBranchElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchIMTHelper.h:11,Availability,error,error,11,"///< Total error count of all tasks done by this helper.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchIMTHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchIMTHelper.h
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx:101,Integrability,rout,routine,101,"////////////////////////////////////////////////////////////////////////////////; /// Initialization routine (run from the constructor so do not make this function virtual)",MatchSource.CODE_COMMENT,tree/tree/src/TBranchObject.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx:411,Availability,error,error,411,"////////////////////////////////////////////////////////////////////////////////; /// Read all branches of a BranchObject and return total number of bytes.; ///; /// - If entry = 0 take current entry number + 1; /// - If entry < 0 reset entry number to 0; ///; /// The function returns the number of bytes read from the input buffer.; ///; /// - If entry does not exist the function returns 0.; /// - If an I/O error occurs, the function returns -1.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchObject.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx:339,Availability,failure,failure,339,"////////////////////////////////////////////////////////////////////////////////; /// Fill expectedClass and expectedType with information on the data type of the; /// object/values contained in this branch (and thus the type of pointers; /// expected to be passed to Set[Branch]Address; /// return 0 in case of success and > 0 in case of failure.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchObject.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx:899,Energy Efficiency,efficient,efficient,899,"////////////////////////////////////////////////////////////////////////////////; /// Set the AutoDelete bit.; ///; /// This function can be used to instruct Root in TBranchObject::ReadBasket; /// to not delete the object referenced by a branchobject before reading a; /// new entry. By default, the object is deleted.; /// - If autodel is true, this existing object will be deleted, a new object; /// created by the default constructor, then object->Streamer called.; /// - If autodel is false, the existing object is not deleted. Root assumes; /// that the user is taking care of deleting any internal object or array; /// This can be done in Streamer itself.; /// - If this branch has sub-branches, the function sets autodel for these; /// branches as well.; /// We STRONGLY suggest to activate this option by default when you create; /// the top level branch. This will make the read phase more efficient; /// because it minimizes the numbers of new/delete operations.; /// Once this option has been set and the Tree is written to a file, it is; /// not necessary to specify the option again when reading, unless you; /// want to set the opposite mode.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchObject.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx:6,Safety,avoid,avoid,6,"// to avoid recursive calls",MatchSource.CODE_COMMENT,tree/tree/src/TBranchObject.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update branch addresses if a new object was created.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchObject.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchObject.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:523,Performance,load,loads,523,"// @(#)root/tree:$Id$; // Author: Rene Brun 19/08/2004; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBranchRef; \ingroup tree. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. ### LIMITATION :; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:677,Performance,load,load,677,"// @(#)root/tree:$Id$; // Author: Rene Brun 19/08/2004; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBranchRef; \ingroup tree. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. ### LIMITATION :; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:1160,Performance,load,loading,1160,"// @(#)root/tree:$Id$; // Author: Rene Brun 19/08/2004; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBranchRef; \ingroup tree. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. ### LIMITATION :; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear entries in the TRefTable.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:3,Performance,Load,Load,3,"// Load the RefTable if we need to.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:175,Usability,clear,cleared,175,"////////////////////////////////////////////////////////////////////////////////; /// - Existing buffers are deleted; /// - Entries, max and min are reset; /// - TRefTable is cleared.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx:179,Usability,clear,cleared,179,"////////////////////////////////////////////////////////////////////////////////; /// Reset a Branch after a Merge operation (drop data but keep customizations); /// TRefTable is cleared.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchRef.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchRef.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:177,Performance,queue,queues,177,"// @(#)root/tree:$Id$; // Author Lukasz Janyst <ljanyst@cern.ch> 23/01/2008; /** \class TBranchSTL; \ingroup tree. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode.; */",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:82,Energy Efficiency,Allocate,Allocate,82,"//---------------------------------------------------------------------------; // Allocate and initialize the basket control arrays; //---------------------------------------------------------------------------",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:82,Energy Efficiency,Allocate,Allocate,82,"//---------------------------------------------------------------------------; // Allocate and initialize the basket control arrays; //---------------------------------------------------------------------------",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:79,Performance,Load,Load,79,"//------------------------------------------------------------------------; // Load unloaded branch; //------------------------------------------------------------------------",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:339,Availability,failure,failure,339,"////////////////////////////////////////////////////////////////////////////////; /// Fill expectedClass and expectedType with information on the data type of the; /// object/values contained in this branch (and thus the type of pointers; /// expected to be passed to Set[Branch]Address; /// return 0 in case of success and > 0 in case of failure.",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:60,Modifiability,variab,variable,60,"// Case of an object data member. Here we allow for the; // variable name to be omitted. Eg, for Event.root with split; // level 1 or above Draw(""GetXaxis"") is the same as Draw(""fH.GetXaxis()"")",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:86,Security,checksum,checksum,86,"//------------------------------------------------------------------------; // If the checksum is there and we're dealing with the foreign class; //------------------------------------------------------------------------",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:80,Security,checksum,checksum,80,"//------------------------------------------------------------------; // If the checksum matches then retrieve the info; //------------------------------------------------------------------",MatchSource.CODE_COMMENT,tree/tree/src/TBranchSTL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:10,Integrability,interface,interface,10,"// Legacy interface, we have no way to know the user's buffer size ....",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:190,Safety,abort,aborts,190,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:34,Availability,error,error,34,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:23,Integrability,rout,routes,23,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:189,Safety,abort,aborts,189,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; // \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:189,Safety,abort,aborts,189,"////////////////////////////////////////////////////////////////////////////////; /// WriteFastArray SQL implementation.; // \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.",MatchSource.CODE_COMMENT,tree/tree/src/TBufferSQL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:778,Modifiability,variab,variable,778,"////////////////////////////////////////////////////////////////////////////////; /// Create a chain.; ///; /// A TChain is a collection of TFile objects.; /// the first parameter ""name"" is the name of the TTree object; /// in the files added with Add.; /// Use TChain::Add to add a new element to this chain.; ///; /// In case the Tree is in a subdirectory, do, eg:; /// ~~~ {.cpp}; /// TChain ch(""subdir/treename"");; /// ~~~; /// Example:; /// Suppose we have 3 files f1.root, f2.root and f3.root. Each file; /// contains a TTree object named ""T"".; /// ~~~ {.cpp}; /// TChain ch(""T""); creates a chain to process a Tree called ""T""; /// ch.Add(""f1.root"");; /// ch.Add(""f2.root"");; /// ch.Add(""f3.root"");; /// ch.Draw(""x"");; /// ~~~; /// The Draw function above will process the variable ""x"" in Tree ""T""; /// reading sequentially the 3 files in the chain ch.; ///; /// The TChain data structure:; ///; /// Each TChainElement has a name equal to the tree name of this TChain; /// and a title equal to the file name. So, to loop over the; /// TFiles that have been added to this chain:; /// ~~~ {.cpp}; /// TObjArray *fileElements=chain->GetListOfFiles();; /// TIter next(fileElements);; /// TChainElement *chEl=0;; /// while (( chEl=(TChainElement*)next() )) {; /// TFile f(chEl->GetTitle());; /// ... do something with f ...; /// }; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:15,Performance,cache,cache,15,"//first delete cache if exists",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:4070,Energy Efficiency,efficient,efficient,4070," for tagging the name of the tree in the file are the same as; /// in the format above.; ///; /// <h4>Details of the nentries parameter</h4>; /// Depending on the value of the parameter, the number of entries in the file; /// is retrieved differently:; /// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; /// in memory to get the number of entries.; /// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; /// assumed to be the number of entries in the file. In this case, no check is; /// made that the file exists and that the corresponding tree exists as well.; /// This second mode is interesting in case the number of entries in the file; /// is already stored in a run data base for example.; /// - If <tt>nentries == TTree::kMaxEntries</tt> (default), the file is not; /// connected. The number of entries in each file will be read only when the; /// file will need to be connected to read an entry. This option is the; /// default and very efficient if one processes the chain sequentially. Note; /// that in case TChain::GetEntry(entry) is called and entry refers to an; /// entry in the 3rd file, for example, this forces the tree headers in the; /// first and second file to be read to find the number of entries in these; /// files. Note that calling TChain::GetEntriesFast after having; /// created a chain with this default returns TTree::kMaxEntries ! Using; /// TChain::GetEntries instead will force all the tree headers in the chain to; /// be read to get the number of entries in each tree.; ///; /// <h4>The %TChain data structure</h4>; /// Each element of the chain is a TChainElement object. It has a name equal to; /// the tree name of this chain (or the name of the specific tree in the added; /// file if it was explicitly tagged) and a title equal to the file name. So, to; /// loop over the files that have been added to this chain:; /// ~~~ {.cpp}; /// TObjArray *fileElements=chain->GetListOfFiles();; /// for (TObject *op: ",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2667,Integrability,depend,depending,2667,"}; /// TChain c;; /// // DO NOT DO THIS; /// // c.Add(""myfile.root/treename"");; /// // DO THIS INSTEAD; /// c.Add(""myfile.root?#treename"");; /// ~~~; /// - Wildcard treatment is triggered by any of the special characters:; /// <b>[]*?</b> which may be used in the file name or subdirectory name,; /// eg. specifying ""xxx*.root"" adds all files starting with xxx in the; /// current file system directory and ""*/*.root"" adds all the files in the; /// current subdirectories (but not in the subsubdirectories).; ///; /// The second format accepted for \p name may have the form of a URL, e.g.:; ///; /// ~~~ {.cpp}; /// root://machine/path/file_name[?[query][#tree_name]]; /// or root://machine/path/file_name; /// or root://machine/path/file_name.root[.oext]/tree_name; /// or root://machine/path/file_name.root[.oext]/tree_name?query; /// ~~~; ///; /// Note the following:; /// - The optional ""query"" token is to be interpreted by the remote server.; /// - Wildcards may be supported in URLs, depending on the protocol plugin and; /// the remote server.; /// - \p http or \p https URLs can contain a query identifier without; /// \p tree_name, but generally URLs can not be written with them because of; /// ambiguity with the wildcard character. (Also see the documentation for; /// TChain::AddFile, which does not support wildcards but allows the URL name; /// to contain a query).; /// - The rules for tagging the name of the tree in the file are the same as; /// in the format above.; ///; /// <h4>Details of the nentries parameter</h4>; /// Depending on the value of the parameter, the number of entries in the file; /// is retrieved differently:; /// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; /// in memory to get the number of entries.; /// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; /// assumed to be the number of entries in the file. In this case, no check is; /// made that the file exists and that the corresponding tree exist",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2684,Integrability,protocol,protocol,2684,"}; /// TChain c;; /// // DO NOT DO THIS; /// // c.Add(""myfile.root/treename"");; /// // DO THIS INSTEAD; /// c.Add(""myfile.root?#treename"");; /// ~~~; /// - Wildcard treatment is triggered by any of the special characters:; /// <b>[]*?</b> which may be used in the file name or subdirectory name,; /// eg. specifying ""xxx*.root"" adds all files starting with xxx in the; /// current file system directory and ""*/*.root"" adds all the files in the; /// current subdirectories (but not in the subsubdirectories).; ///; /// The second format accepted for \p name may have the form of a URL, e.g.:; ///; /// ~~~ {.cpp}; /// root://machine/path/file_name[?[query][#tree_name]]; /// or root://machine/path/file_name; /// or root://machine/path/file_name.root[.oext]/tree_name; /// or root://machine/path/file_name.root[.oext]/tree_name?query; /// ~~~; ///; /// Note the following:; /// - The optional ""query"" token is to be interpreted by the remote server.; /// - Wildcards may be supported in URLs, depending on the protocol plugin and; /// the remote server.; /// - \p http or \p https URLs can contain a query identifier without; /// \p tree_name, but generally URLs can not be written with them because of; /// ambiguity with the wildcard character. (Also see the documentation for; /// TChain::AddFile, which does not support wildcards but allows the URL name; /// to contain a query).; /// - The rules for tagging the name of the tree in the file are the same as; /// in the format above.; ///; /// <h4>Details of the nentries parameter</h4>; /// Depending on the value of the parameter, the number of entries in the file; /// is retrieved differently:; /// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; /// in memory to get the number of entries.; /// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; /// assumed to be the number of entries in the file. In this case, no check is; /// made that the file exists and that the corresponding tree exist",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3220,Integrability,Depend,Depending,3220,"/path/file_name[?[query][#tree_name]]; /// or root://machine/path/file_name; /// or root://machine/path/file_name.root[.oext]/tree_name; /// or root://machine/path/file_name.root[.oext]/tree_name?query; /// ~~~; ///; /// Note the following:; /// - The optional ""query"" token is to be interpreted by the remote server.; /// - Wildcards may be supported in URLs, depending on the protocol plugin and; /// the remote server.; /// - \p http or \p https URLs can contain a query identifier without; /// \p tree_name, but generally URLs can not be written with them because of; /// ambiguity with the wildcard character. (Also see the documentation for; /// TChain::AddFile, which does not support wildcards but allows the URL name; /// to contain a query).; /// - The rules for tagging the name of the tree in the file are the same as; /// in the format above.; ///; /// <h4>Details of the nentries parameter</h4>; /// Depending on the value of the parameter, the number of entries in the file; /// is retrieved differently:; /// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; /// in memory to get the number of entries.; /// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; /// assumed to be the number of entries in the file. In this case, no check is; /// made that the file exists and that the corresponding tree exists as well.; /// This second mode is interesting in case the number of entries in the file; /// is already stored in a run data base for example.; /// - If <tt>nentries == TTree::kMaxEntries</tt> (default), the file is not; /// connected. The number of entries in each file will be read only when the; /// file will need to be connected to read an entry. This option is the; /// default and very efficient if one processes the chain sequentially. Note; /// that in case TChain::GetEntry(entry) is called and entry refers to an; /// entry in the 3rd file, for example, this forces the tree headers in the; /// first and second file t",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2693,Modifiability,plugin,plugin,2693,"}; /// TChain c;; /// // DO NOT DO THIS; /// // c.Add(""myfile.root/treename"");; /// // DO THIS INSTEAD; /// c.Add(""myfile.root?#treename"");; /// ~~~; /// - Wildcard treatment is triggered by any of the special characters:; /// <b>[]*?</b> which may be used in the file name or subdirectory name,; /// eg. specifying ""xxx*.root"" adds all files starting with xxx in the; /// current file system directory and ""*/*.root"" adds all the files in the; /// current subdirectories (but not in the subsubdirectories).; ///; /// The second format accepted for \p name may have the form of a URL, e.g.:; ///; /// ~~~ {.cpp}; /// root://machine/path/file_name[?[query][#tree_name]]; /// or root://machine/path/file_name; /// or root://machine/path/file_name.root[.oext]/tree_name; /// or root://machine/path/file_name.root[.oext]/tree_name?query; /// ~~~; ///; /// Note the following:; /// - The optional ""query"" token is to be interpreted by the remote server.; /// - Wildcards may be supported in URLs, depending on the protocol plugin and; /// the remote server.; /// - \p http or \p https URLs can contain a query identifier without; /// \p tree_name, but generally URLs can not be written with them because of; /// ambiguity with the wildcard character. (Also see the documentation for; /// TChain::AddFile, which does not support wildcards but allows the URL name; /// to contain a query).; /// - The rules for tagging the name of the tree in the file are the same as; /// in the format above.; ///; /// <h4>Details of the nentries parameter</h4>; /// Depending on the value of the parameter, the number of entries in the file; /// is retrieved differently:; /// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; /// in memory to get the number of entries.; /// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; /// assumed to be the number of entries in the file. In this case, no check is; /// made that the file exists and that the corresponding tree exist",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1948,Energy Efficiency,efficient,efficient,1948,"oot' and its use is deprecated.; ///; /// A. If nentries <= 0, the file is opened and the tree header read; /// into memory to get the number of entries.; ///; /// B. If nentries > 0, the file is not opened, and nentries is assumed; /// to be the number of entries in the file. In this case, no check; /// is made that the file exists nor that the tree exists in the file,; /// nor that the real TTree entries match with the input argument.; /// This second mode is interesting in case the number of entries in; /// the file is already stored in a run database for example.; /// \warning If you pass `nentries` > `tree_entries`, this may lead to silent; /// data corruption in your analysis or undefined behavior in your program.; /// Use the other options if unsure.; ///; /// C. If nentries == TTree::kMaxEntries (default), the file is not opened.; /// The number of entries in each file will be read only when the file; /// is opened to read an entry. This option is the default and very; /// efficient if one processes the chain sequentially. Note that in; /// case GetEntry(entry) is called and entry refers to an entry in the; /// third file, for example, this forces the tree headers in the first; /// and second file to be read to find the number of entries in those; /// files. Note that if one calls GetEntriesFast() after having created; /// a chain with this default, GetEntriesFast() will return TTree::kMaxEntries!; /// Using the GetEntries() function instead will force all of the tree; /// headers in the chain to be read to read the number of entries in; /// each tree.; ///; /// D. The TChain data structure; /// Each TChainElement has a name equal to the tree name of this TChain; /// and a title equal to the file name. So, to loop over the; /// TFiles that have been added to this chain:; /// ~~~ {.cpp}; /// TObjArray *fileElements=chain->GetListOfFiles();; /// TIter next(fileElements);; /// TChainElement *chEl=0;; /// while (( chEl=(TChainElement*)next() )) {; /// TFile f(ch",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:578,Performance,load,load,578,"////////////////////////////////////////////////////////////////////////////////; /// Add a new file to this chain.; ///; /// Filename formats are similar to TChain::Add. Wildcards are not; /// applied. urls may also contain query and fragment identifiers; /// where the tree name can be specified in the url fragment.; ///; /// eg.; /// ~~~ {.cpp}; /// root://machine/path/file_name[?query[#tree_name]]; /// root://machine/path/file_name.root[.oext]/tree_name[?query]; /// ~~~; /// If tree_name is given as a part of the file name it is used to; /// as the name of the tree to load from the file. Otherwise if tname; /// argument is specified the chain will load the tree named tname from; /// the file, otherwise the original treename specified in the TChain; /// constructor will be used.; /// Tagging the tree_name with a slash [/tree_name] is only supported for; /// backward compatibility; it requires the file name ot contain the string; /// '.root' and its use is deprecated.; ///; /// A. If nentries <= 0, the file is opened and the tree header read; /// into memory to get the number of entries.; ///; /// B. If nentries > 0, the file is not opened, and nentries is assumed; /// to be the number of entries in the file. In this case, no check; /// is made that the file exists nor that the tree exists in the file,; /// nor that the real TTree entries match with the input argument.; /// This second mode is interesting in case the number of entries in; /// the file is already stored in a run database for example.; /// \warning If you pass `nentries` > `tree_entries`, this may lead to silent; /// data corruption in your analysis or undefined behavior in your program.; /// Use the other options if unsure.; ///; /// C. If nentries == TTree::kMaxEntries (default), the file is not opened.; /// The number of entries in each file will be read only when the file; /// is opened to read an entry. This option is the default and very; /// efficient if one processes the chain sequentially. No",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:659,Performance,load,load,659,"////////////////////////////////////////////////////////////////////////////////; /// Add a new file to this chain.; ///; /// Filename formats are similar to TChain::Add. Wildcards are not; /// applied. urls may also contain query and fragment identifiers; /// where the tree name can be specified in the url fragment.; ///; /// eg.; /// ~~~ {.cpp}; /// root://machine/path/file_name[?query[#tree_name]]; /// root://machine/path/file_name.root[.oext]/tree_name[?query]; /// ~~~; /// If tree_name is given as a part of the file name it is used to; /// as the name of the tree to load from the file. Otherwise if tname; /// argument is specified the chain will load the tree named tname from; /// the file, otherwise the original treename specified in the TChain; /// constructor will be used.; /// Tagging the tree_name with a slash [/tree_name] is only supported for; /// backward compatibility; it requires the file name ot contain the string; /// '.root' and its use is deprecated.; ///; /// A. If nentries <= 0, the file is opened and the tree header read; /// into memory to get the number of entries.; ///; /// B. If nentries > 0, the file is not opened, and nentries is assumed; /// to be the number of entries in the file. In this case, no check; /// is made that the file exists nor that the tree exists in the file,; /// nor that the real TTree entries match with the input argument.; /// This second mode is interesting in case the number of entries in; /// the file is already stored in a run database for example.; /// \warning If you pass `nentries` > `tree_entries`, this may lead to silent; /// data corruption in your analysis or undefined behavior in your program.; /// Use the other options if unsure.; ///; /// C. If nentries == TTree::kMaxEntries (default), the file is not opened.; /// The number of entries in each file will be read only when the file; /// is opened to read an entry. This option is the default and very; /// efficient if one processes the chain sequentially. No",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:976,Modifiability,variab,variable,976,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// ",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1252,Modifiability,variab,variable,1252,"//////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// For additional information see TTree::AddFriend.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1301,Modifiability,variab,variable,1301,"//////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// For additional information see TTree::AddFriend.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1419,Modifiability,variab,variable,1419,"//////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// For additional information see TTree::AddFriend.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1463,Modifiability,variab,variable,1463,"//////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// For additional information see TTree::AddFriend.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1495,Modifiability,variab,variable,1495,"//////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// For additional information see TTree::AddFriend.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:962,Security,access,access,962,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends of this chain.; ///; /// A TChain has a list of friends similar to a tree (see TTree::AddFriend).; /// You can add a friend to a chain with the TChain::AddFriend method, and you; /// can retrieve the list of friends with TChain::GetListOfFriends.; /// This example has four chains each has 20 ROOT trees from 20 ROOT files.; /// ~~~ {.cpp}; /// TChain ch(""t""); // a chain with 20 trees from 20 files; /// TChain ch1(""t1"");; /// TChain ch2(""t2"");; /// TChain ch3(""t3"");; /// ~~~; /// Now we can add the friends to the first chain.; /// ~~~ {.cpp}; /// ch.AddFriend(""t1""); /// ch.AddFriend(""t2""); /// ch.AddFriend(""t3""); /// ~~~; /// \image html tchain_friend.png; ///; ///; /// The parameter is the name of friend chain (the name of a chain is always; /// the name of the tree from which it was created).; /// The original chain has access to all variable in its friends.; /// We can use the TChain::Draw method as if the values in the friends were; /// in the original chain.; /// To specify the chain to use in the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <chainname>.<branchname>.<varname>; /// ~~~; /// If the variable name is enough to uniquely identify the variable, you can; /// leave out the chain and/or branch name.; /// For example, this generates a 3-d scatter plot of variable ""var"" in the; /// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; /// ~~~ {.cpp}; /// ch.Draw(""var:t1.v1:t2.v2"");; /// ~~~; /// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; /// connects the trees in the chain. When a chain is deleted, its friend; /// elements are also deleted.; ///; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original chain. If the friend has fewer entries a warning; /// is given and the resulting histogram will have missing entries.; /// ",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:32,Testability,test,test,32,"// There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:51,Testability,assert,assert,51,"// There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:117,Availability,repair,repairable,117,"// We need to invalidate the loading of the current tree because its list; // of real friends is now obsolete. It is repairable only from LoadTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:29,Performance,load,loading,29,"// We need to invalidate the loading of the current tree because its list; // of real friends is now obsolete. It is repairable only from LoadTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:138,Performance,Load,LoadTree,138,"// We need to invalidate the loading of the current tree because its list; // of real friends is now obsolete. It is repairable only from LoadTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:32,Testability,test,test,32,"// There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:51,Testability,assert,assert,51,"// There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:116,Availability,repair,repairable,116,"// We need to invalidate the loading of the current tree because its list; // of real friend is now obsolete. It is repairable only from LoadTree",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:29,Performance,load,loading,29,"// We need to invalidate the loading of the current tree because its list; // of real friend is now obsolete. It is repairable only from LoadTree",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:137,Performance,Load,LoadTree,137,"// We need to invalidate the loading of the current tree because its list; // of real friend is now obsolete. It is repairable only from LoadTree",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:116,Availability,repair,repairable,116,"// We need to invalidate the loading of the current tree because its list; // of real friend is now obsolete. It is repairable only from LoadTree",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:29,Performance,load,loading,29,"// We need to invalidate the loading of the current tree because its list; // of real friend is now obsolete. It is repairable only from LoadTree",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:137,Performance,Load,LoadTree,137,"// We need to invalidate the loading of the current tree because its list; // of real friend is now obsolete. It is repairable only from LoadTree",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:158,Availability,error,error,158,"////////////////////////////////////////////////////////////////////////////////; /// Draw expression varexp for selected entries.; /// Returns -1 in case of error or number of selected events in case of success.; ///; /// This function accepts TCut objects as arguments.; /// Useful to use the string operator +, example:; /// ~~~{.cpp}; /// ntuple.Draw(""x"",cut1+cut2+cut3);; /// ~~~; ///",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:207,Availability,error,error,207,"////////////////////////////////////////////////////////////////////////////////; /// Process all entries in this chain and draw histogram corresponding to; /// expression varexp.; /// Returns -1 in case of error or number of selected events in case of success.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:287,Availability,failure,failure,287,"////////////////////////////////////////////////////////////////////////////////; /// Get entry from the file to memory.; ///; /// - getall = 0 : get only active branches; /// - getall = 1 : get all branches; ///; /// Return the total number of bytes read,; /// 0 bytes read indicates a failure.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:276,Performance,load,loads,276,"////////////////////////////////////////////////////////////////////////////////; /// Return entry number corresponding to entry.; ///; /// if no TEntryList set returns entry; /// else returns entry \#entry from this entry list and; /// also computes the global entry number (loads all tree headers)",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:31,Performance,Load,LoadTree,31,"//(const_cast<TChain*>(this))->LoadTree(fTreeOffset[treenum]);",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:186,Performance,load,loaded,186,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the current file.; /// If no file is connected, the first file is automatically loaded.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:276,Availability,failure,failure,276,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the list of branches of the current tree.; ///; /// Warning: If there is no current TTree yet, this routine will open the; /// first in the chain.; ///; /// Returns 0 on failure.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:206,Integrability,rout,routine,206,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the list of branches of the current tree.; ///; /// Warning: If there is no current TTree yet, this routine will open the; /// first in the chain.; ///; /// Returns 0 on failure.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:135,Performance,load,load,135,"////////////////////////////////////////////////////////////////////////////////; /// Dummy function.; /// It could be implemented and load all baskets of all trees in the chain.; /// For the time being use TChain::Merge and TTree::LoadBasket; /// on the resulting tree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:232,Performance,Load,LoadBasket,232,"////////////////////////////////////////////////////////////////////////////////; /// Dummy function.; /// It could be implemented and load all baskets of all trees in the chain.; /// For the time being use TChain::Merge and TTree::LoadBasket; /// on the resulting tree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:306,Availability,error,error,306,"////////////////////////////////////////////////////////////////////////////////; /// Find the tree which contains entry, and set it as the current tree.; ///; /// Returns the entry number in that tree.; ///; /// The input argument entry is the entry serial number in the whole chain.; ///; /// In case of error, LoadTree returns a negative number:; /// * -1: The chain is empty.; /// * -2: The requested entry number is less than zero or too large for the chain.; /// * -3: The file corresponding to the entry could not be correctly open; /// * -4: The TChainElement corresponding to the entry is missing or; /// the TTree is missing from the file.; /// * -5: Internal error, please report the circumstance when this happen; /// as a ROOT issue.; /// * -6: An error occurred within the notify callback.; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; /// See TNotifyLink for more information on the notification mechanism.; ///; /// \note This is the only routine which sets the value of fTree to a non-zero pointer.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:670,Availability,error,error,670,"////////////////////////////////////////////////////////////////////////////////; /// Find the tree which contains entry, and set it as the current tree.; ///; /// Returns the entry number in that tree.; ///; /// The input argument entry is the entry serial number in the whole chain.; ///; /// In case of error, LoadTree returns a negative number:; /// * -1: The chain is empty.; /// * -2: The requested entry number is less than zero or too large for the chain.; /// * -3: The file corresponding to the entry could not be correctly open; /// * -4: The TChainElement corresponding to the entry is missing or; /// the TTree is missing from the file.; /// * -5: Internal error, please report the circumstance when this happen; /// as a ROOT issue.; /// * -6: An error occurred within the notify callback.; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; /// See TNotifyLink for more information on the notification mechanism.; ///; /// \note This is the only routine which sets the value of fTree to a non-zero pointer.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:761,Availability,error,error,761,"////////////////////////////////////////////////////////////////////////////////; /// Find the tree which contains entry, and set it as the current tree.; ///; /// Returns the entry number in that tree.; ///; /// The input argument entry is the entry serial number in the whole chain.; ///; /// In case of error, LoadTree returns a negative number:; /// * -1: The chain is empty.; /// * -2: The requested entry number is less than zero or too large for the chain.; /// * -3: The file corresponding to the entry could not be correctly open; /// * -4: The TChainElement corresponding to the entry is missing or; /// the TTree is missing from the file.; /// * -5: Internal error, please report the circumstance when this happen; /// as a ROOT issue.; /// * -6: An error occurred within the notify callback.; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; /// See TNotifyLink for more information on the notification mechanism.; ///; /// \note This is the only routine which sets the value of fTree to a non-zero pointer.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1017,Integrability,rout,routine,1017,"////////////////////////////////////////////////////////////////////////////////; /// Find the tree which contains entry, and set it as the current tree.; ///; /// Returns the entry number in that tree.; ///; /// The input argument entry is the entry serial number in the whole chain.; ///; /// In case of error, LoadTree returns a negative number:; /// * -1: The chain is empty.; /// * -2: The requested entry number is less than zero or too large for the chain.; /// * -3: The file corresponding to the entry could not be correctly open; /// * -4: The TChainElement corresponding to the entry is missing or; /// the TTree is missing from the file.; /// * -5: Internal error, please report the circumstance when this happen; /// as a ROOT issue.; /// * -6: An error occurred within the notify callback.; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; /// See TNotifyLink for more information on the notification mechanism.; ///; /// \note This is the only routine which sets the value of fTree to a non-zero pointer.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:313,Performance,Load,LoadTree,313,"////////////////////////////////////////////////////////////////////////////////; /// Find the tree which contains entry, and set it as the current tree.; ///; /// Returns the entry number in that tree.; ///; /// The input argument entry is the entry serial number in the whole chain.; ///; /// In case of error, LoadTree returns a negative number:; /// * -1: The chain is empty.; /// * -2: The requested entry number is less than zero or too large for the chain.; /// * -3: The file corresponding to the entry could not be correctly open; /// * -4: The TChainElement corresponding to the entry is missing or; /// the TTree is missing from the file.; /// * -5: Internal error, please report the circumstance when this happen; /// as a ROOT issue.; /// * -6: An error occurred within the notify callback.; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; /// See TNotifyLink for more information on the notification mechanism.; ///; /// \note This is the only routine which sets the value of fTree to a non-zero pointer.; ///",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:202,Integrability,wrap,wrapping,202,"// -- Entry is *not* in the chain's current tree.; // Do a linear search of the tree offset array.; // FIXME: We could be smarter by starting at the; // current tree number and going forwards,; // then wrapping around at the end.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:90,Deployability,update,updated,90,"// First set the entry the tree on its owns friends; // (the friends of the chain will be updated in the; // next loop).",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Deployability,Update,Update,3,"// Update the branch/leaf addresses and; // the list of leaves in all TTreeFormula of the TTreePlayer (if any).; // Set the branch statuses for the newly opened file.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:247,Performance,load,loaded,247,"// (fFile != 0 && fTree == 0) can happen when; // InvalidateCurrentTree is called (for example from; // AddFriend). Having fTree === 0 is necessary in that; // case because in some cases GetTree is used as a check; // to see if a TTree is already loaded.; // However, this prevent using the following to reuse; // the TTreeCache object.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:50,Deployability,update,updated,50,"// We do not return yet so that 'fEntries' can be updated with the; // sum of the entries of all the other trees.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:9,Performance,cache,cache,9,"// Reuse cache from previous file (if any).",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:17,Testability,test,test,17,"// Below we must test >= in case the tree has no entries.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Performance,Load,Load,3,"// Load the next TTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:7,Availability,Error,Error,7,"// The Error message already issued. However if we reach here; // we need to make sure that we do not use fTree.; //; // Force a reload of the tree next time.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:13,Integrability,message,message,13,"// The Error message already issued. However if we reach here; // we need to make sure that we do not use fTree.; //; // Force a reload of the tree next time.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:134,Integrability,synchroniz,synchronized,134,"// ----- End of modifications by MvL; // Copy the chain's clone list into the new tree's; // clone list so that branch addresses stay synchronized.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:143,Performance,Load,LoadTree,143,"// Since some of the friends of this chain might simple trees; // (i.e., not really chains at all), we need to execute this; // before calling LoadTree(entry) on the friends (so that; // they use the correct read entry number).; // Change the new current tree to the new entry.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:49,Usability,simpl,simple,49,"// Since some of the friends of this chain might simple trees; // (i.e., not really chains at all), we need to execute this; // before calling LoadTree(entry) on the friends (so that; // they use the correct read entry number).; // Change the new current tree to the new entry.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:36,Availability,error,error,36,"// This is likely to be an internal error, if treeReadEntry was not in range; // (or intentionally -2 for TChain::GetEntries) then something happened; // that is very odd/surprising.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:75,Performance,Load,LoadTree,75,"// An alternative would move this code to each of the function; // calling LoadTree (and to overload a few more).",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Deployability,Update,Update,3,"// Update the addresses of the chain's cloned trees, if any.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Deployability,Update,Update,3,"// Update list of leaves in all TTreeFormula's of the TTreePlayer (if any).",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Availability,Failure,Failure,3,"// Failure: remove",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:330,Integrability,rout,routine,330,"////////////////////////////////////////////////////////////////////////////////; /// Merge all the entries in the chain into a new tree in a new file.; ///; /// See important note in the following function Merge().; ///; /// If the chain is expecting the input tree inside a directory,; /// this directory is NOT created by this routine.; ///; /// So in a case where we have:; /// ~~~ {.cpp}; /// TChain ch(""mydir/mytree"");; /// ch.Merge(""newfile.root"");; /// ~~~; /// The resulting file will have not subdirectory. To recreate; /// the directory structure do:; /// ~~~ {.cpp}; /// TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; /// file->mkdir(""mydir"")->cd();; /// ch.Merge(file, 0);; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:1127,Integrability,rout,routine,1127,"////////////; /// Merge all the entries in the chain into a new tree in the current file.; ///; /// Note: The ""file"" parameter is *not* the file where the new; /// tree will be inserted. The new tree is inserted into; /// gDirectory, which is usually the most recently opened; /// file, or the directory most recently cd()'d to.; ///; /// If option = ""C"" is given, the compression level for all branches; /// in the new Tree is set to the file compression level. By default,; /// the compression level of all branches is the original compression; /// level in the old trees.; ///; /// If basketsize > 1000, the basket size for all branches of the; /// new tree will be set to basketsize.; ///; /// Example using the file generated in $ROOTSYS/test/Event; /// merge two copies of Event.root; /// ~~~ {.cpp}; /// gSystem.Load(""libEvent"");; /// TChain ch(""T"");; /// ch.Add(""Event1.root"");; /// ch.Add(""Event2.root"");; /// ch.Merge(""all.root"");; /// ~~~; /// If the chain is expecting the input tree inside a directory,; /// this directory is NOT created by this routine.; ///; /// So if you do:; /// ~~~ {.cpp}; /// TChain ch(""mydir/mytree"");; /// ch.Merge(""newfile.root"");; /// ~~~; /// The resulting file will not have subdirectories. In order to; /// preserve the directory structure do the following instead:; /// ~~~ {.cpp}; /// TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; /// file->mkdir(""mydir"")->cd();; /// ch.Merge(file, 0);; /// ~~~; /// If 'option' contains the word 'fast' the merge will be done without; /// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBasketsByOffset the baskets are written in; /// the output file in the ",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:887,Performance,Load,Load,887,"////////////////////////////////////////////////////////////////////////////////; /// Merge all the entries in the chain into a new tree in the current file.; ///; /// Note: The ""file"" parameter is *not* the file where the new; /// tree will be inserted. The new tree is inserted into; /// gDirectory, which is usually the most recently opened; /// file, or the directory most recently cd()'d to.; ///; /// If option = ""C"" is given, the compression level for all branches; /// in the new Tree is set to the file compression level. By default,; /// the compression level of all branches is the original compression; /// level in the old trees.; ///; /// If basketsize > 1000, the basket size for all branches of the; /// new tree will be set to basketsize.; ///; /// Example using the file generated in $ROOTSYS/test/Event; /// merge two copies of Event.root; /// ~~~ {.cpp}; /// gSystem.Load(""libEvent"");; /// TChain ch(""T"");; /// ch.Add(""Event1.root"");; /// ch.Add(""Event2.root"");; /// ch.Merge(""all.root"");; /// ~~~; /// If the chain is expecting the input tree inside a directory,; /// this directory is NOT created by this routine.; ///; /// So if you do:; /// ~~~ {.cpp}; /// TChain ch(""mydir/mytree"");; /// ch.Merge(""newfile.root"");; /// ~~~; /// The resulting file will not have subdirectories. In order to; /// preserve the directory structure do the following instead:; /// ~~~ {.cpp}; /// TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; /// file->mkdir(""mydir"")->cd();; /// ch.Merge(file, 0);; /// ~~~; /// If 'option' contains the word 'fast' the merge will be done without; /// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBask",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2424,Performance,optimiz,optimize,2424,"(file, 0);; /// ~~~; /// If 'option' contains the word 'fast' the merge will be done without; /// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBasketsByOffset the baskets are written in; /// the output file in the same order as in the original file; /// (i.e. the basket are sorted on their offset in the original; /// file; Usually this also means that the baskets are sorted; /// on the index/number of the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each; /// individual branches are stored contiguously. This tends to; /// optimize reading speed when reading a small number (1->5) of; /// branches, since all their baskets will be clustered together; /// instead of being spread across the file. However it might; /// decrease the performance when reading more branches (or the full; /// entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest; /// starting entry are written first. (i.e. the baskets are; /// sorted on the index/number of the first entry they contain).; /// This means that on the file the baskets will be in the order; /// in which they will be needed when reading the whole tree; /// sequentially.; ///; /// ## IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW; ///; /// When merging many files, it may happen that the resulting file; /// reaches a size > TTree::fgMaxTreeSize (default = 100 GBytes).; /// In this case the current file is automatically closed and a new; /// file started. If the name of the merged file was ""merged.root"",; /// the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; /// etc. fgMaxTreeSize may be modified via the static",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2632,Performance,perform,performance,2632,"rect copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBasketsByOffset the baskets are written in; /// the output file in the same order as in the original file; /// (i.e. the basket are sorted on their offset in the original; /// file; Usually this also means that the baskets are sorted; /// on the index/number of the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each; /// individual branches are stored contiguously. This tends to; /// optimize reading speed when reading a small number (1->5) of; /// branches, since all their baskets will be clustered together; /// instead of being spread across the file. However it might; /// decrease the performance when reading more branches (or the full; /// entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest; /// starting entry are written first. (i.e. the baskets are; /// sorted on the index/number of the first entry they contain).; /// This means that on the file the baskets will be in the order; /// in which they will be needed when reading the whole tree; /// sequentially.; ///; /// ## IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW; ///; /// When merging many files, it may happen that the resulting file; /// reaches a size > TTree::fgMaxTreeSize (default = 100 GBytes).; /// In this case the current file is automatically closed and a new; /// file started. If the name of the merged file was ""merged.root"",; /// the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; /// etc. fgMaxTreeSize may be modified via the static function; /// TTree::SetMaxTreeSize.; /// When in fast mode, the check and switch is only done in between each; /// input file.; ///; /// ## IMPO",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:811,Testability,test,test,811,"////////////////////////////////////////////////////////////////////////////////; /// Merge all the entries in the chain into a new tree in the current file.; ///; /// Note: The ""file"" parameter is *not* the file where the new; /// tree will be inserted. The new tree is inserted into; /// gDirectory, which is usually the most recently opened; /// file, or the directory most recently cd()'d to.; ///; /// If option = ""C"" is given, the compression level for all branches; /// in the new Tree is set to the file compression level. By default,; /// the compression level of all branches is the original compression; /// level in the old trees.; ///; /// If basketsize > 1000, the basket size for all branches of the; /// new tree will be set to basketsize.; ///; /// Example using the file generated in $ROOTSYS/test/Event; /// merge two copies of Event.root; /// ~~~ {.cpp}; /// gSystem.Load(""libEvent"");; /// TChain ch(""T"");; /// ch.Add(""Event1.root"");; /// ch.Add(""Event2.root"");; /// ch.Merge(""all.root"");; /// ~~~; /// If the chain is expecting the input tree inside a directory,; /// this directory is NOT created by this routine.; ///; /// So if you do:; /// ~~~ {.cpp}; /// TChain ch(""mydir/mytree"");; /// ch.Merge(""newfile.root"");; /// ~~~; /// The resulting file will not have subdirectories. In order to; /// preserve the directory structure do the following instead:; /// ~~~ {.cpp}; /// TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; /// file->mkdir(""mydir"")->cd();; /// ch.Merge(file, 0);; /// ~~~; /// If 'option' contains the word 'fast' the merge will be done without; /// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBask",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:21,Availability,error,error,21,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:27,Integrability,message,message,27,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:21,Availability,error,error,21,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:27,Integrability,message,message,27,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:81,Availability,error,error,81,"// -- LoadTree() has not yet been called, no current tree.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:87,Integrability,message,message,87,"// -- LoadTree() has not yet been called, no current tree.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:6,Performance,Load,LoadTree,6,"// -- LoadTree() has not yet been called, no current tree.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:21,Availability,error,error,21,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:27,Integrability,message,message,27,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:241,Integrability,depend,depends,241,"////////////////////////////////////////////////////////////////////////////////; /// Get the tree url or filename and other information from the name; ///; /// A treename and a url's query section is split off from name. The; /// splitting depends on whether the resulting filename is to be; /// subsequently treated for wildcards or not, since the question mark is; /// both the url query identifier and a wildcard. Wildcard matching is not; /// done in this method itself.; /// ~~~ {.cpp}; /// [xxx://host]/a/path/file_name[?query[#treename]]; /// ~~~; ///; /// The following way to specify the treename is still supported with the; /// constrain that the file name contains the sub-string '.root'.; /// This is now deprecated and will be removed in future versions.; /// ~~~ {.cpp}; /// [xxx://host]/a/path/file.root[.oext][/treename]; /// [xxx://host]/a/path/file.root[.oext][/treename][?query]; /// ~~~; ///; /// Note that in a case like this; /// ~~~ {.cpp}; /// [xxx://host]/a/path/file#treename; /// ~~~; /// i.e. anchor but no options (query), the filename will be the full path, as; /// the anchor may be the internal file name of an archive. Use '?#%treename' to; /// pass the treename if the query field is empty.; ///; /// \param[in] name is the original name; /// \param[out] filename the url or filename to be opened or matched; /// \param[out] treename the treename, which may be found in a url fragment section; /// as a trailing part of the name (deprecated).; /// If not found this will be empty.; /// Exception: a fragment containing the '=' character is _not_; /// interpreted as a treename; /// \param[out] query is the url query section, including the leading question; /// mark. If not found or the query section is only followed by; /// a fragment this will be empty.; /// \param[out] suffix the portion of name which was removed to from filename.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:191,Availability,error,error,191,"////////////////////////////////////////////////////////////////////////////////; /// Process all entries in this chain, calling functions in filename.; /// The return value is -1 in case of error and TSelector::GetStatus() in; /// in case of success.; /// See TTree::Process.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:176,Availability,error,error,176,"////////////////////////////////////////////////////////////////////////////////; /// Process this chain executing the code in selector.; /// The return value is -1 in case of error and TSelector::GetStatus() in; /// in case of success.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:8,Deployability,update,updates,8,"// This updates the proxy chain when we will really use PROOF",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:117,Availability,repair,repairable,117,"// We need to invalidate the loading of the current tree because its list; // of real friends is now obsolete. It is repairable only from LoadTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:29,Performance,load,loading,29,"// We need to invalidate the loading of the current tree because its list; // of real friends is now obsolete. It is repairable only from LoadTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:138,Performance,Load,LoadTree,138,"// We need to invalidate the loading of the current tree because its list; // of real friends is now obsolete. It is repairable only from LoadTree.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:34,Performance,load,loaded,34,"// Save tree file if it is really loaded to the chain",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:140,Performance,Load,LoadTree,140,"////////////////////////////////////////////////////////////////////////////////; /// Set the global branch kAutoDelete bit.; ///; /// When LoadTree loads a new Tree, the branches for which; /// the address is set will have the option AutoDelete set; /// For more details on AutoDelete, see TBranch::SetAutoDelete.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:149,Performance,load,loads,149,"////////////////////////////////////////////////////////////////////////////////; /// Set the global branch kAutoDelete bit.; ///; /// When LoadTree loads a new Tree, the branches for which; /// the address is set will have the option AutoDelete set; /// For more details on AutoDelete, see TBranch::SetAutoDelete.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:147,Availability,error,error,147,"// Set the cache size of the underlying TTree,; // See TTree::SetCacheSize.; // Returns 0 cache state ok (exists or not, as appropriate); // -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:11,Performance,cache,cache,11,"// Set the cache size of the underlying TTree,; // See TTree::SetCacheSize.; // Returns 0 cache state ok (exists or not, as appropriate); // -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:90,Performance,cache,cache,90,"// Set the cache size of the underlying TTree,; // See TTree::SetCacheSize.; // Returns 0 cache state ok (exists or not, as appropriate); // -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:36,Performance,cache,cache,36,"// remember user has requested this cache setting",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:48,Performance,cache,cache,48,"// If we don't have a TTree yet only record the cache size wanted",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:548,Availability,error,error,548,"////////////////////////////////////////////////////////////////////////////////; /// Set branch status to Process or DoNotProcess; ///; /// \param[in] bname is the name of a branch. if bname=""*"", apply to all branches.; /// \param[in] status = 1 branch will be processed,; /// = 0 branch will not be processed; /// \param[out] found; ///; /// See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; ///; /// If found is not 0, the number of branch(es) found matching the regular; /// expression is returned in *found AND the error message 'unknown branch'; /// is suppressed.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:554,Integrability,message,message,554,"////////////////////////////////////////////////////////////////////////////////; /// Set branch status to Process or DoNotProcess; ///; /// \param[in] bname is the name of a branch. if bname=""*"", apply to all branches.; /// \param[in] status = 1 branch will be processed,; /// = 0 branch will not be processed; /// \param[out] found; ///; /// See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; ///; /// If found is not 0, the number of branch(es) found matching the regular; /// expression is returned in *found AND the error message 'unknown branch'; /// is suppressed.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:668,Performance,perform,performing,668,"////////////////////////////////////////////////////////////////////////////////; /// \brief Set the input entry list (processing the entries of the chain will; /// then be limited to the entries in the list).; ///; /// \param[in] elist The entry list to be assigned to this chain.; /// \param[in] opt An option string. Possible values are:; /// - """" (default): both the file names of the chain elements and the file; /// names of the TEntryList sublists are expanded to full path name.; /// - ""ne"": the file names are taken as they are and not expanded; /// - ""sync"": the TChain will go through the TEntryList in lockstep with the; /// trees in the chain rather than performing a lookup based on; /// treename and filename. This is mostly useful when the TEntryList; /// has multiple sublists for the same tree and filename.; /// \throws std::runtime_error If option ""sync"" was chosen and either:; /// - \p elist doesn't have sub entry lists.; /// - the number of sub entry lists in \p elist is different than the; /// number of trees in the chain.; /// - any of the sub entry lists in \p elist doesn't correspond to the; /// tree of the chain with the same index (i.e. it doesn't share the; /// same tree name and file name).; ///; /// This function finds correspondence between the sub-lists of the TEntryList; /// and the trees of the TChain.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Safety,Avoid,Avoid,3,"// Avoid problem with RecursiveRemove.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:430,Availability,error,error,430,"////////////////////////////////////////////////////////////////////////////////; /// Set the input entry list (processing the entries of the chain will then be; /// limited to the entries in the list). This function creates a special kind; /// of entry list (TEntryListFromFile object) that loads lists, corresponding; /// to the chain elements, one by one, so that only one list is in memory at a time.; ///; /// If there is an error opening one of the files, this file is skipped and the; /// next file is loaded; ///; /// File naming convention:; ///; /// - by default, filename_elist.root is used, where filename is the; /// name of the chain element; /// - xxx$xxx.root - $ sign is replaced by the name of the chain element; ///; /// If the list name is not specified (by passing filename_elist.root/listname to; /// the TChain::SetEntryList() function, the first object of class TEntryList; /// in the file is taken.; ///; /// It is assumed, that there are as many list files, as there are elements in; /// the chain and they are in the same order",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:292,Performance,load,loads,292,"////////////////////////////////////////////////////////////////////////////////; /// Set the input entry list (processing the entries of the chain will then be; /// limited to the entries in the list). This function creates a special kind; /// of entry list (TEntryListFromFile object) that loads lists, corresponding; /// to the chain elements, one by one, so that only one list is in memory at a time.; ///; /// If there is an error opening one of the files, this file is skipped and the; /// next file is loaded; ///; /// File naming convention:; ///; /// - by default, filename_elist.root is used, where filename is the; /// name of the chain element; /// - xxx$xxx.root - $ sign is replaced by the name of the chain element; ///; /// If the list name is not specified (by passing filename_elist.root/listname to; /// the TChain::SetEntryList() function, the first object of class TEntryList; /// in the file is taken.; ///; /// It is assumed, that there are as many list files, as there are elements in; /// the chain and they are in the same order",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:509,Performance,load,loaded,509,"////////////////////////////////////////////////////////////////////////////////; /// Set the input entry list (processing the entries of the chain will then be; /// limited to the entries in the list). This function creates a special kind; /// of entry list (TEntryListFromFile object) that loads lists, corresponding; /// to the chain elements, one by one, so that only one list is in memory at a time.; ///; /// If there is an error opening one of the files, this file is skipped and the; /// next file is loaded; ///; /// File naming convention:; ///; /// - by default, filename_elist.root is used, where filename is the; /// name of the chain element; /// - xxx$xxx.root - $ sign is replaced by the name of the chain element; ///; /// If the list name is not specified (by passing filename_elist.root/listname to; /// the TChain::SetEntryList() function, the first object of class TEntryList; /// in the file is taken.; ///; /// It is assumed, that there are as many list files, as there are elements in; /// the chain and they are in the same order",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Safety,Avoid,Avoid,3,"// Avoid problem with RecursiveRemove.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:185,Performance,load,loads,185,"////////////////////////////////////////////////////////////////////////////////; /// This function transfroms the given TEventList into a TEntryList; ///; /// NOTE, that this function loads all tree headers, because the entry numbers; /// in the TEventList are global and have to be recomputed, taking into account; /// the number of entries in each tree.; ///; /// The new TEntryList is owned by the TChain and gets deleted when the chain; /// is deleted. This TEntryList is returned by GetEntryList() function, and after; /// GetEntryList() function is called, the TEntryList is not owned by the chain; /// any more and will not be deleted with it.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Safety,Avoid,Avoid,3,"// Avoid problem with RecursiveRemove.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Safety,Avoid,Avoid,3,"// Avoid problem with RecursiveRemove.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2,Performance,Load,Load,2,"//Load all the tree headers if the tree offsets are not known; //It is assumed here, that loading the last tree will load all; //previous ones",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:90,Performance,load,loading,90,"//Load all the tree headers if the tree offsets are not known; //It is assumed here, that loading the last tree will load all; //previous ones",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:117,Performance,load,load,117,"//Load all the tree headers if the tree offsets are not known; //It is assumed here, that loading the last tree will load all; //previous ones",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:18,Modifiability,extend,extended,18,"// Should this be extended to include the call to TTree::SetName?",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:18,Modifiability,extend,extended,18,"// Should this be extended to include the call to TTree::SetName?",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:40,Modifiability,plugin,plugin,40,"// Make instance of TChainProof via the plugin manager",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:139,Performance,cache,cache,139,"////////////////////////////////////////////////////////////////////////////////; /// Dummy function kept for back compatibility.; /// The cache is now activated automatically when processing TTrees/TChain.",MatchSource.CODE_COMMENT,tree/tree/src/TChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:640,Testability,log,logical,640,"// @(#)root/tree:$Id$; // Author: Rene Brun 14/04/97; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TCut; \ingroup tree. A specialized string object used for TTree selections.; A TCut object has a name and a title. It does not add any data; members compared to a TNamed. It only add a set of operators to; facilitate logical string concatenation. For example, assume; ~~~ {.cpp}; cut1 = ""x<1"" and cut2 = ""y>2""; ~~~; then; ~~~ {.cpp}; cut1 && cut2 will be the string ""(x<1)&&(y>2)""; ~~~; Operators =, +=, +, *, !, &&, || overloaded. Examples of use:; ~~~ {.cpp}; Root > TCut c1 = ""x<1""; Root > TCut c2 = ""y<0""; Root > TCut c3 = c1&&c2; Root > ntuple.Draw(""x"", c1); Root > ntuple.Draw(""x"", c1||""x>0""); Root > ntuple.Draw(""x"", c1&&c2); Root > ntuple.Draw(""x"", ""(x+y)""*(c1&&c2)); ~~~; */",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical and.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical and.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical and.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical or.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical or.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical or.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx:86,Testability,Log,Logical,86,"////////////////////////////////////////////////////////////////////////////////; /// Logical negation.",MatchSource.CODE_COMMENT,tree/tree/src/TCut.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TCut.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2432,Availability,redundant,redundant,2432,"try() is called; for 2 or more indices in a row. ## TTree::Draw() and TChain::Draw(). Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSele",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2486,Integrability,interface,interface,2486,"ee::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make ",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2242,Performance,Load,LoadTree,2242,"etEntry(n)__ - returns the n-th entry number; - __Next__() - returns next entry number. Note, that this function is; much faster than GetEntry, and it's called when GetEntry() is called; for 2 or more indices in a row. ## TTree::Draw() and TChain::Draw(). Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainE",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2406,Performance,Load,LoadTree,2406,"try() is called; for 2 or more indices in a row. ## TTree::Draw() and TChain::Draw(). Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSele",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2610,Performance,Load,LoadTree,2610,"st"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ## Using a TEntryList as",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:3222,Performance,Load,LoadTree,3222,"ntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ## Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList()). while the TTree::SetEntryList() function is only setting the TTree::fEntryList; data member, the same function in TChain also finds correspondence between; the TTrees of this TChain and the sub-lists of this TEntryList. ## TEntryList and the current directory. TEntryList objects are automatically added to the current directory (like TTrees).; However, in case of a TEntryList for a chain, only the top-level entry list is added,; not the sub-lists for specific trees. Placing entry lists in the current directory; allows calling them as a part of a TTreeFormula expression, so if the user wants",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:5362,Performance,Optimiz,OptimizeStorage,5362," for specific trees. Placing entry lists in the current directory; allows calling them as a part of a TTreeFormula expression, so if the user wants; to extract a sublist from a TChain entry list via the GetEntryList() or some other; function, they have to add it to the current directory to be able to use it in; TTreeFormula expressions. ## TEntryList and TEventList. TTree::SetEventList() and TChain::SetEventList() transform a TEventList into a TEntryList; See comments to those functions for more details. ## Types of entry lists; There are two types of entry lists:. #### 1.; for a TTree (fBlocks data member is non-zero); Entry numbers are stored in TEntryListBlocks, which, in their turn, are stored; in the TObjArray fBlocks. The range of the entry numbers is cut into intervals; of kBlockSize entries (currently 64000), so that the first block contains; information which entries out of the first 64000 pass the selection, the second; block - which entries out of the 64000-127999 interval pass the selection, etc.; Some blocks, obviously, might be empty. The internal representation of entry; numbers in the blocks is described in the TEntryListBlock class description, and; this representation might be changed by calling OptimizeStorage() function; (when the list is filled via the Enter() function, this is done automatically,; except for the last block).; Individual entry lists can be merged (functions Merge() and Add()); to make an entry list for a TChain of corresponding TTrees.; Begin_Macro; entrylist_figure1.C; End_Macro. #### 2.; for a TChain (fLists data member is non-zero); It contains a TList of sub-lists (TEntryList objects, corresponding to each TTree); Trees and lists are matched by the TTree name and its file name (full path).; All sub-lists are returned by the GetLists() function and individual lists are; returned by GetEntryList() function. Such lists are no different from the lists for; TTrees, described above.; Begin_Macro; entrylist_figure2.C; End_Macro. */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2432,Safety,redund,redundant,2432,"try() is called; for 2 or more indices in a row. ## TTree::Draw() and TChain::Draw(). Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSele",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:634,Testability,test,testing,634,"////////////////////////////////////////////////////////////////////////////////; /// \brief Add 2 entry lists.; ///; /// \param[in] elist The list that should be added to the current one.; ///; /// \note If you are creating a TEntryList for a TChain and you would like to; /// have a one to one mapping between the sub lists of the TEntryList and; /// the sub trees in the TChain, please do not call this function but use; /// TEntryList::AddSubList instead and pair it with a call to; /// TChain::SetEntryList with option ""sync"". See the AddSubList function; /// documentation for an example usage. This helps for example in a; /// testing or benchmark scenario where a TChain holds multiple times the; /// same tree in the same file. In that case, this function would not be; /// be able to distinguish different sub entry lists that refer to the; /// same treename and filename. Instead it would create a union of all the; /// sub entry lists into one list.",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:645,Testability,benchmark,benchmark,645,"////////////////////////////////////////////////////////////////////////////////; /// \brief Add 2 entry lists.; ///; /// \param[in] elist The list that should be added to the current one.; ///; /// \note If you are creating a TEntryList for a TChain and you would like to; /// have a one to one mapping between the sub lists of the TEntryList and; /// the sub trees in the TChain, please do not call this function but use; /// TEntryList::AddSubList instead and pair it with a call to; /// TChain::SetEntryList with option ""sync"". See the AddSubList function; /// documentation for an example usage. This helps for example in a; /// testing or benchmark scenario where a TChain holds multiple times the; /// same tree in the same file. In that case, this function would not be; /// be able to distinguish different sub entry lists that refer to the; /// same treename and filename. Instead it would create a union of all the; /// sub entry lists into one list.",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:552,Deployability,configurat,configuration,552,"////////////////////////////////////////////////////////////////////////////////; /// \brief Add a sub entry list to the current list.; /// \param[in] elist an entry list that should be added as a sub list of this list.; ///; /// This function is specifically targeted at situations where there is a global; /// TEntryList that should hold one or more sub TEntryList objects. For example,; /// if one wants to create a one to one mapping between the sub entry lists and; /// the trees in the files that make a TChain. Note that in such cases this; /// configuration of the entry list should be used in pair with the option \p ""sync""; /// of the function TChain::SetEntryList; ///; /// ~~~{.cpp}; /// // Create a TChain with two files. Each contains a tree with 20 entries; /// TChain chain{""entries""};; /// chain.Add(""file_20entries_1.root"");; /// chain.Add(""file_20entries_2.root"");; ///; /// // Create a global, empty TEntryList.; /// TEntryList elists;; /// // Create two entry lists. Each one will be referring to a different tree in the chain; /// TEntryList elist1{"""","""",""entries"",""file_20entries_1.root""};; /// TEntryList elist2{"""","""",""entries"",""file_20entries_2.root""};; ///; /// // Select the first ten entries from the first tree and all entries from the second; /// for(auto entry = 0; entry < 10; entry++){; /// elist1.Enter(entry);; /// }; /// for(auto entry = 0; entry < 20; entry++){; /// elist2.Enter(entry);; /// }; ///; /// // Add sub entry lists to the global list; /// elists.AddSubList(&elist1);; /// elists.AddSubList(&elist2);; ///; /// // Set the entry list in the chain. Note the usage of option ""sync""; /// chain.SetEntryList(&elists, ""sync"");; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:552,Modifiability,config,configuration,552,"////////////////////////////////////////////////////////////////////////////////; /// \brief Add a sub entry list to the current list.; /// \param[in] elist an entry list that should be added as a sub list of this list.; ///; /// This function is specifically targeted at situations where there is a global; /// TEntryList that should hold one or more sub TEntryList objects. For example,; /// if one wants to create a one to one mapping between the sub entry lists and; /// the trees in the files that make a TChain. Note that in such cases this; /// configuration of the entry list should be used in pair with the option \p ""sync""; /// of the function TChain::SetEntryList; ///; /// ~~~{.cpp}; /// // Create a TChain with two files. Each contains a tree with 20 entries; /// TChain chain{""entries""};; /// chain.Add(""file_20entries_1.root"");; /// chain.Add(""file_20entries_2.root"");; ///; /// // Create a global, empty TEntryList.; /// TEntryList elists;; /// // Create two entry lists. Each one will be referring to a different tree in the chain; /// TEntryList elist1{"""","""",""entries"",""file_20entries_1.root""};; /// TEntryList elist2{"""","""",""entries"",""file_20entries_2.root""};; ///; /// // Select the first ten entries from the first tree and all entries from the second; /// for(auto entry = 0; entry < 10; entry++){; /// elist1.Enter(entry);; /// }; /// for(auto entry = 0; entry < 20; entry++){; /// elist2.Enter(entry);; /// }; ///; /// // Add sub entry lists to the global list; /// elists.AddSubList(&elist1);; /// elists.AddSubList(&elist2);; ///; /// // Set the entry list in the chain. Note the usage of option ""sync""; /// chain.SetEntryList(&elists, ""sync"");; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:535,Safety,avoid,avoid,535,"/////////////////////////////////////////////////////////////////////////////; /// \brief Enter all entries in a range in the TEntryList.; /// \param[in] start starting entry to enter.; /// \param[in] end ending entry to enter.; /// \param[in] tree passed as is to TEntryList::Enter.; /// \param[in] step step increase of the loop entering the entries.; ///; /// This is a helper function that enters all entries between \p start; /// (inclusive) and \p end (exclusive) to the TEntryList in a loop. It; /// is useful also in PyROOT to avoid having to do the same in a Python loop.",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:199,Integrability,protocol,protocol,199,"////////////////////////////////////////////////////////////////////////////////; /// To be able to re-localize the entry-list we identify the file by just the; /// name and the anchor, i.e. we drop protocol, host, options, ...; /// The result in the form 'file#anchor' (or 'file', if no anchor is present); /// is saved in 'fn'.; /// The function optionally (is 'local' is defined) checks file locality (i.e.; /// protocol 'file://') returning the result in '*local' .",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:415,Integrability,protocol,protocol,415,"////////////////////////////////////////////////////////////////////////////////; /// To be able to re-localize the entry-list we identify the file by just the; /// name and the anchor, i.e. we drop protocol, host, options, ...; /// The result in the form 'file#anchor' (or 'file', if no anchor is present); /// is saved in 'fn'.; /// The function optionally (is 'local' is defined) checks file locality (i.e.; /// protocol 'file://') returning the result in '*local' .",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:330,Safety,avoid,avoid,330,"////////////////////////////////////////////////////////////////////////////////; /// Return the entry list, corresponding to treename and filename; /// By default, the filename is first tried as is, and then, if the corresponding list; /// is not found, the filename is expanded to the absolute path, and compared again.; /// To avoid it, use option ""ne""",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:23,Security,Hash,Hash,23,"//fStringHash = stotal.Hash();",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:35,Integrability,protocol,protocol,35,"// The filename contained also the protocol and host: this was dropped; // in version > 1 to allow re-localization",MatchSource.CODE_COMMENT,tree/tree/src/TEntryList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx:1012,Performance,perform,performance,1012,"// @(#)root/tree:$Id$; // Author: Bruno Lenzi 12/07/2011; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListArray; \ingroup tree. A list of entries and subentries in a TTree or TChain. TEntryListArray is an extension of TEntryList, used to hold selected entries and; subentries (sublists) for when the user has a TTree with containers (vectors, arrays, ...). ## Usage with TTree::Draw to select entries and subentries. ### To fill a list elist; ~~~ {.cpp}; tree->Draw("">> elist"", ""x > 0"", ""entrylistarray"");`; ~~~; ### To use a list to select entries and subentries; ~~~ {.cpp}; tree->SetEntryList(elist);; tree->Draw(""y"");; tree->Draw(""z"");; ~~~; Its main purpose is to improve the performance of a code that needs to apply; complex cuts on TTree::Draw multiple times. After the first call above to; TTree::Draw, a TEntryListArray is created and filled with the entries and the; indices of the arrays that satisfied the selection cut (x > 0). In the subsequent; calls to TTree::Draw, only these entries / subentries are used to fill histograms. ## About the class. The class derives from TEntryList and can be used basically in the same way.; This same class is used to keep entries and subentries, so there are two types of; TEntryListArray's:. 1. The ones that only hold subentries; - fEntry is set to the entry# for which the subentries correspond; - fSubLists must be 0; 2. The ones that hold entries and eventually lists with subentries in fSubLists.; - fEntry = -1 for those; - If there are no sublists for a given entry, all the subentries will be used; in the selection. ## Additions with respect to TEntryList. 1. Data members:; - fSubLists: a container to hold",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListArray.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx:2180,Usability,resume,resume,2180,">> elist"", ""x > 0"", ""entrylistarray"");`; ~~~; ### To use a list to select entries and subentries; ~~~ {.cpp}; tree->SetEntryList(elist);; tree->Draw(""y"");; tree->Draw(""z"");; ~~~; Its main purpose is to improve the performance of a code that needs to apply; complex cuts on TTree::Draw multiple times. After the first call above to; TTree::Draw, a TEntryListArray is created and filled with the entries and the; indices of the arrays that satisfied the selection cut (x > 0). In the subsequent; calls to TTree::Draw, only these entries / subentries are used to fill histograms. ## About the class. The class derives from TEntryList and can be used basically in the same way.; This same class is used to keep entries and subentries, so there are two types of; TEntryListArray's:. 1. The ones that only hold subentries; - fEntry is set to the entry# for which the subentries correspond; - fSubLists must be 0; 2. The ones that hold entries and eventually lists with subentries in fSubLists.; - fEntry = -1 for those; - If there are no sublists for a given entry, all the subentries will be used; in the selection. ## Additions with respect to TEntryList. 1. Data members:; - fSubLists: a container to hold the sublists; - fEntry: the entry number if the list is used to hold subentries; - fLastSubListQueried and fSubListIter: a pointer to the last sublist queried; and an iterator to resume the loop from the last sublist queried (to speed up; selection and insertion in TTree::Draw); 2. Public methods:; - Contains, Enter and Remove with subentry as argument; - GetSubListForEntry: to return the sublist corresponding to the given entry; 3. Protected methods:; - AddEntriesAndSubLists: called by Add when adding two TEntryList arrays with sublists; - ConvertToTEntryListArray: convert TEntryList to TEntryListArray; - RemoveSubList: to remove the given sublist; - RemoveSubListForEntry: to remove the sublist corresponding to the given entry; - SetEntry: to get / set a sublist for the given entry; */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListArray.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx:25,Safety,avoid,avoid,25,"// Reset the iterator to avoid missing the entry next to the new one (bug in TIter?)",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListArray.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:968,Performance,Optimiz,OptimizeStorage,968,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListBlock; \ingroup tree. Used by TEntryList to store the entry numbers. There are 2 ways to represent entry numbers in a TEntryListBlock:. 1. as bits, where passing entry numbers are assigned 1, not passing - 0; 2. as a simple array of entry numbers; - storing the numbers of entries that pass; - storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function.; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is; again changed to 1). Begin_Macro; entrylistblock_figure1.C; End_Macro. ## Operations on blocks (see also function comments). - __Merge__() - adds all entries from one block to the other. If the first block; uses array representation, it's changed to bits representation only; if the total number of passing entries is still less than kBlockSize; - __GetEntry(n)__ - returns n-th non-zero entry.; - __Next__() - return next non-zero entry. In case of representation 1), Next(); is faster than GetEntry(); */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListBlock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:1065,Performance,Optimiz,OptimizeStorage,1065,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListBlock; \ingroup tree. Used by TEntryList to store the entry numbers. There are 2 ways to represent entry numbers in a TEntryListBlock:. 1. as bits, where passing entry numbers are assigned 1, not passing - 0; 2. as a simple array of entry numbers; - storing the numbers of entries that pass; - storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function.; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is; again changed to 1). Begin_Macro; entrylistblock_figure1.C; End_Macro. ## Operations on blocks (see also function comments). - __Merge__() - adds all entries from one block to the other. If the first block; uses array representation, it's changed to bits representation only; if the total number of passing entries is still less than kBlockSize; - __GetEntry(n)__ - returns n-th non-zero entry.; - __Next__() - return next non-zero entry. In case of representation 1), Next(); is faster than GetEntry(); */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListBlock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:1196,Performance,Optimiz,OptimizeStorage,1196,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListBlock; \ingroup tree. Used by TEntryList to store the entry numbers. There are 2 ways to represent entry numbers in a TEntryListBlock:. 1. as bits, where passing entry numbers are assigned 1, not passing - 0; 2. as a simple array of entry numbers; - storing the numbers of entries that pass; - storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function.; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is; again changed to 1). Begin_Macro; entrylistblock_figure1.C; End_Macro. ## Operations on blocks (see also function comments). - __Merge__() - adds all entries from one block to the other. If the first block; uses array representation, it's changed to bits representation only; if the total number of passing entries is still less than kBlockSize; - __GetEntry(n)__ - returns n-th non-zero entry.; - __Next__() - return next non-zero entry. In case of representation 1), Next(); is faster than GetEntry(); */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListBlock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:655,Usability,simpl,simple,655,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 27/10/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListBlock; \ingroup tree. Used by TEntryList to store the entry numbers. There are 2 ways to represent entry numbers in a TEntryListBlock:. 1. as bits, where passing entry numbers are assigned 1, not passing - 0; 2. as a simple array of entry numbers; - storing the numbers of entries that pass; - storing the numbers of entries that don't pass. In both cases, a UShort_t* is used. The second option is better in case; less than 1/16 or more than 15/16 of entries pass the selection, and the representation can be; changed by calling OptimizeStorage() function.; When the block is being filled, it's always stored as bits, and the OptimizeStorage(); function is called by TEntryList when it starts filling the next block. If; Enter() or Remove() is called after OptimizeStorage(), representation is; again changed to 1). Begin_Macro; entrylistblock_figure1.C; End_Macro. ## Operations on blocks (see also function comments). - __Merge__() - adds all entries from one block to the other. If the first block; uses array representation, it's changed to bits representation only; if the total number of passing entries is still less than kBlockSize; - __GetEntry(n)__ - returns n-th non-zero entry.; - __Next__() - return next non-zero entry. In case of representation 1), Next(); is faster than GetEntry(); */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListBlock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:116,Performance,optimiz,optimized,116,"////////////////////////////////////////////////////////////////////////////////; /// If the block has already been optimized and the entries; /// are stored as a list and not as bits, trying to enter a new entry; /// will make the block switch to bits representation",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListBlock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:142,Performance,optimiz,optimized,142,"////////////////////////////////////////////////////////////////////////////////; /// Remove entry \#entry; /// If the block has already been optimized and the entries; /// are stored as a list and not as bits, trying to remove a new entry; /// will make the block switch to bits representation",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListBlock.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:1189,Availability,error,error,1189,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 17/03/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListFromFile; \ingroup tree. Manages entry lists from different files, when they are not loaded; in memory at the same time. This entry list should only be used when processing a TChain (see; TChain::SetEntryList() function). File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element.; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken.; It is assumed that there are as many lists, as there are chain elements,; and they are in the same order. If one of the list files can't be opened, or there is an error reading a list; from the file, this list is skipped and the entry loop continues on the next; list.; */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:523,Performance,load,loaded,523,"// @(#)root/tree:$Id$; // Author: Anna Kreshuk 17/03/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEntryListFromFile; \ingroup tree. Manages entry lists from different files, when they are not loaded; in memory at the same time. This entry list should only be used when processing a TChain (see; TChain::SetEntryList() function). File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element.; - xxx$xxx.root - $ sign is replaced by the name of the chain element; If the list name is not specified (by passing filename_elist.root/listname to; the TChain::SetEntryList() function, the first object of class TEntryList; in the file is taken.; It is assumed that there are as many lists, as there are chain elements,; and they are in the same order. If one of the list files can't be opened, or there is an error reading a list; from the file, this list is skipped and the entry loop continues on the next; list.; */",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:24,Performance,load,loaded,24,"//this list hasn't been loaded yet",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:168,Performance,load,loaded,168,"////////////////////////////////////////////////////////////////////////////////; /// Returns the total number of entries in the list.; /// If some lists have not been loaded, loads them.",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:176,Performance,load,loads,176,"////////////////////////////////////////////////////////////////////////////////; /// Returns the total number of entries in the list.; /// If some lists have not been loaded, loads them.",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:3,Availability,Error,Error,3,"// Error(""Next"", ""No more entries, last list\n"");",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:2,Performance,load,load,2,"//load the next non-empty list. fTreeNumber is changed by LoadList()",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:58,Performance,Load,LoadList,58,"//load the next non-empty list. fTreeNumber is changed by LoadList()",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:86,Performance,Load,Loads,86,"////////////////////////////////////////////////////////////////////////////////; /// Loads the list \#listnumber; /// This is the only function that can modify fCurrent and fFile data members",MatchSource.CODE_COMMENT,tree/tree/src/TEntryListFromFile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEventList.cxx:61,Deployability,update,update,61,"// TEventLists are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,tree/tree/src/TEventList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEventList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEventList.cxx:72,Security,hash,hashlist,72,"// TEventLists are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,tree/tree/src/TEventList.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEventList.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TFriendElement.cxx:602,Modifiability,variab,variable,602,"// @(#)root/tree:$Id$; // Author: Rene Brun 07/04/2001; /*************************************************************************; * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TFriendElement; \ingroup tree. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. To add a TFriendElement to an existing TTree T, do:; ~~~ {.cpp}; T.AddFriend(""friendTreename"",""friendTreeFile"");; ~~~; See TTree::AddFriend for more information.; */",MatchSource.CODE_COMMENT,tree/tree/src/TFriendElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TFriendElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:1298,Availability,Error,Error,1298,"/**; * \class ROOT::TIOFeatures; * \ingroup tree; *; * `TIOFeatures` provides the end-user with the ability to change the IO behavior; * of data written via a `TTree`. This class allows access to experimental and non-default; * features.; *; * When one of these features are activated, forward compatibility breaks may occur.; * That is, older versions of ROOT may not be able to read files written by this version; * of ROOT that have enabled these non-default features.; *; * To utilize `TIOFeatures`, create the object, set the desired feature flags, then attach; * it to a `TTree`. All subsequently created branches (and their baskets) will be serialized; * using those particular features.; *; * Example usage:; * ~~~{.cpp}; * ROOT::TIOFeatures features;; * features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; * ttree_ref.SetIOFeatures(features);; * ~~~; *; * The method `TTree::SetIOFeatures` creates a copy of the feature set; subsequent changes; * to the `TIOFeatures` object do not propagate to the `TTree`.; */; ////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:1304,Integrability,message,message,1304,"/**; * \class ROOT::TIOFeatures; * \ingroup tree; *; * `TIOFeatures` provides the end-user with the ability to change the IO behavior; * of data written via a `TTree`. This class allows access to experimental and non-default; * features.; *; * When one of these features are activated, forward compatibility breaks may occur.; * That is, older versions of ROOT may not be able to read files written by this version; * of ROOT that have enabled these non-default features.; *; * To utilize `TIOFeatures`, create the object, set the desired feature flags, then attach; * it to a `TTree`. All subsequently created branches (and their baskets) will be serialized; * using those particular features.; *; * Example usage:; * ~~~{.cpp}; * ROOT::TIOFeatures features;; * features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; * ttree_ref.SetIOFeatures(features);; * ~~~; *; * The method `TTree::SetIOFeatures` creates a copy of the feature set; subsequent changes; * to the `TIOFeatures` object do not propagate to the `TTree`.; */; ////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:186,Security,access,access,186,"/**; * \class ROOT::TIOFeatures; * \ingroup tree; *; * `TIOFeatures` provides the end-user with the ability to change the IO behavior; * of data written via a `TTree`. This class allows access to experimental and non-default; * features.; *; * When one of these features are activated, forward compatibility breaks may occur.; * That is, older versions of ROOT may not be able to read files written by this version; * of ROOT that have enabled these non-default features.; *; * To utilize `TIOFeatures`, create the object, set the desired feature flags, then attach; * it to a `TTree`. All subsequently created branches (and their baskets) will be serialized; * using those particular features.; *; * Example usage:; * ~~~{.cpp}; * ROOT::TIOFeatures features;; * features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; * ttree_ref.SetIOFeatures(features);; * ~~~; *; * The method `TTree::SetIOFeatures` creates a copy of the feature set; subsequent changes; * to the `TIOFeatures` object do not propagate to the `TTree`.; */; ////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:1127,Usability,Clear,Clear,1127,"/**; * \class ROOT::TIOFeatures; * \ingroup tree; *; * `TIOFeatures` provides the end-user with the ability to change the IO behavior; * of data written via a `TTree`. This class allows access to experimental and non-default; * features.; *; * When one of these features are activated, forward compatibility breaks may occur.; * That is, older versions of ROOT may not be able to read files written by this version; * of ROOT that have enabled these non-default features.; *; * To utilize `TIOFeatures`, create the object, set the desired feature flags, then attach; * it to a `TTree`. All subsequently created branches (and their baskets) will be serialized; * using those particular features.; *; * Example usage:; * ~~~{.cpp}; * ROOT::TIOFeatures features;; * features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; * ttree_ref.SetIOFeatures(features);; * ~~~; *; * The method `TTree::SetIOFeatures` creates a copy of the feature set; subsequent changes; * to the `TIOFeatures` object do not propagate to the `TTree`.; */; ////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:260,Availability,Error,Error,260,"////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:266,Integrability,message,message,266,"////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:89,Usability,Clear,Clear,89,"////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:260,Availability,Error,Error,260,"////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:266,Integrability,message,message,266,"////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:89,Usability,Clear,Clear,89,"////////////////////////////////////////////////////////////////////////////; /// \brief Clear a specific IO feature from this set.; /// \param[in] input_bits The specific feature to disable.; ///; /// Removes a feature from the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:238,Availability,Error,Error,238,"////////////////////////////////////////////////////////////////////////////; /// \brief Set a specific IO feature.; /// \param[in] input_bits The specific feature to enable.; ///; /// Sets a feature in the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.; ///; /// If the feature is supported by ROOT, this function returns true; otherwise,; /// it returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:244,Integrability,message,message,244,"////////////////////////////////////////////////////////////////////////////; /// \brief Set a specific IO feature.; /// \param[in] input_bits The specific feature to enable.; ///; /// Sets a feature in the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.; ///; /// If the feature is supported by ROOT, this function returns true; otherwise,; /// it returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:238,Availability,Error,Error,238,"////////////////////////////////////////////////////////////////////////////; /// \brief Set a specific IO feature.; /// \param[in] input_bits The specific feature to enable.; ///; /// Sets a feature in the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.; ///; /// If the feature is supported by ROOT, this function returns true; otherwise,; /// it returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:244,Integrability,message,message,244,"////////////////////////////////////////////////////////////////////////////; /// \brief Set a specific IO feature.; /// \param[in] input_bits The specific feature to enable.; ///; /// Sets a feature in the `TIOFeatures` object; emits an Error message if; /// the IO feature is not supported by this version of ROOT.; ///; /// If the feature is supported by ROOT, this function returns true; otherwise,; /// it returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:549,Availability,error,error,549,"/////////////////////////////////////////////////////////////////////////////; /// \brief Given a IO feature string, set the corresponding feature; /// \param [in] value Feature name to test.; ///; /// This allows one to set a feature given a specific string from the; /// TBasket::EIOBits enum.; ///; /// *NOTE* this function is quite slow and users are strongly encouraged to; /// use the type-safe `Set` version instead. This has been added for better; /// CLI interfaces.; ///; /// Returns true only if a new feature was set; otherwise emits an error message; /// and returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:464,Integrability,interface,interfaces,464,"/////////////////////////////////////////////////////////////////////////////; /// \brief Given a IO feature string, set the corresponding feature; /// \param [in] value Feature name to test.; ///; /// This allows one to set a feature given a specific string from the; /// TBasket::EIOBits enum.; ///; /// *NOTE* this function is quite slow and users are strongly encouraged to; /// use the type-safe `Set` version instead. This has been added for better; /// CLI interfaces.; ///; /// Returns true only if a new feature was set; otherwise emits an error message; /// and returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:555,Integrability,message,message,555,"/////////////////////////////////////////////////////////////////////////////; /// \brief Given a IO feature string, set the corresponding feature; /// \param [in] value Feature name to test.; ///; /// This allows one to set a feature given a specific string from the; /// TBasket::EIOBits enum.; ///; /// *NOTE* this function is quite slow and users are strongly encouraged to; /// use the type-safe `Set` version instead. This has been added for better; /// CLI interfaces.; ///; /// Returns true only if a new feature was set; otherwise emits an error message; /// and returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:396,Safety,safe,safe,396,"/////////////////////////////////////////////////////////////////////////////; /// \brief Given a IO feature string, set the corresponding feature; /// \param [in] value Feature name to test.; ///; /// This allows one to set a feature given a specific string from the; /// TBasket::EIOBits enum.; ///; /// *NOTE* this function is quite slow and users are strongly encouraged to; /// use the type-safe `Set` version instead. This has been added for better; /// CLI interfaces.; ///; /// Returns true only if a new feature was set; otherwise emits an error message; /// and returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:186,Testability,test,test,186,"/////////////////////////////////////////////////////////////////////////////; /// \brief Given a IO feature string, set the corresponding feature; /// \param [in] value Feature name to test.; ///; /// This allows one to set a feature given a specific string from the; /// TBasket::EIOBits enum.; ///; /// *NOTE* this function is quite slow and users are strongly encouraged to; /// use the type-safe `Set` version instead. This has been added for better; /// CLI interfaces.; ///; /// Returns true only if a new feature was set; otherwise emits an error message; /// and returns false.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:89,Testability,Test,Test,89,"////////////////////////////////////////////////////////////////////////////; /// \brief Test to see if a given feature is set; /// \param[in] input_bits The specific feature to test.; ///; /// Returns true if the feature is enables in this object and supported by; /// this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:178,Testability,test,test,178,"////////////////////////////////////////////////////////////////////////////; /// \brief Test to see if a given feature is set; /// \param[in] input_bits The specific feature to test.; ///; /// Returns true if the feature is enables in this object and supported by; /// this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:89,Testability,Test,Test,89,"////////////////////////////////////////////////////////////////////////////; /// \brief Test to see if a given feature is set; /// \param[in] input_bits The specific feature to test.; ///; /// Returns true if the feature is enables in this object and supported by; /// this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx:178,Testability,test,test,178,"////////////////////////////////////////////////////////////////////////////; /// \brief Test to see if a given feature is set; /// \param[in] input_bits The specific feature to test.; ///; /// Returns true if the feature is enables in this object and supported by; /// this version of ROOT.",MatchSource.CODE_COMMENT,tree/tree/src/TIOFeatures.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TIOFeatures.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx:1324,Integrability,depend,depending,1324,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TLeaf; \ingroup tree. A TLeaf describes individual elements of a TBranch; See TBranch structure in TTree. A TTree object is a list of TBranch.; A TBranch object is a list of TLeaf. In most cases, the TBranch; will have one TLeaf.; A TLeaf describes the branch data types and holds the data. A few notes about the data held by the leaf. It can contain:; 1. a single object or primitive (e.g., one float),; 2. a fixed-number of objects (e.g., each entry has two floats).; The number of elements per entry is saved in `fLen`.; 3. a dynamic number of primitives. The number of objects in each; entry is saved in the `fLeafCount` branch. Note options (2) and (3) can combined - if fLeafCount says an entry; has 3 elements and fLen is 2, then there will be 6 objects in that; entry. Additionally, `fNdata` is transient and generated on read to; determine the necessary size of a buffer to hold event data;; depending on the call-site, it may be sized larger than the number; of elements. */",MatchSource.CODE_COMMENT,tree/tree/src/TLeaf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx:190,Availability,error,error,190,"////////////////////////////////////////////////////////////////////////////////; /// If the class supports it, generate an offset array base.; ///; /// This class only returns `nullptr` on error.",MatchSource.CODE_COMMENT,tree/tree/src/TLeaf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx:15,Safety,avoid,avoid,15,"// In order to avoid a virtual call, we assume ROOT developers will override; // the default GenerateOffsetArray for cases where this function does not apply.",MatchSource.CODE_COMMENT,tree/tree/src/TLeaf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx:93,Integrability,rout,routine,93,"////////////////////////////////////////////////////////////////////////////////; /// Helper routine for TLeafX::SetAddress.; ///; /// The return value is non-zero if we owned the old; /// value buffer and must delete it now. The size; /// of the value buffer is recalculated and stored,; /// and a decision is made whether or not we own the; /// new value buffer.",MatchSource.CODE_COMMENT,tree/tree/src/TLeaf.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafB.cxx:757,Energy Efficiency,allocate,allocate,757,"// -- Reallocate.; // Note:; // 1) For a varying length array we do this based on; // an indirect estimator of the size of the value; // buffer since we have no record of how large it; // actually is. If the current length of the; // varying length array is less than it has been; // in the past, then reallocate the value buffer; // to the larger of either the calculated new size; // or the maximum size it has ever been.; //; // 2) The second condition checks if the new value; // buffer size calculated by ResetAddress() is; // smaller than the most we have ever used, and; // if it is, then we increase the new size and; // reallocate.; //; // 3) The third condition is checking to see if we; // have been given a value buffer, if not then; // we must allocate one.; //",MatchSource.CODE_COMMENT,tree/tree/src/TLeafB.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafB.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafC.cxx:460,Modifiability,variab,variable,460,"// @(#)root/tree:$Id$; // Author: Rene Brun 17/03/97; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TLeafC; \ingroup tree. A TLeaf for a variable length string.; */",MatchSource.CODE_COMMENT,tree/tree/src/TLeafC.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafC.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafElement.cxx:31,Availability,failure,failure,31,"// Returns non-zero in case of failure",MatchSource.CODE_COMMENT,tree/tree/src/TLeafElement.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafElement.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx:137,Usability,simpl,simple,137,"////////////////////////////////////////////////////////////////////////////////; /// Returns current value of leaf.; /// - if leaf is a simple type, i must be set to 0; /// - if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/src/TLeafG.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx:136,Usability,simpl,simple,136,"////////////////////////////////////////////////////////////////////////////////; /// Returns current value of leaf; /// - if leaf is a simple type, i must be set to 0; /// - if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/src/TLeafG.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx:107,Performance,perform,performing,107,"////////////////////////////////////////////////////////////////////////////////; /// Deserialize input by performing byteswap as needed.",MatchSource.CODE_COMMENT,tree/tree/src/TLeafG.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafI.cxx:136,Usability,simpl,simple,136,"////////////////////////////////////////////////////////////////////////////////; /// Returns current value of leaf; /// - if leaf is a simple type, i must be set to 0; /// - if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/src/TLeafI.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafI.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafI.cxx:107,Performance,perform,performing,107,"////////////////////////////////////////////////////////////////////////////////; /// Deserialize input by performing byteswap as needed.",MatchSource.CODE_COMMENT,tree/tree/src/TLeafI.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafI.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafL.cxx:137,Usability,simpl,simple,137,"////////////////////////////////////////////////////////////////////////////////; /// Returns current value of leaf.; /// - if leaf is a simple type, i must be set to 0; /// - if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/src/TLeafL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafL.cxx:136,Usability,simpl,simple,136,"////////////////////////////////////////////////////////////////////////////////; /// Returns current value of leaf; /// - if leaf is a simple type, i must be set to 0; /// - if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/src/TLeafL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafL.cxx:107,Performance,perform,performing,107,"////////////////////////////////////////////////////////////////////////////////; /// Deserialize input by performing byteswap as needed.",MatchSource.CODE_COMMENT,tree/tree/src/TLeafL.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafL.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafS.cxx:137,Usability,simpl,simple,137,"////////////////////////////////////////////////////////////////////////////////; /// Returns current value of leaf.; /// - if leaf is a simple type, i must be set to 0; /// - if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,tree/tree/src/TLeafS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafS.cxx:107,Performance,perform,performing,107,"////////////////////////////////////////////////////////////////////////////////; /// Deserialize input by performing byteswap as needed.",MatchSource.CODE_COMMENT,tree/tree/src/TLeafS.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafS.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:80,Modifiability,variab,variables,80,"/** \class TNtuple; \ingroup tree. A simple TTree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; ~~~ {.cpp}; TNtuple(name,title,varlist,bufsize); ~~~; It is filled via:; ~~~ {.cpp}; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....); ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Ntuple.",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:101,Modifiability,variab,variable,101,"/** \class TNtuple; \ingroup tree. A simple TTree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; ~~~ {.cpp}; TNtuple(name,title,varlist,bufsize); ~~~; It is filled via:; ~~~ {.cpp}; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....); ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Ntuple.",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:37,Usability,simpl,simple,37,"/** \class TNtuple; \ingroup tree. A simple TTree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; ~~~ {.cpp}; TNtuple(name,title,varlist,bufsize); ~~~; It is filled via:; ~~~ {.cpp}; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....); ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Ntuple.",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:232,Energy Efficiency,energy,energy,232,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:169,Modifiability,variab,variables,169,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:259,Modifiability,variab,variable,259,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:367,Modifiability,variab,variables,367,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:19,Modifiability,variab,variables,19,"// Count number of variables (separated by :)",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:30,Modifiability,variab,variable,30,"// Create one branch for each variable",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx:124,Modifiability,variab,variables,124,"////////////////////////////////////////////////////////////////////////////////; /// Read from filename as many columns as variables in the ntuple; /// the function returns the number of rows found in the file; /// The second argument ""branchDescriptor"" is currently not used.; /// Lines in the input file starting with ""#"" are ignored.",MatchSource.CODE_COMMENT,tree/tree/src/TNtuple.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtuple.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:82,Modifiability,variab,variables,82,"/** \class TNtupleD; \ingroup tree. A simple TTree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; ~~~ {.cpp}; TNtupleD(name,title,varlist,bufsize); ~~~; It is filled via:; ~~~ {.cpp}; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....); ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Ntuple.",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:103,Modifiability,variab,variable,103,"/** \class TNtupleD; \ingroup tree. A simple TTree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; ~~~ {.cpp}; TNtupleD(name,title,varlist,bufsize); ~~~; It is filled via:; ~~~ {.cpp}; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....); ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Ntuple.",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:38,Usability,simpl,simple,38,"/** \class TNtupleD; \ingroup tree. A simple TTree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; ~~~ {.cpp}; TNtupleD(name,title,varlist,bufsize); ~~~; It is filled via:; ~~~ {.cpp}; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....); ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Ntuple.",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:232,Energy Efficiency,energy,energy,232,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:169,Modifiability,variab,variables,169,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:259,Modifiability,variab,variable,259,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:367,Modifiability,variab,variables,367,"////////////////////////////////////////////////////////////////////////////////; /// Create an Ntuple.; ///; /// The parameter varlist describes the list of the ntuple variables; /// separated by a colon:; ///; /// Example: `x:y:z:energy`; ///; /// For each variable in the list a separate branch is created.; ///; /// NOTE:; /// - Use TTree to create branches with variables of different data types.; /// - Use TTree when the number of branches is large (> 100).",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:19,Modifiability,variab,variables,19,"// Count number of variables (separated by :)",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:30,Modifiability,variab,variable,30,"// Create one branch for each variable",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx:124,Modifiability,variab,variables,124,"////////////////////////////////////////////////////////////////////////////////; /// Read from filename as many columns as variables in the ntuple; /// the function returns the number of rows found in the file; /// The second argument ""branchDescriptor"" is currently not used.; /// Lines in the input file starting with ""#"" are ignored.",MatchSource.CODE_COMMENT,tree/tree/src/TNtupleD.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TNtupleD.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:3,Testability,Log,Log,3,"// Log file",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:48,Modifiability,variab,variables,48,"// The input list should contain info about the variables and; // selection cuts: save them into the macro title",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:3,Testability,Log,Log,3,"// Log notification also in the instance",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:21,Performance,load,loaded,21,"// List of libraries loaded at creation",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:91,Testability,log,log,91,"////////////////////////////////////////////////////////////////////////////////; /// Fill log file.",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:94,Deployability,update,update,94,"////////////////////////////////////////////////////////////////////////////////; /// Set (or update) query in archived state.",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx:163,Security,access,access,163,"////////////////////////////////////////////////////////////////////////////////; /// Return first instance of class 'classname' in the input list.; /// Useful to access TDSet, TEventList, ...",MatchSource.CODE_COMMENT,tree/tree/src/TQueryResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TQueryResult.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TreeUtils.cxx:276,Availability,error,error,276,"//Enforce/limit what can be a Tuple.; //Actually, at the moment you can only use; //the fill function for TNtuple/TNtupleD; //(enforced by hidden definition and explicit instantiations).; //But in future this can potentially change.; //TODO: there is no line number in any of error messages.; //It can be improved, though, we can have mixed line endings; //so I can not rely on this numbering (for example, my vim shows these lines:; //aaaa\r\r\nbbb as; //aaaa; //bbbb; //Though it can be also treated as; //aaaa; //; //bbb; //or even as; //aaaa; //; //; //bbb - so line numbers can be useless and misleading.",MatchSource.CODE_COMMENT,tree/tree/src/TreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TreeUtils.cxx:282,Integrability,message,messages,282,"//Enforce/limit what can be a Tuple.; //Actually, at the moment you can only use; //the fill function for TNtuple/TNtupleD; //(enforced by hidden definition and explicit instantiations).; //But in future this can potentially change.; //TODO: there is no line number in any of error messages.; //It can be improved, though, we can have mixed line endings; //so I can not rely on this numbering (for example, my vim shows these lines:; //aaaa\r\r\nbbb as; //aaaa; //bbbb; //Though it can be also treated as; //aaaa; //; //bbb; //or even as; //aaaa; //; //; //bbb - so line numbers can be useless and misleading.",MatchSource.CODE_COMMENT,tree/tree/src/TreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TreeUtils.cxx:117,Integrability,depend,depends,117,"//Skip empty lines, comments and whitespaces before; //the first 'non-ws' symbol:; //it can be a delimiter/a number (depends on a context) or an invalid symbol.",MatchSource.CODE_COMMENT,tree/tree/src/TreeUtils.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TreeUtils.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:2676,Performance,perform,performs,2676," only. - bool TSelector::Notify(). This method is called at the first entry; of a new file in a chain. - bool TSelector::Process(Long64_t entry). This method is called; to process an entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; entry is selected histograms can be filled. Processing stops; when this function returns false. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF. - bool TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; The function returns true if the entry must be processed,; false otherwise. This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected entries. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too. - void TSelector::Terminate(). This method is called at the end of; the loop on all entries. When using PROOF Terminate() is call on; the client only. Typically one performs the fits on the produced; histograms or write the histograms to file in this method. __WARNING when a selector is used with a TChain:__. in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call `GetEntry(entry)`.; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use `fChain->GetTree()->GetEntry(entry);`; */",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:1633,Safety,avoid,avoiding,1633," every time a new TTree is; attached. - void TSelector::SlaveBegin(). Create e.g. histograms in this method.; This method is called (with or without PROOF) before looping on the; entries in the Tree. When using PROOF, this method is called on; each worker node. - void TSelector::Begin(). Mostly for backward compatibility; use; SlaveBegin() instead. Both methods are called before looping on the; entries in the Tree. When using PROOF, Begin() is called on the; client only. - bool TSelector::Notify(). This method is called at the first entry; of a new file in a chain. - bool TSelector::Process(Long64_t entry). This method is called; to process an entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; entry is selected histograms can be filled. Processing stops; when this function returns false. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF. - bool TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; The function returns true if the entry must be processed,; false otherwise. This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected entries. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too. - void TSelector::Terminate(). This method is called at the end of; the loop on all entries. When using PROOF Terminate() is call on; the cl",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:86,Safety,Abort,Abort,86,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:161,Safety,abort,aborted,161,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:233,Safety,abort,aborted,233,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:347,Safety,abort,aborted,347,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:356,Safety,Abort,Abort,356,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:443,Safety,abort,abort,443,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:514,Safety,abort,abort,514,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:110,Performance,load,loaded,110,"////////////////////////////////////////////////////////////////////////////////; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded. The corresponding binary file and shared; /// library will be deleted at the end of the function.; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// The static function returns a pointer to a TSelector object",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:406,Performance,load,loaded,406,"////////////////////////////////////////////////////////////////////////////////; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded. The corresponding binary file and shared; /// library will be deleted at the end of the function.; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// The static function returns a pointer to a TSelector object",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:607,Performance,load,loaded,607,"////////////////////////////////////////////////////////////////////////////////; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded. The corresponding binary file and shared; /// library will be deleted at the end of the function.; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// The static function returns a pointer to a TSelector object",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:722,Performance,load,loaded,722,"////////////////////////////////////////////////////////////////////////////////; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded. The corresponding binary file and shared; /// library will be deleted at the end of the function.; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// The static function returns a pointer to a TSelector object",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:98,Availability,failure,failure,98,"// if a file was not specified, try to load the class via the interpreter;; // this returns 0 (== failure) in the case the class is already in memory; // but does not have a dictionary, so we just raise a flag for better; // diagnostic in the case the class is not found in the CINT ClassInfo table.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:39,Performance,load,load,39,"// if a file was not specified, try to load the class via the interpreter;; // this returns 0 (== failure) in the case the class is already in memory; // but does not have a dictionary, so we just raise a flag for better; // diagnostic in the case the class is not found in the CINT ClassInfo table.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:366,Safety,avoid,avoid,366,"////////////////////////////////////////////////////////////////////////////////; /// Imports the content of 'output' in the internal output list. Existing content; /// in the output list is discarded (unless found also in 'output').; /// In particular, if 'output' is nullptr or empty, reset the internal list.; /// On return, the content of 'output' is cleared to avoid double deletion issues.; /// (The caller is responsible of 'output' as container: its content is transferred; /// under the selector ownership).",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:355,Usability,clear,cleared,355,"////////////////////////////////////////////////////////////////////////////////; /// Imports the content of 'output' in the internal output list. Existing content; /// in the output list is discarded (unless found also in 'output').; /// In particular, if 'output' is nullptr or empty, reset the internal list.; /// On return, the content of 'output' is cleared to avoid double deletion issues.; /// (The caller is responsible of 'output' as container: its content is transferred; /// under the selector ownership).",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:524,Availability,avail,available,524,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:279,Performance,load,loaded,279,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:510,Performance,load,loaded,510,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:818,Safety,Abort,Abort,818,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:651,Usability,simpl,simple,651,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,tree/tree/src/TSelector.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:8486,Availability,avail,available,8486," done via the TBranch::SetAddress member function. \anchor addingacolumnofobjs; ## Add a column holding objects. ~~~ {.cpp}; MyClass object;; auto branch = tree.Branch(branchname, &object, bufsize, splitlevel); ~~~; Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. - if splitlevel=0, the object is serialized in the branch buffer.; - if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; - if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. Another available syntax is the following:. ~~~ {.cpp}; auto branch = tree.Branch(branchname, &p_object, bufsize, splitlevel); auto branch = tree.Branch(branchname, className, &p_object, bufsize, splitlevel); ~~~; - p_object is a pointer to an object.; - If className is not specified, Branch uses the type of p_object to determine the; type of the object.; - If className is used to specify explicitly the object type, the className must; be of a type related to the one pointed to by the pointer. It should be either; a parent or derived class. Note: The pointer whose address is passed to TTree::Branch must not; be destroyed (i.e. go out of scope) until the TTree is deleted or; TTree::ResetBranchAddress is called. Note: The pointer p_object must be initialized before calling TTree::Branch; - Do either:; ~~~ {.cpp}; MyDataClass* p_object = nullptr;; tree.Branch(branchname, &p_object);; ~~~; - Or:; ~~~ {.cpp}; auto p_object = new MyDataClass;; tree.Branch(branchname, &p_object);; ~~~; Whether the pointer is set ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:11133,Deployability,update,update,11133," TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. \anchor fillthetree; ## Fill the Tree. A TTree instance is filled with the invocation of the TTree::Fill method:; ~~~ {.cpp}; tree.Fill(); ~~~; Upon its invocation, a loop on all defined branches takes place that for each branch invokes; the TBranch::Fill method. \anchor addcoltoexistingtree; ## Add a column to an already existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved.; ~~~ {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");. Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3. for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }. t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; ~~~; It is not always possible to add branches to existing datasets stored in TFiles: for example,; these files might not be writeable, just readable. In addition, modifying in place a TTree; causes a new TTree instance to be written and the previous one to be deleted.; For this reasons, ROOT offers the concept of friends for TTree and TChain:; if is good practice to rely on friend trees rather than adding a branch manually. \anchor fullexample; ## An Example. Begin_Macro; ../../../tutorials/tree/tree.C; End_Macro. ~~~ {.cpp}; // A simple example with histograms and a tree; //; // This program creates :; // - a one dimen",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:816,Energy Efficiency,reduce,reduce,816,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1497,Energy Efficiency,allocate,allocated,1497," the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make several branches.; Making several branches is particularly interesting in the data analysis phase,; when it is desirable to have a high reading rate and not all columns are equally interesting. \anchor creatingattreetoc; ## Create a TTree to store columnar data; - [Construct a TTree](\ref creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:9611,Energy Efficiency,allocate,allocated,9611,"bject, bufsize, splitlevel); ~~~; - p_object is a pointer to an object.; - If className is not specified, Branch uses the type of p_object to determine the; type of the object.; - If className is used to specify explicitly the object type, the className must; be of a type related to the one pointed to by the pointer. It should be either; a parent or derived class. Note: The pointer whose address is passed to TTree::Branch must not; be destroyed (i.e. go out of scope) until the TTree is deleted or; TTree::ResetBranchAddress is called. Note: The pointer p_object must be initialized before calling TTree::Branch; - Do either:; ~~~ {.cpp}; MyDataClass* p_object = nullptr;; tree.Branch(branchname, &p_object);; ~~~; - Or:; ~~~ {.cpp}; auto p_object = new MyDataClass;; tree.Branch(branchname, &p_object);; ~~~; Whether the pointer is set to zero or not, the ownership of the object; is not taken over by the TTree. I.e. even though an object will be allocated; by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; be deleted when the TTree is deleted. \anchor addingacolumnoftclonesarray; ## Add a column holding TClonesArray instances. *It is recommended to use STL containers instead of TClonesArrays*. ~~~ {.cpp}; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); ~~~; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. \anchor fillthetree; ## Fill the Tree. A TTree instance is filled with the invocation of the TTree::Fill method:; ~~~ {.cpp}; tree.Fill(); ~~~; Upon its invocation, a loop on all defined branches takes place that for each branch invokes; the TBranch::Fill method. \anchor addcoltoexistingtree; ## Add a column to an already existing Tree. You may want to add a branch to an existing tree. For ex",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1665,Modifiability,Variab,Variables,1665,"a coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make several branches.; Making several branches is particularly interesting in the data analysis phase,; when it is desirable to have a high reading rate and not all columns are equally interesting. \anchor creatingattreetoc; ## Create a TTree to store columnar data; - [Construct a TTree](\ref creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding an object](\ref addingacolumnofobjs); - [Add a column holding a TObjectArray](\ref addingacolumnofobjs); - [Fill the tree](\ref fillthetree); - [Add a column to an already existing Tree](\ref add",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2923,Modifiability,Variab,Variables,2923," into; one single I/O buffer or to make several branches.; Making several branches is particularly interesting in the data analysis phase,; when it is desirable to have a high reading rate and not all columns are equally interesting. \anchor creatingattreetoc; ## Create a TTree to store columnar data; - [Construct a TTree](\ref creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding an object](\ref addingacolumnofobjs); - [Add a column holding a TObjectArray](\ref addingacolumnofobjs); - [Fill the tree](\ref fillthetree); - [Add a column to an already existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3002,Modifiability,variab,variables,3002," into; one single I/O buffer or to make several branches.; Making several branches is particularly interesting in the data analysis phase,; when it is desirable to have a high reading rate and not all columns are equally interesting. \anchor creatingattreetoc; ## Create a TTree to store columnar data; - [Construct a TTree](\ref creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding an object](\ref addingacolumnofobjs); - [Add a column holding a TObjectArray](\ref addingacolumnofobjs); - [Fill the tree](\ref fillthetree); - [Add a column to an already existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3356,Modifiability,variab,variables,3356,"ef creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding an object](\ref addingacolumnofobjs); - [Add a column holding a TObjectArray](\ref addingacolumnofobjs); - [Fill the tree](\ref fillthetree); - [Add a column to an already existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3677,Modifiability,variab,variable,3677,"eady existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated m",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3741,Modifiability,variab,variable,3741,"eady existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated m",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3763,Modifiability,variab,variable,3763,"eady existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated m",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3812,Modifiability,variab,variable,3812,"); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`L",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:4000,Modifiability,variab,variable,4000,"s: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); -",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:4052,Modifiability,variab,variable,4052,"s: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); -",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:4075,Modifiability,variab,variable,4075,"he STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5174,Modifiability,variab,variable,5174," - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5268,Modifiability,variab,variable,5268," - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5404,Modifiability,variab,variable,5404," - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`); - `S` : a 16 bit signed integer (`Short_t`); - `s` : a 16 bit unsigned integer (`UShort_t`); - `I` : a 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5494,Modifiability,variab,variable,5494," 32 bit signed integer (`Int_t`); - `i` : a 32 bit unsigned integer (`UInt_t`); - `F` : a 32 bit floating point (`Float_t`); - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; the standard rules of opaque t",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5646,Modifiability,variab,variable,5646,"oating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; the standard rules of opaque typedefs annotation are valid. For example, if only; 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`. \anchor ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5688,Modifiability,variab,variable,5688,"oating point with truncated mantissa (`Float16_t`); - `D` : a 64 bit floating point (`Double_t`); - `d` : a 24 bit truncated floating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; the standard rules of opaque typedefs annotation are valid. For example, if only; 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`. \anchor ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:5774,Modifiability,portab,portable,5774,"oating point (`Double32_t`); - `L` : a 64 bit signed integer (`Long64_t`); - `l` : a 64 bit unsigned integer (`ULong64_t`); - `G` : a long signed integer, stored as 64 bit (`Long_t`); - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); - `O` : [the letter `o`, not a zero] a boolean (`bool`). Examples:; - A int: ""myVar/I""; - A float array with fixed size: ""myArrfloat[42]/F""; - An double array with variable size, held by the `myvar` column: ""myArrdouble[myvar]/D""; - An Double32_t array with variable size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; the standard rules of opaque typedefs annotation are valid. For example, if only; 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`. \anchor addingacolumnofstl; ## Adding a column holding STL collection instances (e.g. std::vector, std::list, std::unordered_map). ~~~ {",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:6167,Modifiability,variab,variable,6167,"e size, held by the `myvar` column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; - The `myvar` column, which holds the variable size, **MUST** be an `Int_t` (/I). - If the address points to a single numerical variable, the leaflist is optional:; ~~~ {.cpp}; int value;; tree->Branch(branchname, &value);; ~~~; - If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable TTree (i.e. you will not be able to read it back on a; platform with a different padding strategy).; We recommend to persistify objects rather than composite leaflists.; - In case of the truncated floating point types (Float16_t and Double32_t) you can; furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; the type character. For example, for storing a variable size array `myArr` of; `Double32_t` with values within a range of `[0, 2*pi]` and the size of which is stored; in an `Int_t` (/I) branch called `myArrSize`, the syntax for the `leaflist` string would; be: `myArr[myArrSize]/d[0,twopi]`. Of course the number of bits could be specified,; the standard rules of opaque typedefs annotation are valid. For example, if only; 18 bits were sufficient, the syntax would become: `myArr[myArrSize]/d[0,twopi,18]`. \anchor addingacolumnofstl; ## Adding a column holding STL collection instances (e.g. std::vector, std::list, std::unordered_map). ~~~ {.cpp}; auto branch = tree.Branch( branchname, STLcollection, buffsize, splitlevel);; ~~~; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:10674,Modifiability,variab,variable,10674,"e is deleted. \anchor addingacolumnoftclonesarray; ## Add a column holding TClonesArray instances. *It is recommended to use STL containers instead of TClonesArrays*. ~~~ {.cpp}; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); ~~~; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. \anchor fillthetree; ## Fill the Tree. A TTree instance is filled with the invocation of the TTree::Fill method:; ~~~ {.cpp}; tree.Fill(); ~~~; Upon its invocation, a loop on all defined branches takes place that for each branch invokes; the TBranch::Fill method. \anchor addcoltoexistingtree; ## Add a column to an already existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved.; ~~~ {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");. Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3. for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }. t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; ~~~; It is not always possible to add branches to existing datasets stored in TFiles: for example,; these files might not be writeable, just readable. In addition, modifying in place a TTree; causes a new TTree instance",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:785,Performance,optimiz,optimized,785,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:878,Performance,perform,performance,878,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:12699,Safety,detect,detector,12699,"ition, modifying in place a TTree; causes a new TTree instance to be written and the previous one to be deleted.; For this reasons, ROOT offers the concept of friends for TTree and TChain:; if is good practice to rely on friend trees rather than adding a branch manually. \anchor fullexample; ## An Example. Begin_Macro; ../../../tutorials/tree/tree.C; End_Macro. ~~~ {.cpp}; // A simple example with histograms and a tree; //; // This program creates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;. // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;. // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:905,Security,access,access,905,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:10072,Security,access,access,10072,"address is passed to TTree::Branch must not; be destroyed (i.e. go out of scope) until the TTree is deleted or; TTree::ResetBranchAddress is called. Note: The pointer p_object must be initialized before calling TTree::Branch; - Do either:; ~~~ {.cpp}; MyDataClass* p_object = nullptr;; tree.Branch(branchname, &p_object);; ~~~; - Or:; ~~~ {.cpp}; auto p_object = new MyDataClass;; tree.Branch(branchname, &p_object);; ~~~; Whether the pointer is set to zero or not, the ownership of the object; is not taken over by the TTree. I.e. even though an object will be allocated; by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; be deleted when the TTree is deleted. \anchor addingacolumnoftclonesarray; ## Add a column holding TClonesArray instances. *It is recommended to use STL containers instead of TClonesArrays*. ~~~ {.cpp}; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); ~~~; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. \anchor fillthetree; ## Fill the Tree. A TTree instance is filled with the invocation of the TTree::Fill method:; ~~~ {.cpp}; tree.Fill(); ~~~; Upon its invocation, a loop on all defined branches takes place that for each branch invokes; the TBranch::Fill method. \anchor addcoltoexistingtree; ## Add a column to an already existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tr",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:765,Testability,test,tested,765,"// @(#)root/tree:$Id$; // Author: Rene Brun 12/01/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \defgroup tree Tree Library. In order to store columnar datasets, ROOT provides the TTree, TChain,; TNtuple and TNtupleD classes.; The TTree class represents a columnar dataset. Any C++ type can be stored in the; columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; it is demonstrated to scale and it's battle tested. It has been optimized during the years; to reduce dataset sizes on disk and to deliver excellent runtime performance.; It allows to access only part of the columns of the datasets, too.; The TNtuple and TNtupleD classes are specialisations of the TTree class which can; only hold single precision and double precision floating-point numbers respectively;; The TChain is a collection of TTrees, which can be located also in different files. */; /** \class TTree; \ingroup tree. A TTree represents a columnar dataset. Any C++ type can be stored in its columns. A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; represented by the TBranch class.; Behind each branch, buffers are allocated automatically by ROOT.; Such buffers are automatically written to disk or kept in memory until the size stored in the; attribute fMaxVirtualSize is reached.; Variables of one branch are written to the same buffer. A branch buffer is; automatically compressed if the file compression attribute is set (default).; Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one object into; one single I/O buffer or to make ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2965,Usability,simpl,simple,2965," into; one single I/O buffer or to make several branches.; Making several branches is particularly interesting in the data analysis phase,; when it is desirable to have a high reading rate and not all columns are equally interesting. \anchor creatingattreetoc; ## Create a TTree to store columnar data; - [Construct a TTree](\ref creatingattree); - [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding an object](\ref addingacolumnofobjs); - [Add a column holding a TObjectArray](\ref addingacolumnofobjs); - [Fill the tree](\ref fillthetree); - [Add a column to an already existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3384,Usability,simpl,simple,3384,"mentaltypes); - [Add a column of a STL Collection instances](\ref addingacolumnofstl); - [Add a column holding an object](\ref addingacolumnofobjs); - [Add a column holding a TObjectArray](\ref addingacolumnofobjs); - [Fill the tree](\ref fillthetree); - [Add a column to an already existing Tree](\ref addcoltoexistingtree); - [An Example](\ref fullexample). \anchor creatingattree; ## Construct a TTree. ~~~ {.cpp}; TTree tree(name, title); ~~~; Creates a Tree with name and title. Various kinds of branches can be added to a tree:; - Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; structures.; - Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. \anchor addcolumnoffundamentaltypes; ## Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures.; It is strongly recommended to persistify those as objects rather than lists of leaves. ~~~ {.cpp}; auto branch = tree.Branch(branchname, address, leaflist, bufsize); ~~~; - address is the address of the first item of a structure; - leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - `C` : a character string terminated by the 0 character; - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; - `b` : an 8 bit unsigned integer (`UChar_t`",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:10887,Usability,simpl,simple,10887,"~~ {.cpp}; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); ~~~; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. \anchor fillthetree; ## Fill the Tree. A TTree instance is filled with the invocation of the TTree::Fill method:; ~~~ {.cpp}; tree.Fill(); ~~~; Upon its invocation, a loop on all defined branches takes place that for each branch invokes; the TBranch::Fill method. \anchor addcoltoexistingtree; ## Add a column to an already existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved.; ~~~ {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");. Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3. for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }. t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; ~~~; It is not always possible to add branches to existing datasets stored in TFiles: for example,; these files might not be writeable, just readable. In addition, modifying in place a TTree; causes a new TTree instance to be written and the previous one to be deleted.; For this reasons, ROOT offers the concept of friends for TTree and TChain:; if is good practice to rely on friend t",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:12044,Usability,simpl,simple,12044," = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3. for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }. t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; ~~~; It is not always possible to add branches to existing datasets stored in TFiles: for example,; these files might not be writeable, just readable. In addition, modifying in place a TTree; causes a new TTree instance to be written and the previous one to be deleted.; For this reasons, ROOT offers the concept of friends for TTree and TChain:; if is good practice to rely on friend trees rather than adding a branch manually. \anchor fullexample; ## An Example. Begin_Macro; ../../../tutorials/tree/tree.C; End_Macro. ~~~ {.cpp}; // A simple example with histograms and a tree; //; // This program creates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POI",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:13114,Usability,simpl,simple,13114,"file histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;. // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;. // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);. // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);. // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; //",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:14132,Usability,simpl,simple,14132," **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;. // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;. // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);. // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);. // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; // End of the loop. tree.Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application upon file destruction.; hfile.Close();. return 0;; }; ~~~; */",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:72,Performance,multi-thread,multi-thread,72,"// We could also add some code to acquire an actual; // lock to prevent multi-thread issues",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:417,Performance,cache,cache,417,"////////////////////////////////////////////////////////////////////////////////; /// Estimate the cluster size.; ///; /// In almost all cases, this quickly returns the size of the auto-flush; /// in the TTree.; ///; /// However, in the case where the cluster size was not fixed (old files and; /// case where autoflush was explicitly set to zero), we need estimate; /// a cluster size in relation to the size of the cache.; ///; /// After this value is calculated once for the TClusterIterator, it is; /// cached and reused in future calls.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:507,Performance,cache,cached,507,"////////////////////////////////////////////////////////////////////////////////; /// Estimate the cluster size.; ///; /// In almost all cases, this quickly returns the size of the auto-flush; /// in the TTree.; ///; /// However, in the case where the cluster size was not fixed (old files and; /// case where autoflush was explicitly set to zero), we need estimate; /// a cluster size in relation to the size of the cache.; ///; /// After this value is calculated once for the TClusterIterator, it is; /// cached and reused in future calls.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:34,Performance,cache,cache,34,"// If neither file nor tree has a cache, use the current default.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:18,Performance,cache,cache,18,"//delete the file cache if it points to this Tree",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:73,Safety,avoid,avoid,73,"// Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; // this RecursiveRemove while we delete our content.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:36,Energy Efficiency,allocate,allocated,36,"// I'm ready to destroy any objects allocated by; // SetAddress() by my branches. If I have clones,; // tell them to zero their pointers to this shared; // memory.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:131,Deployability,release,release,131,"// I have clones.; // I am about to delete the objects created by; // SetAddress() which we are sharing, so tell; // the clones to release their pointers to them.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:53,Deployability,release,release,53,"// Get rid of our branches, note that this will also release; // any memory allocated by TBranchElement::SetAddress().",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:76,Energy Efficiency,allocate,allocated,76,"// Get rid of our branches, note that this will also release; // any memory allocated by TBranchElement::SetAddress().",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:49,Safety,detect,detect,49,"// The TBranch destructor is using fDirectory to detect whether it; // owns the TFile that contains its data (See TBranch::~TBranch)",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:357,Availability,error,error,357,"////////////////////////////////////////////////////////////////////////////////; /// Add branch with name bname to the Tree cache.; /// If bname=""*"" all branches are added to the cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:125,Performance,cache,cache,125,"////////////////////////////////////////////////////////////////////////////////; /// Add branch with name bname to the Tree cache.; /// If bname=""*"" all branches are added to the cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:180,Performance,cache,cache,180,"////////////////////////////////////////////////////////////////////////////////; /// Add branch with name bname to the Tree cache.; /// If bname=""*"" all branches are added to the cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:276,Performance,cache,cache,276,"////////////////////////////////////////////////////////////////////////////////; /// Add branch with name bname to the Tree cache.; /// If bname=""*"" all branches are added to the cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:288,Availability,error,error,288,"////////////////////////////////////////////////////////////////////////////////; /// Add branch b to the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:111,Performance,cache,cache,111,"////////////////////////////////////////////////////////////////////////////////; /// Add branch b to the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:207,Performance,cache,cache,207,"////////////////////////////////////////////////////////////////////////////////; /// Add branch b to the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:376,Availability,error,error,376,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch with name 'bname' from the Tree cache.; /// If bname=""*"" all branches are removed from the cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:136,Performance,cache,cache,136,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch with name 'bname' from the Tree cache.; /// If bname=""*"" all branches are removed from the cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:195,Performance,cache,cache,195,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch with name 'bname' from the Tree cache.; /// If bname=""*"" all branches are removed from the cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:297,Performance,cache,cache,297,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch with name 'bname' from the Tree cache.; /// If bname=""*"" all branches are removed from the cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:357,Performance,cache,cache,357,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch with name 'bname' from the Tree cache.; /// If bname=""*"" all branches are removed from the cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:301,Availability,error,error,301,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch b from the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:120,Performance,cache,cache,120,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch b from the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:222,Performance,cache,cache,222,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch b from the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:282,Performance,cache,cache,282,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch b from the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:517,Modifiability,variab,variable,517,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends.; ///; /// This function:; /// - opens a file if filename is specified; /// - reads a Tree with name treename from the file (current directory); /// - adds the Tree to the list of friends; /// see other AddFriend functions; ///; /// A TFriendElement TF describes a TTree object TF in a file.; /// When a TFriendElement TF is added to the list of friends of an; /// existing TTree T, any variable from TF can be referenced in a query; /// to T.; ///; /// A tree keeps a list of friends. In the context of a tree (or a chain),; /// friendship means unrestricted access to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/o",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1014,Modifiability,variab,variables,1014,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends.; ///; /// This function:; /// - opens a file if filename is specified; /// - reads a Tree with name treename from the file (current directory); /// - adds the Tree to the list of friends; /// see other AddFriend functions; ///; /// A TFriendElement TF describes a TTree object TF in a file.; /// When a TFriendElement TF is added to the list of friends of an; /// existing TTree T, any variable from TF can be referenced in a query; /// to T.; ///; /// A tree keeps a list of friends. In the context of a tree (or a chain),; /// friendship means unrestricted access to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/o",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1723,Modifiability,variab,variables,1723,"to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in th",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1906,Modifiability,variab,variablename,1906,"iends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original tree. If the friend tree has fewer entries a; /// warning is given and the missing entries are not included in the histogram.; /// To retrieve the list of friends from",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1954,Modifiability,variab,variable,1954,"iends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original tree. If the friend tree has fewer entries a; /// warning is given and the missing entries are not included in the histogram.; /// To retrieve the list of friends from",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2080,Modifiability,variab,variable,2080,"dFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original tree. If the friend tree has fewer entries a; /// warning is given and the missing entries are not included in the histogram.; /// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; /// When the tree is written to file (TTree::Write), the friends list is saved; /// with it. And when the tree is retr",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2125,Modifiability,variab,variable,2125,"dFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original tree. If the friend tree has fewer entries a; /// warning is given and the missing entries are not included in the histogram.; /// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; /// When the tree is written to file (TTree::Write), the friends list is saved; /// with it. And when the tree is retr",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2157,Modifiability,variab,variable,2157,"dFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original tree. If the friend tree has fewer entries a; /// warning is given and the missing entries are not included in the histogram.; /// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; /// When the tree is written to file (TTree::Write), the friends list is saved; /// with it. And when the tree is retr",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:804,Safety,risk,risk,804,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends.; ///; /// This function:; /// - opens a file if filename is specified; /// - reads a Tree with name treename from the file (current directory); /// - adds the Tree to the list of friends; /// see other AddFriend functions; ///; /// A TFriendElement TF describes a TTree object TF in a file.; /// When a TFriendElement TF is added to the list of friends of an; /// existing TTree T, any variable from TF can be referenced in a query; /// to T.; ///; /// A tree keeps a list of friends. In the context of a tree (or a chain),; /// friendship means unrestricted access to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/o",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:690,Security,access,access,690,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends.; ///; /// This function:; /// - opens a file if filename is specified; /// - reads a Tree with name treename from the file (current directory); /// - adds the Tree to the list of friends; /// see other AddFriend functions; ///; /// A TFriendElement TF describes a TTree object TF in a file.; /// When a TFriendElement TF is added to the list of friends of an; /// existing TTree T, any variable from TF can be referenced in a query; /// to T.; ///; /// A tree keeps a list of friends. In the context of a tree (or a chain),; /// friendship means unrestricted access to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/o",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1000,Security,access,access,1000,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends.; ///; /// This function:; /// - opens a file if filename is specified; /// - reads a Tree with name treename from the file (current directory); /// - adds the Tree to the list of friends; /// see other AddFriend functions; ///; /// A TFriendElement TF describes a TTree object TF in a file.; /// When a TFriendElement TF is added to the list of friends of an; /// existing TTree T, any variable from TF can be referenced in a query; /// to T.; ///; /// A tree keeps a list of friends. In the context of a tree (or a chain),; /// friendship means unrestricted access to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/o",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2417,Security,access,access,2417,"d(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/or branch name.; /// For example, these commands generate a 3-d scatter plot of variable ""var""; /// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; /// TTree ft2.; /// ~~~ {.cpp}; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// tree.AddFriend(""ft2"",""friendfile2.root"");; /// tree.Draw(""var:ft1.v1:ft2.v2"");; /// ~~~; /// \image html ttree_friend2.png; ///; /// The picture illustrates the access of the tree and its friends with a; /// Draw command.; /// When AddFriend is called, the ROOT file is automatically opened and the; /// friend tree (ft1) is read into memory. The new friend (ft1) is added to; /// the list of friends of tree.; /// The number of entries in the friend must be equal or greater to the number; /// of entries of the original tree. If the friend tree has fewer entries a; /// warning is given and the missing entries are not included in the histogram.; /// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; /// When the tree is written to file (TTree::Write), the friends list is saved; /// with it. And when the tree is retrieved, the trees on the friends list are; /// also retrieved and the friendship restored.; /// When a tree is deleted, the elements of the friend list are also deleted.; /// It is possible to declare a friend tree that has the same internal; /// structure (same branches and leaves) as the original tree, and compare the; ///",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:8,Testability,assert,assert,8,"// this assert is for historical reasons. Don't remove it unless you understand all the consequences.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1206,Availability,recover,recovered,1206,"safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1290,Availability,recover,recovered,1290,"utoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustr",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2122,Availability,error,error,2122,"e closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTree *ntuple = (TTree*)f.Get(""ntuple"");; /// TCanvas c1;; /// Int_t first = 0;; /// while(1) {; /// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; /// else ntuple->Draw(""px>>+hpx"",""""",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1255,Deployability,UPDATE,UPDATE,1255,"safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3203,Deployability,Update,Update,3203,"he status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTree *ntuple = (TTree*)f.Get(""ntuple"");; /// TCanvas c1;; /// Int_t first = 0;; /// while(1) {; /// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; /// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; /// first = (Int_t)ntuple->GetEntries();; /// c1.Update();; /// gSystem->Sleep(1000); //sleep 1 second; /// ntuple->Refresh();; /// }; /// }; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:177,Safety,safe,safe,177,"////////////////////////////////////////////////////////////////////////////////; /// AutoSave tree header every fAutoSave bytes.; ///; /// When large Trees are produced, it is safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1206,Safety,recover,recovered,1206,"safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1290,Safety,recover,recovered,1290,"utoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustr",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1927,Safety,safe,safer,1927," make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTre",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:942,Testability,test,tests,942,"/////////////////////////////////////////////////////////////////////////////; /// AutoSave tree header every fAutoSave bytes.; ///; /// When large Trees are produced, it is safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new he",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2473,Testability,test,test,2473,"he status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTree *ntuple = (TTree*)f.Get(""ntuple"");; /// TCanvas c1;; /// Int_t first = 0;; /// while(1) {; /// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; /// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; /// first = (Int_t)ntuple->GetEntries();; /// c1.Update();; /// gSystem->Sleep(1000); //sleep 1 second; /// ntuple->Refresh();; /// }; /// }; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2914,Testability,test,test,2914,"he status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTree *ntuple = (TTree*)f.Get(""ntuple"");; /// TCanvas c1;; /// Int_t first = 0;; /// while(1) {; /// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; /// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; /// first = (Int_t)ntuple->GetEntries();; /// c1.Update();; /// gSystem->Sleep(1000); //sleep 1 second; /// ntuple->Refresh();; /// }; /// }; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:8,Availability,error,error,8,"// This error message is repeated several times in the code. We write it once.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:14,Integrability,message,message,14,"// This error message is repeated several times in the code. We write it once.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:122,Safety,detect,detection,122,"////////////////////////////////////////////////////////////////////////////////; /// Same as TTree::Branch but automatic detection of the class name.; /// \see TTree::Branch for other details.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:122,Safety,detect,detection,122,"////////////////////////////////////////////////////////////////////////////////; /// Same as TTree::Branch but automatic detection of the class name.; /// \see TTree::Branch for other details.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:122,Safety,detect,detection,122,"////////////////////////////////////////////////////////////////////////////////; /// Same as TTree::Branch but automatic detection of the class name.; /// \see TTree::Branch for other details.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:85,Integrability,Wrap,Wrapper,85,"////////////////////////////////////////////////////////////////////////////////; // Wrapper to turn Branch call with an std::array into the relevant leaf list; // call",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1381,Safety,avoid,avoid,1381,"ased by 1 every time a new collection is found.; /// For example if list is a TObjArray*; /// - if splitlevel = 1, one top level branch is created for each element; /// of the TObjArray.; /// - if splitlevel = 2, one top level branch is created for each array element.; /// if, in turn, one of the array elements is a TCollection, one top level; /// branch will be created for each element of this collection.; ///; /// In case a collection element is a TClonesArray, the special Tree constructor; /// for TClonesArray is called.; /// The collection itself cannot be a TClonesArray.; ///; /// The function returns the total number of branches created.; ///; /// If name is given, all branch names will be prefixed with name_.; ///; /// IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; ///; /// IMPORTANT NOTE2: The branches created by this function will have names; /// corresponding to the collection or object names. It is important; /// to give names to collections to avoid misleading branch names or; /// identical branch names. By default collections have a name equal to; /// the corresponding class name, e.g. the default name for a TList is ""TList"".; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// Example:; /// ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2421,Testability,test,test,2421,"TANT NOTE2: The branches created by this function will have names; /// corresponding to the collection or object names. It is important; /// to give names to collections to avoid misleading branch names or; /// identical branch names. By default collections have a name equal to; /// the corresponding class name, e.g. the default name for a TList is ""TList"".; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// Example:; /// ~~~ {.cpp}; /// {; /// TTree T(""T"",""test list"");; /// TList *list = new TList();; ///; /// TObjArray *a1 = new TObjArray();; /// a1->SetName(""a1"");; /// list->Add(a1);; /// TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; /// TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; /// a1->Add(ha1a);; /// a1->Add(ha1b);; /// TObjArray *b1 = new TObjArray();; /// b1->SetName(""b1"");; /// list->Add(b1);; /// TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; /// TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; /// b1->Add(hb1a);; /// b1->Add(hb1b);; ///; /// TObjArray *a2 = new TObjArray();; /// a2->SetName(""a2"");; /// list->Add(a2);; /// TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; /// TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; /// a2->Add(ha2a);; /// a2->Add(ha2b);; ///; /// T.Branch(list,16000,2);; /// T.Print();; /// }; /// ~~~",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1852,Usability,simpl,simply,1852,", the special Tree constructor; /// for TClonesArray is called.; /// The collection itself cannot be a TClonesArray.; ///; /// The function returns the total number of branches created.; ///; /// If name is given, all branch names will be prefixed with name_.; ///; /// IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; ///; /// IMPORTANT NOTE2: The branches created by this function will have names; /// corresponding to the collection or object names. It is important; /// to give names to collections to avoid misleading branch names or; /// identical branch names. By default collections have a name equal to; /// the corresponding class name, e.g. the default name for a TList is ""TList"".; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// Example:; /// ~~~ {.cpp}; /// {; /// TTree T(""T"",""test list"");; /// TList *list = new TList();; ///; /// TObjArray *a1 = new TObjArray();; /// a1->SetName(""a1"");; /// list->Add(a1);; /// TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; /// TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; /// a1->Add(ha1a);; /// a1->Add(ha1b);; /// TObjArray *b1 = new TObjArray();; /// b1->SetName(""b1"");; /// list->Add(b1);; /// TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; /// TH1F *hb1b = new TH1F",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:202,Modifiability,variab,variables,202,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:253,Modifiability,variab,variables,253,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:604,Modifiability,variab,variable,604,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:676,Modifiability,variab,variable,676,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:698,Modifiability,variab,variable,698,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:751,Modifiability,variab,variable,751,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:835,Modifiability,variab,variable,835,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:891,Modifiability,variab,variable,891,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:914,Modifiability,variab,variable,914,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2167,Modifiability,variab,variable,2167,"e type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values are supported with the following syntax:; /// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; /// if nelem is a leaf name, it is used as the variable size of the array,; /// otherwise return 0.; /// The leaf referred to by nelem **MUST** be an int (/I),; /// - If leaf name has the form var[nelem], where nelem is a non-negative integer, then; /// it is used as the fixed size of the array.; /// - If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); /// where nelem and nelem2 are non-negative integer) then; /// it is used as a 2 dimensional array of fixed size.; /// - In case of the truncated floating point types (Float16_t and Double32_t) you c",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3554,Security,access,access,3554,"4 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values are supported with the following syntax:; /// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; /// if nelem is a leaf name, it is used as the variable size of the array,; /// otherwise return 0.; /// The leaf referred to by nelem **MUST** be an int (/I),; /// - If leaf name has the form var[nelem], where nelem is a non-negative integer, then; /// it is used as the fixed size of the array.; /// - If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); /// where nelem and nelem2 are non-negative integer) then; /// it is used as a 2 dimensional array of fixed size.; /// - In case of the truncated floating point types (Float16_t and Double32_t) you can; /// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; /// the type character. See `TStreamerElement::GetRange()` for further information.; ///; /// Any of other form is not supported.; ///; /// Note that the TTree will assume that all the item are contiguous in memory.; /// On some platform, this is not always true of the member of a struct or a class,; /// due to padding and alignment. Sorting your data member in order of decreasing; /// sizeof usually leads to their being contiguous in memory.; ///; /// * bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entries in the Tree randomly and your Tree is in split mode.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:241,Usability,simpl,simple,241,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree Branch.; ///; /// This Branch constructor is provided to support non-objects in; /// a Tree. The variables described in leaflist may be simple; /// variables or structures. // See the two following; /// constructors for writing objects in a Tree.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// * address is the address of the first item of a structure.; /// * leaflist is the concatenation of all the variable names and types; /// separated by a colon character :; /// The variable name and the variable type are separated by a slash (/).; /// The variable type may be 0,1 or 2 characters. If no type is given,; /// the type of the variable is assumed to be the same as the previous; /// variable. If the first variable does not have a type, it is assumed; /// of type F by default. The list of currently supported types is given below:; /// - `C` : a character string terminated by the 0 character; /// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; /// - `b` : an 8 bit unsigned integer (`UChar_t`); /// - `S` : a 16 bit signed integer (`Short_t`); /// - `s` : a 16 bit unsigned integer (`UShort_t`); /// - `I` : a 32 bit signed integer (`Int_t`); /// - `i` : a 32 bit unsigned integer (`UInt_t`); /// - `F` : a 32 bit floating point (`Float_t`); /// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); /// - `D` : a 64 bit floating point (`Double_t`); /// - `d` : a 24 bit truncated floating point (`Double32_t`); /// - `L` : a 64 bit signed integer (`Long64_t`); /// - `l` : a 64 bit unsigned integer (`ULong64_t`); /// - `G` : a long signed integer, stored as 64 bit (`Long_t`); /// - `g` : a long unsigned integer, stored as 64 bit (`ULong_t`); /// - `O` : [the letter `o`, not a zero] a boolean (`bool`); ///; /// Arrays of values ar",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:344,Availability,avail,available,344,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree BranchObject.; ///; /// Build a TBranchObject for an object of class classname.; /// addobj is the address of a pointer to an object of class classname.; /// IMPORTANT: classname must derive from TObject.; /// The class dictionary must be available (ClassDef in class header).; ///; /// This option requires access to the library where the corresponding class; /// is defined. Accessing one single data member in the object implies; /// reading the full object.; /// See the next Branch constructor for a more efficient storage; /// in case the entry consists of arrays of identical objects.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entrie",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:615,Energy Efficiency,efficient,efficient,615,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree BranchObject.; ///; /// Build a TBranchObject for an object of class classname.; /// addobj is the address of a pointer to an object of class classname.; /// IMPORTANT: classname must derive from TObject.; /// The class dictionary must be available (ClassDef in class header).; ///; /// This option requires access to the library where the corresponding class; /// is defined. Accessing one single data member in the object implies; /// reading the full object.; /// See the next Branch constructor for a more efficient storage; /// in case the entry consists of arrays of identical objects.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entrie",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:413,Security,access,access,413,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree BranchObject.; ///; /// Build a TBranchObject for an object of class classname.; /// addobj is the address of a pointer to an object of class classname.; /// IMPORTANT: classname must derive from TObject.; /// The class dictionary must be available (ClassDef in class header).; ///; /// This option requires access to the library where the corresponding class; /// is defined. Accessing one single data member in the object implies; /// reading the full object.; /// See the next Branch constructor for a more efficient storage; /// in case the entry consists of arrays of identical objects.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entrie",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:482,Security,Access,Accessing,482,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree BranchObject.; ///; /// Build a TBranchObject for an object of class classname.; /// addobj is the address of a pointer to an object of class classname.; /// IMPORTANT: classname must derive from TObject.; /// The class dictionary must be available (ClassDef in class header).; ///; /// This option requires access to the library where the corresponding class; /// is defined. Accessing one single data member in the object implies; /// reading the full object.; /// See the next Branch constructor for a more efficient storage; /// in case the entry consists of arrays of identical objects.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entrie",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1979,Security,access,access,1979,"////////////////////////; /// Create a new TTree BranchObject.; ///; /// Build a TBranchObject for an object of class classname.; /// addobj is the address of a pointer to an object of class classname.; /// IMPORTANT: classname must derive from TObject.; /// The class dictionary must be available (ClassDef in class header).; ///; /// This option requires access to the library where the corresponding class; /// is defined. Accessing one single data member in the object implies; /// reading the full object.; /// See the next Branch constructor for a more efficient storage; /// in case the entry consists of arrays of identical objects.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entries in the Tree randomly and your Tree is in split mode.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1161,Usability,simpl,simply,1161,"////////////////////////; /// Create a new TTree BranchObject.; ///; /// Build a TBranchObject for an object of class classname.; /// addobj is the address of a pointer to an object of class classname.; /// IMPORTANT: classname must derive from TObject.; /// The class dictionary must be available (ClassDef in class header).; ///; /// This option requires access to the library where the corresponding class; /// is defined. Accessing one single data member in the object implies; /// reading the full object.; /// See the next Branch constructor for a more efficient storage; /// in case the entry consists of arrays of identical objects.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entries in the Tree randomly and your Tree is in split mode.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:54,Availability,error,error,54,"// Invalid array specification.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:60,Integrability,message,message,60,"// Invalid array specification.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:110,Availability,error,error,110,"// We have a class type.; // Note: This cannot happen due to the rd->IsObject() test above.; // FIXME: Put an error message here just in case.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:116,Integrability,message,message,116,"// We have a class type.; // Note: This cannot happen due to the rd->IsObject() test above.; // FIXME: Put an error message here just in case.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:80,Testability,test,test,80,"// We have a class type.; // Note: This cannot happen due to the rd->IsObject() test above.; // FIXME: Put an error message here just in case.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1181,Availability,avail,available,1181,"n is designed to replace the internal; /// implementation of the old TTree::Branch (whose implementation; /// has been moved to BranchOld).; ///; /// NOTE: The 'Bronch' method supports only one possible calls; /// signature (where the object type has to be specified; /// explicitly and the address must be the address of a pointer).; /// For more flexibility use 'Branch'. Use Bronch only in (rare); /// cases (likely to be legacy cases) where both the new and old; /// implementation of Branch needs to be used at the same time.; ///; /// This function is far more powerful than the old Branch; /// function. It supports the full C++, including STL and has; /// the same behaviour in split or non-split mode. classname does; /// not have to derive from TObject. The function is based on; /// the new TStreamerInfo.; ///; /// Build a TBranchElement for an object of class classname.; ///; /// addr is the address of a pointer to an object of class; /// classname. The class dictionary must be available (ClassDef; /// in class header).; ///; /// Note: See the comments in TBranchElement::SetAddress() for a more; /// detailed discussion of the meaning of the addr parameter.; ///; /// This option requires access to the library where the; /// corresponding class is defined. Accessing one single data; /// member in the object implies reading the full object.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:754,Energy Efficiency,power,powerful,754,"////////////////////////////////////////////////////////////////////////////////; /// Create a new TTree BranchElement.; ///; /// ## WARNING about this new function; ///; /// This function is designed to replace the internal; /// implementation of the old TTree::Branch (whose implementation; /// has been moved to BranchOld).; ///; /// NOTE: The 'Bronch' method supports only one possible calls; /// signature (where the object type has to be specified; /// explicitly and the address must be the address of a pointer).; /// For more flexibility use 'Branch'. Use Bronch only in (rare); /// cases (likely to be legacy cases) where both the new and old; /// implementation of Branch needs to be used at the same time.; ///; /// This function is far more powerful than the old Branch; /// function. It supports the full C++, including STL and has; /// the same behaviour in split or non-split mode. classname does; /// not have to derive from TObject. The function is based on; /// the new TStreamerInfo.; ///; /// Build a TBranchElement for an object of class classname.; ///; /// addr is the address of a pointer to an object of class; /// classname. The class dictionary must be available (ClassDef; /// in class header).; ///; /// Note: See the comments in TBranchElement::SetAddress() for a more; /// detailed discussion of the meaning of the addr parameter.; ///; /// This option requires access to the library where the; /// corresponding class is defined. Accessing one single data; /// member in the object implies reading the full object.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` ",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1394,Security,access,access,1394,"where the object type has to be specified; /// explicitly and the address must be the address of a pointer).; /// For more flexibility use 'Branch'. Use Bronch only in (rare); /// cases (likely to be legacy cases) where both the new and old; /// implementation of Branch needs to be used at the same time.; ///; /// This function is far more powerful than the old Branch; /// function. It supports the full C++, including STL and has; /// the same behaviour in split or non-split mode. classname does; /// not have to derive from TObject. The function is based on; /// the new TStreamerInfo.; ///; /// Build a TBranchElement for an object of class classname.; ///; /// addr is the address of a pointer to an object of class; /// classname. The class dictionary must be available (ClassDef; /// in class header).; ///; /// Note: See the comments in TBranchElement::SetAddress() for a more; /// detailed discussion of the meaning of the addr parameter.; ///; /// This option requires access to the library where the; /// corresponding class is defined. Accessing one single data; /// member in the object implies reading the full object.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 member",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1463,Security,Access,Accessing,1463,"s of a pointer).; /// For more flexibility use 'Branch'. Use Bronch only in (rare); /// cases (likely to be legacy cases) where both the new and old; /// implementation of Branch needs to be used at the same time.; ///; /// This function is far more powerful than the old Branch; /// function. It supports the full C++, including STL and has; /// the same behaviour in split or non-split mode. classname does; /// not have to derive from TObject. The function is based on; /// the new TStreamerInfo.; ///; /// Build a TBranchElement for an object of class classname.; ///; /// addr is the address of a pointer to an object of class; /// classname. The class dictionary must be available (ClassDef; /// in class header).; ///; /// Note: See the comments in TBranchElement::SetAddress() for a more; /// detailed discussion of the meaning of the addr parameter.; ///; /// This option requires access to the library where the; /// corresponding class is defined. Accessing one single data; /// member in the object implies reading the full object.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2830,Security,access,access,2830," classname. The class dictionary must be available (ClassDef; /// in class header).; ///; /// Note: See the comments in TBranchElement::SetAddress() for a more; /// detailed discussion of the meaning of the addr parameter.; ///; /// This option requires access to the library where the; /// corresponding class is defined. Accessing one single data; /// member in the object implies reading the full object.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entries in the Tree randomly and your Tree is in split mode.; ///; /// Use splitlevel < 0 instead of splitlevel=0 when the class; /// has a custom Streamer; ///; /// Note: if the split level is set to the default (99), TTree::Branch will; /// not issue a warning if the class can not be split.",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2012,Usability,simpl,simply,2012,"/// Build a TBranchElement for an object of class classname.; ///; /// addr is the address of a pointer to an object of class; /// classname. The class dictionary must be available (ClassDef; /// in class header).; ///; /// Note: See the comments in TBranchElement::SetAddress() for a more; /// detailed discussion of the meaning of the addr parameter.; ///; /// This option requires access to the library where the; /// corresponding class is defined. Accessing one single data; /// member in the object implies reading the full object.; ///; /// By default the branch buffers are stored in the same file as the Tree.; /// use TBranch::SetFile to specify a different file; ///; /// IMPORTANT NOTE about branch names:; ///; /// And in general, in case two or more master branches contain subbranches; /// with identical names, one must add a ""."" (dot) character at the end; /// of the master branch name. This will force the name of the subbranches; /// to be of the form `master.subbranch` instead of simply `subbranch`.; /// This situation happens when the top level object; /// has two or more members referencing the same class.; /// For example, if a Tree has two branches B1 and B2 corresponding; /// to objects of the same class MyClass, one can do:; /// ~~~ {.cpp}; /// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; /// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; /// ~~~; /// if MyClass has 3 members a,b,c, the two instructions above will generate; /// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; ///; /// bufsize is the buffer size in bytes for this branch; /// The default value is 32000 bytes and should be ok for most cases.; /// You can specify a larger value (e.g. 256000) if your Tree is not split; /// and each entry is large (Megabytes); /// A small value for bufsize is optimum if you intend to access; /// the entries in the Tree randomly and your Tree is in split mode.; ///; /// Use splitlevel < 0 instead of splitlevel=0 when the class; /// has a custom Streamer; ///; ///",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:24,Availability,Error,Error,24,"//if (!collProxy) {; // Error(""Bronch"", ""%s is missing its CollectionProxy (for branch %s)"", classname, name);; //}",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:7,Safety,Avoid,Avoid,7,"//; // Avoid splitting unsplittable classes.; //",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:303,Availability,failure,failure,303,"////////////////////////////////////////////////////////////////////////////////; /// Build a Tree Index (default is TTreeIndex).; /// See a description of the parameters and functionality in; /// TTreeIndex::TTreeIndex().; ///; /// The return value is the number of entries in the Index (< 0 indicates failure).; ///; /// A TTreeIndex object pointed by fTreeIndex is created.; /// This object will be automatically deleted by the TTree destructor.; /// If an index is already existing, this is replaced by the new one without being; /// deleted. This behaviour prevents the deletion of a previously external index; /// assigned to the TTree via the TTree::SetTreeIndex() method.; /// \see also comments in TTree::SetTreeIndex().",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:217,Modifiability,variab,variable,217,"////////////////////////////////////////////////////////////////////////////////; /// Enable the TTreeCache unless explicitly disabled for this TTree by; /// a prior call to `SetCacheSize(0)`.; /// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; /// `TTreeCache.Size` has been set to zero, this call will over-ride them with; /// a value of 1.0 (i.e. use a cache size to hold 1 cluster); ///; /// Return true if there is a cache attached to the `TTree` (either pre-exisiting; /// or created as part of this call)",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:263,Modifiability,config,config,263,"////////////////////////////////////////////////////////////////////////////////; /// Enable the TTreeCache unless explicitly disabled for this TTree by; /// a prior call to `SetCacheSize(0)`.; /// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; /// `TTreeCache.Size` has been set to zero, this call will over-ride them with; /// a value of 1.0 (i.e. use a cache size to hold 1 cluster); ///; /// Return true if there is a cache attached to the `TTree` (either pre-exisiting; /// or created as part of this call)",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:382,Performance,cache,cache,382,"////////////////////////////////////////////////////////////////////////////////; /// Enable the TTreeCache unless explicitly disabled for this TTree by; /// a prior call to `SetCacheSize(0)`.; /// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; /// `TTreeCache.Size` has been set to zero, this call will over-ride them with; /// a value of 1.0 (i.e. use a cache size to hold 1 cluster); ///; /// Return true if there is a cache attached to the `TTree` (either pre-exisiting; /// or created as part of this call)",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:448,Performance,cache,cache,448,"////////////////////////////////////////////////////////////////////////////////; /// Enable the TTreeCache unless explicitly disabled for this TTree by; /// a prior call to `SetCacheSize(0)`.; /// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; /// `TTreeCache.Size` has been set to zero, this call will over-ride them with; /// a value of 1.0 (i.e. use a cache size to hold 1 cluster); ///; /// Return true if there is a cache attached to the `TTree` (either pre-exisiting; /// or created as part of this call)",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:25,Performance,cache,cache,25,"// Check for an existing cache",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:394,Availability,error,error,394,"////////////////////////////////////////////////////////////////////////////////; /// Check whether or not the address described by the last 3 parameters; /// matches the content of the branch. If a Data Model Evolution conversion; /// is involved, reset the fInfo of the branch.; /// The return values are:; //; /// - kMissingBranch (-5) : Missing branch; /// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); /// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; /// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; /// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; /// - kMatch (0) : perfect match; /// - kMatchConversion (1) : match with (I/O) conversion; /// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; /// - kMakeClass (3) : MakeClass mode so we can not check.; /// - kVoidPtr (4) : void* passed so no check was made.; /// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; /// In addition this can be multiplexed with the two bits:; /// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; /// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; /// This bits can be masked out by using kDecomposedObjMask",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1126,Availability,avail,available,1126,"////////////////////////////////////////////////////////////////////////////////; /// Check whether or not the address described by the last 3 parameters; /// matches the content of the branch. If a Data Model Evolution conversion; /// is involved, reset the fInfo of the branch.; /// The return values are:; //; /// - kMissingBranch (-5) : Missing branch; /// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); /// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; /// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; /// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; /// - kMatch (0) : perfect match; /// - kMatchConversion (1) : match with (I/O) conversion; /// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; /// - kMakeClass (3) : MakeClass mode so we can not check.; /// - kVoidPtr (4) : void* passed so no check was made.; /// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; /// In addition this can be multiplexed with the two bits:; /// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; /// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; /// This bits can be masked out by using kDecomposedObjMask",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1539,Availability,mask,masked,1539,"////////////////////////////////////////////////////////////////////////////////; /// Check whether or not the address described by the last 3 parameters; /// matches the content of the branch. If a Data Model Evolution conversion; /// is involved, reset the fInfo of the branch.; /// The return values are:; //; /// - kMissingBranch (-5) : Missing branch; /// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); /// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; /// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; /// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; /// - kMatch (0) : perfect match; /// - kMatchConversion (1) : match with (I/O) conversion; /// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; /// - kMakeClass (3) : MakeClass mode so we can not check.; /// - kVoidPtr (4) : void* passed so no check was made.; /// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; /// In addition this can be multiplexed with the two bits:; /// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; /// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; /// This bits can be masked out by using kDecomposedObjMask",MatchSource.CODE_COMMENT,tree/tree/src/TTree.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx
