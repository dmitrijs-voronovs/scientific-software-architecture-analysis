id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:3442,Availability,avail,available,3442,"_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound, e:; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in xrange(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[0][:zetaindx]; post = basisarray[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname, zHI, valueHI, verbose=True):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; if isinstance(valu",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:25033,Availability,avail,available,25033," <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:25081,Availability,avail,available,25081,"v[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correla",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:17433,Deployability,update,update,17433,"H['mrccsd'] = {; 'scf': 'SCF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsd': 'CCSD TOTAL ENERGY'}; VARH['mrccsd(t)'] = {; 'scf': 'SCF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsd': 'CCSD TOTAL ENERGY',; 'mrccsd(t)': 'CCSD(T) TOTAL ENERGY'}; VARH['mrccsdt'] = {; 'scf': 'SCF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'scf': 'SCF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scf': 'SCF TOTAL ENERGY',; 'ci%s' % (str(cilevel)): 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH['mp%s' % (str(mplevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH. VARH = return_energy_components(). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:59380,Deployability,update,updated,59380,".pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_basis'] = basis_list[1]. ptype_value, wfn = cbs(func, label, **cbs_kwargs). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:17709,Energy Efficiency,energy,energy,17709,"F TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY'}; VARH['mrccsdt(q)'] = {; 'scf': 'SCF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mrccsdt': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scf': 'SCF TOTAL ENERGY',; 'ci%s' % (str(cilevel)): 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH['mp%s' % (str(mplevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH. VARH = return_energy_components(). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the refe",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:17917,Energy Efficiency,energy,energy,17917,"': 'CCSDT TOTAL ENERGY',; 'mrccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scf': 'SCF TOTAL ENERGY',; 'ci%s' % (str(cilevel)): 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH['mp%s' % (str(mplevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH. VARH = return_energy_components(). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn key",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:18602,Energy Efficiency,energy,energy,18602,"ergy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t);",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:18751,Energy Efficiency,energy,energy,18751,"ergy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t);",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:18775,Energy Efficiency,energy,energy,18775,"ergy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t);",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:18822,Energy Efficiency,energy,energy,18822,"ergy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t);",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:19178,Energy Efficiency,energy,energy,19178,"ar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywor",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:19394,Energy Efficiency,energy,energy,19394,"l function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixe",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:19972,Energy Efficiency,energy,energy,19972,".rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates t",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20199,Energy Efficiency,energy,energy,20199,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a seco",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20237,Energy Efficiency,energy,energy,20237,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a seco",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20526,Energy Efficiency,energy,energy,20526,"lccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param de",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20566,Energy Efficiency,energy,energy,20566,"lccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param de",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20786,Energy Efficiency,energy,energy,20786,"type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20849,Energy Efficiency,energy,energy,20849,"type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20999,Energy Efficiency,energy,energy,20999,"ch case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indic",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21062,Energy Efficiency,energy,energy,21062,"ch case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indic",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21194,Energy Efficiency,energy,energy,21194,"eference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21264,Energy Efficiency,energy,energy,21264,"eference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21421,Energy Efficiency,energy,energy,21421,ng; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. I,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21491,Energy Efficiency,energy,energy,21491,ng; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. I,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21623,Energy Efficiency,energy,energy,21623,rgument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |d,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21692,Energy Efficiency,energy,energy,21692,rgument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |d,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21850,Energy Efficiency,energy,energy,21850,"a_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influe",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:21919,Energy Efficiency,energy,energy,21919,"a_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influe",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22051,Energy Efficiency,energy,energy,22051,"d. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indi",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22121,Energy Efficiency,energy,energy,22121,"d. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indi",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22279,Energy Efficiency,energy,energy,22279," string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_bas",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22349,Energy Efficiency,energy,energy,22349," string; :param delta2_wfn_lesser: |dl| ``delta_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_bas",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22481,Energy Efficiency,energy,energy,22481,". :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22550,Energy Efficiency,energy,energy,22550,". :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22708,Energy Efficiency,energy,energy,22708,"string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:22777,Energy Efficiency,energy,energy,22777,"string; :param delta3_wfn_lesser: |dl| ``delta2_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:23146,Energy Efficiency,energy,energy,23146,"ion energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates t",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:23451,Energy Efficiency,energy,energy,23451,"`'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth d",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:23696,Energy Efficiency,energy,energy,23696,"` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets empl",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:23950,Energy Efficiency,energy,energy,23950,"lation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24203,Energy Efficiency,energy,energy,24203," any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24457,Energy Efficiency,energy,energy,24457,"basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtp",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24710,Energy Efficiency,energy,energy,24710," correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapola",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:24752,Energy Efficiency,energy,energy,24752,"elta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two va",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:25287,Energy Efficiency,energy,energy,25287,"pdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. :type delta5_basis: :ref:`basis string <apdx:basisElement>`; :param delta5_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: functio",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:25710,Energy Efficiency,energy,energy,25710,"elta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:26076,Energy Efficiency,energy,energy,26076,"; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:26452,Energy Efficiency,energy,energy,26452,"c:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_s",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:26828,Energy Efficiency,energy,energy,26828, basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:27205,Energy Efficiency,energy,energy,27205,"; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name=",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:27581,Energy Efficiency,energy,energy,27581,"; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:27970,Energy Efficiency,energy,energy,27970,"pl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correcti",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28125,Energy Efficiency,energy,energy,28125,"he basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28233,Energy Efficiency,energy,energy,28233,"ker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, de",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28366,Energy Efficiency,energy,energy,28366,"scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC'",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28586,Energy Efficiency,energy,energy,28586,"c:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28749,Energy Efficiency,energy,energy,28749,"c:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29052,Energy Efficiency,energy,energy,29052,"VDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29873,Energy Efficiency,energy,energy,29873,"tion atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Esta",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29920,Energy Efficiency,energy,energy,29920,"tion atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Esta",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30057,Energy Efficiency,energy,energy,30057,"tion atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Esta",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30706,Energy Efficiency,energy,energy,30706,"l.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30980,Energy Efficiency,energy,energy,30980,"""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationErro",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31564,Energy Efficiency,energy,energy,31564,"ry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Reque",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32154,Energy Efficiency,energy,energy,32154,"s not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32758,Energy Efficiency,energy,energy,32758,"ARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # el",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33388,Energy Efficiency,energy,energy,33388," to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_less",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:34083,Energy Efficiency,energy,energy,34083,"a3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:35906,Energy Efficiency,energy,energy,35906,"if do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZET",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36190,Energy Efficiency,energy,energy,36190,"elta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; #",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36561,Energy Efficiency,energy,energy,36561,"o_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_brac",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36870,Energy Efficiency,energy,energy,36870,"correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37187,Energy Efficiency,energy,energy,37187,"n kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37500,Energy Efficiency,energy,energy,37500," list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot b",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37812,Energy Efficiency,energy,energy,37812,"lid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:38085,Energy Efficiency,energy,energy,38085,"rgs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_hel",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:38736,Energy Efficiency,energy,energy,38736,"energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:38971,Energy Efficiency,energy,energy,38971,"sis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:39213,Energy Efficiency,energy,energy,39213,"kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.pri",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:39464,Energy Efficiency,energy,energy,39464,"else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian']; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian']; GRAND_NEED = []; MODELCHEM = []; if do_scf:; NEED = _expand_scheme_orders(cbs_scf_scheme",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:39732,Energy Efficiency,energy,energy,39732,"else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian']; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian']; GRAND_NEED = []; MODELCHEM = []; if do_scf:; NEED = _expand_scheme_orders(cbs_scf_scheme",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:40000,Energy Efficiency,energy,energy,40000,"else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian']; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian']; GRAND_NEED = []; MODELCHEM = []; if do_scf:; NEED = _expand_scheme_orders(cbs_scf_scheme",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:40483,Energy Efficiency,energy,energy,40483,"eme = kwargs['delta3_scheme']; #; # # Establish treatment for delta4 correction energy; # if do_delta4:; # if len(BSTD4) == 2:; # cbs_delta4_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta4_scheme = xtpl_highest_1; # if 'delta4_scheme' in kwargs:; # cbs_delta4_scheme = kwargs['delta4_scheme']; #; # # Establish treatment for delta5 correction energy; # if do_delta5:; # if len(BSTD5) == 2:; # cbs_delta5_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta5_scheme = xtpl_highest_1; # if 'delta5_scheme' in kwargs:; # cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian']; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian']; GRAND_NEED = []; MODELCHEM = []; if do_scf:; NEED = _expand_scheme_orders(cbs_scf_scheme, BSTR, ZETR, cbs_scf_wfn, natom); GRAND_NEED.append(dict(zip(d_fields, ['scf', cbs_scf_scheme,; _contract_bracketed_basis(BSTR), cbs_scf_wfn, NEED, +1, 0.0, None, None]))). if do_corl:; NEED = _expand_scheme_orders(cbs_corl_scheme, BSTC, ZETC, cbs_corl_wfn, natom); GRAND_NEED.append(dict(zip(d_fields, ['corl', cbs_corl_scheme,; _contract_bracketed_basis(BSTC), cbs_corl_wfn, NEED, +1, 0.0, None, None]))). NEED = _expand_scheme_orders(cbs_corl_scheme, BSTC, ZETC, cbs_corl_wfn_lesser, natom); GRAND_NEED.append(dict(zip(d_fields, ['corl', cbs_corl_scheme,; _contract_bracketed_basis(BSTC), cbs_corl_wfn_lesser, NEED, -1, 0.0, None, None]))). if do_delta:; NEED = _expand_scheme_orders(cbs_delta_scheme, BSTD, ZETD, cbs_delta_wfn, natom); GRAND_NEED.append(dict(zip(d_fields, ['delta', cbs_delta_scheme,; _contract_bracketed_basis(BS",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:44445,Energy Efficiency,energy,energy,44445,"D.append(dict(zip(d_fields, ['delta4', cbs_delta4_scheme,; # reconstitute_bracketed_basis(NEED), cbs_delta4_wfn_lesser, NEED, -1, 0.0]))); #; # if do_delta5:; # NEED = call_function_in_1st_argument(cbs_delta5_scheme,; # mode='requisition', basisname=BSTD5, basiszeta=ZETD5, wfnname=cbs_delta5_wfn); # GRAND_NEED.append(dict(zip(d_fields, ['delta5', cbs_delta5_scheme,; # reconstitute_bracketed_basis(NEED), cbs_delta5_wfn, NEED, +1, 0.0]))); #; # NEED = call_function_in_1st_argument(cbs_delta5_scheme,; # mode='requisition', basisname=BSTD5, basiszeta=ZETD5, wfnname=cbs_delta5_wfn_lesser); # GRAND_NEED.append(dict(zip(d_fields, ['delta5', cbs_delta5_scheme,; # reconstitute_bracketed_basis(NEED), cbs_delta5_wfn_lesser, NEED, -1, 0.0]))). for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]. addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; instructions = ''; instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; dups += 1; if dups >= 1:; del JOBS[indx_job]. # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if (VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]) and \; (mc['f_basis'] == job['f_basis']) and not \; (mc['f_wfn'] == job['f_wfn']):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:45052,Energy Efficiency,energy,energy,45052,"bs_delta5_scheme,; # reconstitute_bracketed_basis(NEED), cbs_delta5_wfn_lesser, NEED, -1, 0.0]))). for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). # Apply chemical reasoning to choose the minimum computations to run; JOBS = MODELCHEM[:]. addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; instructions = ''; instructions += """""" Naive listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Remove duplicate modelchem portion listings; for mc in MODELCHEM:; dups = -1; for indx_job, job in enumerate(JOBS):; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; dups += 1; if dups >= 1:; del JOBS[indx_job]. # Remove chemically subsumed modelchem portion listings; if ptype == 'energy':; for mc in MODELCHEM:; for wfn in VARH[mc['f_wfn']]:; for indx_job, job in enumerate(JOBS):; if (VARH[mc['f_wfn']][wfn] == VARH[job['f_wfn']][job['f_wfn']]) and \; (mc['f_basis'] == job['f_basis']) and not \; (mc['f_wfn'] == job['f_wfn']):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(dict(zip(f_fields, [wfn, job['f_basis'], job['f_zeta'],; 0.0,; psi4.Matrix(natom, 3),; psi4.Matrix(3 * natom, 3 * natom)]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); psi4.print_out(instructions). psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(p4c",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:47184,Energy Efficiency,energy,energy,47184,"on across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; psi4.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper(), addlremark[ptype]); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; psi4.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = psi4.get_variable(VARH[wfn][wfn]). if verbose > 1:; psi4.print_variables(); psi4.clean_variables(); psi4.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']):; mce['f_energy'] = mc['f_energ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:47264,Energy Efficiency,energy,energy,47264,"s to be communicated to optimize() so reset by that optstash; psi4.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper(), addlremark[ptype]); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; psi4.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = psi4.get_variable(VARH[wfn][wfn]). if verbose > 1:; psi4.print_variables(); psi4.clean_variables(); psi4.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_rete",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:47759,Energy Efficiency,energy,energy,47759,"olecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; psi4.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']):; job['f_energy'] = psi4.get_variable(VARH[wfn][wfn]). if verbose > 1:; psi4.print_variables(); psi4.clean_variables(); psi4.clean(). # Copy data from 'run' to 'obtained' table; for mce in JOBS_EXT:; if (mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']. psioh.set_specific_retention(p4const.PSIF_SCF_MOS, False). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Results: %s ' % label)\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Insert obtained energies into the array that stores the cbs stages; for stage in GRAND_NEED:; for lvl in stage['d_need'].items():; MODELCHEM.append(lvl[1]). for job in JOBS_EXT:; # Dont ask; if (((lvl[1]['f_wfn'] == job['f_wfn']) or; ((lvl[1]['f_wfn'][3:]",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:53879,Energy Efficiency,energy,energy,53879,"gy'], GRAND_NEED[8]['d_scheme'].__name__); # if do_delta5:; # tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[10]['d_stage'], GRAND_NEED[10]['d_wfn'] + ' - ' + GRAND_NEED[11]['d_wfn'],; # '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. psi4.print_out(tables). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); psi4.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; wfn = psi4.new_wavefunction(molecule, BSTR[-1]). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. _lmh_labels = {1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']}. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszet",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:53969,Energy Efficiency,energy,energy,53969,"n'] + ' - ' + GRAND_NEED[11]['d_wfn'],; # '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. psi4.print_out(tables). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); psi4.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; wfn = psi4.new_wavefunction(molecule, BSTR[-1]). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. _lmh_labels = {1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']}. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). if int(scheme.__name__.split('_')[-1]) != Nxtpl:; raise ValidationError(""""""Call to '%s' not valid with '%s' basi",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:57978,Energy Efficiency,energy,energy,57978,"lse:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_b",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:9527,Integrability,rout,routines,9527,""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; psi4.print_out(cbsscheme). return value. elif isinstance(valueLO, (psi4.Matrix, psi4.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = psi4.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if isinstance(valueLO, float):; value = (valueHI * zHI ** 3 - valueLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (valueHI - valueLO) / (zHI ** (-3) - zLO ** (-3)). # final = valueSCF + value; final = value; if verbose:; # Output",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30901,Integrability,wrap,wrapper,30901," cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_cor",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31212,Integrability,wrap,wrapper,31212," what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True;",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31471,Integrability,wrap,wrapper,31471,"the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31789,Integrability,wrap,wrapper,31789,"_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32054,Integrability,wrap,wrapper,32054,"rl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32385,Integrability,wrap,wrapper,32385,"e ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta cor",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32656,Integrability,wrap,wrapper,32656,"].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to procee",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:32999,Integrability,wrap,wrapper,32999,"ELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33282,Integrability,wrap,wrapper,33282," in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 me",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33631,Integrability,wrap,wrapper,33631," recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method le",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33980,Integrability,wrap,wrapper,33980,"nized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:34326,Integrability,wrap,wrapper,34326,3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta an,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:34675,Integrability,wrap,wrapper,34675,wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + de,MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:46837,Integrability,depend,dependent,46837,"ations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); psi4.print_out(instructions). psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(p4const.PSIF_SCF_MOS, True); # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; psi4.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper(), addlremark[ptype]); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if ptype == 'energy':; mc['f_energy'] = response; elif ptype == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_gradient'].print_out(); elif ptype == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = psi4.get_variable('CURRENT ENERGY'); if verbose > 1:; mc['f_hessian'].print_out(); Njobs += 1; if verbose > 1:; psi4.print_out(""\nCURRENT ENERGY: %14.16f\n"" % mc['f_energy']). # Fill in energies for subsumed methods; if ptype == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in JOBS_EXT:; if (wfn == job['f_wfn']",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:56523,Integrability,wrap,wrapper,56523,"ments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are contructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; cbs = complete_basis_set. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_d",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:57268,Integrability,wrap,wrapper,57268,"; return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:58548,Integrability,wrap,wrapper,58548,".pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_basis'] = basis_list[1]. ptype_value, wfn = cbs(func, label, **cbs_kwargs). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:17942,Modifiability,variab,variables,17942,": 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH['ci%s' % (str(cilevel))] = {; 'scf': 'SCF TOTAL ENERGY',; 'ci%s' % (str(cilevel)): 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH['mp%s' % (str(mplevel))] = {; 'hf': 'HF TOTAL ENERGY',; 'mp%s' % (str(mplevel)): 'MP%s TOTAL ENERGY' % (str(mplevel))}; for mplevel2 in range(2, mplevel):; VARH['mp%s' % (str(mplevel))]['mp%s' % (str(mplevel2))] = \; 'MP%s TOTAL ENERGY' % (str(mplevel2)). # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH. VARH = return_energy_components(). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all precedi",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:58200,Modifiability,variab,variables,58200,"c, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_basis'] = basis_list[1]. ptype_value, wfn = cbs(func, label, **cbs_kwargs). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. Quick search. Enter search terms o",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20013,Performance,perform,performed,20013,".rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates t",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29577,Performance,optimiz,optimize,29577,"e (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.crea",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:29598,Performance,optimiz,optimize,29598,"e (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). # Establish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.crea",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:46312,Performance,optimiz,optimize,46312,"']) and not \; (mc['f_wfn'] == job['f_wfn']):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(dict(zip(f_fields, [wfn, job['f_basis'], job['f_zeta'],; 0.0,; psi4.Matrix(natom, 3),; psi4.Matrix(3 * natom, 3 * natom)]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); psi4.print_out(instructions). psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(p4const.PSIF_SCF_MOS, True); # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; psi4.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper(), addlremark[ptype]); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if pt",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:1557,Security,validat,validate,1557,"l be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; from __future__ import absolute_import; from __future__ import division; import re; import math; import numpy as np; import psi4; import qcdb; import p4util; import driver_util; import p4const; from p4util.exceptions import *; from procedures.interface_cfour import cfour_psivar_list. zeta_values = ['d', 't', 'q', '5', '6', '7', '8']; zeta_val2sym = {k + 2: v for k, v in zip(range(7), zeta_values)}; zeta_sym2val = {v: k for k, v in zeta_val2sym.items()}. def _expand_bracketed_basis(basisstring, molecule=None):; r""""""Function to transform and validate basis series specification; *basisstring* for cbs(). A basis set with no paired square brackets is; passed through with zeta level 0 (e.g., '6-31+G(d,p)' is returned as; [6-31+G(d,p)] and [0]). A basis set with square brackets is checked; for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4,; 5]). This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiv",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:8001,Testability,log,log,8001,""""" HI-zeta Data""""""); valueHI.print_out(); psi4.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); psi4.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); psi4.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; psi4.print_out(cbsscheme). return value. elif isinstance(v",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:9308,Testability,log,log,9308,"ame.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper(),; zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; psi4.print_out(cbsscheme). return value. elif isinstance(valueLO, (psi4.Matrix, psi4.Vector)):; valueLO = np.array(valueLO); valueMD = np.array(valueMD); valueHI = np.array(valueHI). nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = psi4.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if isinstance(va",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:27916,Usability,simpl,simple,27916,"pl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correcti",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28063,Usability,simpl,simple,28063,"he basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_cbs.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:15250,Availability,error,error,15250,"gy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; psi4.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; ret_energy = energy_body_dict[max_nbody]; else:; ret_energy = energy_body_dict[max_nbody]; ret_energy -= energy_body_dict[1]. if ptype != 'energy':; if return_total_data:; np_final_ptype = ptype_body_dict[max_nbody].copy(); else:; np_final_ptype = ptype_body_dict[max_nbody].copy(); np_final_ptype -= ptype_body_dict[1]. ret_ptype = psi4.Matrix.from_array(np_final_ptype); else:; ret_ptype = ret_energy. # Build and set a wavefunction; wfn = psi4.new_wavefunction(molecule, 'sto-3g'); wfn.nbody_energy = energies_dict; wfn.nbody_ptype = ptype_dict; wfn.nbody_body_energy = energy_body_dict; wfn.nbody_body_ptype = ptype_body_dict. if ptype == 'gradient':; wfn.set_gradient(ret_ptype); elif ptype == 'hessian':; wfn.set_hessian(ret_ptype). psi4.set_variable(""CURRENT ENERGY"", ret_energy). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. Quick search. Enter search terms or a module, class or",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:16380,Deployability,update,updated,16380,"able('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; ret_energy = energy_body_dict[max_nbody]; else:; ret_energy = energy_body_dict[max_nbody]; ret_energy -= energy_body_dict[1]. if ptype != 'energy':; if return_total_data:; np_final_ptype = ptype_body_dict[max_nbody].copy(); else:; np_final_ptype = ptype_body_dict[max_nbody].copy(); np_final_ptype -= ptype_body_dict[1]. ret_ptype = psi4.Matrix.from_array(np_final_ptype); else:; ret_ptype = ret_energy. # Build and set a wavefunction; wfn = psi4.new_wavefunction(molecule, 'sto-3g'); wfn.nbody_energy = energies_dict; wfn.nbody_ptype = ptype_dict; wfn.nbody_body_energy = energy_body_dict; wfn.nbody_body_ptype = ptype_body_dict. if ptype == 'gradient':; wfn.set_gradient(ret_ptype); elif ptype == 'hessian':; wfn.set_hessian(ret_ptype). psi4.set_variable(""CURRENT ENERGY"", ret_energy). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:3469,Energy Efficiency,energy,energy,3469,"e.end * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += hess[rel_sl1, rel_sl2]. else:; raise KeyError(""ptype can only be gradient or hessian How did you end up here?""). def _print_nbody_energy(energy_body_dict, header):; psi4.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); psi4.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = energy_body_dict.keys(); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * p4const.psi_hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * p4const.psi_hartree2kcalmol; psi4.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; psi4.print_out(""\n""). [docs]def _nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:3770,Energy Efficiency,energy,energy,3770,"ader):; psi4.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); psi4.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = energy_body_dict.keys(); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * p4const.psi_hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * p4const.psi_hartree2kcalmol; psi4.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; psi4.print_out(""\n""). [docs]def _nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:3880,Energy Efficiency,energy,energy,3880,".E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = energy_body_dict.keys(); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * p4const.psi_hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * p4const.psi_hartree2kcalmol; psi4.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; psi4.print_out(""\n""). [docs]def _nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: i",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:3967,Energy Efficiency,energy,energy,3967,"body_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * p4const.psi_hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * p4const.psi_hartree2kcalmol; psi4.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; psi4.print_out(""\n""). [docs]def _nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleu",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:5025,Energy Efficiency,energy,energy,5025,"g: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: M",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:5252,Energy Efficiency,energy,energy,5252,"lecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:5674,Energy Efficiency,energy,energy,5674,"rection to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() == 'nocp':; do_nocp = True; if (num == 0): return_method = 'nocp'; elif btype.lower() == 'vmfc':; do_vmfc = True; if (num == 0): return_method = 'vmfc'; else:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). max_nbody = kwargs.get('max_nbody', -1); max_frag = molecule.nfragments(); if max_nbody == -1:; max_nbody = molecule.nfragments(); else:; max_nbody = min(max_nbody, max_frag). # What levels do we ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:10559,Energy Efficiency,energy,energy,10559,"[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); ptype_dict[pair] = func(method_string, molecule=current_mol, **kwargs); energies_dict[pair] = psi4.get_variable(""CURRENT ENERGY""); psi4.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % ; (str(pair[0]), str(pair[1]), energies_dict[pair])); ; # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # psi4.set_global_option('DF_INTS_IO', 'LOAD'). psi4.clean(). # Final dictionaries; cp_energy_by_level = {n: 0.0 for n in nbody_range}; nocp_energy_by_level = {n: 0.0 for n in nbody_range}. cp_energy_body_dict = {n: 0.0 for n in nbody_range}; nocp_energy_body_dict = {n: 0.0 for n in nbody_range}; vmfc_energy_body_dict = {n: 0.0 for n in nbody_range}. # Build out ptype dictionaries if needed; if ptype != 'energy':; if ptype == 'gradient':; arr_shape = (molecule_total_atoms, 3); elif ptype == 'hessian':; arr_shape = (molecule_total_atoms * 3, molecule_total_atoms * 3); else:; raise KeyError(""N-Body: ptype '%s' not recognized"" % ptype). cp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = None, None; nocp_ptype_by_level, nocp_ptype_body_dict = None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:11789,Energy Efficiency,energy,energy,11789,"n nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; else:; cp_ptype_by_level, cp_ptype_body_dict = None, None; nocp_ptype_by_level, nocp_ptype_body_dict = None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1) ** (n - len(tup[0]))) * energies_dict[tup]. # Do ptype; if ptype != 'energy':; _sum_cluster_ptype_data(ptype, ptype_dict, cp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; cp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; nocp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, vmfc_level_list[n],; fragment_slice_dict, fragment_size_dict,; vmfc_ptype_by_level[n], vmfc=True). # Compute cp energy and ptype; if do_cp:; for n in nbody_range:; if n == max_frag:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Inte",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:12216,Energy Efficiency,energy,energy,12216,"None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1) ** (n - len(tup[0]))) * energies_dict[tup]. # Do ptype; if ptype != 'energy':; _sum_cluster_ptype_data(ptype, ptype_dict, cp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; cp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; nocp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, vmfc_level_list[n],; fragment_slice_dict, fragment_size_dict,; vmfc_ptype_by_level[n], vmfc=True). # Compute cp energy and ptype; if do_cp:; for n in nbody_range:; if n == max_frag:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_ener",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:12348,Energy Efficiency,energy,energy,12348,"None, None; vmfc_ptype_body_dict = None. # Sum up all of the levels; for n in nbody_range:. # Energy; cp_energy_by_level[n] = sum(energies_dict[v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(energies_dict[v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1) ** (n - len(tup[0]))) * energies_dict[tup]. # Do ptype; if ptype != 'energy':; _sum_cluster_ptype_data(ptype, ptype_dict, cp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; cp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; nocp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, vmfc_level_list[n],; fragment_slice_dict, fragment_size_dict,; vmfc_ptype_by_level[n], vmfc=True). # Compute cp energy and ptype; if do_cp:; for n in nbody_range:; if n == max_frag:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_ener",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:12604,Energy Efficiency,energy,energy,12604,"dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1) ** (n - len(tup[0]))) * energies_dict[tup]. # Do ptype; if ptype != 'energy':; _sum_cluster_ptype_data(ptype, ptype_dict, cp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; cp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict,; nocp_ptype_by_level[n]); _sum_cluster_ptype_data(ptype, ptype_dict, vmfc_level_list[n],; fragment_slice_dict, fragment_size_dict,; vmfc_ptype_by_level[n], vmfc=True). # Compute cp energy and ptype; if do_cp:; for n in nbody_range:; if n == max_frag:; cp_energy_body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if ptype != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:13200,Energy Efficiency,energy,energy,13200,"body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if ptype != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[max_nbody] - nocp_energy_body_dict[1]; psi4.set_variable('Non-Counterpoise Corrected Total Energy', nocp_energy_body_dict[max_nbody]); psi4.set_variable('Non-Counterpoise Corrected Interaction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:13338,Energy Efficiency,energy,energy,13338,"body_dict[n] = cp_energy_by_level[n]; if ptype != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if ptype != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[max_nbody] - nocp_energy_body_dict[1]; psi4.set_variable('Non-Counterpoise Corrected Total Energy', nocp_energy_body_dict[max_nbody]); psi4.set_variable('Non-Counterpoise Corrected Interaction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:13602,Energy Efficiency,energy,energy,13602,"]; cp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[max_nbody] - cp_energy_body_dict[1]; psi4.set_variable('Counterpoise Corrected Total Energy', cp_energy_body_dict[max_nbody]); psi4.set_variable('Counterpoise Corrected Interaction Energy', cp_interaction_energy). for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, cp_energy_body_dict[n] - cp_energy_body_dict[1]). # Compute nocp energy and ptype; if do_nocp:; for n in nbody_range:; if n == max_frag:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if ptype != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[max_nbody] - nocp_energy_body_dict[1]; psi4.set_variable('Non-Counterpoise Corrected Total Energy', nocp_energy_body_dict[max_nbody]); psi4.set_variable('Non-Counterpoise Corrected Interaction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; psi4.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_ener",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:14234,Energy Efficiency,energy,energy,14234,"e != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(max_frag - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if ptype != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[max_nbody] - nocp_energy_body_dict[1]; psi4.set_variable('Non-Counterpoise Corrected Total Energy', nocp_energy_body_dict[max_nbody]); psi4.set_variable('Non-Counterpoise Corrected Interaction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; psi4.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; re",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:15469,Energy Efficiency,energy,energy,15469,"able('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; ret_energy = energy_body_dict[max_nbody]; else:; ret_energy = energy_body_dict[max_nbody]; ret_energy -= energy_body_dict[1]. if ptype != 'energy':; if return_total_data:; np_final_ptype = ptype_body_dict[max_nbody].copy(); else:; np_final_ptype = ptype_body_dict[max_nbody].copy(); np_final_ptype -= ptype_body_dict[1]. ret_ptype = psi4.Matrix.from_array(np_final_ptype); else:; ret_ptype = ret_energy. # Build and set a wavefunction; wfn = psi4.new_wavefunction(molecule, 'sto-3g'); wfn.nbody_energy = energies_dict; wfn.nbody_ptype = ptype_dict; wfn.nbody_body_energy = energy_body_dict; wfn.nbody_body_ptype = ptype_body_dict. if ptype == 'gradient':; wfn.set_gradient(ret_ptype); elif ptype == 'hessian':; wfn.set_hessian(ret_ptype). psi4.set_variable(""CURRENT ENERGY"", ret_energy). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:3498,Integrability,depend,depending,3498,"e.end * 3)). for abs_sl1, rel_sl1 in zip(abs_slices, rel_slices):; for abs_sl2, rel_sl2 in zip(abs_slices, rel_slices):; ret[abs_sl1, abs_sl2] += hess[rel_sl1, rel_sl2]. else:; raise KeyError(""ptype can only be gradient or hessian How did you end up here?""). def _print_nbody_energy(energy_body_dict, header):; psi4.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); psi4.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; nbody_range = energy_body_dict.keys(); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * p4const.psi_hartree2kcalmol; int_e_kcal = (energy_body_dict[n] - energy_body_dict[1]) * p4const.psi_hartree2kcalmol; psi4.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" %; (n, energy_body_dict[n], int_e_kcal, delta_e_kcal)); previous_e = energy_body_dict[n]; psi4.print_out(""\n""). [docs]def _nbody_gufunc(func, method_string, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized univeral function for computing interaction quantities. :returns: *return type of func* |w--w| The interaction data. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| interaction data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: function; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:6841,Testability,test,testing,6841,"type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() == 'nocp':; do_nocp = True; if (num == 0): return_method = 'nocp'; elif btype.lower() == 'vmfc':; do_vmfc = True; if (num == 0): return_method = 'vmfc'; else:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). max_nbody = kwargs.get('max_nbody', -1); max_frag = molecule.nfragments(); if max_nbody == -1:; max_nbody = molecule.nfragments(); else:; max_nbody = min(max_nbody, max_frag). # What levels do we need?; nbody_range = range(1, max_nbody + 1); fragment_range = range(1, max_frag + 1). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = psi4.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # psi4.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = psi4.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = bsse_type_list[0]; if len(bsse_type_list) >1:; bsse_str = str(bsse_type_list); psi4.print_out(""\n\n""); psi4.print_out("" ===> N-Body Interaction Abacus <===\n""); psi4.print_out("" BSSE Treatment: %s\n"" % bsse_str). cp_compute_list = {x:set() for x in nbody_range}; nocp_compute_list = {x:set() for x in nbody_range}; vmfc_compute_list = {x:set() for x in nbody_range}; vmfc_level_list = {x:set() for x in nbody_range} # Need to sum something slightly different. # Build up compute sets; if do_cp:; # Everything is in dimer basis; basis_tuple = tuple(fragment_range); for nbody in nbody_range:; for x in it.combinations(fragment_range, nbody):; cp_c",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:10082,Testability,test,testing,10082,"ems():; fragment_slice_dict[k] = slice(start, start + v); start += v. molecule_total_atoms = sum(fragment_size_dict.values()). # Now compute the energies; energies_dict = {}; ptype_dict = {}; for n in compute_list.keys():; psi4.print_out(""\n ==> N-Body: Now computing %d-body complexes <==\n\n"" % n); print(""\n ==> N-Body: Now computing %d-body complexes <==\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; psi4.print_out(""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); ptype_dict[pair] = func(method_string, molecule=current_mol, **kwargs); energies_dict[pair] = psi4.get_variable(""CURRENT ENERGY""); psi4.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" % ; (str(pair[0]), str(pair[1]), energies_dict[pair])); ; # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # psi4.set_global_option('DF_INTS_IO', 'LOAD'). psi4.clean(). # Final dictionaries; cp_energy_by_level = {n: 0.0 for n in nbody_range}; nocp_energy_by_level = {n: 0.0 for n in nbody_range}. cp_energy_body_dict = {n: 0.0 for n in nbody_range}; nocp_energy_body_dict = {n: 0.0 for n in nbody_range}; vmfc_energy_body_dict = {n: 0.0 for n in nbody_range}. # Build out ptype dictionaries if needed; if ptype != 'energy':; if ptype == 'gradient':; arr_shape = (molecule_total_atoms, 3); elif ptype == 'hessian':; arr_shape = (molecule_total_atoms * 3, molecule_total_atoms * 3); else:; raise KeyError(""N-Body: ptype '%s' not recognized"" % ptype). cp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; noc",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_nbody.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:1635,Availability,avail,available,1635,"lied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; import math; import re; import psi4; import qcdb; import p4util; from p4util.exceptions import *; from procedures import *. def _method_exists(ptype, method_name):; r""""""; Quick check to see if this method exists, if it does not exist we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence crite",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:8543,Deployability,update,updated,8543," 'fullname': 'CCSDTQP-3' },; 'sdtqph-3' : { 'method': 8, 'order': 6, 'fullname': 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (name)). elif re.match(r'^[a-z]+\d+$', name):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(name); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if namestump in ['mp', 'zapt', 'ci']:; # Let mp2, mp3, mp4 pass through to select functions; if namestump == 'mp' and namelevel in [2, 3, 4]:; return name, None; # Otherwise return method and order; else:; return namestump, namelevel; else:; return name, None; else:; return name, None. [docs]def parse_cotton_irreps(irrep, point_group):; r""""""Function to return validated Cotton ordering index for molecular; *point_group* from string or integer irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. try:; return cotton[point_group.lower()][str(irrep).lower()]; except KeyError:; raise ValidationError(""""""Irrep '%s' not valid for point group '%s'."""""" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:1845,Energy Efficiency,energy,energy,1845,"icense along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; import math; import re; import psi4; import qcdb; import p4util; from p4util.exceptions import *; from procedures import *. def _method_exists(ptype, method_name):; r""""""; Quick check to see if this method exists, if it does not exist we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2179,Energy Efficiency,energy,energy,2179,"r""""""; Quick check to see if this method exists, if it does not exist we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2238,Energy Efficiency,energy,energy,2238,"we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', psc",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2950,Energy Efficiency,energy,energy,2950,"http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:3039,Energy Efficiency,energy,energy,3039,"y if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:3462,Energy Efficiency,energy,energy,3462,"ethod; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and spec",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:3965,Energy Efficiency,energy,energy,3965,"ergy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; '",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:4138,Energy Efficiency,energy,energy,4138,"et_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; 'sdtqp' : { 'method': 1, 'order': 5, 'fullname': 'CCSDTQP' },; 'sdtqph' : { 'method': 1, 'order': 6, 'fullname': 'CCSDTQPH' },; 'sd(t)' : { 'method': ",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2900,Integrability,depend,dependent,2900,"http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2957,Integrability,rout,routines,2957,"http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:4584,Safety,avoid,avoid,4584,"4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; 'sdtqp' : { 'method': 1, 'order': 5, 'fullname': 'CCSDTQP' },; 'sdtqph' : { 'method': 1, 'order': 6, 'fullname': 'CCSDTQPH' },; 'sd(t)' : { 'method': 3, 'order': -3, 'fullname': 'CCSD(T)' },; 'sdt(q)' : { 'method': 3, 'order': -4, 'fullname': 'CCSDT(Q)' },; 'sdtq(p)' : { 'method': 3, 'order': -5, 'fullname': 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method': 3, 'order': -6, 'fullname': 'CCSDTQP(H)' },; 'sd(t)_l' : { 'method': 4, 'order': -3, 'fullname': 'CCSD(T)_L' },; 'sdt(q)_l' : { 'method': 4, 'order': -4, 'fullname': 'CCSDT(Q)_L' },; 'sdtq(p)_l' : { 'method': 4, 'order': -5, 'fullname': 'CCSDTQ(P)_L' },; 'sdtqp(h)_l' : { 'method': 4, 'order': -6, 'fullname': 'CCSDTQP(H)_L",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:7411,Security,validat,validated,7411,"llname': 'CC6' },; 'sdt-3' : { 'method': 8, 'order': 3, 'fullname': 'CCSDT-3' },; 'sdtq-3' : { 'method': 8, 'order': 4, 'fullname': 'CCSDTQ-3' },; 'sdtqp-3' : { 'method': 8, 'order': 5, 'fullname': 'CCSDTQP-3' },; 'sdtqph-3' : { 'method': 8, 'order': 6, 'fullname': 'CCSDTQPH-3' }; }. # looks for 'sdt(q)' in dictionary; if ccfullname in methods:; return 'mrcc', methods[ccfullname]; else:; raise ValidationError('MRCC method \'%s\' invalid.' % (name)). elif re.match(r'^[a-z]+\d+$', name):; decompose = re.compile(r'^([a-z]+)(\d+)$').match(name); namestump = decompose.group(1); namelevel = int(decompose.group(2)). if namestump in ['mp', 'zapt', 'ci']:; # Let mp2, mp3, mp4 pass through to select functions; if namestump == 'mp' and namelevel in [2, 3, 4]:; return name, None; # Otherwise return method and order; else:; return namestump, namelevel; else:; return name, None; else:; return name, None. [docs]def parse_cotton_irreps(irrep, point_group):; r""""""Function to return validated Cotton ordering index for molecular; *point_group* from string or integer irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. try:; return cotton[point_group.lower()][str(irrep).lower()]; except KeyError:; raise ValidationError(""""""Irrep '%s' not valid for point group '%s'."""""" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. i",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2217,Testability,test,test,2217,"we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', psc",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:4590,Usability,undo,undoing,4590,"4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; 'sdtqp' : { 'method': 1, 'order': 5, 'fullname': 'CCSDTQP' },; 'sdtqph' : { 'method': 1, 'order': 6, 'fullname': 'CCSDTQPH' },; 'sd(t)' : { 'method': 3, 'order': -3, 'fullname': 'CCSD(T)' },; 'sdt(q)' : { 'method': 3, 'order': -4, 'fullname': 'CCSDT(Q)' },; 'sdtq(p)' : { 'method': 3, 'order': -5, 'fullname': 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method': 3, 'order': -6, 'fullname': 'CCSDTQP(H)' },; 'sd(t)_l' : { 'method': 4, 'order': -3, 'fullname': 'CCSD(T)_L' },; 'sdt(q)_l' : { 'method': 4, 'order': -4, 'fullname': 'CCSDT(Q)_L' },; 'sdtq(p)_l' : { 'method': 4, 'order': -5, 'fullname': 'CCSDTQ(P)_L' },; 'sdtqp(h)_l' : { 'method': 4, 'order': -6, 'fullname': 'CCSDTQP(H)_L",MatchSource.WIKI,psi4manual/1.0.0/_modules/driver_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:10907,Availability,down,down,10907," wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out(""""""\t%6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; psi4.print_out(line). psi4.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); fh.close(). fh = open(stats_filename, 'w'); fh.write(""""""\t%6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line); fh.close(). # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). return E. [docs]def ip_fitting(molecule, omega_l, omega_r, **kwargs):; kwargs = p4util.kwargs_lower(kwargs). # By default, zero the omega to 3 digits; omega_tol = kwargs.get('omega_tolerance', 1.0E-3). # By default, do up to twenty iterations; maxiter = kwargs.get('maxiter', 20). # By default, do not read ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:19260,Deployability,update,updated,19260,"= delta; repeat_r = 0; repeat_l = repeat_l + 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True; break. # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.IO.set_default_namespace(""""). psi4.print_out(""""""\n\t==> IP Fitting Results <==\n\n""""""). psi4.print_out(""""""\t => Occupation Determination <= \n\n""""""); psi4.print_out(""""""\t %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); psi4.print_out(""""""\t Neutral: %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge0, mult0, HOMO)); psi4.print_out(""""""\t Cation: %6d %6d %6d %6d %6d\n\n"""""" % (N - 1, Na1, Nb1, charge1, mult1)). psi4.print_out(""""""\t => Regula Falsi Iterations <=\n\n""""""); psi4.print_out(""""""\t%3s %11s %14s %14s %14s %s\n"""""" % ('N','Omega','IP','kIP','Delta','Type')); for k in range(len(omegas)):; psi4.print_out(""""""\t%3d %11.3E %14.6E %14.6E %14.6E %s\n"""""" % ; (k + 1, omegas[k], IPs[k], kIPs[k], IPs[k] - kIPs[k], types[k])); if converged:; psi4.print_out(""""""\n\tIP Fitting Converged\n""""""); psi4.print_out(""""""\tFinal omega = %14.6E\n"""""" % ((omega_l + omega_r) / 2)); psi4.print_out(""""""\n\t""M,I. does the dying. Fleet just does the flying.""\n""""""); psi4.print_out(""""""\t\t\t-Starship Troopers\n""""""). else:; psi4.print_out(""""""\n\tIP Fitting did not converge!\n""""""). psi4.set_global_option(""DF_INTS_IO"", ""NONE""); psi4.set_global_option(""GUESS"", old_guess). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:1570,Energy Efficiency,charge,chargep,1570,"t your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. import psi4; import os; import math; import p4util; from molutil import *; from driver import *; from p4util.exceptions import *. # Scan from +1 electron to -1 electron; [docs]def frac_traverse(molecule, **kwargs):; kwargs = p4util.kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; molecule.update_geometry(); charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. # By default, the multiplicity of the cation/anion are mult0 + 1; # These are overridden with the cation_mult and anion_mult kwargs; multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0;; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:1593,Energy Efficiency,charge,chargem,1593,"t your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. import psi4; import os; import math; import p4util; from molutil import *; from driver import *; from p4util.exceptions import *. # Scan from +1 electron to -1 electron; [docs]def frac_traverse(molecule, **kwargs):; kwargs = p4util.kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; molecule.update_geometry(); charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. # By default, the multiplicity of the cation/anion are mult0 + 1; # These are overridden with the cation_mult and anion_mult kwargs; multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0;; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:3416,Energy Efficiency,energy,energy,3416,"LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if psi4.get_global_option('REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:3579,Energy Efficiency,charge,chargem,3579," orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = False; if psi4.get_global_option('REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(LUMO) - 1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOA",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:3731,Energy Efficiency,energy,energy,3731,".get_global_option('REFERENCE') == 'UKS':; hf_guess = kwargs.get('hf_guess', True). # By default, re-guess at each N; continuous_guess = kwargs.get('continuous_guess', False). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(LUMO) - 1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:4168,Energy Efficiency,energy,energy,4168,"io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(LUMO) - 1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; psi4.set_global_option(""GUESS"", old_guess); if hf_guess:; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"", ""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"", ""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:5049,Energy Efficiency,energy,energy,5049,"cc in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(LUMO) - 1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; psi4.set_global_option(""GUESS"", old_guess); if hf_guess:; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"", ""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"", ""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_LOAD"", False). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(HOMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(HOMO) - 1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). psi4.set_global_option(""DF_INTS_IO"", old_df_ints_io",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:5441,Energy Efficiency,energy,energy,5441,"s.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; psi4.set_global_option(""GUESS"", old_guess); if hf_guess:; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"", ""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"", ""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_LOAD"", False). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(HOMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(HOMO) - 1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). psi4.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. psi4.print_out('\n\t""You trying to be a hero ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:7799,Energy Efficiency,charge,charge,7799,""""""" % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). return E. # Pull all the electrons out, one at a time; [docs]def frac_nuke(molecule, **kwargs):; kwargs = p4util.kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; molecule.update_geometry(); charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; ch",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:8396,Energy Efficiency,energy,energy,8396,"n not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); els",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:8743,Energy Efficiency,charge,charge,8743,"-= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:8812,Energy Efficiency,charge,charge,8812,"charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:8821,Energy Efficiency,charge,charge,8821,"charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0;; if ('nmax' in kwargs):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, drop the files to the molecule's name; root = kwargs.get('filename', molecule.name()); traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:9195,Energy Efficiency,energy,energy,9195,"Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn= energy('scf', return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na =",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:9726,Energy Efficiency,charge,charge,9726,"% (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n');",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:9769,Energy Efficiency,charge,charge,9769," HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out(""""""\t%6s %6s %6s %6s %6",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:10189,Energy Efficiency,charge,charge,10189,"FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out(""""""\t%6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; psi4.print_out(line). psi4.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(le",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:10258,Energy Efficiency,charge,charge,10258,"; C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out(""""""\t%6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; psi4.print_out(line). psi4.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentia",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:10267,Energy Efficiency,charge,charge,10267,"; C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); #ref = psi4.legacy_wavefunction(); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append(""""""\t%6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out(""""""\t%6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; psi4.print_out(line). psi4.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentia",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:12757,Energy Efficiency,energy,energy,12757,"its; omega_tol = kwargs.get('omega_tolerance', 1.0E-3). # By default, do up to twenty iterations; maxiter = kwargs.get('maxiter', 20). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; molecule.update_geometry(); charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; psi4.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; psi4.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = psi4.get_global_option(""GUESS""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""); psi4.print_out(""""""\n\t==> IP Fitting SCF: Burn-in <==\n""""""); E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if HOMO > 0:; Na1 = Na1 - 1;; else:; Nb1 = Nb1 - 1;. charge1 = charge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; psi4.set_global_option('DFT_OMEGA', omega_r). # Neutral; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:13641,Energy Efficiency,energy,energy,13641,"S""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""); psi4.print_out(""""""\n\t==> IP Fitting SCF: Burn-in <==\n""""""); E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if HOMO > 0:; Na1 = Na1 - 1;; else:; Nb1 = Nb1 - 1;. charge1 = charge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; psi4.set_global_option('DFT_OMEGA', omega_r). # Neutral; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IP",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:14263,Energy Efficiency,energy,energy,14263," []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; psi4.set_global_option('DFT_OMEGA', omega_r). # Neutral; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:15038,Energy Efficiency,energy,energy,15038,"""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l =",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:15603,Energy Efficiency,energy,energy,15603,"t Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; step = 0; while True:. step = step + 1. # Regula Falsi (modified); if repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, mole",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:16555,Energy Efficiency,energy,energy,16555,"t Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; step = 0; while True:. step = step + 1. # Regula Falsi (modified); if repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n"""""" % omega); E1 = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l = repeat_l + 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:17110,Energy Efficiency,energy,energy,17110," repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Omega = %11.3E <==\n"""""" % omega); E1 = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IP = E1 - E0; kIP = -E_HOMO; delta = IP - kIP. if kIP > IP:; omega_r = omega; E0r = E0; E1r = E1; IPr = IP; kIPr = kIP; delta_r = delta; repeat_r = 0; repeat_l = repeat_l + 1; else:; omega_l = omega; E0l = E0; E1l = E1; IPl = IP; kIPl = kIP; delta_l = delta; repeat_l = 0;; repeat_r = repeat_r + 1. omegas.append(omega); types.append('Regula-Falsi'); E0s.append(E0); E1s.append(E1); IPs.append(IP); kIPs.append(kIP). # Termination; if (abs(omega_l - omega_r) < omega_tol or step > maxiter):; converged = True; break. # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.IO.set_default_namespace(""""). psi4.print_out(""""""\n\t==> IP Fitting Results <==\n\n""""""). psi4.print_out(""""""\t => Occupation Determination <= \n\n""""""); psi4.print_out(""""""\t %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:14434,Integrability,message,message,14434,"lecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(char",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:14537,Integrability,message,message,14537,"lecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0;; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOr = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Right Endpoint <==\n""""""); E1r = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPr = E1r - E0r;; kIPr = -E_HOMOr;; delta_r = IPr - kIPr;. if IPr > kIPr:; message = (""""""\n***IP Fitting Error: Right Omega limit should have kIP > IP""""""); raise ValidationError(message). omegas.append(omega_r); types.append('Right Limit'); E0s.append(E0r); E1s.append(E1r); IPs.append(IPr); kIPs.append(kIPr). # Use previous orbitals from here out; psi4.set_global_option(""GUESS"", ""READ""). # Left endpoint; psi4.set_global_option('DFT_OMEGA', omega_l). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(char",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:15771,Integrability,message,message,15771,"tral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; step = 0; while True:. step = step + 1. # Regula Falsi (modified); if repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/frac.html:15873,Integrability,message,message,15873,"tral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Left Endpoint <==\n""""""); E0l, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; E_HOMO = E_b; E_HOMOl = E_HOMO; psi4.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; psi4.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); psi4.print_out(""""""\n\t==> IP Fitting SCF: Cation, Left Endpoint <==\n""""""); E1l = energy('scf', molecule=molecule, **kwargs); psi4.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; message = (""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP""""""); raise ValidationError(message). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; step = 0; while True:. step = step + 1. # Regula Falsi (modified); if repeat_l > 1:; delta_l = delta_l / 2.0; if repeat_r > 1:; delta_r = delta_r / 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; psi4.set_global_option('DFT_OMEGA', omega). # Neutral; psi4.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Omega = %11.3E <==\n"""""" % omega); E0, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO = 0.0; if Nb == 0:; E_HOMO = eps_a[int(Na - 1)]; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; E_HOMO = E_a; else:; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/frac.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:6705,Deployability,update,updated,6705,"0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:3470,Energy Efficiency,energy,energy,3470,"on in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence electrons; nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); driver.energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); driver.energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); #run_fnocc('_mp2',**kwargs); driver.energy('mp2'); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:3708,Energy Efficiency,energy,energy,3708,"REEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence electrons; nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); driver.energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); driver.energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); #run_fnocc('_mp2',**kwargs); driver.energy('mp2'); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n'",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:3953,Energy Efficiency,energy,energy,3953,"cpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); driver.energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); driver.energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); #run_fnocc('_mp2',**kwargs); driver.energy('mp2'); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_out('\n'); psi4.print_out(' QCISD(T): %20.12lf\n' % eqci); psi4.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n' % zpe); psi4.print_out('\n'); psi4.print_out(' ==> 0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:5486,Energy Efficiency,energy,energy,5486,"\n' % e_delta_g2); psi4.print_out(' E(2DF): %20.12lf\n' % e_2df); psi4.print_out(' E(+): %20.12lf\n' % e_plus); psi4.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n' % zpe); psi4.print_out('\n'); psi4.print_out(' ==> 0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:5617,Energy Efficiency,energy,energy,5617," E(G1 HLC): %20.12lf\n' % hlc1); psi4.print_out(' E(G2 HLC): %20.12lf\n' % hlc); psi4.print_out(' E(ZPE): %20.12lf\n' % zpe); psi4.print_out('\n'); psi4.print_out(' ==> 0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules   ",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:5968,Energy Efficiency,energy,energy,5968,"0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:6089,Energy Efficiency,energy,energy,6089,"0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:6416,Energy Efficiency,energy,energy,6416,"0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:6476,Energy Efficiency,energy,energy,6476,"0 Kelvin Results <==\n'); psi4.print_out('\n'); eg2_0k = eg2 + zpe + hlc; psi4.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); psi4.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); psi4.print_out(' G2: %20.12lf\n' % eg2_0k). psi4.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); psi4.set_variable(""G2 TOTAL ENERGY"",eg2_0k); psi4.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). psi4.print_out('\n'); T = psi4.get_global_option('T'); psi4.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); psi4.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. psi4.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); psi4.print_out('\n'). psi4.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2(MP2) ENTHALPY"",enthalpy); psi4.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. psi4.print_out(' G2 energy: %20.12lf\n' % internal_energy ); psi4.print_out(' G2 enthalpy: %20.12lf\n' % enthalpy); psi4.print_out(' G2 free energy: %20.12lf\n' % gibbs). psi4.set_variable(""CURRENT ENERGY"",eg2_0k). psi4.set_variable(""G2 INTERNAL ENERGY"",internal_energy); psi4.set_variable(""G2 ENTHALPY"",enthalpy); psi4.set_variable(""G2 FREE ENERGY"",gibbs). psi4.clean(). optstash.restore(). # return 0K g2 results; return eg2_0k. # aliases for g2; driver.procedures['energy']['gaussian-2'] = run_gaussian_2; driver.procedures['energy']['g2'] = run_gaussian_2. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:1815,Performance,optimiz,optimize,1815,"e the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. # Gn theory. import re; import os; import math; import warnings; import driver; import psi4; import p4util; import p4const; #from driver import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)'",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:1912,Performance,optimiz,optimize,1912," of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. # Gn theory. import re; import os; import math; import warnings; import driver; import psi4; import p4util; import p4const; #from driver import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence elect",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:2406,Performance,optimiz,optimize,2406,"SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence electrons; nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:2597,Performance,optimiz,optimize,2597,"(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence electrons; nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); driver.energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(",MatchSource.WIKI,psi4manual/1.0.0/_modules/gaussian_n.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html
https://psicode.org/psi4manual/1.0.0/_modules/index.html:150,Availability,avail,available,150,"﻿. Overview: module code — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » . All modules for which code is available; aliases; diatomic; driver; driver_cbs; driver_nbody; driver_util; frac; gaussian_n; inputparser; interactive; molutil; p4util.basislist; p4util.basislistdunning; p4util.basislistother; p4util.exceptions; p4util.inpsight; p4util.numpy_helper; p4util.optproc; p4util.procutil; p4util.text; p4util.util; procedures.functional; procedures.interface_cfour; procedures.proc; procedures.proc_util; procedures.roa; procedures.wrappers_cfour; pubchem; qcdb.basislist; qcdb.basislistdunning; qcdb.basislistother; qcdb.cfour; qcdb.dashparam; qcdb.dbproc; qcdb.dbwrap; qcdb.exceptions; qcdb.interface_dftd3; qcdb.jajo; qcdb.libmintsbasisset; qcdb.libmintsbasissetparser; qcdb.libmintscoordentry; qcdb.libmintsgshell; qcdb.libmintsmolecule; qcdb.libmintspointgrp; qcdb.modelchems; qcdb.molecule; qcdb.molpro; qcdb.molpro2; qcdb.mpl; qcdb.oldpymodules; qcdb.options; qcdb.orca; qcdb.orient; qcdb.parker; qcdb.pdict; qcdb.psi4; qcdb.psiutil; qcdb.psivardefs; qcdb.qcformat; qcdb.qchem; qcdb.subsetgenerator; qcdb.textables; qcdb.vecutil; qmmm; wrapper_autofrag; wrapper_database. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » . © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/index.html
https://psicode.org/psi4manual/1.0.0/_modules/index.html:1407,Deployability,update,updated,1407,"﻿. Overview: module code — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » . All modules for which code is available; aliases; diatomic; driver; driver_cbs; driver_nbody; driver_util; frac; gaussian_n; inputparser; interactive; molutil; p4util.basislist; p4util.basislistdunning; p4util.basislistother; p4util.exceptions; p4util.inpsight; p4util.numpy_helper; p4util.optproc; p4util.procutil; p4util.text; p4util.util; procedures.functional; procedures.interface_cfour; procedures.proc; procedures.proc_util; procedures.roa; procedures.wrappers_cfour; pubchem; qcdb.basislist; qcdb.basislistdunning; qcdb.basislistother; qcdb.cfour; qcdb.dashparam; qcdb.dbproc; qcdb.dbwrap; qcdb.exceptions; qcdb.interface_dftd3; qcdb.jajo; qcdb.libmintsbasisset; qcdb.libmintsbasissetparser; qcdb.libmintscoordentry; qcdb.libmintsgshell; qcdb.libmintsmolecule; qcdb.libmintspointgrp; qcdb.modelchems; qcdb.molecule; qcdb.molpro; qcdb.molpro2; qcdb.mpl; qcdb.oldpymodules; qcdb.options; qcdb.orca; qcdb.orient; qcdb.parker; qcdb.pdict; qcdb.psi4; qcdb.psiutil; qcdb.psivardefs; qcdb.qcformat; qcdb.qchem; qcdb.subsetgenerator; qcdb.textables; qcdb.vecutil; qmmm; wrapper_autofrag; wrapper_database. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » . © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/index.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/index.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17365,Availability,error,error,17365,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17553,Availability,error,error,17553,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17714,Availability,error,error,17714,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:26543,Deployability,update,updated,26543," ''. future_string = re.compile('^from __future__ import .*$', flags=re.MULTILINE); temp = re.sub(future_string, future_replace, temp). # imports; imports = '\n'.join(future_imports) + '\n'; imports += 'from psi4 import *\n'; imports += 'import dependency_check\n'; imports += 'from p4const import *\n'; imports += 'from p4util import *\n'; imports += 'from molutil import *\n'; imports += 'from diatomic import anharmonicity\n'; imports += 'from driver import *\n'; imports += 'from gaussian_n import *\n'; imports += 'from qmmm import *\n'; imports += 'from aliases import *\n'; imports += 'from driver_cbs import *\n'; imports += 'from wrapper_database import database, db, DB_RGT, DB_RXN\n'; imports += 'from wrapper_autofrag import auto_fragments\n'; # imports += 'from qmmm import *\n'; imports += 'psi4_io = psi4.IOManager.shared_object()\n'; imports += 'psi4.efp_init()\n' # initialize EFP object before Molecule read in. # psirc (a baby PSIthon script that might live in ~/.psi4rc); psirc = ''; homedir = os.path.expanduser('~'); psirc_file = homedir + '/.psi4rc'; if os.path.isfile(psirc_file):; fh = open(psirc_file); psirc = fh.read(); fh.close(). # Override scratch directory if user specified via env_var; scratch = ''; scratch_env = psi4.Process.environment['PSI_SCRATCH']; if len(scratch_env):; scratch += 'psi4_io.set_default_path(""%s"")\n' % (scratch_env). blank_mol = 'geometry(""""""\n'; blank_mol += '0 1\nH\nH 1 0.74\n'; blank_mol += '"""""",""blank_molecule_psi4_yo"")\n'. temp = imports + psirc + scratch + blank_mol + temp. return temp. if __name__ == ""__main__"":; result = process_input(""""""; molecule h2 {; H; H 1 R. R = .9; }. set basis 6-31G**. """"""). print(""Result\n==========================""); print(result). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:14381,Energy Efficiency,charge,charge,14381,"e:; lines2.append(line); lines = lines2. # 1. Look for units [ang|bohr|au|a.u.] defaults to ang; re_units = re.compile(r'^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*', re.IGNORECASE); units = 'ang'; lines2 = []; for line in lines:; mobj = re_units.match(line); if mobj:; unit = mobj.group(1); if unit in ['bohr', 'au', 'a.u.']:; units = 'bohr'; else:; units = 'ang'; else:; lines2.append(line); lines = lines2. # 2. Look for basis basisname, defaults to cc-pvdz; # 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit; re_basis = re.compile(r'\s*basis[\s=]+(\S+)\s*$', re.IGNORECASE); re_df_basis = re.compile(r'\s*df_basis_scf[\s=]+(\S+)\s*$', re.IGNORECASE); basis = 'cc-pvdz'; df_basis_scf = 'cc-pvdz-jkfit'; lines2 = []; for line in lines:; mobj = re_basis.match(line); if mobj:; basis = mobj.group(1); else:; mobj = re_df_basis.match(line); if mobj:; df_basis_scf = mobj.group(1); else:; lines2.append(line); lines = lines2. # 4. Look for charge lines Z x y z, convert according to unit convention; charge_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$'); lines2 = []; for line in lines:; mobj = charge_re.match(line); if mobj:; if units == 'ang':; extern += '%sqmmm.addChargeAngstrom(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2), mobj.group(3), mobj.group(4)); if units == 'bohr':; extern += '%sqmmm.addChargeBohr(%s,%s,%s,%s)\n' % (spaces, mobj.group(1), mobj.group(2), mobj.group(3), mobj.group(4)); else:; lines2.append(line); lines = lines2. # 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines; spacer_re = re.compile(r'^\s*--\s*$'); frags = []; frags.append([]); for line in lines:; mobj = spacer_re.match(line); if mobj:; if len(frags[len(frags) - 1]):; frags.append([]); else:; frags[len(frags) - 1].append(line). extern += '%sextern_mol_temp = psi4.get_active_molecule()\n' % (spaces). mol_re = re.compile(r'\s*\S+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:1735,Integrability,message,message,1735,"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; n",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:1815,Integrability,message,message,1815,"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; n",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:1910,Integrability,wrap,wrapping,1910,"tails.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # ",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2135,Integrability,message,message,2135,"rse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key,",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2212,Integrability,message,message,2212,"rse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key,",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2306,Integrability,wrap,wrap,2306,". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2419,Integrability,wrap,wrapped,2419,"lute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module ==",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2577,Integrability,wrap,wrap,2577,"rom the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; return ""%spsi4.set_global_option(\""%s\",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2808,Integrability,wrap,wraps,2808,"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; return ""%spsi4.set_global_option(\""%s\"", %s)\n"" % (spaces, key, value); else:; # It's a local option, so we need the module name in there too; return ""%spsi4.set_local_option(\""%s\"", \""%s\"", %s)\n"" % (spaces, module, key, value). [docs]def process_set_command(matchobj):; """"""Function to process match of al",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:5967,Integrability,message,message,5967,"tchobj = re.match(r'^\s*(\w+)[\s=]+(.*?)$', command); # Is the syntax correct? If so, process the line; if matchobj:; result += process_option(spaces, module, matchobj.group(1), matchobj.group(2), command); # Reset the string; command = """"; else:; bad_option_syntax(command); return result. [docs]def process_from_file_command(matchobj):; """"""Function that process a match of ``from_file`` in molecule block.""""""; string = matchobj.group(2); mol=psi4.mol_from_file(string,1); tempmol=[line for line in mol.split('\n') if line.strip() != '']; mol2=set(tempmol); mol=""""; for i in mol2:; mol+=i; mol+=""\n""; return mol. [docs]def process_pubchem_command(matchobj):; """"""Function to process match of ``pubchem`` in molecule block.""""""; string = matchobj.group(2); if re.match(r'^\s*[0-9]+\s*$', string):; # This is just a number - must be a CID; pcobj = pubchem.PubChemObj(int(string), '', ''); try:; return pcobj.getMoleculeString(); except Exception as e:; return e.message; else:; # Search pubchem for the provided string; try:; results = pubchem.getPubChemResults(string); except Exception as e:; return e.message. # N.B. Anything starting with PubchemError will be handled correctly by the molecule parser; # in libmints, which will just print the rest of the string and exit gracefully.; if not results:; # Nothing!; return ""PubchemError\n\tNo results were found when searching PubChem for %s.\n"" % (string); elif len(results) == 1:; # There's only 1 result - use it; return results[0].getMoleculeString(); else:; # There are multiple results. Print and exit; msg = ""\tPubchemError\n""; msg += ""\tMultiple pubchem results were found. Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. [docs]def process_mol",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:6109,Integrability,message,message,6109,"f matchobj:; result += process_option(spaces, module, matchobj.group(1), matchobj.group(2), command); # Reset the string; command = """"; else:; bad_option_syntax(command); return result. [docs]def process_from_file_command(matchobj):; """"""Function that process a match of ``from_file`` in molecule block.""""""; string = matchobj.group(2); mol=psi4.mol_from_file(string,1); tempmol=[line for line in mol.split('\n') if line.strip() != '']; mol2=set(tempmol); mol=""""; for i in mol2:; mol+=i; mol+=""\n""; return mol. [docs]def process_pubchem_command(matchobj):; """"""Function to process match of ``pubchem`` in molecule block.""""""; string = matchobj.group(2); if re.match(r'^\s*[0-9]+\s*$', string):; # This is just a number - must be a CID; pcobj = pubchem.PubChemObj(int(string), '', ''); try:; return pcobj.getMoleculeString(); except Exception as e:; return e.message; else:; # Search pubchem for the provided string; try:; results = pubchem.getPubChemResults(string); except Exception as e:; return e.message. # N.B. Anything starting with PubchemError will be handled correctly by the molecule parser; # in libmints, which will just print the rest of the string and exit gracefully.; if not results:; # Nothing!; return ""PubchemError\n\tNo results were found when searching PubChem for %s.\n"" % (string); elif len(results) == 1:; # There's only 1 result - use it; return results[0].getMoleculeString(); else:; # There are multiple results. Print and exit; msg = ""\tPubchemError\n""; msg += ""\tMultiple pubchem results were found. Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. [docs]def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matcho",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:11796,Integrability,message,message,11796,"= symbol_re.match(line); result += """"""%s mol.set_basis_by_symbol(""%s"", ""%s"", role=role)\n"""""" % \; (spaces, m.group('symbol'), m.group('basis')). elif label_re.match(line):; m = label_re.match(line); result += """"""%s mol.set_basis_by_label(""%s"", ""%s"", role=role)\n"""""" % \; (spaces, m.group('label'), m.group('basis')). elif all_re.match(line):; m = all_re.match(line); result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, m.group('basis')). else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if len(result.split('\n')) == 3:; # case with no [basname] markers where whole block is contents of gbs file; result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, name); result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(name), basblock[0]); else:; message = (""Conflicting basis set specification: assign lines present but shells have no [basname] label.""""""); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(basblock[idx]), basblock[idx + 1]). result += """"""%s return basstrings\n"""""" % (spaces); result += """"""%spsi4.set_global_option(\""%s\"", \""%s\"")"""""" % (spaces, basistype, name); return result. [docs]def process_pcm_command(matchobj):; """"""Function to process match of ``pcm name? { ... }``.""""""; spacing = str(matchobj.group(1)) # Ignore..; name = str(matchobj.group(2)) # Ignore..; block = str(matchobj.group(3)); fp = open('pcmsolver.inp', 'w'); fp.write(block); fp.close(); import pcm_placeholder; sys.path.append(pcm_placeholder.PCMSolver_PARSE_DIR); import pcmsolver; pcmsolver.parse_pcm_input('pcmsolver.inp'); return """" # The file has been wr",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:11933,Integrability,message,message,11933,"% \; (spaces, m.group('label'), m.group('basis')). elif all_re.match(line):; m = all_re.match(line); result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, m.group('basis')). else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if len(result.split('\n')) == 3:; # case with no [basname] markers where whole block is contents of gbs file; result += """"""%s mol.set_basis_all_atoms(""%s"", role=role)\n"""""" % \; (spaces, name); result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(name), basblock[0]); else:; message = (""Conflicting basis set specification: assign lines present but shells have no [basname] label.""""""); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; result += """"""%s basstrings['%s'] = \""\""\""\n%s\n\""\""\""\n"""""" % \; (spaces, basname(basblock[idx]), basblock[idx + 1]). result += """"""%s return basstrings\n"""""" % (spaces); result += """"""%spsi4.set_global_option(\""%s\"", \""%s\"")"""""" % (spaces, basistype, name); return result. [docs]def process_pcm_command(matchobj):; """"""Function to process match of ``pcm name? { ... }``.""""""; spacing = str(matchobj.group(1)) # Ignore..; name = str(matchobj.group(2)) # Ignore..; block = str(matchobj.group(3)); fp = open('pcmsolver.inp', 'w'); fp.write(block); fp.close(); import pcm_placeholder; sys.path.append(pcm_placeholder.PCMSolver_PARSE_DIR); import pcmsolver; pcmsolver.parse_pcm_input('pcmsolver.inp'); return """" # The file has been written to disk; nothing needed in Psi4 input. [docs]def process_external_command(matchobj):; """"""Function to process match of ``external name? { ... }``.""""""; spaces = str(matchobj.group(1)); name = str(matchobj.group(2)); if not name or name.isspace():; name = ""extern",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17347,Integrability,message,message,17347,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17417,Integrability,message,message,17417,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17535,Integrability,message,message,17535,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17624,Integrability,message,message,17624,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17696,Integrability,message,message,17696,"rn += '%spsi4.set_global_option_python(""EXTERN"", extern)\n' % (spaces). return extern. [docs]def check_parentheses_and_brackets(input_string, exit_on_error):; """"""Function to check that all parenthesis and brackets; in *input_string* are paired. On that condition, *exit_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newli",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:17784,Integrability,message,message,17784,"_on_error* =1,; otherwise 0. """"""; # This returns 1 if the string's all matched up, 0 otherwise; import collections. # create left to right parenthesis mappings; lrmap = {""("": "")"", ""["": ""]"", ""{"": ""}""}. # derive sets of left and right parentheses; lparens = set(lrmap.keys()); rparens = set(lrmap.values()). parenstack = collections.deque(); all_matched = 1; for ch in input_string:; if ch in lparens:; parenstack.append(ch); elif ch in rparens:; opench = """"; try:; opench = parenstack.pop(); except IndexError:; # Run out of opening parens; all_matched = 0; if exit_on_error:; message = (""Input error: extra %s"" % (ch)); raise TestComparisonError(message); if lrmap[opench] != ch:; # wrong type of parenthesis popped from stack; all_matched = 0; if exit_on_error:; message = (""Input error: %s closed with a %s"" % (opench, ch)); raise TestComparisonError(message); if len(parenstack) != 0:; all_matched = 0; if exit_on_error:; message = (""Input error: Unmatched %s"" % (parenstack.pop())); raise TestComparisonError(message). return all_matched. [docs]def parse_multiline_array(input_list):; """"""Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. """"""; line = input_list.pop(0); # Keep adding lines to the current one, until all parens match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - han",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:20251,Integrability,message,message,20251," expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; for line_count in range(input_start, len(input_lines)):; line = input_lines[line_count]; if re.match(stop_re, line):; input_stop = line_count; break. if input_start == -1 or input_stop == -1:; message = ('Cannot extract infile from outfile.'); raise TestComparisonError(message). raw_input = '\n'.join(input_lines[input_start:input_stop]); raw_input += '\n'. # Echo the infile on the outfile; if print_level > 0:; psi4.print_out(""\n ==> Input File <==\n\n""); psi4.print_out(""--------------------------------------------------------------------------\n""); psi4.print_out(raw_input); psi4.print_out(""--------------------------------------------------------------------------\n""); psi4.flush_outfile(). #NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:; # function [objname] { ... }; # which has the regex capture group:; #; # r'^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}', re.MULTILINE | re.DOTALL | re.IGNORECASE; #; # your function is in capture group #1; # your objname is in capture group #2; # your data is in capture group #3. # Sections that are truly to be taken literally (spaces included); # Must be stored then subbed in the end to escape the normal processi",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:20328,Integrability,message,message,20328,"replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; for line_count in range(input_start, len(input_lines)):; line = input_lines[line_count]; if re.match(stop_re, line):; input_stop = line_count; break. if input_start == -1 or input_stop == -1:; message = ('Cannot extract infile from outfile.'); raise TestComparisonError(message). raw_input = '\n'.join(input_lines[input_start:input_stop]); raw_input += '\n'. # Echo the infile on the outfile; if print_level > 0:; psi4.print_out(""\n ==> Input File <==\n\n""); psi4.print_out(""--------------------------------------------------------------------------\n""); psi4.print_out(raw_input); psi4.print_out(""--------------------------------------------------------------------------\n""); psi4.flush_outfile(). #NOTE: If adding mulitline data to the preprocessor, use ONLY the following syntax:; # function [objname] { ... }; # which has the regex capture group:; #; # r'^(\s*?)FUNCTION\s*(\w*?)\s*\{(.*?)\}', re.MULTILINE | re.DOTALL | re.IGNORECASE; #; # your function is in capture group #1; # your objname is in capture group #2; # your data is in capture group #3. # Sections that are truly to be taken literally (spaces included); # Must be stored then subbed in the end to escape the normal processing. # Process ""cfour name? { ... }""; cfour = re.compile(r'^(\s*?)",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2028,Modifiability,variab,variable,2028,"Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2162,Modifiability,variab,variable,2162,"rse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key,",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2674,Modifiability,variab,variables,2674,"rom the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; return ""%spsi4.set_global_option(\""%s\",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:2907,Modifiability,variab,variables,2907,"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val):; # This must be a number, don't wrap it in quotes; return val; elif re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % (val). [docs]def quotify(string, isbasis=False):; """"""Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When *basis*; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. """"""; # This wraps anything that looks like a string in quotes, and removes leading; # dollar signs from python variables; if isbasis:; wordre = re.compile(r'(([$]?)([-+()*.,\w\""\'/\\]+))'); else:; wordre = re.compile(r'(([$]?)([-+()*.\w\""\'/\\]+))'); string = wordre.sub(process_word_quotes, string); return string. [docs]def process_option(spaces, module, key, value, line):; """"""Function to process a line with set or in a set block; into global/local domain and keyword/value. """"""; module = module.upper(); key = key.upper(); isbasis = True if 'BASIS' in key else False; value = quotify(value.strip(), isbasis=isbasis). if module == ""GLOBALS"" or module == ""GLOBAL"" or module == """" or module.isspace():; # If it's really a global, we need slightly different syntax; return ""%spsi4.set_global_option(\""%s\"", %s)\n"" % (spaces, key, value); else:; # It's a local option, so we need the module name in there too; return ""%spsi4.set_local_option(\""%s\"", \""%s\"", %s)\n"" % (spaces, module, key, value). [docs]def process_set_command(matchobj):; """"""Function to process match of al",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:1263,Security,access,access,1263,") 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[E",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:19096,Security,validat,validate,19096," match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]def process_input(raw_input, print_level=1):; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; *raw_input* is printed to the output file unless *print_level* =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; f",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:7536,Usability,clear,clear,7536," exit; msg = ""\tPubchemError\n""; msg += ""\tMultiple pubchem results were found. Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. [docs]def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); pubchemre = re.compile(r'^(\s*pubchem\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command,geometry); molecule = spaces. molecule += 'psi4.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%spsi4.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. [docs]def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. [docs]def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(random.randint(0, 99999)); literals[literalkey] = cfourblock; return ""%spsi4.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). [docs]def process_extract_command(matchobj):; """"""Function to process match of ``extract_subsets``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); result = matchobj.g",MatchSource.WIKI,psi4manual/1.0.0/_modules/inputparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html
https://psicode.org/psi4manual/1.0.0/_modules/interactive.html:1369,Deployability,update,update,1369,"﻿. interactive — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for interactive; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import; from psi4 import *; import readline # optional, will allow Up/Down/History in the console; import code. [docs]def run():; print_out(""\nStarting interactive session.\n\n""). vars = globals().copy(); vars.update(locals()); shell = code.InteractiveConsole(vars); shell.interact(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/interactive.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/interactive.html
https://psicode.org/psi4manual/1.0.0/_modules/interactive.html:1640,Deployability,update,updated,1640,"﻿. interactive — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for interactive; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import; from psi4 import *; import readline # optional, will allow Up/Down/History in the console; import code. [docs]def run():; print_out(""\nStarting interactive session.\n\n""). vars = globals().copy(); vars.update(locals()); shell = code.InteractiveConsole(vars); shell.interact(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/interactive.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/interactive.html
https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:5312,Availability,fault,faulty,5312,"portion of the register; val = 1; for k in range(nreal - 1, rank, -1):; reals[k] = val; val = val + 1. # boundary condition is promotion into; # [nfrag+1 nfrag-1 ...]; if (reals[0] > nfrag):; break. return clusters. [docs]def new_set_attr(self, name, value):; """"""Function to redefine __setattr__ method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name); if isvar:; fxn = object.__getattribute__(self, ""set_variable""); fxn(name, value); return. object.__setattr__(self, name, value). [docs]def new_get_attr(self, name):; """"""Function to redefine __getattr__ method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name). if isvar:; fxn = object.__getattribute__(self, ""get_variable""); return fxn(name). return object.__getattribute__(self, name). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all",MatchSource.WIKI,psi4manual/1.0.0/_modules/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html
https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:8172,Deployability,update,updated,8172,"ueue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. Permitted for user use but deprecated in; driver in favor of explicit molecule-passing. """"""; molecule = psi4.Molecule.create_molecule_from_string(geom); molecule.set_name(name). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. """"""; psi4.set_active_molecule(mol). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html
https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:6614,Performance,queue,queue,6614,"; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. Permitted for user use but deprecated in; driver in favor of exp",MatchSource.WIKI,psi4manual/1.0.0/_modules/molutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:1982,Availability,error,error,1982,"e Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import print_function; """"""Queries the PubChem database using a compound name (i.e. 1,3,5-hexatriene); to obtain a molecule string that can be passed to Molecule. ::. results = getPubChemObj(""1,3,5-hexatriene""). Results is an array of results from PubChem matches to your query.; for entry in results:; entry[""CID""] => PubChem compound identifer; entry[""IUPAC""] => IUPAC name for the resulting compound; entry[""PubChemObj""] => instance of PubChemObj for this compound. entry[""PubChemObj""].getMoleculeString() => returns a string compatible; with Psi4's Molecule creation. """"""; from __future__ import absolute_import; try:; # Python 2 syntax; from urllib2 import urlopen; from urllib2 import quote; from urllib2 import URLError; except ImportError:; # Python 3 syntax; from urllib.request import urlopen; from urllib.parse import quote; from urllib.error import URLError; import xml.etree.ElementTree as ET; import time; import gzip; import re; import sys; import os; from p4util.exceptions import *. [docs]class PubChemObj(object):. def __init__(self, cid, mf, iupac):; self.url = 'http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi'; self.cid = cid; self.mf = mf; self.iupac = iupac; self.natom = 0; self.dataSDF = ''. def __str__(self):; return ""%17d %s\n"" % (self.cid, self.iupac). [docs] def getSDF(self):; """"""Function to return the SDF (structure-data file) of the PubChem object.""""""; if (len(self.dataSDF) == 0):; def extract_xml_keyval(xml, key):; """""" A useful helper function for parsing a single key from XML. """"""; try:; # Python 2.6 (ElementTree 1.2 API); matches = xml.getiterator(key); except:; # Python 2.7 (ElementTree 1.3 API); matches = list(xml.iter(key)); if len(matches) == 0:; return None; elif len(matches) == 1:; return matches[0].text; else:; print(matches); raise ValidationError(""""""PubChem: too many matches found %d"""""" % (len(matches))). ",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:3958,Availability,down,download,3958,"found %d"""""" % (len(matches))). url = ""http://pubchem.ncbi.nlm.nih.gov/pug/pug.cgi""; initial_request = """"""; <PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_download>; <PCT-Download>; <PCT-Download_uids>; <PCT-QueryUids>; <PCT-QueryUids_ids>; <PCT-ID-List>; <PCT-ID-List_db>pccompound</PCT-ID-List_db>; <PCT-ID-List_uids>; <PCT-ID-List_uids_E>%d</PCT-ID-List_uids_E>; </PCT-ID-List_uids>; </PCT-ID-List>; </PCT-QueryUids_ids>; </PCT-QueryUids>; </PCT-Download_uids>; <PCT-Download_format value=""sdf""/>; <PCT-Download_use-3d value=""true""/>; <PCT-Download_n-3d-conformers>%d</PCT-Download_n-3d-conformers>; </PCT-Download>; </PCT-InputData_download>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % (self.cid, 1). print(""\tPosting PubChem request for CID %d"" % self.cid); server_response = urlopen(url, initial_request).read(); xml = ET.fromstring(server_response); for attempt in range(4):; if attempt == 3:; raise ValidationError(""""""PubChem: timed out""""""); # Look for a download location in the XML response; download_url = extract_xml_keyval(xml, 'PCT-Download-URL_url'); if download_url:; print(""\tDownloading from PubChem...""); # We have a download location; gogetit; file_name = '_psi4_pubchem_temp_download_.tgz'; response = urlopen(download_url); data = response.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:;",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:4131,Availability,down,download,4131,"oad>; <PCT-Download_uids>; <PCT-QueryUids>; <PCT-QueryUids_ids>; <PCT-ID-List>; <PCT-ID-List_db>pccompound</PCT-ID-List_db>; <PCT-ID-List_uids>; <PCT-ID-List_uids_E>%d</PCT-ID-List_uids_E>; </PCT-ID-List_uids>; </PCT-ID-List>; </PCT-QueryUids_ids>; </PCT-QueryUids>; </PCT-Download_uids>; <PCT-Download_format value=""sdf""/>; <PCT-Download_use-3d value=""true""/>; <PCT-Download_n-3d-conformers>%d</PCT-Download_n-3d-conformers>; </PCT-Download>; </PCT-InputData_download>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % (self.cid, 1). print(""\tPosting PubChem request for CID %d"" % self.cid); server_response = urlopen(url, initial_request).read(); xml = ET.fromstring(server_response); for attempt in range(4):; if attempt == 3:; raise ValidationError(""""""PubChem: timed out""""""); # Look for a download location in the XML response; download_url = extract_xml_keyval(xml, 'PCT-Download-URL_url'); if download_url:; print(""\tDownloading from PubChem...""); # We have a download location; gogetit; file_name = '_psi4_pubchem_temp_download_.tgz'; response = urlopen(download_url); data = response.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:4491,Availability,down,download,4491,"rmat value=""sdf""/>; <PCT-Download_use-3d value=""true""/>; <PCT-Download_n-3d-conformers>%d</PCT-Download_n-3d-conformers>; </PCT-Download>; </PCT-InputData_download>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % (self.cid, 1). print(""\tPosting PubChem request for CID %d"" % self.cid); server_response = urlopen(url, initial_request).read(); xml = ET.fromstring(server_response); for attempt in range(4):; if attempt == 3:; raise ValidationError(""""""PubChem: timed out""""""); # Look for a download location in the XML response; download_url = extract_xml_keyval(xml, 'PCT-Download-URL_url'); if download_url:; print(""\tDownloading from PubChem...""); # We have a download location; gogetit; file_name = '_psi4_pubchem_temp_download_.tgz'; response = urlopen(download_url); data = response.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the Pub",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5019,Availability,avail,available,5019,"yval(xml, 'PCT-Download-URL_url'); if download_url:; print(""\tDownloading from PubChem...""); # We have a download location; gogetit; file_name = '_psi4_pubchem_temp_download_.tgz'; response = urlopen(download_url); data = response.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % ",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5291,Availability,down,download,5291,"sponse.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + N",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5351,Availability,down,download,5351,"me); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""Pubchem",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5360,Availability,error,error,5360,"me); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""Pubchem",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:6003,Availability,avail,available,6003,"int(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5105,Deployability,update,update,5105,"ownload location; gogetit; file_name = '_psi4_pubchem_temp_download_.tgz'; response = urlopen(download_url); data = response.read(); fh = open(file_name, 'wb'); fh.write(data); fh.close(); unzipped = gzip.open(file_name); self.dataSDF = unzipped.read(); unzipped.close(); try:; os.remove(file_name); except:; pass; print(""\tDone!""); break; # We didn't find a download location yet.; if attempt == 0:; # If this is the first try, take a ticket; ticket = extract_xml_keyval(xml, 'PCT-Waiting_reqid'); #print(""ticket = "" + ticket); statusrequest = """"""<PCT-Data>; <PCT-Data_input>; <PCT-InputData>; <PCT-InputData_request>; <PCT-Request>; <PCT-Request_reqid>%d</PCT-Request_reqid>; <PCT-Request_type value=""status""/>; </PCT-Request>; </PCT-InputData_request>; </PCT-InputData>; </PCT-Data_input>; </PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = """,MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:8994,Deployability,update,updated,8994,"leString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise ValidationError(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID:""; l = data.find(tag, l) + len(tag); #if l == 4:; # break; cid = int(data[l:data.find(b""\n"", l)]); l = data.find(b'\t', l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj); i += 1. print(""\tFound %d results"" % (len(ans))); return ans. if __name__ == ""__main__"":; try:; #obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); obj = getPubChemResults(""4-[bis(4-hydroxyphenyl)methyl]phenol""); except Exception as e:; print(e.message). for r in obj:; print(r); print(r.getMoleculeString()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:7231,Integrability,message,message,7231,"pile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = self.getCartesian(); except Exception as e:; raise; molstr = ""%d\n%s\n%s"" % (self.natom, self.iupac, temp); return molstr. [docs] def getMoleculeString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise ValidationError(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:8733,Integrability,message,message,8733,"leString(self):; """"""Function to obtain a molecule string through; getCartesian() or fail.; """"""; try:; return self.getCartesian(); except Exception as e:; return e.message. [docs]def getPubChemResults(name):; """"""Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. """"""; url = 'http://www.ncbi.nlm.nih.gov/sites/entrez?db=pccompound&term=%s&format=text' % quote(name); print(""\tSearching PubChem database for %s"" % (name)); try:; loc = urlopen(url); except URLError as e:; msg = ""\tPubchemError\n%s\n\treceived when trying to open\n\t%s\n"" % (str(e), url); msg += ""\tCheck your internet connection, and the above URL, and try again.\n""; raise ValidationError(msg); data = loc.read(). ans = []; l = data.find(b""<pre>""); l = data.find(b""\n"", l); i = 1; while(True):; l = data.find(str(""%d. "" % i).encode(sys.getdefaultencoding()), l); if l == -1:; break; tag = b""MF: ""; l = data.find(tag, l) + len(tag); mf = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""IUPAC name: ""; l = data.find(tag, l) + len(tag); iupac = data[l:data.find(b'\n', l)].decode(sys.getdefaultencoding()); tag = b""CID:""; l = data.find(tag, l) + len(tag); #if l == 4:; # break; cid = int(data[l:data.find(b""\n"", l)]); l = data.find(b'\t', l) + 1. pubobj = PubChemObj(cid, mf, iupac); ans.append(pubobj); i += 1. print(""\tFound %d results"" % (len(ans))); return ans. if __name__ == ""__main__"":; try:; #obj = getPubChemResults(""1-methoxy-4-[(E)-prop-1-enyl]benzene""); #obj = getPubChemResults(""sodium benzenesulfonate""); obj = getPubChemResults(""4-[bis(4-hydroxyphenyl)methyl]phenol""); except Exception as e:; print(e.message). for r in obj:; print(r); print(r.getMoleculeString()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/pubchem.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:1139,Deployability,integrat,integrate,1139,"EGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; from __future__ import absolute_import; import re; import os; import math; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:5220,Deployability,update,updated,5220,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:1152,Energy Efficiency,charge,charges,1152,"EGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; from __future__ import absolute_import; import re; import os; import math; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:1810,Energy Efficiency,charge,charges,1810,"TNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; from __future__ import absolute_import; import re; import os; import math; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYP",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:2339,Energy Efficiency,energy,energy,2339,"ecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:2869,Energy Efficiency,charge,charges,2869,"basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def ad",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:3632,Energy Efficiency,charge,charges,3632,"changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:3774,Energy Efficiency,charge,charge,3774,"psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to de",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:3905,Energy Efficiency,charge,charge,3905,"sity. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:3974,Energy Efficiency,charge,charges,3974,"elf.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.di",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4080,Energy Efficiency,charge,charge,4080,"r(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, cla",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4154,Energy Efficiency,charge,charges,4154,"itter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4437,Energy Efficiency,charge,charges,4437,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4498,Energy Efficiency,charge,charges,4498,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4518,Energy Efficiency,charge,charges,4518,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4538,Energy Efficiency,charge,charges,4538,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4558,Energy Efficiency,charge,charges,4558,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4758,Energy Efficiency,charge,charge,4758,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4823,Energy Efficiency,charge,charges,4823,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4852,Energy Efficiency,charge,charge,4852,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4867,Energy Efficiency,charge,charges,4867,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4899,Energy Efficiency,charge,charge,4899,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4910,Energy Efficiency,charge,charge,4910,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4921,Energy Efficiency,charge,charge,4921,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4932,Energy Efficiency,charge,charge,4932,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:1139,Integrability,integrat,integrate,1139,"EGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with classes to integrate MM charges into; a QM calculation. """"""; from __future__ import absolute_import; import re; import os; import math; from driver import *. [docs]class Diffuse(object):. def __init__(self, molecule, basisname, ribasisname):. self.molecule = molecule; self.basisname = basisname; self.ribasisname = ribasisname; self.basis = None; self.ribasis = None; self.da = None; self.Da = None; self.wfn = None. def __str__(self):. s = ' => Diffuse <=\n\n'; s = s + ' ' + str(self.molecule) + '\n'; s = s + ' ' + self.basisname + '\n'; s = s + ' ' + self.ribasisname + '\n'; s = s + '\n'. return s. [docs] def fitScf(self):; """"""Function to run scf and fit a system of diffuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:2836,Performance,perform,perform,2836,"basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def ad",MatchSource.WIKI,psi4manual/1.0.0/_modules/qmmm.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:4860,Deployability,update,updated,4860,"; X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < _autofragment_convert(u, symbol) + _autofragment_convert(i, symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". moleculenew = psi4.Molecule.create_molecule_from_string(new_geom); moleculenew.set_name(molname); moleculenew.update_geometry(); moleculenew.print_cluster(); psi4.print_out("""""" Exiting auto_fragments\n""""""). return moleculenew. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_autofrag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:2406,Energy Efficiency,energy,energy,2406,"012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. [docs]def auto_fragments(**kwargs):; r""""""Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. :returns: :ref:`Molecule<sec:psimod_Molecule>`) |w--w| fragmented molecule. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molname = molecule.name(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_autofrag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:2352,Usability,simpl,simple,2352,"012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. [docs]def auto_fragments(**kwargs):; r""""""Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. :returns: :ref:`Molecule<sec:psimod_Molecule>`) |w--w| fragmented molecule. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molname = molecule.name(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_autofrag.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3403,Availability,avail,available,3403,"yz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4605,Availability,avail,available,4605,"erforms a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4631,Availability,avail,availableDatabases,4631,"erforms a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4894,Availability,avail,available,4894," string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4920,Availability,avail,availableDatabases,4920," string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5782,Availability,avail,available,5782,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.;",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5807,Availability,avail,availableDatabases,5807,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.;",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5866,Availability,error,error,5866,"ther correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.;",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:6401,Availability,avail,available,6401,"boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:6977,Availability,avail,available,6977,"tom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7185,Availability,avail,available,7185,"cates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='sm",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13459,Availability,error,error,13459,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; d",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13798,Availability,avail,available,13798,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:14400,Availability,avail,available,14400,"('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = t",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:14612,Availability,avail,available,14612,"rk = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Data",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:14836,Availability,avail,available,14836,"able for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuo",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:15124,Availability,avail,available,15124,"te']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternative",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:26636,Availability,error,error,26636,"= 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %1",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:26822,Availability,error,error,26822,"ables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:26829,Availability,error,error,26829,"ables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:26988,Availability,error,error,26988,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27026,Availability,error,error,27026,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27040,Availability,error,error,27040,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27078,Availability,error,error,27078,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27097,Availability,error,error,27097,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27120,Availability,error,error,27120,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27141,Availability,error,error,27141,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:27149,Availability,error,error,27149,"; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < abs(minDerror):; minDerror = error; if abs(error) > abs(maxDerror):; maxDerror = error; MSDerror += error; MADerror += abs(error); RMSDerror += error * error; count_rxn += 1; tables += """"""\n %s\n"""""" % (table_delimit). if count_rxn:. MSDerror /= float(count_rxn); MADerror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3980,Deployability,continuous,continuous,3980,"ndicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complex",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4127,Deployability,continuous,continuous,4127," :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whet",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:11450,Deployability,continuous,continuous,11450,"ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:11517,Deployability,continuous,continuous,11517,"lculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise V",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:15695,Deployability,continuous,continuous,15695,"um':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if db_mode == 'sow':; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a si",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:15796,Deployability,continuous,continuous,15796,"um':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if db_mode == 'sow':; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a si",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:17856,Deployability,continuous,continuous,17856,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:20620,Deployability,continuous,continuous,20620," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = psi4.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); frea",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:20932,Deployability,continuous,continuous,20932," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = psi4.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); frea",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28280,Deployability,update,update,28280,"RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28317,Deployability,update,update,28317,"nt_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt')",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:30071,Deployability,update,updated,30071,"ame), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str, bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1231,Energy Efficiency,energy,energy,1231,"ge; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of r",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3096,Energy Efficiency,energy,energy,3096,"EVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3515,Energy Efficiency,energy,energy,3515," not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3671,Energy Efficiency,energy,energy,3671,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3804,Energy Efficiency,energy,energy,3804,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4832,Energy Efficiency,energy,energy,4832,"ython functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are emp",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5478,Energy Efficiency,energy,energy,5478,"rgies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5527,Energy Efficiency,energy,energy,5527,"rgies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5969,Energy Efficiency,energy,energy,5969,") only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. C",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:6077,Energy Efficiency,energy,energy,6077,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]``",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7542,Energy Efficiency,energy,energy,7542,"'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish func",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7959,Energy Efficiency,energy,energy,7959," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard an",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8036,Energy Efficiency,energy,energy,8036," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard an",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8053,Energy Efficiency,energy,energy,8053," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard an",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8207,Energy Efficiency,energy,energy,8207,"ult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadi",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8227,Energy Efficiency,energy,energy,8227,"ult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadi",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8600,Energy Efficiency,energy,energy,8600," S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if d",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:11882,Energy Efficiency,energy,energy,11882,"ll reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (d",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:12344,Energy Efficiency,energy,energy,12344," whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; r",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13920,Energy Efficiency,energy,energy,13920,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_sub",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13987,Energy Efficiency,energy,energy,13987,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_sub",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:20669,Energy Efficiency,energy,energy,20669," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = psi4.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); frea",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:20814,Energy Efficiency,energy,energy,20814," float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = psi4.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); frea",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:22304,Energy Efficiency,energy,energy,22304,"_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23752,Energy Efficiency,energy,energy,23752," ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested pro",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23834,Energy Efficiency,energy,energy,23834,"exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by t",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:25980,Energy Efficiency,energy,energy,25980,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < ab",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:4540,Integrability,wrap,wrappers,4540,"|dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-poin",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8371,Integrability,wrap,wrappers,8371,"age SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('P",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:16188,Integrability,wrap,wrapper,16188,"Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if db_mode == 'sow':; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer archite",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:17835,Integrability,wrap,wrapper,17835,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:18038,Integrability,wrap,wrapper,18038," instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:19797,Integrability,wrap,wrapper,19797,"ves = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (psi4.get_memory()); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); #chgdoptval = psi4.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; pass; #raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects resul",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:19870,Integrability,depend,dependent,19870,"CTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (psi4.get_memory()); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); #chgdoptval = psi4.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; pass; #raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:21730,Integrability,wrap,wrapper,21730,"cts results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = psi4.Molecule.create_molecule_from_string(GEOS[rgt].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.up",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1893,Modifiability,variab,variables,1893,"s.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:2832,Modifiability,variab,variable,2832," popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs``",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:6033,Modifiability,variab,variables,6033,":`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]``",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:6107,Modifiability,variab,variable,6107,"|| ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:6239,Modifiability,flexible,flexible,6239,"e computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is c",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13891,Modifiability,variab,variables,13891,"ch(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_sub",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:22582,Modifiability,variab,variable,22582,"if db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:22609,Modifiability,variab,variable,22609,"s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError(",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23889,Modifiability,variab,variable,23889,"xcept IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:24054,Modifiability,variab,variable,24054,"ace.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:24764,Modifiability,variab,variables,24764,"0.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:25022,Modifiability,variab,variable,25022,"i4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from\n""""""; tables += """""" 'Reagent' values according to weightings 'Wt', as for the REQUESTED ENERGY below.\n""""""; tables += """""" Depending on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:25987,Modifiability,variab,variable,25987,"ng on the nature of the variable, this may or may not make any physical sense.\n""""""; for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); VRXN[db_rxn] = {}. for envv in db_tabulate:; envv = envv.upper(); tables += """"""\n ==> %s <==\n\n"""""" % (envv.title()); tables += _tblhead(maxrgt, table_delimit, 2). for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8s %8s %8s %8s"""""" % (db_rxn, '', '****', '', ''); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; VRXN[db_rxn][envv] = 0.0; for i in range(len(ACTV[db_rxn])):; VRXN[db_rxn][envv] += VRGT[ACTV[db_rxn][i]][envv] * RXNM[db_rxn][ACTV[db_rxn][i]]. tables += """"""\n%23s %16.8f """""" % (db_rxn, VRXN[db_rxn][envv]); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (VRGT[ACTV[db_rxn][i]][envv], RXNM[db_rxn][ACTV[db_rxn][i]]); tables += """"""\n %s\n"""""" % (table_delimit). # tabulate primary requested energy variable with statistics; count_rxn = 0; minDerror = 100000.0; maxDerror = 0.0; MSDerror = 0.0; MADerror = 0.0; RMSDerror = 0.0. tables += """"""\n ==> %s <==\n\n"""""" % ('Requested Energy'); tables += _tblhead(maxrgt, table_delimit, 1); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn). if FAIL[rxn]:; tables += """"""\n%23s %8.4f %8s %10s %10s"""""" % (db_rxn, BIND[db_rxn], '****', '****', '****'); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). else:; ERXN[db_rxn] = 0.0; for i in range(len(ACTV[db_rxn])):; ERXN[db_rxn] += ERGT[ACTV[db_rxn][i]] * RXNM[db_rxn][ACTV[db_rxn][i]]; error = p4const.psi_hartree2kcalmol * ERXN[db_rxn] - BIND[db_rxn]. tables += """"""\n%23s %8.4f %8.4f %10.4f %10.4f"""""" % (db_rxn, BIND[db_rxn], p4const.psi_hartree2kcalmol * ERXN[db_rxn],; error, error * p4const.psi_cal2J); for i in range(len(ACTV[db_rxn])):; tables += """""" %16.8f %2.0f"""""" % (ERGT[ACTV[db_rxn][i]], RXNM[db_rxn][ACTV[db_rxn][i]]). if abs(error) < ab",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1256,Performance,optimiz,optimize,1256,"-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3534,Performance,optimiz,optimize,3534," not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3597,Performance,perform,performed,3597,"ns (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3645,Performance,perform,performs,3645,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3698,Performance,optimiz,optimize,3698,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3728,Performance,optimiz,optimization,3728,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3771,Performance,perform,performs,3771,"bedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7994,Performance,optimiz,optimize,7994," for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard an",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:9551,Performance,load,load,9551,"p('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'); user_reference = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' %",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:9713,Performance,load,load,9713,", None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'); user_reference = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:9872,Performance,load,loading,9872,"ITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'); user_reference = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:22006,Performance,load,loads,22006,"].create_psi4_string_from_molecule()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); ERGT[rgt] = func(molecule=molecule, **kwargs); psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(); #psi4.opt_clean(); psi4.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary wil",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1716,Security,access,access,1716,"t WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedde",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:2251,Security,access,accessible,2251,"SA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:2689,Security,access,access,2689," popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs``",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:16132,Security,access,accessed,16132,"Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if db_mode == 'sow':; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer archite",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:17779,Security,access,accessed,17779,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5636,Testability,benchmark,benchmark,5636," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:5662,Testability,benchmark,benchmark,5662," bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: string; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employed for the; calculation of error statistics. :type tabulate: array of strings; :param tabulate: |dl| ``[]`` |dr| || ``['scf total energy', 'natom']`` || etc. Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. :type subset: string or array of strings; :param subset:. Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See `Available Databases`_ for available values. * ``'small'`` || ``'large'`` || ``'equilibrium'``; Calls predefined subsets of the requested database, either; ``'small'``, a few of the smallest database members,; ``'large'``, the largest of the database members, or; ``'equilibrium'``, the equilibrium g",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7686,Testability,benchmark,benchmark,7686,"ilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:7750,Testability,benchmark,benchmark,7750,"ilibrium geometries for a database; composed of dissociation curves.; * ``'BzBz_S'`` || ``'FaOOFaON'`` || ``'ArNe'`` || ``'HB'`` || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive).; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13440,Testability,benchmark,benchmark,13440,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; d",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13549,Testability,benchmark,benchmark,13549,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; d",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13595,Testability,benchmark,benchmark,13595,"_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; d",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13777,Testability,benchmark,benchmark,13777,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:18133,Testability,benchmark,benchmark,18133,"le names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""psi4.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""psi4.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = '';",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28264,Usability,clear,clear,28264,"float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28301,Usability,clear,clear,28301,"rt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str +=",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28716,Usability,simpl,simple,28716,"4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = ",MatchSource.WIKI,psi4manual/1.0.0/_modules/wrapper_database.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:3687,Deployability,install,installed,3687,"tion to add basis *fit* as associated fitting basis; member *jkfit* to a BasisFamily object.; """"""; self.jkfit = sanitize_basisname(fit). [docs] def add_rifit(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *rifit* to a BasisFamily object.; """"""; self.rifit = sanitize_basisname(fit). [docs] def add_dualfit(self, fit):; """"""Function to add basis *fit* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; re",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:4105,Deployability,install,installed,4105,"ed helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jfit(name):; """"""Function to return an appropriate J fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(); ; for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; re",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:4385,Deployability,install,installed,4385,"``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jfit(name):; """"""Function to return an appropriate J fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(); ; for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jfit; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_fa",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:6486,Deployability,update,updated,6486,"ame(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jfit(name):; """"""Function to return an appropriate J fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(); ; for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jfit; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jkfit; return None. [docs]def corresponding_rifit(name):; """"""Function to return an appropriate RI fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.rifit; return None. [docs]def corresponding_dualfit(name):; """"""Function to return an appropriate DUAL helper basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:3601,Performance,load,load,3601,"tion to add basis *fit* as associated fitting basis; member *jkfit* to a BasisFamily object.; """"""; self.jkfit = sanitize_basisname(fit). [docs] def add_rifit(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *rifit* to a BasisFamily object.; """"""; self.rifit = sanitize_basisname(fit). [docs] def add_dualfit(self, fit):; """"""Function to add basis *fit* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; re",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:4301,Security,validat,validate,4301,"``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jfit(name):; """"""Function to return an appropriate J fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(); ; for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jfit; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_fa",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistdunning.html:30043,Deployability,update,updated,30043,"); basisfamily_list.append(basis_marccpcv_6pd_z); basis_febccpv6z = BasisFamily('feb-cc-pV6Z'); basisfamily_list.append(basis_febccpv6z); basis_febccpv_6pd_z = BasisFamily('feb-cc-pV(6+d)Z'); basisfamily_list.append(basis_febccpv_6pd_z); basis_febccpcv6z = BasisFamily('feb-cc-pCV6Z'); basisfamily_list.append(basis_febccpcv6z); basis_febccpcv_6pd_z = BasisFamily('feb-cc-pCV(6+d)Z'); basisfamily_list.append(basis_febccpcv_6pd_z); basis_daugccpv6z = BasisFamily('d-aug-cc-pV6Z'); basisfamily_list.append(basis_daugccpv6z); basis_daugccpcv6z = BasisFamily('d-aug-cc-pCV6Z'); basisfamily_list.append(basis_daugccpcv6z); basis_ccpv6z.add_rifit('cc-pV6Z-RI'); basis_ccpv_6pd_z.add_rifit('cc-pV6Z-RI'); basis_augccpv6z.add_rifit('aug-cc-pV6Z-RI'); basis_augccpv_6pd_z.add_rifit('aug-cc-pV6Z-RI'); basis_heavyaugccpv6z.add_rifit('heavy-aug-cc-pV6Z-RI'); basis_heavyaugccpv_6pd_z.add_rifit('heavy-aug-cc-pV6Z-RI'); basis_junccpv6z.add_rifit('jun-cc-pV6Z-RI'); basis_junccpv_6pd_z.add_rifit('jun-cc-pV6Z-RI'); basis_mayccpv6z.add_rifit('may-cc-pV6Z-RI'); basis_mayccpv_6pd_z.add_rifit('may-cc-pV6Z-RI'); basis_aprccpv6z.add_rifit('apr-cc-pV6Z-RI'); basis_aprccpv_6pd_z.add_rifit('apr-cc-pV6Z-RI'); basis_marccpv6z.add_rifit('mar-cc-pV6Z-RI'); basis_marccpv_6pd_z.add_rifit('mar-cc-pV6Z-RI'); basis_febccpv6z.add_rifit('feb-cc-pV6Z-RI'); basis_febccpv_6pd_z.add_rifit('feb-cc-pV6Z-RI'); basis_ccpvtz.add_dualfit('cc-pvtz-dual'); basis_ccpvqz.add_dualfit('cc-pvqz-dual'); basis_augccpvdz.add_dualfit('aug-cc-pvdz-dual'); basis_augccpvtz.add_dualfit('aug-cc-pvtz-dual'); basis_augccpvqz.add_dualfit('aug-cc-pvqz-dual'); basis_heavyaugccpvtz.add_dualfit('heavy-aug-cc-pvtz-dual'); basis_heavyaugccpvqz.add_dualfit('heavy-aug-cc-pvqz-dual'). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislistdunning.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistdunning.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistother.html:17901,Deployability,update,updated,17901,"t('heavy-aug-cc-pvtz-ri'). basis_6311ppg.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_d_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_d_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppgs.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppgss.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_2pd_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_2pd_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_3pd_.add_jkfit('aug-cc-pvtz-jkfit'). basis_6311ppg.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_d_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_d_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppgs.add_rifit('aug-cc-pvtz-ri'); basis_6311ppgss.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_2pd_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_2pd_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_3pd_.add_rifit('aug-cc-pvtz-ri'). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislistother.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistother.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistother.html:11065,Security,validat,validated,11065,d(basis_def2qzvpd); basisfamily_list.append(basis_def2qzvpp); basisfamily_list.append(basis_def2qzvppd). # Others; basis_dz = BasisFamily('DZ'); basis_dzp = BasisFamily('DZP'); basis_dzvp = BasisFamily('DZVP'); basis_psi3dzp = BasisFamily('psi3-DZP'); basis_psi3tz2p = BasisFamily('psi3-TZ2P'); basis_psi3tz2pf = BasisFamily('psi3-TZ2PF'); basis_sadlejlpoldl = BasisFamily('sadlej-lpol-dl'); basis_sadlejlpolds = BasisFamily('sadlej-lpol-ds'); basis_sadlejlpolfl = BasisFamily('sadlej-lpol-fl'); basis_sadlejlpolfs = BasisFamily('sadlej-lpol-fs'). basisfamily_list.append(basis_dz); basisfamily_list.append(basis_dzp); basisfamily_list.append(basis_dzvp); basisfamily_list.append(basis_psi3dzp); basisfamily_list.append(basis_psi3tz2p); basisfamily_list.append(basis_psi3tz2pf); basisfamily_list.append(basis_sadlejlpoldl); basisfamily_list.append(basis_sadlejlpolds); basisfamily_list.append(basis_sadlejlpolfl); basisfamily_list.append(basis_sadlejlpolfs). # Here lie practical (non-validated) fitting bases for; # Pople orbital basis sets. basis_sto3g.add_jkfit('cc-pvdz-ri'); basis_sto3g.add_rifit('cc-pvdz-ri'); basis_321g.add_jkfit('cc-pvdz-ri'); basis_321g.add_rifit('cc-pvdz-ri'). basis_631g.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_p_.add_jkfit('cc-pvdz-jkfit'); basis_631gs.add_jkfit('cc-pvdz-jkfit'); basis_631gss.add_jkfit('cc-pvdz-jkfit'); basis_631g.add_rifit('cc-pvdz-ri'); basis_631g_d_.add_rifit('cc-pvdz-ri'); basis_631g_d_p_.add_rifit('cc-pvdz-ri'); basis_631gs.add_rifit('cc-pvdz-ri'); basis_631gss.add_rifit('cc-pvdz-ri'). basis_631pg.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_p_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgs.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgss.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_p_.add_rifit('heavy-aug-cc-pvdz-ri'); basi,MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/basislistother.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistother.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1417,Availability,error,error,1417,"edistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1713,Availability,error,error,1713," WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXExcep",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2018,Availability,error,error,2018,", Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to Q",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2351,Availability,error,error,2351," problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2926,Availability,avail,available,2926,"lass ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:3548,Deployability,update,updated,3548,"lass ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1423,Integrability,message,message,1423,"edistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1550,Integrability,message,message,1550,"ware Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]clas",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1719,Integrability,message,message,1719," WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXExcep",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1846,Integrability,message,message,1846,"NU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:1997,Integrability,depend,dependencies,1997,"lic License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); el",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2024,Integrability,message,message,2024,", Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to Q",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2152,Integrability,message,message,2152,"ric exceptions classes.""""""; from __future__ import absolute_import; import psi4. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiExcepti",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2357,Integrability,message,message,2357," problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2485,Integrability,message,message,2485,"__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Modu",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2700,Integrability,message,message,2700,"lass ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:3119,Integrability,message,message,3119,"lass ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:3298,Integrability,message,message,3298,"lass ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html:2288,Testability,test,test,2288,"; """"""Error class for Psi.""""""; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nCSXException: %s\n\n' % (msg)). [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = msg; psi4.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/inpsight.html:20133,Deployability,update,updated,20133,"n'); fh.write('// ***********************************************\n'); fh.write('#macro check_shadow()\n'); fh.write(' #if (!Shadows)\n'); fh.write(' no_shadow \n'); fh.write(' #end\n'); fh.write('#end\n'); fh.write('\n'); fh.write('#macro translucentFinish(T)\n'); fh.write(' #local shineFactor = T;\n'); fh.write(' #if (T <= 0.25)\n'); fh.write(' #declare shineFactor = (1.0-4*T);\n'); fh.write(' #end\n'); fh.write(' #if (T > 0.25)\n'); fh.write(' #declare shineFactor = 0;\n'); fh.write(' #end\n'); fh.write(' finish {\n'); fh.write(' ambient 0.45\n'); fh.write(' diffuse 0.84\n'); fh.write(' specular 0.22\n'); fh.write(' roughness .00001\n'); fh.write(' metallic shineFactor\n'); fh.write(' phong 0.9*shineFactor\n'); fh.write(' phong_size 120*shineFactor\n'); fh.write('}#end\n'); fh.write('\n'); fh.write('#macro a(X,Y,Z,RADIUS,R,G,B,T)\n'); fh.write(' sphere{<X,Y,Z>,RADIUS\n'); fh.write(' pigment{rgbt<R,G,B,T>}\n'); fh.write(' translucentFinish(T)\n'); fh.write(' check_shadow()}\n'); fh.write('#end\n'); fh.write('\n'); fh.write('#macro b(X1,Y1,Z1,RADIUS1,X2,Y2,Z2,RADIUS2,R,G,B,T)\n'); fh.write(' cone{<X1,Y1,Z1>,RADIUS1,<X2,Y2,Z2>,RADIUS2\n'); fh.write(' pigment{rgbt<R,G,B,T>}\n'); fh.write(' translucentFinish(T)\n'); fh.write(' check_shadow()}\n'); fh.write('#end \n'). for bond in self.bonds:; fh.write('b(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)\n' % \; (str(bond[0]),str(bond[1]),str(bond[2]),str(bond[3]),\; str(bond[4]),str(bond[5]),str(bond[6]),str(bond[7]),\; str(bond[8]),str(bond[9]),str(bond[10]),str(bond[11]))); for atom in self.atoms:; fh.write('a(%s,%s,%s,%s,%s,%s,%s,%s)\n' % \; (str(atom[1]),str(atom[2]),str(atom[3]),str(atom[4]),\; str(atom[5]),str(atom[6]),str(atom[7]),str(atom[8]))). fh.close(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/inpsight.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/inpsight.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:8974,Deployability,update,updated,8974,"== '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, ret):; if d1 == 0: continue; dense_ret[start: start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, ret):; if d1 == 0: continue. dense_ret[start1: start1 + d1, start2: start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; if 0 in matrix.__array_interface__[""shape""]:; return np.empty(shape = matrix.__array_interface__[""shape""]); else:; return np.array(matrix, copy=copy). def _build_view(matrix):; """"""; Builds a view of the vector or matrix; """"""; views = to_array(matrix, copy=False, dense=False); if matrix.nirrep() > 1:; return tuple(views); else:; return views. @property; def _np_shape(self):; if not hasattr(self, '_np_view_data'):; self._np_view_data = _build_view(self). if self.nirrep() > 1:; return tuple(self._np_view_data[x].shape for x in range(self.nirrep())); else:; return self._np_view_data.shape. @property; def _np_view(self):; if not hasattr(self, '_np_view_data'):; self._np_view_data = _build_view(self). return self._np_view_data. # Matirx attributes; psi4.Matrix.from_array = array_to_matrix; psi4.Matrix.to_array = to_array; psi4.Matrix.shape = _np_shape; psi4.Matrix.np = _np_view. # Vector attributes; psi4.Vector.from_array = array_to_matrix; psi4.Vector.to_array = to_array; psi4.Vector.shape = _np_shape; psi4.Vector.np = _np_view. # Dimension attributes; psi4.Dimension.from_list = _dimension_from_list; psi4.Dimension.to_tuple = _dimension_to_tuple. # CIVector attributes. @property; def _civec_view(self):; ""Returns a view of the CIVector's buffer""; return np.asarray(self). psi4.CIVector.np = _civec_view. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:4296,Integrability,interface,interface,4296,"rand(20); >>> vector = array_to_matrix(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); >>> (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == psi4.Matrix:; sdim1 = psi4.Dimension(irreps); sdim2 = psi4.Dimension(irreps); ; for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == psi4.Vector:; sdim1 = psi4.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:4358,Integrability,interface,interface,4358,"(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); >>> (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == psi4.Matrix:; sdim1 = psi4.Dimension(irreps); sdim2 = psi4.Dimension(irreps); ; for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == psi4.Vector:; sdim1 = psi4.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; r",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:4434,Integrability,interface,interface,4434,"matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); >>> (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == psi4.Matrix:; sdim1 = psi4.Dimension(irreps); sdim2 = psi4.Dimension(irreps); ; for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == psi4.Vector:; sdim1 = psi4.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:;",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:4968,Integrability,interface,interface,4968,"d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == psi4.Vector:; sdim1 = psi4.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; r",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:5105,Integrability,interface,interface,5105,", 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for interface, vals in zip(ret.array_interfaces(), arr):; if 0 in interface.__array_interface__[""shape""]:; continue; else:; view = np.asarray(interface); view[:] = vals. return ret . # No irreps implied by list; else:; if arr_type == psi4.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a n",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:5645,Integrability,interface,interface,5645,"_Matrix: If dim1 is supplied must supply dim2 also""); ; dim1 = psi4.Dimension.from_list(dim1) ; dim2 = psi4.Dimension.from_list(dim2) . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); else:; ret.append(np.array(h, copy=copy)). # Return the list of arrays; if dense is False:; return ret; ; # Build the dense matrix; if isinstance(matrix, psi4.Vector):; ret_type = '1D'",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:5753,Integrability,interface,interface,5753,") . if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""); ; ret = self(name, dim1, dim2); ; start1 = 0; start2 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); else:; ret.append(np.array(h, copy=copy)). # Return the list of arrays; if dense is False:; return ret; ; # Build the dense matrix; if isinstance(matrix, psi4.Vector):; ret_type = '1D'; elif isinstance(matrix, psi4.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:6187,Usability,simpl,simply,6187," start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); else:; ret.append(np.array(h, copy=copy)). # Return the list of arrays; if dense is False:; return ret; ; # Build the dense matrix; if isinstance(matrix, psi4.Vector):; ret_type = '1D'; elif isinstance(matrix, psi4.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in ret:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, ret):; if d1 == 0: continue; dense_ret[start: start + d1",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/optproc.html:4519,Deployability,update,updated,4519,"as changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_local) + ')', self.value_local); text += """""" Used (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_used) + ')', self.value_used); else:; text += """""" ==> %s Option in Global Scope <==\n\n"""""" % (self.option); text += """""" Global (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_global) + ')', self.value_global); text += """"""\n""""""; return text. [docs] def restore(self):; psi4.set_global_option(self.option, self.value_global); if not self.haschanged_global:; psi4.revoke_global_option_changed(self.option); if self.module:; psi4.set_local_option(self.module, self.option, self.value_local); if not self.haschanged_local:; psi4.revoke_local_option_changed(self.module, self.option). [docs]class OptionsState(object):; """"""Class to contain multiple :py:func:`~optproc.OptionsState` objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return. ::. >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """"""; def __init__(self, *largs):; self.data = []; for item in largs:; if len(item) == 2:; self.data.append(OptionState(item[1], item[0])); elif len(item) == 1:; self.data.append(OptionState(item[0])); else:; raise ValidationError('Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s' % (item)). def __str__(self):; text = ''; for item in self.data:; text += str(item); return text. [docs] def restore(self):; for item in self.data:; item.restore(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/optproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/optproc.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:3780,Availability,avail,available,3780,"""""""; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(fileno); namespace = psio.get_default_namespace(); targetfile = filepath + 'psi' + '.' + pidspace + '.' + namespace + '.' + str(fileno); return targetfile. [docs]def format_molecule_for_input(mol, name='', forcexyz=False):; """"""Function to return a string of the output of; :py:func:`inputparser.process_input` applied to the XYZ; format of molecule, passed as either fragmented; geometry string *mol* or molecule instance *mol*.; Used to capture molecule information from database; modules and for distributed (sow/reap) input files.; For the reverse, see :py:func:`molutil.geometry`. """"""; # when mol is already a string; if isinstance(mol, basestring):; mol_string = mol; mol_name = name; # when mol is psi4.Molecule or qcdb.Molecule object; else:; # save_string_for_psi4 is the more detailed choice as it includes fragment; # (and possibly no_com/no_reorient) info. but this is only available; # for qcdb Molecules. Since save_string_xyz was added to libmints just; # for the sow/reap purpose, may want to unify these fns sometime.; # the time for unification is nigh; if forcexyz:; mol_string = mol.save_string_xyz(); else:; mol_string = mol.create_psi4_string_from_molecule(); mol_name = mol.name() if name == '' else name. commands = """"""\nmolecule %s {\n%s%s\n}\n"""""" % (mol_name, mol_string,; '\nno_com\nno_reorient' if forcexyz else ''); return commands. [docs]def format_options_for_input(molecule=None, **kwargs):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. """"""; if molecule is not None:; symmetry = molecule.find_point_group(0.00001).symbol(); commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (psi4.",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:7105,Availability,avail,available,7105," pickle.dump(kwargs, filename); filename.write('''"""""")\n'''.encode('utf-8')); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n"""""".encode('utf-8')); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*;",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:7177,Availability,avail,available,7177,"= pickle.loads(pickle_kw)\n"""""".encode('utf-8')); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminat",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:7508,Availability,avail,available,7508," for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:13678,Availability,avail,available,13678," return an input file in preprocessed psithon.; Captures memory, molecule, options, function, method, and kwargs.; Used to write distributed (sow/reap) input files. """"""; commands = """"""\n# This is a psi4 input file auto-generated from the %s() wrapper.\n\n"""""" % (inspect.stack()[1][3]); commands += """"""memory %d mb\n\n"""""" % (int(0.000001 * psi4.get_memory())); if not allButMol:; molecule = psi4.get_active_molecule(); molecule.update_geometry(); commands += format_molecule_for_input(molecule); commands += '\n'; commands += prepare_options_for_modules(changedOnly=True, commandsInsteadDict=True); commands += """"""\n%s('%s', """""" % (func.__name__, name.lower()); for key in kwargs.keys():; commands += """"""%s=%r, """""" % (key, kwargs[key]); commands += ')\n\n'. return commands. [docs]def expand_psivars(pvdefs):; """"""Dictionary *pvdefs* has keys with names of PsiVariables to be; created and values with dictionary of two keys: 'args', the; PsiVariables that contribute to the key and 'func', a function (or; lambda) to combine them. This function builds those PsiVariables if; all the contributors are available. Helpful printing is available when; PRINT > 2. """"""; verbose = psi4.get_global_option('PRINT'). for pvar, action in pvdefs.iteritems():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = psi4.get_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, basestring):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); psi4.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:13709,Availability,avail,available,13709," return an input file in preprocessed psithon.; Captures memory, molecule, options, function, method, and kwargs.; Used to write distributed (sow/reap) input files. """"""; commands = """"""\n# This is a psi4 input file auto-generated from the %s() wrapper.\n\n"""""" % (inspect.stack()[1][3]); commands += """"""memory %d mb\n\n"""""" % (int(0.000001 * psi4.get_memory())); if not allButMol:; molecule = psi4.get_active_molecule(); molecule.update_geometry(); commands += format_molecule_for_input(molecule); commands += '\n'; commands += prepare_options_for_modules(changedOnly=True, commandsInsteadDict=True); commands += """"""\n%s('%s', """""" % (func.__name__, name.lower()); for key in kwargs.keys():; commands += """"""%s=%r, """""" % (key, kwargs[key]); commands += ')\n\n'. return commands. [docs]def expand_psivars(pvdefs):; """"""Dictionary *pvdefs* has keys with names of PsiVariables to be; created and values with dictionary of two keys: 'args', the; PsiVariables that contribute to the key and 'func', a function (or; lambda) to combine them. This function builds those PsiVariables if; all the contributors are available. Helpful printing is available when; PRINT > 2. """"""; verbose = psi4.get_global_option('PRINT'). for pvar, action in pvdefs.iteritems():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = psi4.get_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, basestring):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); psi4.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:14506,Deployability,update,updated,14506," return an input file in preprocessed psithon.; Captures memory, molecule, options, function, method, and kwargs.; Used to write distributed (sow/reap) input files. """"""; commands = """"""\n# This is a psi4 input file auto-generated from the %s() wrapper.\n\n"""""" % (inspect.stack()[1][3]); commands += """"""memory %d mb\n\n"""""" % (int(0.000001 * psi4.get_memory())); if not allButMol:; molecule = psi4.get_active_molecule(); molecule.update_geometry(); commands += format_molecule_for_input(molecule); commands += '\n'; commands += prepare_options_for_modules(changedOnly=True, commandsInsteadDict=True); commands += """"""\n%s('%s', """""" % (func.__name__, name.lower()); for key in kwargs.keys():; commands += """"""%s=%r, """""" % (key, kwargs[key]); commands += ')\n\n'. return commands. [docs]def expand_psivars(pvdefs):; """"""Dictionary *pvdefs* has keys with names of PsiVariables to be; created and values with dictionary of two keys: 'args', the; PsiVariables that contribute to the key and 'func', a function (or; lambda) to combine them. This function builds those PsiVariables if; all the contributors are available. Helpful printing is available when; PRINT > 2. """"""; verbose = psi4.get_global_option('PRINT'). for pvar, action in pvdefs.iteritems():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = psi4.get_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, basestring):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); psi4.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:7786,Energy Efficiency,energy,energy,7786,"; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Abo",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:7902,Energy Efficiency,energy,energy,7902,"; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casings(attr)):; try:; getattr(module, per); except AttributeError:; pass; else:; array = getattr(module, per); break. return array. [docs]def import_ignorecase(module):; """"""Function to import *module* in any possible lettercase; permutation. Returns module object if available, None if not. """"""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Abo",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9420,Energy Efficiency,energy,energy,9420,"ept IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Need some option to get either all or changed. - Need some option to either get dict or set string or psimod command list. - command return doesn't revoke has_changed setting for unchanged with changedOnly=False. """"""; modules = [; # PSI4 Modules; ""ADC"", ""CCENERGY"", ""CCEOM"", ""CCDENSITY"", ""CCLAMBDA"", ""CCHB",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9459,Energy Efficiency,energy,energy,9459,"ept IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Need some option to get either all or changed. - Need some option to either get dict or set string or psimod command list. - command return doesn't revoke has_changed setting for unchanged with changedOnly=False. """"""; modules = [; # PSI4 Modules; ""ADC"", ""CCENERGY"", ""CCEOM"", ""CCDENSITY"", ""CCLAMBDA"", ""CCHB",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9526,Energy Efficiency,energy,energy,9526," found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Need some option to get either all or changed. - Need some option to either get dict or set string or psimod command list. - command return doesn't revoke has_changed setting for unchanged with changedOnly=False. """"""; modules = [; # PSI4 Modules; ""ADC"", ""CCENERGY"", ""CCEOM"", ""CCDENSITY"", ""CCLAMBDA"", ""CCHBAR"",; ""CCRESPONSE"", ""CCSORT"", ""CCTRIPLES"", ""CLAG"", ""CPHF"", ""CIS"",; ""DCFT"", ""DETCI"", ""DFMP2""",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:12823,Integrability,wrap,wrapper,12823,"s)\n"""""" % (module, opt, val); #if changedOnly:; # print('Appending module %s option %s value %s has_changed %s.' % \; # (module, opt, psi4.get_option(module, opt), psi4.has_option_changed(module, opt))); except RuntimeError:; pass. if commandsInsteadDict:; return commands; else:; return options. [docs]def mat2arr(mat):; """"""Function to convert psi4.Matrix *mat* to Python array of arrays.; Expects psi4.Matrix to be flat with respect to symmetry. """"""; if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]def format_currentstate_for_input(func, name, allButMol=False, **kwargs):; """"""Function to return an input file in preprocessed psithon.; Captures memory, molecule, options, function, method, and kwargs.; Used to write distributed (sow/reap) input files. """"""; commands = """"""\n# This is a psi4 input file auto-generated from the %s() wrapper.\n\n"""""" % (inspect.stack()[1][3]); commands += """"""memory %d mb\n\n"""""" % (int(0.000001 * psi4.get_memory())); if not allButMol:; molecule = psi4.get_active_molecule(); molecule.update_geometry(); commands += format_molecule_for_input(molecule); commands += '\n'; commands += prepare_options_for_modules(changedOnly=True, commandsInsteadDict=True); commands += """"""\n%s('%s', """""" % (func.__name__, name.lower()); for key in kwargs.keys():; commands += """"""%s=%r, """""" % (key, kwargs[key]); commands += ')\n\n'. return commands. [docs]def expand_psivars(pvdefs):; """"""Dictionary *pvdefs* has keys with names of PsiVariables to be; created and values with dictionary of two keys: 'args', the; PsiVariables that contribute to the key and 'func', a function (or; lambda) to combine them. This function builds those PsiVariables if; all the contributors are available. Helpful printing is available when; PRINT > 2. """"""; verbose = psi4.get_global_option('PRINT'). for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:6186,Performance,load,loads,6186,"optval); # Next four lines were conflict between master and roa branches (TDC, 10/29/2014); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, list):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''.encode('utf-8')); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''.encode('utf-8')); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n"""""".encode('utf-8')); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if n",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/procutil.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html:5421,Availability,error,error,5421,"type=1, width=35, strNotOutfile=False):; """"""Function to print *text* to output file in a banner of; minimum width *width* and minimum three-line height for; *type* = 1 or one-line height for *type* = 2. If *strNotOutfile*; is True, function returns string rather than printing it; to output file. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; if (len(line) > max_length):; max_length = len(line). max_length = max([width, max_length]). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). if strNotOutfile:; return banner; else:; psi4.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; print(stuff, file=sys.stdout). [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Function to compute the Levenshtein distance between two strings.""""""; oneago = None; thisrow = range(1, len(seq2) + 1) + [0]; for x in xrange(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in xrange(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1,options,max_distance):; """"""Function to compute approximate string matches from a list of options.""""""; matches = []; for seq2 in options:; distance = levenshtein(seq1,seq2); if distance <= max_distance:; matches.append(seq2); return matches. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyr",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html:6426,Deployability,update,updated,6426,"dth *width* and minimum three-line height for; *type* = 1 or one-line height for *type* = 2. If *strNotOutfile*; is True, function returns string rather than printing it; to output file. """"""; lines = text.split('\n'); max_length = 0; for line in lines:; if (len(line) > max_length):; max_length = len(line). max_length = max([width, max_length]). null = ''; if type == 1:; banner = ' //' + null.center(max_length, '>') + '//\n'; for line in lines:; banner += ' //' + line.center(max_length) + '//\n'; banner += ' //' + null.center(max_length, '<') + '//\n'. if type == 2:; banner = ''; for line in lines:; banner += (' ' + line + ' ').center(max_length, '='). if strNotOutfile:; return banner; else:; psi4.print_out(banner). [docs]def print_stdout(stuff):; """"""Function to print *stuff* to standard output stream.""""""; print(stuff, file=sys.stdout). [docs]def print_stderr(stuff):; """"""Function to print *stuff* to standard error stream.""""""; print(stuff, file=sys.stderr). [docs]def levenshtein(seq1, seq2):; """"""Function to compute the Levenshtein distance between two strings.""""""; oneago = None; thisrow = range(1, len(seq2) + 1) + [0]; for x in xrange(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in xrange(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]def find_approximate_string_matches(seq1,options,max_distance):; """"""Function to compute approximate string matches from a list of options.""""""; matches = []; for seq2 in options:; distance = levenshtein(seq1,seq2); if distance <= max_distance:; matches.append(seq2); return matches. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html:1380,Modifiability,flexible,flexible,1380,"ng files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import print_function; """"""Module with utility classes and functions related; to data tables and text. """"""; #CUimport psi4; import sys; import re; import p4const; from .exceptions import *. [docs]class Table(object):; """"""Class defining a flexible Table object for storing data."""""". def __init__(self, rows=(),; row_label_width=10,; row_label_precision=4,; cols=(),; width=16, precision=10):; self.row_label_width = row_label_width; self.row_label_precision = row_label_precision; self.width = width; self.precision = precision; self.rows = rows. if isinstance(cols, str):; self.cols = (cols,); else:; self.cols = cols. self.labels = []; self.data = []. [docs] def format_label(self):; """"""Function to pad the width of Table object labels.""""""; #str = lambda x: (('%%%d.%df' % (self.row_label_width, self.row_label_precision)) % x); str = lambda x: (('%%%ds' % (self.row_label_width)) % x); return "" "".join(map(str, self.labels)). [docs] def format_values(self, values):; """"""Function to pad the width of Table object data cells.""""""; str = lambda x: (('%%%d.%df' % (self.width, self.precision)) % x); return "" "".join(map(str, values)). def __getitem__(self, value):; self.labels.append(value); return self. def __setitem__(self, name, va",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/text.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:3788,Availability,failure,failure,3788,"ties(wfn); cp.compute_properties(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`uti",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4442,Availability,failure,failure,4442," pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in in",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4875,Availability,failure,failure,4875,"ed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise T",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5353,Availability,failure,failure,5353,"alue *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(),",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:7439,Availability,failure,failure,7439,"arisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), exp",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:8794,Availability,failure,failure,8794,"s):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; m",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9511,Availability,failure,failure,9511,"risonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 a",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:13123,Availability,avail,available,13123,"_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]def xml2dict(filename=None):; """"""Read XML *filename* into nested OrderedDict-s. *filename* defaults to; active CSX file. """"""; import xmltodict as xd; if filename is None:; csx = os.path.splitext(psi4.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); exc",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:14833,Deployability,update,updated,14833," getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. """"""; if 'csx4psi' in sys.modules.keys():; if psi4.get_global_option('WRITE_CSX'):; enedict = csx2endict(); compare_integers(len(enedict) >= 2, True, 'CSX harvested'); for pv, en in enedict.iteritems():; compare_values(psi4.get_variable(pv), en, 6, 'CSX ' + pv + ' ' + str(round(en, 4))). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:1701,Energy Efficiency,energy,energy,1701,"THOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with utility functions for use in input files.""""""; import sys; import os; import math; import numpy as np; from .exceptions import *. [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = psi4.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals ; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not psi4.has_global_option_changed('CUBEPROP_TASKS'):; psi4.set_global_",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:2289,Energy Efficiency,energy,energy,2289,"wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = psi4.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals ; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not psi4.has_global_option_changed('CUBEPROP_TASKS'):; psi4.set_global_option('CUBEPROP_TASKS',['ORBITALS']). cp = psi4.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [do",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:2554,Energy Efficiency,energy,energy,2554,"which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = psi4.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals ; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not psi4.has_global_option_changed('CUBEPROP_TASKS'):; psi4.set_global_option('CUBEPROP_TASKS',['ORBITALS']). cp = psi4.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.form",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:12948,Energy Efficiency,reduce,reduce,12948,"rrish/psi.12345.h2o.32 /tmp/temp; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /scratch/parrish/psi.12345.32 /tmp/temp; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]def xml2dict(filename=None):; """"""Read XML *filename* into nested OrderedDict-s. *filename* defaults to; active CSX file. """"""; import xmltodict as xd; if filename is None:; csx = os.path.splitext(psi4.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:13342,Energy Efficiency,energy,energy,13342,"p = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]def xml2dict(filename=None):; """"""Read XML *filename* into nested OrderedDict-s. *filename* defaults to; active CSX file. """"""; import xmltodict as xd; if filename is None:; csx = os.path.splitext(psi4.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:3841,Integrability,message,message,3841,"to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Perform",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4042,Integrability,message,message,4042,"i4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4078,Integrability,message,message,4078,"i4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4124,Integrability,message,message,4124,"t_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, comput",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4216,Integrability,message,message,4216," the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:fun",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4523,Integrability,message,message,4523,"+ '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4641,Integrability,message,message,4641," """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), comput",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4955,Integrability,message,message,4955,"xpected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5073,Integrability,message,message,5073,"se TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5512,Integrability,message,message,5512," = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5665,Integrability,message,message,5665,"s(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - compute",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5725,Integrability,message,message,5725,"e two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does no",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5884,Integrability,message,message,5884,"lure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check yo",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:6036,Integrability,message,message,6036,"ComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); ps",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:6212,Integrability,message,message,6212,"ints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compar",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:6295,Integrability,message,message,6295,"er of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.suc",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:6471,Integrability,message,message,6471,"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep))); raise TestComparisonError(message); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:7597,Integrability,message,message,7597,"abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:7750,Integrability,message,message,7750,"match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:7868,Integrability,message,message,7868,"ng of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:8039,Integrability,message,message,8039,"); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:8358,Integrability,message,message,8358,"xpected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to c",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:8512,Integrability,message,message,8512,"lues. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a syste",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9174,Integrability,message,message,9174,"ry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = Fals",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9286,Integrability,message,message,9286,"computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filena",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9813,Integrability,message,message,9813,"r element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scra",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9922,Integrability,message,message,9922,"omputed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. """""". pid = str(os",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9939,Integrability,message,message,9939,"omputed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. """""". pid = str(os",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:10070,Integrability,message,message,10070,"pe1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:13085,Modifiability,variab,variables,13085,"_scratch('/tmp/temp', 'psi', '', 32, True):; -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = psi4.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp';; if move:; cp = '/bin/mv';. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]def xml2dict(filename=None):; """"""Read XML *filename* into nested OrderedDict-s. *filename* defaults to; active CSX file. """"""; import xmltodict as xd; if filename is None:; csx = os.path.splitext(psi4.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); exc",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:14261,Security,validat,validate,14261," getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. """"""; if 'csx4psi' in sys.modules.keys():; if psi4.get_global_option('WRITE_CSX'):; enedict = csx2endict(); compare_integers(len(enedict) >= 2, True, 'CSX harvested'); for pv, en in enedict.iteritems():; compare_values(psi4.get_variable(pv), en, 6, 'CSX ' + pv + ' ' + str(round(en, 4))). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:3824,Testability,test,test,3824,"docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exa",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4478,Testability,test,test,4478,"format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4911,Testability,test,test,4911," to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps =",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:5449,Testability,test,test,5449,"n failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:7534,Testability,test,test,7534,".cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if(abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10 ** (-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if(failed):; print(""Check your output file for reporting of the matrices.""); psi4.print_out(""The Failed Test Matrices\n""); psi4.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); psi4.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label). [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); succ",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:8889,Testability,test,test,8889,"\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube fi",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:9547,Testability,test,test,9547,"[docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move = False):. """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_",MatchSource.WIKI,psi4manual/1.0.0/_modules/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:99670,Deployability,update,updated,99670,"t). N = len(points); rho_a = psi4.Vector(N); rho_b = psi4.Vector(N); gamma_aa = psi4.Vector(N); gamma_ab = psi4.Vector(N); gamma_bb = psi4.Vector(N); tau_a = psi4.Vector(N); tau_b = psi4.Vector(N). index = 0; for point in points:; rho_a[index] = point['rho_a']; rho_b[index] = point['rho_b']; gamma_aa[index] = point['gamma_aa']; gamma_ab[index] = point['gamma_ab']; gamma_bb[index] = point['gamma_bb']; index = index + 1. super = build_superfunctional(functional, N, 1); super.test_functional(rho_a, rho_b, gamma_aa, gamma_ab, gamma_bb, tau_a, tau_b). v = super.value('V'); v_rho_a = super.value('V_RHO_A'); v_rho_b = super.value('V_RHO_B'); v_gamma_aa = super.value('V_GAMMA_AA'); v_gamma_ab = super.value('V_GAMMA_AB'); v_gamma_bb = super.value('V_GAMMA_BB'). if not v_gamma_aa:; v_gamma_aa = tau_a; v_gamma_ab = tau_a; v_gamma_bb = tau_a. tasks = ['v', 'v_rho_a', 'v_rho_b', 'v_gamma_aa', 'v_gamma_ab', 'v_gamma_bb']; mapping = {; 'v': v,; 'v_rho_a': v_rho_a,; 'v_rho_b': v_rho_b,; 'v_gamma_aa': v_gamma_aa,; 'v_gamma_ab': v_gamma_ab,; 'v_gamma_bb': v_gamma_bb,; }. super.print_detail(3); index = 0; for point in points:; psi4.print_out('rho_a= %11.3E, rho_b= %11.3E, gamma_aa= %11.3E, gamma_ab= %11.3E, gamma_bb= %11.3E\n' % (rho_a[index], rho_b[index], gamma_aa[index], gamma_ab[index], gamma_bb[index])). for task in tasks:; v_ref = point[task]; v_obs = mapping[task][index]; delta = v_obs - v_ref; if (v_ref == 0.0):; epsilon = 0.0; else:; epsilon = abs(delta / v_ref); if (epsilon < 1.0E-11):; passed = 'PASSED'; else:; passed = 'FAILED'; check = False. psi4.print_out('\t%-15s %24.16E %24.16E %24.16E %24.16E %6s\n' % (task, v_ref, v_obs, delta, epsilon, passed)). index = index + 1. psi4.print_out('\n'); return check. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:21276,Energy Efficiency,allocate,allocate,21276,"x_functional,; }. [docs]def build_functional(alias):; name = alias.lower(); return functionals[name](name). [docs]def functional_list():; val = []; for key in functionals.keys():; val.append(functionals[key](key)); return val. ## ==> SuperFunctionals <== ##. [docs]def build_ws_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wS_X'); # Tab in, trailing newlines; sup.set_description(' Slater Short-Range LSDA Exchange\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_X'); # Tab in, trailing newlines; sup.set_description(' PBE Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoin",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:22119,Energy Efficiency,allocate,allocate,22119,"; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_X'); # Tab in, trailing newlines; sup.set_description(' PBE Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol_X'); # Tab in, trailing newlines; sup.set_description(' PBEsol Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpw92_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_po",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:22974,Energy Efficiency,allocate,allocate,22974,"omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol_X'); # Tab in, trailing newlines; sup.set_description(' PBEsol Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpw92_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPW92_C'); # Tab in, trailing newlines; sup.set_description(' Short-Range PW92 Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPW92_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.3); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:23693,Energy Efficiency,allocate,allocate,23693,"9)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpw92_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPW92_C'); # Tab in, trailing newlines; sup.set_description(' Short-Range PW92 Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPW92_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.3); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_C'); # Tab in, trailing newlines; sup.set_description(' Short-Range PBE Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE2",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:24408,Energy Efficiency,allocate,allocate,24408,"n(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPW92_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.3); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_c_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_C'); # Tab in, trailing newlines; sup.set_description(' Short-Range PBE Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE2'); # Tab in, trailing newlines; sup.set_description(' Double-Hybrid PBE LRC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and a",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:25165,Energy Efficiency,allocate,allocate,25165,"up.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE2'); # Tab in, trailing newlines; sup.set_description(' Double-Hybrid PBE LRC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' TODO\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('wPBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB88_X'); # Tab in, trailing newlines; sup.set_description(' B88 Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:26008,Energy Efficiency,allocate,allocate,26008,"; sup.set_x_omega(0.3); sup.set_c_omega(0.5); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb88_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB88_X'); # Tab in, trailing newlines; sup.set_description(' B88 Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SVWN'); # Tab in, trailing newlines; sup.set_description(' SVWN3 (RPA) LSDA Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('S_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customizat",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:26809,Energy Efficiency,allocate,allocate,26809,"')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_svwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SVWN'); # Tab in, trailing newlines; sup.set_description(' SVWN3 (RPA) LSDA Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('S_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.b",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:27689,Energy Efficiency,allocate,allocate,27689,"ga(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # =",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:28507,Energy Efficiency,allocate,allocate,28507," after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:29268,Energy Efficiency,allocate,allocate,29268,"dd_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('FT97'); # Tab in, trailing newlines; sup.set_description(' FT97 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' M. Filatov and W. Theil, Int. J. Quant. Chem., 62, 603-616, 1997\n'). # Add member functionals; sup.add_x_functional(build_functional('FT97B_X')); sup.add_c_functional(build_functional('FT97_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv)",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:30092,Energy Efficiency,allocate,allocate,30092," adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('FT97'); # Tab in, trailing newlines; sup.set_description(' FT97 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' M. Filatov and W. Theil, Int. J. Quant. Chem., 62, 603-616, 1997\n'). # Add member functionals; sup.add_x_functional(build_functional('FT97B_X')); sup.add_c_functional(build_functional('FT97_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybrid ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:30908,Energy Efficiency,allocate,allocate,30908,"up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE'); # Tab in, trailing newlines; sup.set_description(' PBE GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. Lett., 77(18), 3865-3868, 1996\n'). # Add member functionals; sup.add_x_functional(build_functional('PBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_superfunctional(name, npoints, deriv):. sup = build_pbe_superfunctional(name, npoints, deriv); sup.set_name('PBE0'); sup.set_description(' PBE0 Hybrid GGA Exchange-Correlation Functional\n'); sup.set_citation(' Adamo et. al., J. Chem. Phys., 110(13), 6158, 1999\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_sogga_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SOGGA'); # Tab in, trailing newlines; sup.set_description(' Second Order GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 128(18), 184109, 2008\n'). # Add member functionals; sup.add_x_functional(build_functional('SOGGA_X')). C = build_functional('PBE_C'); C.set_parameter('bet', 0.037526); sup.add_c_functional(C). # Set GKS u",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:32092,Energy Efficiency,allocate,allocate,32092," GGA Exchange-Correlation Functional\n'); sup.set_citation(' Adamo et. al., J. Chem. Phys., 110(13), 6158, 1999\n'); sup.set_x_alpha(0.25); return sup. [docs]def build_sogga_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('SOGGA'); # Tab in, trailing newlines; sup.set_description(' Second Order GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 128(18), 184109, 2008\n'). # Add member functionals; sup.add_x_functional(build_functional('SOGGA_X')). C = build_functional('PBE_C'); C.set_parameter('bet', 0.037526); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:33074,Energy Efficiency,allocate,allocate,33074,"t; sup.allocate(); return sup. [docs]def build_b3lyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP'); # Tab in, trailing newlines; sup.set_description(' B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hf_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HF_X'); # Tab in, trailing newlines; sup.set_description(' Hartree-Fock Exchange Functional\n'); # Tab in, trailing newlines; sup.set_citation(' \n'). # Add member functionals; hf_x = build_functional('hf_x'); hf_x.set_alpha(1.0); sup.add_x_functional(hf_x). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(1.0); sup.set_c_alpha(0.0). sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines;",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:33755,Energy Efficiency,allocate,allocate,33755,"alpha(0.81); vwn = build_functional('VWN3RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(vwn); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hf_x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HF_X'); # Tab in, trailing newlines; sup.set_description(' Hartree-Fock Exchange Functional\n'); # Tab in, trailing newlines; sup.set_citation(' \n'). # Add member functionals; hf_x = build_functional('hf_x'); hf_x.set_alpha(1.0); sup.add_x_functional(hf_x). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(1.0); sup.set_c_alpha(0.0). sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:34733,Energy Efficiency,allocate,allocate,34733,"(0.0). sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5)\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b970_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-0'); # Tab in, trailing newlines; sup.set_description(' B97-0 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set_p",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:36089,Energy Efficiency,allocate,allocate,36089," Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.1737); C.set_parameter('B97_ss_a1', 2.3487); C.set_parameter('B97_ss_a2', -2.4868). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.1943); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b971_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-1'); # Tab in, trailing newlines; sup.set_description(' B97-1 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_ss_",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:37469,Energy Efficiency,allocate,allocate,37469,"nctional\n'); # Tab in, trailing newlines; sup.set_citation(' F.A. Hamprecht et. al., J. Chem. Phys., 109(15), 6264-6271, 1998\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-1_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.789518); X.set_parameter('B97_a1', 0.573805); X.set_parameter('B97_a2', 0.660975). C = build_functional('B_C'); C.set_name('B97-1_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.955689); C.set_parameter('B97_os_a1', 0.788552); C.set_parameter('B97_os_a2', -5.47869). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.0820011); C.set_parameter('B97_ss_a1', 2.71681); C.set_parameter('B97_ss_a2', -2.87103). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b972_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-2'); # Tab in, trailing newlines; sup.set_description(' B97-2 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamm",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:38846,Energy Efficiency,allocate,allocate,38846," Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Wilson et. al., J. Chem. Phys., 115(20), 9233-9242, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-2_X'); X.set_alpha(1.0 / 0.79). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.827642); X.set_parameter('B97_a1', 0.047840); X.set_parameter('B97_a2', 1.761250). C = build_functional('B_C'); C.set_name('B97-2_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.999849); C.set_parameter('B97_os_a1', 1.40626); C.set_parameter('B97_os_a2', -7.44060). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.585808); C.set_parameter('B97_ss_a1', -0.691682); C.set_parameter('B97_ss_a2', 0.394796). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.21); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d2p4_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-D2P4'); # Tab in, trailing newlines; sup.set_description(' B97-D Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_par",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:40300,Energy Efficiency,allocate,allocate,40300,"e, J. Comput. Chem., 27, 1787-1799, 2006\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-D_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08662); X.set_parameter('B97_a1', -0.52127); X.set_parameter('B97_a2', 3.25429). C = build_functional('B_C'); C.set_name('B97-D_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.69041); C.set_parameter('B97_os_a1', 6.30270); C.set_parameter('B97_os_a2', -14.9712). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.22340); C.set_parameter('B97_ss_a1', -1.56208); C.set_parameter('B97_ss_a2', 1.94293). sup.add_x_functional(X); sup.add_c_functional(C). # => -D2 (s = 1.25) <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b97-d', 'd2p4'))). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b97d2gr_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D2GR'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b97-d', 'd2gr'))). return sup. [docs]def build_b97d3zero_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b97-d', 'd3zero'))). return sup. [docs]def build_b97d3bj_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b97-d', 'd3bj'))). return sup. [docs]def build_b97d3mzero_superfunctional(name, npoints, deriv):. sup = build_b97d2p4_superfunctional(name, npoints, deriv); sup.set_name('B97-D3MZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b97-d',",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:43162,Energy Efficiency,allocate,allocate,43162,".0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09320); X.set_parameter('B97_a1', -0.744056); X.set_parameter('B97_a2', 5.59920); X.set_parameter('B97_a3', -6.78549); X.set_parameter('B97_a4', 4.49357). C = build_functional('B_C'); C.set_name('HCTH_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.729974); C.set_parameter('B97_os_a1', 3.35287); C.set_parameter('B97_os_a2', -11.5430); C.set_parameter('B97_os_a3', 8.08564); C.set_parameter('B97_os_a4', -4.47857). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.222601); C.set_parameter('B97_ss_a1', -0.0338622); C.set_parameter('B97_ss_a2', -0.0125170); C.set_parameter('B97_ss_a3', -0.802496); C.set_parameter('B97_ss_a4', 1.55396). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth120_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH120'); # Tab in, trailing newlines; sup.set_description(' HCTH120 Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Boese, et. al., J. Chem. Phys., 112(4), 1670-1678, 2000\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH120_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09163); X.set_parameter('B97_a1', -0.747215); X.set_parameter('B97_a2', 5.07833); X.set_parameter('B97_a3', -4.10746); X.set_parameter('B97_a4', 1.17173). C = build_functional('B_C'); C.set_name('HCTH120_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.514730); C.set_parameter('B97_os_a1', 6.929",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:44769,Energy Efficiency,allocate,allocate,44769,"1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09163); X.set_parameter('B97_a1', -0.747215); X.set_parameter('B97_a2', 5.07833); X.set_parameter('B97_a3', -4.10746); X.set_parameter('B97_a4', 1.17173). C = build_functional('B_C'); C.set_name('HCTH120_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.514730); C.set_parameter('B97_os_a1', 6.92982); C.set_parameter('B97_os_a2', -24.7073); C.set_parameter('B97_os_a3', 23.1098); C.set_parameter('B97_os_a4', -11.3234). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.489508); C.set_parameter('B97_ss_a1', -0.260699); C.set_parameter('B97_ss_a2', 0.432917); C.set_parameter('B97_ss_a3', -1.99247); C.set_parameter('B97_ss_a4', 2.48531). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth120d3zero_superfunctional(name, npoints, deriv):. sup = build_hcth120_superfunctional(name, npoints, deriv); sup.set_name('HCTH120-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('hcth120', 'd3zero'))). return sup. [docs]def build_hcth120d3bj_superfunctional(name, npoints, deriv):. sup = build_hcth120_superfunctional(name, npoints, deriv); sup.set_name('HCTH120-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('hcth120', 'd3bj'))). return sup. [docs]def build_hcth147_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH147'); # Tab in, trailing newlines; sup.set_description(' HCTH147 Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Boese, et. al., J. Chem",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:46902,Energy Efficiency,allocate,allocate,46902,"1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.09025); X.set_parameter('B97_a1', -0.799194); X.set_parameter('B97_a2', 5.57212); X.set_parameter('B97_a3', -5.86760); X.set_parameter('B97_a4', 3.04544). C = build_functional('B_C'); C.set_name('HCTH147_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.542352); C.set_parameter('B97_os_a1', 7.01464); C.set_parameter('B97_os_a2', -28.3822); C.set_parameter('B97_os_a3', 35.0329); C.set_parameter('B97_os_a4', -20.4284). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 0.562576); C.set_parameter('B97_ss_a1', 0.0171436); C.set_parameter('B97_ss_a2', -1.30636); C.set_parameter('B97_ss_a3', 1.05747); C.set_parameter('B97_ss_a4', 0.885429). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_hcth407_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('HCTH407'); # Tab in, trailing newlines; sup.set_description(' HCTH407 Pure-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Boese and N.C. Handy, J. Chem. Phys., 114(13), 5497-5503, 2001\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('HCTH407_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1'",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:48513,Energy Efficiency,allocate,allocate,48513,"ha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1', 4.42374); C.set_parameter('B97_os_a2', -19.2218); C.set_parameter('B97_os_a3', 42.5721); C.set_parameter('B97_os_a4', -42.0052). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.18777); C.set_parameter('B97_ss_a1', -2.40292); C.set_parameter('B97_ss_a2', 5.61741); C.set_parameter('B97_ss_a3', -9.17923); C.set_parameter('B97_ss_a4', 6.24798). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blypd2p4_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D2P4'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd2p4'))). return sup. [docs]def build_blypd2gr_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D2GR'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd2gr'))). return sup. [docs]def build_blypd3zero_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd3zero'))). return sup. [docs]def build_blypd3bj_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd3bj'))). re",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:60157,Energy Efficiency,allocate,allocate,60157,"ional(name, npoints, deriv):. sup = build_pbe0_superfunctional(name, npoints, deriv); sup.set_name('PBE0-D3MBJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('pbe0', 'd3mbj'))). return sup. [docs]def build_wsvwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wSVWN'); # Tab in, trailing newlines; sup.set_description(' LSDA SR-XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbed3zero_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, np",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:61037,Energy Efficiency,allocate,allocate,61037,"ga(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbed3zero_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcwpbe', 'd3zero'))). return sup. [docs]def build_wpbed3bj_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcwpbe', 'd3bj'))). return sup. [docs]def build_wpbed3mzero_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3MZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcwpbe', 'd3mzero'))). return sup. [docs]def build_wpbed3mbj_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3MBJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcw",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:63206,Energy Efficiency,allocate,allocate,63206,"); sup.set_description(' PBE0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wpbesol_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol'); # Tab in, trailing newlines; sup.set_description(' PBEsol SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol0_superfunctional(name, npoints, deriv):. sup = build_wpbesol_superfunctional(name, npoints, deriv); sup.set_name('wPBEsol0'); sup.set_description(' PBEsol0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wblyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; su",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:64360,Energy Efficiency,allocate,allocate,64360,"Esol0'); sup.set_description(' PBEsol0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wblyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wBLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wB88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97'); # Tab in, trailing newlines; sup.set_description(' Parameterized LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97_X'); X.set_alpha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.0); X.set_parameter('B97_a1', 1.13116E0); X.set_parameter('B97_a2', -2.74915E0); X.set_parameter('B97_a3', 1.20900E1); X.set_parameter('B97_a4', -5.71642E0). C = build_functional('B_C'); C.set_name('wB97_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.99051E0); C.set_param",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:65957,Energy Efficiency,allocate,allocate,65957,"). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.0); X.set_parameter('B97_a1', 1.13116E0); X.set_parameter('B97_a2', -2.74915E0); X.set_parameter('B97_a3', 1.20900E1); X.set_parameter('B97_a4', -5.71642E0). C = build_functional('B_C'); C.set_name('wB97_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.99051E0); C.set_parameter('B97_os_a2', -1.70066E1); C.set_parameter('B97_os_a3', 1.07292E0); C.set_parameter('B97_os_a4', 8.88211E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -2.55352E0); C.set_parameter('B97_ss_a2', 1.18926E1); C.set_parameter('B97_ss_a3', -2.69452E1); C.set_parameter('B97_ss_a4', 1.70927E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 128, 084106, 2008\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.157706)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:67597,Energy Efficiency,allocate,allocate,67597,"eter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a4', 1.72901E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.157706); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97xd_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-D'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, Phys. Chem. Chem. Phys., 10, 6615-6620, 2008\n'). # Add member functionals; alpha = 2.22036E-1; omega = 0.2; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - alpha)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 7.77964E-1) # Table 1: c_{x\sigma,0}; X.set_parameter('B97_a1', 6.61160E-1) # Table 1: c_{x\sigma,1}; X.set_parameter('B97_a2', 5.74541E-1) # Table 1: c_{x\sigma,2}; X.set_parameter('B97_a3', -5.25671E0) # Table 1: c_{x\sigma,3}; X.set_parameter('B9",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:69868,Energy Efficiency,allocate,allocate,69868,"; C.set_parameter('B97_os_a2', -1.20477E1) # Table 1: c_{c\alpha\beta,2}; C.set_parameter('B97_os_a3', 1.40847E1) # Table 1: c_{c\alpha\beta,3}; C.set_parameter('B97_os_a4', -8.50809E0) # Table 1: c_{c\alpha\beta,4}. C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0) # Table 1: c_{c\sigma\sigma,0}; C.set_parameter('B97_ss_a1', -6.90539E0) # Table 1: c_{c\sigma\sigma,1}; C.set_parameter('B97_ss_a2', 3.13343E1) # Table 1: c_{c\sigma\sigma,2}; C.set_parameter('B97_ss_a3', -5.10533E1) # Table 1: c_{c\sigma\sigma,3}; C.set_parameter('B97_ss_a4', 2.64423E1) # Table 1: c_{c\sigma\sigma,4}. sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(omega) # Table 1: omega; sup.set_c_omega(0.0); sup.set_x_alpha(alpha) # Table 1: c_x; sup.set_c_alpha(0.0). # => -D2 (CHG Damping Function) <= #; sup.set_dispersion(psi4.Dispersion.build('-CHG', 1.0, 0.0, 0.0, 0.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Differen",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:70937,Energy Efficiency,power,power,70937,"ame, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Phys., 123, 161103, 2005\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp) # Different effective kp; X.set_parameter('PBE_mu', mu) # Different effective mu. # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', 0.08151); X.set_parameter('Meta_a2', -0.43956); X.set_parameter('Meta_a3', -3.22422); X.set_parameter('Meta_a4', 2.01819); X.set_parameter('Meta_a5', 8.79431); X.set_parameter('Meta_a6', -0.00295); X.set_parameter('Meta_a7', 9.82029); X.set_parameter('Meta_a8', -4.82351); X.set_parameter('Meta_a9', -48.17574); X.set_parameter('Meta_a10', 3.64802); X.set_parameter('Meta_a11', 34.02248). C = build_functional('M_C'); C.set_name('M05_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.78569); C.set_parameter('B97_os_a2', -14.15261); C.set_parameter('B97_os_a3', -7.46589); C.set_parameter('B97_os_a4', 17.94491). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', 3.77344); C.set_parameter('B97_ss_a2', -26.04",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:72361,Energy Efficiency,allocate,allocate,72361,".set_parameter('Meta_a11', 34.02248). C = build_functional('M_C'); C.set_name('M05_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 3.78569); C.set_parameter('B97_os_a2', -14.15261); C.set_parameter('B97_os_a3', -7.46589); C.set_parameter('B97_os_a4', 17.94491). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', 3.77344); C.set_parameter('B97_ss_a2', -26.04463); C.set_parameter('B97_ss_a3', 30.69913); C.set_parameter('B97_ss_a4', -9.22695). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.28) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp); X.set_parameter('PBE_mu', mu). # Meta Exchange type ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:73393,Energy Efficiency,power,power,73393,"[docs]def build_m05_2x_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('M05-2X'); # Tab in, trailing newlines; sup.set_description(' Heavily Parameterized Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Zhao et. al., J. Chem. Theory Comput., 2, 364, 2006\n'). # Add member functionals; X = build_functional('M_X'); X.set_name('M05_2X_X'); X.set_alpha(1.0). # LSDA Exchange type is Slater, no parameters. # GGA Exchange type is PBE, special parameters because Truhlar is lazy; C1 = 3.36116E-3; C2 = 4.49267E-3; K0 = 3.0 / 2.0 * math.pow(3.0 / (math.pi * 4.0), 1.0 / 3.0); k0 = math.pow(6.0 * math.pi * math.pi, 1.0 / 3.0); kp = C1 / (C2 * K0); mu = 4.0 * k0 * k0 * kp * C2; X.set_parameter('PBE_kp', kp); X.set_parameter('PBE_mu', mu). # Meta Exchange type is insane mess of w power series expansion; X.set_parameter('Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.56833); X.set_parameter('Meta_a2', -1.30057); X.set_parameter('Meta_a3', 5.50070); X.set_parameter('Meta_a4', 9.06402); X.set_parameter('Meta_a5', -32.21075); X.set_parameter('Meta_a6', -23.73298); X.set_parameter('Meta_a7', 70.22996); X.set_parameter('Meta_a8', 29.88614); X.set_parameter('Meta_a9', -60.25778); X.set_parameter('Meta_a10', -13.22205); X.set_parameter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2', -3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4', -10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -3.05430); C.set_parameter('B",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:74832,Energy Efficiency,allocate,allocate,74832,"meter('Meta_a11', 15.23694). C = build_functional('M_C'); C.set_name('M05_2X_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 1.09297); C.set_parameter('B97_os_a2', -3.79171); C.set_parameter('B97_os_a3', 2.82810); C.set_parameter('B97_os_a4', -10.58909). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -3.05430); C.set_parameter('B97_ss_a2', 7.61854); C.set_parameter('B97_ss_a3', 1.47665); C.set_parameter('B97_ss_a4', -11.92365). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.56) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_m05d3zero_superfunctional(name, npoints, deriv):. sup = build_m05_superfunctional(name, npoints, deriv); sup.set_name('M05-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('m05', 'd3zero'))). return sup. [docs]def build_m05_2xd3zero_superfunctional(name, npoints, deriv):. sup = build_m05_2x_superfunctional(name, npoints, deriv); sup.set_name('M05-2X-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('m05-2x', 'd3zero'))). return sup. [docs]def build_dldf_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('dlDF'); # Tab in, trailing newlines; sup.set_description(' Dispersionless Hybrid Meta-GGA XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Pernal et. al., Phys. Rev. Lett., 103, 263201, 2009\",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:77190,Energy Efficiency,allocate,allocate,77190,"'Meta_a0', 1.0); X.set_parameter('Meta_a1', -0.1637571); X.set_parameter('Meta_a2', -0.1880028); X.set_parameter('Meta_a3', -0.4490609); X.set_parameter('Meta_a4', -0.0082359). C = build_functional('M_C'); C.set_name('dlDF_C'). # LSDA Correlation type is PW92, no parameters. # GGA Correlation type is B97; C.set_parameter('B97_os_gamma', 0.0031 * 2.0); C.set_parameter('B97_os_a0', 1.00000); C.set_parameter('B97_os_a1', 5.9515308); C.set_parameter('B97_os_a2', -11.1602877). C.set_parameter('B97_ss_gamma', 0.06); C.set_parameter('B97_ss_a0', 1.00000); C.set_parameter('B97_ss_a1', -2.5960897); C.set_parameter('B97_ss_a2', 2.2233793). # Meta Correlation type is Becke metric, no parameters. # Add the functionals in; sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.6144129) # Hartree-Fock exact exchange; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dldfd09_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D09'). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2009', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_dldfd_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D'). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_hfd_superfunctional(name, npoints, deriv):. sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv); sup.set_name('HF+D'); sup.set_x_alpha(1.0). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this firs",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:78099,Energy Efficiency,allocate,allocate,78099,"; sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dldfd09_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D09'). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2009', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_dldfd_superfunctional(name, npoints, deriv):. sup = build_dldf_superfunctional(name, npoints, deriv); sup.set_name('dlDF+D'). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. return sup. [docs]def build_hfd_superfunctional(name, npoints, deriv):. sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv); sup.set_name('HF+D'); sup.set_x_alpha(1.0). # => +D <= #; sup.set_dispersion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B2PLYP'); # Tab in, trailing newlines; sup.set_description(' B2PLYP Double Hybrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Chem. Phys., 124, 034108, 2006\n'). # Add member functionals; becke = build_functional('B88_X'); becke.set_alpha(1.0); sup.add_x_functional(becke); lyp = build_functional('LYP_C'); lyp.set_alpha(1.0); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.53); sup.set_c_alpha(0.27). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_2tqz_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.Supe",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:78986,Energy Efficiency,allocate,allocate,78986,"sion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B2PLYP'); # Tab in, trailing newlines; sup.set_description(' B2PLYP Double Hybrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Chem. Phys., 124, 034108, 2006\n'). # Add member functionals; becke = build_functional('B88_X'); becke.set_alpha(1.0); sup.add_x_functional(becke); lyp = build_functional('LYP_C'); lyp.set_alpha(1.0); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.53); sup.set_c_alpha(0.27). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_2tqz_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-2(TQZ)'); # Tab in, trailing newlines; sup.set_description(' Double Hybrid LRC B97 GGA XC Functional (TQZ parametrization)\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 131, 174105, 2009\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.636158)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 3.15503E-1); X.set_parameter('B97_a1', 1.04772E0); X.set_parameter('B97_a2', -2.33506E0); X.set_parameter('B97_a3', 3.19909E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.18198E-1); C.set_parameter('B97",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:80607,Energy Efficiency,allocate,allocate,80607,"set_alpha(1.0 / (1.0 - 0.636158)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 3.15503E-1); X.set_parameter('B97_a1', 1.04772E0); X.set_parameter('B97_a2', -2.33506E0); X.set_parameter('B97_a3', 3.19909E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.18198E-1); C.set_parameter('B97_os_a1', -5.85956E-1); C.set_parameter('B97_os_a2', 4.27080E0); C.set_parameter('B97_os_a3', -6.48897E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 9.08460E-1); C.set_parameter('B97_ss_a1', -2.80936E0); C.set_parameter('B97_ss_a2', 6.02676E0); C.set_parameter('B97_ss_a3', -4.56981E0). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.636158); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.447105); sup.set_c_ss_alpha(0.529319). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_2lp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-2(LP)'); # Tab in, trailing newlines; sup.set_description(' Double Hybrid LRC B97 GGA XC Functional (Large Pople parametrization)\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 131, 174105, 2009\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.678792)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 2.51767E-1); X.set_parameter('B97_a1', 1.57375E0); X.set_parameter('B97_a2', -5.26624E0); X.set_parameter('B97_a3', 6.74313E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.53261E-1); C.set_paramete",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:82232,Energy Efficiency,allocate,allocate,82232,"X.set_alpha(1.0 / (1.0 - 0.678792)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 2.51767E-1); X.set_parameter('B97_a1', 1.57375E0); X.set_parameter('B97_a2', -5.26624E0); X.set_parameter('B97_a3', 6.74313E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.53261E-1); C.set_parameter('B97_os_a1', -1.16626E0); C.set_parameter('B97_os_a2', 6.84409E0); C.set_parameter('B97_os_a3', -8.90640E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.15698E0); C.set_parameter('B97_ss_a1', -3.31669E0); C.set_parameter('B97_ss_a2', 6.27265E0); C.set_parameter('B97_ss_a3', -4.51464E0). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.678792); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.477992); sup.set_c_ss_alpha(0.581569). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE0-2'); # Tab in, trailing newlines; sup.set_description(' PBE0-2 Double Hydrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J. Chai, Chem. Phys. Lett., 538, 121-125, 2012\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(1.0); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.793701); sup.set_c_alpha(0.5). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.bla",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:83106,Energy Efficiency,allocate,allocate,83106,"up.set_c_os_alpha(0.477992); sup.set_c_ss_alpha(0.581569). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pbe0_2_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PBE0-2'); # Tab in, trailing newlines; sup.set_description(' PBE0-2 Double Hydrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J. Chai, Chem. Phys. Lett., 538, 121-125, 2012\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(1.0); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.793701); sup.set_c_alpha(0.5). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-BLYP'); # Tab in, trailing newlines; sup.set_description(' DSD-BLYP Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('B88_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('LYP_C'); C.set_alpha(0.55); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.71); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.46); sup.set_c_ss_alpha(0.43). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build('-D2', 0.35, 0.0, 0.0, 0.0)). # => End User-Customization <= #. # Call th",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:84131,Energy Efficiency,allocate,allocate,84131,"ild_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-BLYP'); # Tab in, trailing newlines; sup.set_description(' DSD-BLYP Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('B88_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('LYP_C'); C.set_alpha(0.55); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.71); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.46); sup.set_c_ss_alpha(0.43). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build('-D2', 0.35, 0.0, 0.0, 0.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_pbep86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEP86'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEP86 Dispersion-corrected SCS Double Hybrid XC Functional (opt. for -D2)\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('P86_C'); C.set_alpha(0.45); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.68); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.23); sup.set_c_os_alpha(0.51). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbep86', 'd2p4'))). # => End User-",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:85185,Energy Efficiency,allocate,allocate,85185,"l(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEP86'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEP86 Dispersion-corrected SCS Double Hybrid XC Functional (opt. for -D2)\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('P86_C'); C.set_alpha(0.45); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.68); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.23); sup.set_c_os_alpha(0.51). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbep86', 'd2p4'))). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_pbepbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbepbe', 'd2p4'))). # => End User-Customization <",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:86224,Energy Efficiency,allocate,allocate,86224,"_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbepbe', 'd2p4'))). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b2plypd2p4_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D2P4'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd2p4'))). return sup. [docs]def build_b2plypd2gr_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D2GR'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd2gr'))). return sup. [docs]def build_b2plypd3zero_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd3zero'))). return sup. [docs]def build_b2plypd3bj_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*das",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:88552,Energy Efficiency,allocate,allocate,88552,"ypd3mbj_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3MBJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('b2plyp', 'd3mbj'))). return sup. [docs]def build_primitive_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. key = name.upper(); fun = build_functional(key). # No spaces, keep it short and according to convention; sup.set_name(key); # Tab in, trailing newlines; sup.set_description(fun.description()); # Tab in, trailing newlines; sup.set_citation(fun.citation()). # Add member functionals. if (key[-1] == 'X'):; sup.add_x_functional(fun); else:; sup.add_c_functional(fun). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. # Superfunctional lookup table; superfunctionals = {; 's_x' : build_primitive_superfunctional,; 'b88_x' : build_primitive_superfunctional,; 'b3_x' : build_primitive_superfunctional,; 'pbe_x' : build_primitive_superfunctional,; 'rpbe_x' : build_primitive_superfunctional,; 'sogga_x' : build_primitive_superfunctional,; 'pbesol_x' : build_primitive_superfunctional,; 'pw91_x' : build_primitive_superfunctional,; 'ws_x' : build_ws_x_superfunctional,; 'wpbe_x' : build_wpbe_x_superfunctional,; 'wpbesol_x' : build_wpbesol_x_superfunctional,; 'wb88_x' : build_wb88_x_superfunctional,; 'lyp_c' : build_primitive_superfunctional,; 'ft97b_x' : build_primitive_superfunctional,; 'pz81_c' : build_primitive_superfunctional,; 'p86_c' : build_primitive_superfunctional,; 'pw91_c' : build_primitive_superfunctional,; 'pw92_c' : build_primitive_superfunctional,; 'pbe_c' : build_primitive_superfunctional,; 'ft97_c' : build_primitive_superfunctional,; 'vwn5rpa_c' : build_primitive_superfunctional,; 'v",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:5442,Availability,fault,fault,5442,")). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(random.randint(0, 99999)); if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMA",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13185,Availability,error,error,13185," c4grad:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_ac",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13319,Deployability,update,update,13319,"s.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_option('CFOUR', 'TRANSL",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:16943,Deployability,update,updated,16943,"sis %s\n' % (psi4.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(psi4.MintsHelper().basisset().has_puream()). # Handle psi4 keywords implying cfour keyword values; if psi4.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = psi4.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; psi4.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:2258,Energy Efficiency,energy,energy,2258,"e, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import sys; import inspect; import random. # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; import qcdb; from molutil import *; from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~driver.energy` or :py:func:`~driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: string; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: string; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:4237,Energy Efficiency,energy,energy,4237,"is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: string; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser's; aggression, blank lines need to be replaced by the text blankline. """"""; lowername = name.lower(); internal_p4c4_info = {}. optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(random.randint(0, 99999)); if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_s",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13432,Energy Efficiency,energy,energy,13432,"gs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); q",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:1197,Integrability,interface,interface,1197,"r; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import sys; import inspect; import random. # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; import qcdb; from molutil import *; from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:1926,Integrability,wrap,wrappers,1926,"# You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import sys; import inspect; import random. # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; import qcdb; from molutil import *; from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~driver.energy` or :py:func:`~driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: string; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:5918,Integrability,message,message,5918,"(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; psi4.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #psi4.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #psi4.print_out(open('ZMAT', 'r').read()); #psi4.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Beg",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:5955,Integrability,interface,interface,5955,"(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; psi4.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #psi4.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #psi4.print_out(open('ZMAT', 'r').read()); #psi4.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Beg",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:6278,Integrability,message,message,6278,"ATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; psi4.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #psi4.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #psi4.print_out(open('ZMAT', 'r').read()); #psi4.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); psi4.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen wit",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:8423,Integrability,message,message,8423,"s.path.sep; p4out = open(pathfill + psi4.outfile_name(), 'a'). # Handle user's OMP_NUM_THREADS and CFOUR_OMP_NUM_THREADS; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data; internal_p4c4_info['output'] = c4out. # Restore user's OMP_NUM_THREADS; if omp_num_threads_found == True:; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. c4files = {}; p4out.write('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); p4out.write(' CFOUR scratch file %s has been read\n' % (item)); p4out.write('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; p4out.write('\n'). molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; q",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:8548,Integrability,message,message,8548,"ser's OMP_NUM_THREADS and CFOUR_OMP_NUM_THREADS; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data; internal_p4c4_info['output'] = c4out. # Restore user's OMP_NUM_THREADS; if omp_num_threads_found == True:; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. c4files = {}; p4out.write('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); p4out.write(' CFOUR scratch file %s has been read\n' % (item)); p4out.write('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; p4out.write('\n'). molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcd",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:4999,Modifiability,variab,variables,4999," to be replaced by the text blankline. """"""; lowername = name.lower(); internal_p4c4_info = {}. optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(random.randint(0, 99999)); if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:2287,Performance,optimiz,optimize,2287,"odule are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import sys; import inspect; import random. # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; import qcdb; from molutil import *; from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~driver.energy` or :py:func:`~driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: string; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: string; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or Z",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:5785,Performance,load,loaded,5785,"amespace() + \; '.cfour.' + str(random.randint(0, 99999)); if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; psi4.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #psi4.print_out('\n====== Begin ZMAT input for CFOUR ======\n')",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:6501,Performance,load,loaded,6501," None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; psi4.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); psi4.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; psi4.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #psi4.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #psi4.print_out(open('ZMAT', 'r').read()); #psi4.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); psi4.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + psi4.outfile_name()); psi4.close_outfile(); pathfill = '' if os.path.isabs(psi4.outfile_name()) else current_directory + os.path.sep; p4out = open(pathfill + psi4.out",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:7211,Performance,load,loaded,7211," Use molecule {} block and BASIS keyword. """"""; psi4.print_out(message); psi4.print_out(' Search path that was tried:\n'); psi4.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; psi4.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #psi4.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #psi4.print_out(open('ZMAT', 'r').read()); #psi4.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); psi4.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + psi4.outfile_name()); psi4.close_outfile(); pathfill = '' if os.path.isabs(psi4.outfile_name()) else current_directory + os.path.sep; p4out = open(pathfill + psi4.outfile_name(), 'a'). # Handle user's OMP_NUM_THREADS and CFOUR_OMP_NUM_THREADS; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']; if psi4.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.std",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:14985,Performance,load,loaded,14985,"(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if psi4.get_global_option('BASIS') == '':; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(psi4.BasisSet.pyconstruct_orbital(molecule, ""BASIS"", psi4.get_global_option('BASIS')).genbas()); psi4.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (psi4.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(psi4.MintsHelper().basisset().has_puream()). # Handle psi4 keywords implying cfour keyword values; if psi4.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psik",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:2635,Security,access,accessible,2635," # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; import qcdb; from molutil import *; from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~driver.energy` or :py:func:`~driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: string; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: string; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: string; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GE",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13300,Usability,clear,clear,13300,"ts otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:8833,Availability,avail,available,8833,"directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; fun",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:25787,Availability,avail,available,25787,"'', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', psi4.get_active_mol",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:32532,Availability,avail,available,32532,"global_option('QMEFP', True) # apt to go haywire if set locally to efp; psi4.efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; ref_wfn = psi4.new_wavefunction(scf_molecule, psi4.get_global_option('BASIS')); scf_wfn = psi4.scf(ref_wfn, precallback, postcallback); e_scf = psi4.get_variable('CURRENT ENERGY'). # We always would like to print a little dipole information; if kwargs.get('scf_do_dipole', True):; oeprop = psi4.OEProp(scf_wfn); oeprop.set_title(""SCF""); oeprop.add(""DIPOLE""); oeprop.compute(); psi4.set_variable(""CURRENT DIPOLE X"", psi4.get_variable(""SCF DIPOLE X"")); psi4.set_variable(""CURRENT DIPOLE Y"", psi4.get_variable(""SCF DIPOLE Y"")); psi4.set_variable(""CURRENT DIPOLE Z"", psi4.get_variable(""SCF DIPOLE Z"")). optstash.restore(); return scf_wfn. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """""". if (psi4.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCFT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). dcft_wfn = psi4.dcft(ref_wfn); return dcft_wfn. [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); dcft_wfn = run_dcft(name, **kwargs). derivobj = psi4.Deriv(dcft_wfn); derivobj.set_tpdm_presorted(True); grad = derivobj.compute(). dcft_wfn.set_gradient(grad). optstash.restore(); return dcft_wfn. [docs]def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:47995,Availability,avail,avail,47995,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). psi4.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = psi4.occ(ref_wfn). derivobj = psi4.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """""". optstash = proc_util.scf_set_reference_local(name). scf_wfn = scf_helper(name, **kwargs). optstash.restore(); return scf_wfn. [docs]def run_scf_gradient(name, **",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:54980,Availability,avail,available,54980,"C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (psi4.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'ccsd(at)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; psi4.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if psi4.get_global_option('RUN_CCTRANSORT'):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ccwfn = psi4.ccenergy(ref_wfn). if name == 'ccsd(at)':; psi4.cchbar(ref_wfn); psi4.cclambda(ref_wfn). optstash.restore(); return ccwfn. [docs]def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if psi4.get_global_option('FREEZE_CORE') == 'TRUE':; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'ccsd':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if user_ref != 'UHF':; raise ValidationError('Reference %s for CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). derivobj = psi4.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; psi4.set_local",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:55445,Availability,avail,available,55445,"ransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ccwfn = psi4.ccenergy(ref_wfn). if name == 'ccsd(at)':; psi4.cchbar(ref_wfn); psi4.cclambda(ref_wfn). optstash.restore(); return ccwfn. [docs]def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if psi4.get_global_option('FREEZE_CORE') == 'TRUE':; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'ccsd':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if user_ref != 'UHF':; raise ValidationError('Reference %s for CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). derivobj = psi4.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); psi4.set_local_op",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:67332,Availability,avail,available,67332," root)); root = root - 1; if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs); elif name == 'eom-cc2':. user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs); elif name == 'eom-cc3':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). psi4.cchbar(ref_wfn); psi4.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. [docs]def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; opts",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:70720,Availability,avail,available,70720,"ference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). return psi4.adc(ref_wfn). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:70815,Availability,avail,available,70815,"e, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). return psi4.adc(ref_wfn). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable(",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:72935,Availability,avail,available,72935,"me.upper())); psi4.print_out(' -------------------------\n'); psi4.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); psi4.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); psi4.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)). optstash.restore(); return scf_wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if psi4.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; psi4.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_opti",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:73030,Availability,avail,available,73030," (returnvalue - vdh)); psi4.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); psi4.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)). optstash.restore(); return scf_wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if psi4.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; psi4.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'm",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:73580,Availability,avail,available,73580," 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if psi4.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; psi4.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; psi4.set_local_option('DETCI', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level = 4; else:; level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; psi4.set_local_opt",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:92740,Availability,fault,fault,92740," None:; ref_wfn = scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); psi4.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy into the outfile; psi4.print_out('\n===== Begin fort.56 input for MRCC ======\n'); psi4.print_out(open('fort.56', 'r').read()); psi4.print_out('===== End fort.56 input for MRCC ======\n'). # Close psi4 output file and reopen with filehandle; psi4.close_outfile(",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:95531,Availability,error,errored,95531,"de = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data. # try:; # if psi4.outfile_name() == 'stdout':; # retcode = subprocess.call('dmrcc', shell=True, env=lenv); # else:; # retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + psi4.outfile_name(), shell=True, env=lenv); #; # if retcode < 0:; # print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); # exit(1); # elif retcode > 0:; # print('MRCC errored %d' % retcode, file=sys.stderr); # exit(1); #; # except OSError as e:; # print('Execution failed: %s' % e, file=sys.stderr); # exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; psi4.set_variable(m + ' TOTAL ENERGY', ene); psi4.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; psi4.set_variable('CURRENT ENERGY', ene); psi4.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:107774,Availability,avail,available,107774,"S') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif psi4.get_option('FNOCC', 'NAT_ORBS'):; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. [docs]def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF', 'SCF_TYPE']; ). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; psi4.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; psi4.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. molecule = ref_wfn.molecule(). # The DF case; if psi4.get_option('DETCI', 'MCSCF_TYPE') == 'DF':. # Do NOT set global options in general, this is a bit of a hack; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'). # The non-DF case; else:; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:109544,Availability,avail,available,109544,"None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. molecule = ref_wfn.molecule(). # The DF case; if psi4.get_option('DETCI', 'MCSCF_TYPE') == 'DF':. # Do NOT set global options in general, this is a bit of a hack; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'). # The non-DF case; else:; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('DETCI', 'MCSCF_SO'):; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = psi4.detci(ref_wfn). # We always would like to print a little dipole information; oeprop = psi4.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); psi4.set_variable(""CURRENT DIPOLE X"", psi4.get_variable(name.upper() + "" DIPOLE X"")); psi4.set_variable(""CURRENT DIPOLE Y"", psi4.get_variable(name.upper() + "" DIPOLE Y"")); psi4.set_variable(""CURRENT DIPOLE Z"", psi4.get_variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. [docs]def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """"""; # initialize library; efp = psi4.get_active_efp(). if efp.nfragments() == 0:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # set options; psi4.set_global_option('QMEFP', False) # apt to go haywire if set locally to efp; psi4.efp_set_options(). efp.print_out(); returnvalue = efp.compute(); return returnvalue. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:64435,Deployability,configurat,configuration,64435,"ass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_dipole=False, use_c1=True, **kwargs) # C1 certified. psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). dfmp2_wfn = psi4.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('SCS-MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = psi4.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return dfmp2_wfn. [docs]def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). psi4.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; psi4.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = psi4.get_global_option('avg_states'); nroots = psi4.get_global_option('num_roots'); if len(states) != nroots:; states = range(1, nroots + 1). # Run OEProp; oe = psi4.OEProp(ciwfn); oe.set_title(name.upper()); for prop",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:73211,Deployability,configurat,configuration,73211,"wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if psi4.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; psi4.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; psi4.set_local_option('DETCI', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level =",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:109976,Deployability,update,updated,109976,"None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. molecule = ref_wfn.molecule(). # The DF case; if psi4.get_option('DETCI', 'MCSCF_TYPE') == 'DF':. # Do NOT set global options in general, this is a bit of a hack; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'). # The non-DF case; else:; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('DETCI', 'MCSCF_SO'):; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = psi4.detci(ref_wfn). # We always would like to print a little dipole information; oeprop = psi4.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); psi4.set_variable(""CURRENT DIPOLE X"", psi4.get_variable(name.upper() + "" DIPOLE X"")); psi4.set_variable(""CURRENT DIPOLE Y"", psi4.get_variable(name.upper() + "" DIPOLE Y"")); psi4.set_variable(""CURRENT DIPOLE Z"", psi4.get_variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. [docs]def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """"""; # initialize library; efp = psi4.get_active_efp(). if efp.nfragments() == 0:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # set options; psi4.set_global_option('QMEFP', False) # apt to go haywire if set locally to efp; psi4.efp_set_options(). efp.print_out(); returnvalue = efp.compute(); return returnvalue. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:1243,Energy Efficiency,energy,energy,1243,"hemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_opti",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:2057,Energy Efficiency,energy,energy,2057,"51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:5587,Energy Efficiency,energy,energy,5587," reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module =",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:7835,Energy Efficiency,energy,energy,7835,"', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:10156,Energy Efficiency,energy,energy,10156,"*kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = ps",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:11716,Energy Efficiency,energy,energy,11716,"', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:13238,Energy Efficiency,energy,energy,13238,"', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:14804,Energy Efficiency,energy,energy,14804,"dError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd_gradient(name, **",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:16590,Energy Efficiency,energy,energy,16590,"c is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:18159,Energy Efficiency,energy,energy,18159,"odError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MO",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:18935,Energy Efficiency,energy,energy,18935,"_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21144,Energy Efficiency,energy,energy,21144,"lecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_o",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21929,Energy Efficiency,energy,energy,21929,"name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, *",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:23648,Energy Efficiency,energy,energy,23648,"; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_op",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:24434,Energy Efficiency,energy,energy,24434," name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:25205,Energy Efficiency,energy,energy,25205,"or(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:47951,Energy Efficiency,energy,energy,47951,"ocal_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp2.5':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'mp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'omp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'). elif name == 'lccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name == 'olccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). psi4.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = psi4.occ(ref_wfn). derivobj = psi4.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad). optstash.restore(); return occ_wfn. [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """""". optstash = proc_util.scf_set_reference_local(name). scf_wfn = scf_helper(name, **kwargs). optstash.restore(); return scf_wfn. [docs]def run_scf_gradient(name, **",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:53681,Energy Efficiency,energy,energy,53681,", 'WFN', 'CCSD_AT'); psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_AT'); elif name == 'cc2':; psi4.set_local_option('TRANSQT2', 'WFN', 'CC2'); psi4.set_local_option('CCSORT', 'WFN', 'CC2'); psi4.set_local_option('CCTRANSORT', 'WFN', 'CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; psi4.set_local_option('TRANSQT2', 'WFN', 'CC3'); psi4.set_local_option('CCSORT', 'WFN', 'CC3'); psi4.set_local_option('CCTRANSORT', 'WFN', 'CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (psi4.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'ccsd(at)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; psi4.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if psi4.get_global_option('RUN_CCTRANSORT'):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ccwfn = psi4.ccenergy(ref_wfn). if name == 'ccsd(at)':; psi4.cchbar(ref_wfn); psi4.cclambda(ref_wfn). optstash.restore(); return ccwfn. [docs]def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI modul",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:69517,Energy Efficiency,energy,energy,69517,"d':; psi4.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); ref_wfn = run_eom_cc(name, **kwargs); else:; psi4.print_out('DGAS: proc.py:1599 hitting an undefined sequence'); psi4.clean(); raise ValueError('Hit a wall in proc.py:1599'). psi4.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'XI', 'TRUE'); psi4.cclambda(ref_wfn); psi4.ccdensity(ref_wfn); psi4.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'XI', 'FALSE'); psi4.cclambda(ref_wfn); psi4.ccdensity(ref_wfn). derivobj = psi4.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if psi4.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). return psi4.adc(ref_wfn). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); i",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:72127,Energy Efficiency,energy,energy,72127,"_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue); psi4.print_out('\n\n'); psi4.print_out(' %s Energy Summary\n' % (name.upper())); psi4.print_out(' -------------------------\n'); psi4.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); psi4.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); psi4.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)). optstash.restore(); return scf_wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return w",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:84350,Energy Efficiency,charge,charge-transfer,84350,"ame in ['sapt2+(3)(ccd)', 'sapt2+(3)(ccd)dmp2']:; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', False); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name in ['sapt2+3(ccd)', 'sapt2+3(ccd)dmp2']:; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True). psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn). from qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(); for term in ['ELST', 'EXCH', 'IND', 'DISP', 'TOTAL']:; psi4.set_variable(' '.join(['SAPT', term, 'ENERGY']), ; psi4.get_variable(' '.join([name.upper(), term, 'ENERGY']))); psi4.set_variable('CURRENT ENERGY', psi4.get_variable('SAPT TOTAL ENERGY')). return dimer_wfn. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). if 'ref_wfn' in kwargs:; psi4.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_poin",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:95919,Energy Efficiency,energy,energy,95919,"(external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data. # try:; # if psi4.outfile_name() == 'stdout':; # retcode = subprocess.call('dmrcc', shell=True, env=lenv); # else:; # retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + psi4.outfile_name(), shell=True, env=lenv); #; # if retcode < 0:; # print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); # exit(1); # elif retcode > 0:; # print('MRCC errored %d' % retcode, file=sys.stderr); # exit(1); #; # except OSError as e:; # print('Execution failed: %s' % e, file=sys.stderr); # exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; psi4.set_variable(m + ' TOTAL ENERGY', ene); psi4.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; psi4.set_variable('CURRENT ENERGY', ene); psi4.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:97369,Energy Efficiency,energy,energy,97369,"e iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.print_out('\n'); psi4.print_out(iface_contents). return ref_wfn. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE']). psi4.set_local_option('FNOCC', 'DFCC', True); psi4.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = psi4.get_global_option(mtd_type); if type_val == 'CD':; psi4.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'CD'); psi4.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); elif type_val == 'DF':; if psi4.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:99992,Energy Efficiency,energy,energy,99992,"t_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if psi4.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). fnocc_wfn = psi4.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). psi4.set_local_option('FNOCC', 'DFCC', False); psi4.set_local_option('FNOCC', 'RUN_CEPA', False); psi4.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'fno-ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'RUN_CCSD', True); psi4.set_local_o",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:103569,Energy Efficiency,energy,energy,103569,"e); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; psi4.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; psi4.set_local_option('FNOCC', 'RUN_MP4', True); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif nam",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:103586,Energy Efficiency,energy,energy,103586,"e); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); elif name == 'mp3':; psi4.set_local_option('FNOCC', 'RUN_MP3', True); elif name == 'mp4':; psi4.set_local_option('FNOCC', 'RUN_MP4', True); psi4.set_local_option('FNOCC', 'COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name == 'mp3':; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'fno-mp3':; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp3); elif name == 'mp4(sdq)':; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif nam",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:105161,Energy Efficiency,energy,energy,105161,"iable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC', 'RUN_CEPA', True); psi4.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). p",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:1851,Integrability,wrap,wrappers,1851,"neral Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; i",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:8963,Integrability,rout,route,8963,"et_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gra",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:25918,Integrability,rout,route,25918,"if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', psi4.get_active_molecule()); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:53788,Integrability,rout,routine,53788,"si4.set_local_option('CCSORT', 'WFN', 'CC2'); psi4.set_local_option('CCTRANSORT', 'WFN', 'CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; psi4.set_local_option('TRANSQT2', 'WFN', 'CC3'); psi4.set_local_option('CCSORT', 'WFN', 'CC3'); psi4.set_local_option('CCTRANSORT', 'WFN', 'CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (psi4.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'ccsd(at)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; psi4.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if psi4.get_global_option('RUN_CCTRANSORT'):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ccwfn = psi4.ccenergy(ref_wfn). if name == 'ccsd(at)':; psi4.cchbar(ref_wfn); psi4.cclambda(ref_wfn). optstash.restore(); return ccwfn. [docs]def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDE",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:56513,Integrability,rout,routine,56513,"4.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (psi4.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). psi4.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); psi4.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; while True:; if (psi4.get_global_option(""RUN_CCTRANSORT"")):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ref_wfn = psi4.ccenergy(ref_wfn); psi4.print_out('Brueckner convergence check: %s\n' % bool(psi4.get_variable('BRUECKNER CONVERGED'))); if (psi4.get_variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= psi4.get_option('CCENERGY', 'BCCD_MAXITER'):; psi4.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); psi4.pr",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:94834,Integrability,message,message,94834,"# Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; os.environ['NO_STOP_MESSAGE'] = '1'. # Obtain user's OMP_NUM_THREADS so that we don't blow it away.; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data. # try:; # if psi4.outfile_name() == 'stdout':; # retcode = subprocess.call('dmrcc', shell=True, env=lenv); # else:; # retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + psi4.outfile_name(), shell=True, env=lenv); #; # if retcode < 0:; # print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); # exit(1); # elif retcode > 0:; # print('MRCC errored %d' % retcode, file=sys.stderr); # exit(1); #; # except OSError as e:; # print('Execution failed: %s' % e, file=sys.stderr); # exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_thr",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:94955,Integrability,message,message,94955,"P is used; os.environ['NO_STOP_MESSAGE'] = '1'. # Obtain user's OMP_NUM_THREADS so that we don't blow it away.; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data. # try:; # if psi4.outfile_name() == 'stdout':; # retcode = subprocess.call('dmrcc', shell=True, env=lenv); # else:; # retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + psi4.outfile_name(), shell=True, env=lenv); #; # if retcode < 0:; # print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); # exit(1); # elif retcode > 0:; # print('MRCC errored %d' % retcode, file=sys.stderr); # exit(1); #; # except OSError as e:; # print('Execution failed: %s' % e, file=sys.stderr); # exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; ene = 0.0; for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:64435,Modifiability,config,configuration,64435,"ass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_dipole=False, use_c1=True, **kwargs) # C1 certified. psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). dfmp2_wfn = psi4.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('SCS-MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = psi4.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return dfmp2_wfn. [docs]def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). psi4.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; psi4.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = psi4.get_global_option('avg_states'); nroots = psi4.get_global_option('num_roots'); if len(states) != nroots:; states = range(1, nroots + 1). # Run OEProp; oe = psi4.OEProp(ciwfn); oe.set_title(name.upper()); for prop",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:71480,Modifiability,variab,variables,71480,"EFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue); psi4.print_out('\n\n'); psi4.print_out(' %s Energy Summary\n' % (name.upper())); psi4.print_out(' -------------------------\n'); psi4.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); psi4.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); psi4.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)). optstash.restore(); return scf_wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):;",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:73211,Modifiability,config,configuration,73211,"wfn. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if psi4.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; psi4.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; psi4.set_local_option('DETCI', 'WFN', 'DETCI'); psi4.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level =",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:92482,Modifiability,variab,variables,92482,"apt_wfn. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = psi4.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); psi4.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy int",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:1253,Performance,optimiz,optimize,1253,"hemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_opti",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:2105,Performance,perform,performance,2105,"51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:3853,Performance,perform,performance,3853," in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if func is None:; raise ManagedMethodError(['select_mp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and dire",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:4822,Performance,perform,performance,4822,"ction selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE');",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:5635,Performance,perform,performance,5635," reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module =",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:6443,Performance,perform,performance,6443,"2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE')",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:7209,Performance,perform,performance,7209,"Error(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type ==",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:7883,Performance,perform,performance,7883,"', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:9303,Performance,perform,performance,9303,"lif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; referen",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:10204,Performance,perform,performance,10204,"*kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = ps",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:11010,Performance,perform,performance,11010,"'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Consideri",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:11764,Performance,perform,performance,11764,"', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:12550,Performance,perform,performance,12550,"e, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:13286,Performance,perform,performance,13286,"', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:14098,Performance,perform,performance,14098,"robe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:14852,Performance,perform,performance,14852,"dError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd_gradient(name, **",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:15905,Performance,perform,performance,15905,"r best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:16638,Performance,perform,performance,16638,"c is None:; raise ManagedMethodError(['select_lccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:17447,Performance,perform,performance,17447,"TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Co",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:18207,Performance,perform,performance,18207,"odError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MO",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:18983,Performance,perform,performance,18983,"_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:20214,Performance,perform,performance,20214,"'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21192,Performance,perform,performance,21192,"lecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_o",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21977,Performance,perform,performance,21977,"name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, *",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:23031,Performance,perform,performance,23031," or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:23696,Performance,perform,performance,23696,"; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_op",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:24482,Performance,perform,performance,24482," name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:25253,Performance,perform,performance,25253,"or(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:28370,Performance,load,load,28370,"e; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; #psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); #psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; scf_molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. #if (castdf):; # if yes.match(str(castdf)):; # guessbasisdf = p4util.corresponding_jkfit(guessbasis); # else:; # guessbasisdf = castdf. # Switch to the guess namespace; namespace = psi4.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; psi4.IO.set_default_namespace(guesspace). # Setup initial SCF; psi4.set_global_option('BASIS', guessbasis); if (castdf):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'); psi4.set_local_option('SCF",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:33465,Performance,optimiz,optimized,33465,"nal theory calculation. """""". if (psi4.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCFT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). dcft_wfn = psi4.dcft(ref_wfn); return dcft_wfn. [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); dcft_wfn = run_dcft(name, **kwargs). derivobj = psi4.Deriv(dcft_wfn); derivobj.set_tpdm_presorted(True); grad = derivobj.compute(). dcft_wfn.set_gradient(grad). optstash.restore(); return dcft_wfn. [docs]def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = psi4.get_global_option(mtd_type); if type_val == 'DF':; psi4.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); elif type_val == 'CD':; psi4.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'CD'); psi4.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if psi4.get_option('SCF', 'SCF_TYPE') != 'CD':; psi4.set_local",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:35607,Performance,optimiz,optimized,35607,"om('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); set_cholesky_from('CC_TYPE'). elif name == 'ccd':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); set_cholesky_from('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:36671,Performance,optimiz,optimized,36671,"itals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:38945,Performance,optimiz,optimized,38945,"mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'OEPROP', 'TRUE'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:40569,Performance,optimiz,optimized,40569,"nError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'OEPROP', 'TRUE'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); psi4.set_local_option('DFOCC', 'QCHF', 'TRUE'); psi4.set_local_option('DFOCC', 'E_CONVERGENCE', 8). psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); psi4.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); psi4.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunctio",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:2447,Security,validat,validation,2447,"m __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:8951,Security,access,access,8951,"et_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gra",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:25906,Security,access,access,25906,"if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', psi4.get_active_molecule()); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:57876,Usability,simpl,simple,57876,"CF', 'SCF_TYPE'), ref_wfn). psi4.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); psi4.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; while True:; if (psi4.get_global_option(""RUN_CCTRANSORT"")):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ref_wfn = psi4.ccenergy(ref_wfn); psi4.print_out('Brueckner convergence check: %s\n' % bool(psi4.get_variable('BRUECKNER CONVERGED'))); if (psi4.get_variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= psi4.get_option('CCENERGY', 'BCCD_MAXITER'):; psi4.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); psi4.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; psi4.cctriples(ref_wfn). optstash.restore(); return ref_wfn. [docs]def run_dft_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to :py:func:`~proc.run_scf`; since DFT properties all handled through oeprop. """"""; optstash = proc_util.dft_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, *kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return scf_wfn. [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, **kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); re",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:58452,Usability,simpl,simple,58452,"""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); psi4.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; psi4.cctriples(ref_wfn). optstash.restore(); return ref_wfn. [docs]def run_dft_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to :py:func:`~proc.run_scf`; since DFT properties all handled through oeprop. """"""; optstash = proc_util.dft_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, *kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return scf_wfn. [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, **kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return scf_wfn. [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excite",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:66024,Usability,clear,clear,66024,"casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = psi4.get_global_option('avg_states'); nroots = psi4.get_global_option('num_roots'); if len(states) != nroots:; states = range(1, nroots + 1). # Run OEProp; oe = psi4.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(). # If we have more than one root, compute all data; if nroots > 1:; psi4.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); root = root - 1; if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). psi4.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 1, root)); root = root - 1; if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN'",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:3140,Availability,avail,available,3140,"ass; else:; psi4.set_local_option('SCF','REFERENCE','RHF'); elif psi4.get_option('SCF','REFERENCE') == 'UKS':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; pass; else:; psi4.set_local_option('SCF','REFERENCE','UHF'); return optstash. [docs]def dft_set_reference_local(name):; """"""; Figures out the correct DFT reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternat",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:3235,Availability,avail,available,3235,"len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; pass; else:; psi4.set_local_option('SCF','REFERENCE','UHF'); return optstash. [docs]def dft_set_reference_local(name):; """"""; Figures out the correct DFT reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written base",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:5054,Deployability,update,updated,5054," DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'CD', 'PK', 'DIRECT']:; mints = psi4.MintsHelper(wfn.basisset()); mints.set_print(1); mints.integrals(). [docs]def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = psi4.get_option('SCF', 'SCF_TYPE'); supp_jk_type = ['DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)) . Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:4478,Integrability,rout,routine,4478," DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'CD', 'PK', 'DIRECT']:; mints = psi4.MintsHelper(wfn.basisset()); mints.set_print(1); mints.integrals(). [docs]def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = psi4.get_option('SCF', 'SCF_TYPE'); supp_jk_type = ['DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)) . Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/proc_util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/roa.html:6325,Deployability,update,updated,6325,"------------------------------------------'); print('\t%%%%%%%%%% {} %%%%%%%%%%'.format(gauge_list[g_idx])); print('----------------------------------------------------------------------\n\n'); psi4.print_out('\n\n----------------------------------------------------------------------\n'); psi4.print_out('\t%%%%%%%%%% {} %%%%%%%%%%\n'.format(gauge_list[g_idx])); psi4.print_out('----------------------------------------------------------------------\n\n'); print('roa.py:85 I am not being passed a molecule, grabbing from global :('); psi4.scatter(psi4.get_active_molecule(), step, dip_polar_list, gauge, dip_quad_polar_list). db['roa_computed'] = True. db.close(). # SAVE this for when multiple wavelengths works; # # Get list of omega values; # omega = psi4.get_option('CCRESPONSE','OMEGA'); # if len(omega) > 1:; # units = copy.copy(omega[-1]); # omega.pop(); # else:; # units = 'atomic'; # wavelength = copy.copy(omega[0]); # # Set up units for scatter.cc; # if units == 'NM':; # wavelength = (psi_c * psi_h * 1*(10**-9))/(wavelength * psi_hartree2J); # if units == 'HZ':; # wavelength = wavelength * psi_h / psi_hartree2J; # if units == 'EV':; # wavelength = wavelength / psi_hartree2ev; # if units == 'atomic':; # pass; # ################################; # ### ###; # ### DATABASE STRUCTURE ###; # ### ###; # ################################. # Dict of dicts; # inputs_generated (boolean); # job_status: (ordered Dict); # key-> {atom}_{cord}_{p/m}; # val-> (not_started,running,finished); # job_list: (string); # status (string); # jobs_complete (boolean); # roa_computed (boolean); # prop (string) = roa; #. # ?; # data: dipole_polarizability; # : optical_rotation; # : dipole_quadrupole_polarizability; # ?; # results:. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/roa.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/roa.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/roa.html:2251,Performance,perform,performed,2251," p4const import *; import p4util; import psi4; import collections; import shelve; import copy; import sys; import inspect; import os; # Relative hack for now; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile(inspect.currentframe()))[0], ""../""))); sys.path.append(path_dir); from . import findif_response_utils. [docs]def run_roa(name, **kwargs):; """"""; Main driver for managing Raman Optical activity computations with; CC response theory. Uses distributed finite differences approach -->; 1. Sets up a database to keep track of running/finished/waiting; computations.; 2. Generates separate input files for displaced geometries.; 3. When all displacements are run, collects the necessary information; from each displaced computation, and computes final result.; """""". # Get list of omega values -> Make sure we only have one wavelength; # Catch this now before any real work gets done; omega = psi4.get_option('CCRESPONSE', 'OMEGA'); if len(omega) > 2:; raise Exception('ROA scattering can only be performed for one wavelength.'); else:; pass. psi4.print_out(; 'Running ROA computation. Subdirectories for each '; 'required displaced geometry have been created.\n\n'). dbno = 0; # Initialize database; db = shelve.open('database', writeback=True); # Check if final result is in here; # ->if we have already computed roa, back up the dict; # ->copy it setting this flag to false and continue; if ('roa_computed' in db) and ( db['roa_computed'] ):; db2 = shelve.open('.database.bak{}'.format(dbno), writeback=True); dbno += 1; for key,value in db.iteritems():; db2[key]=value. db2.close(); db['roa_computed'] = False; else:; db['roa_computed'] = False. if 'inputs_generated' not in db:; findif_response_utils.initialize_database(db,name,""roa"", [""roa_tensor""]). # Generate input files; if not db['inputs_generated']:; findif_response_utils.generate_inputs(db,name); # handled by helper db['inputs_generated'] = True. # Check job status; if db['inputs_generated'] and",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/roa.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/roa.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:2430,Availability,fault,fault,2430,"m psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import inspect; import glob; import shelve; import datetime; import difflib; #from driver import *; # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. [docs]def run_cfour_module(xmod):; # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message) . c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; #if psi4.outfile_name() == 'stdout':; # sys.stdout.write(data); #else:; # p4out.write(data); # p4out.flush(); c4out += data; #internal_p4c4_info['output'] = c4out; return c4out. [docs]def vpt2(name, **kwargs):; """"""Perform vibrational second-order perturbation computation through; Cfour to get anharmon",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4207,Availability,error,error,4207,"; c4out += data; #internal_p4c4_info['output'] = c4out; return c4out. [docs]def vpt2(name, **kwargs):; """"""Perform vibrational second-order perturbation computation through; Cfour to get anharmonic frequencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission director",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4426,Availability,recover,recovery,4426,"uencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:5369,Availability,checkpoint,checkpoint,5369,"- S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_directory + '/' + os.path.splitext(psi4.outfile_name())[0] + '.shelf', writeback=True). # Cfour keywords to request vpt2 analysis through findif gradients; psi4.set_local_option('CFOUR', 'CFOUR_VIBRATION', 'FINDIF'); psi4.set_local_option('CFOUR', 'CFOUR_FREQ_ALGORITHM', 'PARALLEL'); psi4.set_local_option('CFOUR', 'CFOUR_ANH_ALGORITHM', 'PARALLEL'); psi4.set_local_option('CFOUR', 'CFOUR_ANHARMONIC', 'VPT2'); psi4.set_local_option('CFOUR', 'CFOUR_FD_PROJECT', 'OFF'). # When a Psi4 method is requested for vpt2, a skeleton of; # computations in Cfour is still required to hang the gradients; # upon. The skeleton is as cheap as possible (integrals only; # & sto-3g) and set up here.; if isC4notP4:; skelname = lowername; else:; skelname = 'c4-scf'; psi4.set_global_option('BASIS', 'STO-3G'); # P4 'c4-scf'/'cfour'CALC_LEVEL lowername # temporary; # C4 lowername cfour{} # temporary. if 'status' not in shelf:; shelf['status'] = 'initializ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:29680,Availability,error,error,29680,"leted'; if reap_job_validate is not None:; isOkJob, msg, temp = reap_job_validate(dir, prefix, job, linkage, keys); if isOkJob:; formatArgs[4] = '& Validated'; else:; isOk = False; msgError += msg; formatArgs[4] = 'INVALID'; break; else:; isOk = False; formatArgs[2] = 'Running'; elif os.path.isfile(fjafile):; formatArgs[3] = 'Completed'; else:; isOk = False; formatArgs[1] = 'Waiting'; instructions += """""" {0:<27} {1:^10} {2:^10} {3:^10} {4:^10}\n"""""".format(*formatArgs); instructions += '\n' + msgError + '\n\n'. return isOk, instructions. [docs]def reap_job_validate(dir, prefix, item, linkage, keys):; """"""For a given output file whose path is constructed with; *dir* + '/' + *prefix* + '-' + *item* + '.out', tests that the file; exists and has *prefix* RESULTS lines for each piece of information; requested in list *keys* and that those lines correspond to the; appropriate *linkage* and *item*. Returns *keys* along with their; scanned values in dict *reapings*, along with error and success; messages in *instructions* and a boolean *isOk* indicating whether; all *keys* reaped sucessfully. """"""; isOk = True; instructions = ''; reapings = {}; outfile = dir + '/' + prefix + '-' + item + '.out'. try:; with open(outfile, 'r') as handle:; for line in handle:; if line.find(prefix + ' RESULT:') == 0:; sline = line.split(); if sline[2:7] == ['linkage', str(linkage), 'for', 'item', item]:; yieldsAt = line.find('yields'); beingAt = line.find('being'); if beingAt > yieldsAt > -1:; key = line[yieldsAt + 6:beingAt].strip(); val = line[beingAt + 5:].strip(); if key in keys:; reapings[key] = eval(val); #psi4.print_out(' CFOUR scratch file %s for %s has been read\n' % ('JOBARC', zm12)); else:; isOk = False; instructions += """"""Outfile file %s; has corrupted sowreap result line:\n%s\n\n"""""" % (outfile, line); else:; isOk = False; instructions += """"""Outfile file %s; has sowreap result of either incompatible linkage (observed: %s, expected: %s); or incompatible job affiliation (observed: %s, exp",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4829,Deployability,continuous,continuous,4829,"iles; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_directory + '/' + os.path.splitext(psi4.outfile_name())[0] + '.shelf', writeback=True). # Cfour keywords to request vpt2 analysis through findif gradients; psi4.set_local_option('CFOUR', 'CFOUR_VIBRATION', 'FINDIF'); psi4.set_local_option('CFOUR', 'CFOUR_FREQ_ALGORITHM', 'PARALLEL'); psi4.set_local_",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4884,Deployability,continuous,continuous,4884,"y a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_directory + '/' + os.path.splitext(psi4.outfile_name())[0] + '.shelf', writeback=True). # Cfour keywords to request vpt2 analysis through findif gradients; psi4.set_local_option('CFOUR', 'CFOUR_VIBRATION', 'FINDIF'); psi4.set_local_option('CFOUR', 'CFOUR_FREQ_ALGORITHM', 'PARALLEL'); psi4.set_local_option('CFOUR', 'CFOUR_ANH_ALGORITHM', 'PARALLEL'); psi4.set_local_option('CFOUR', 'CFOUR_ANHARMONIC', 'VPT2'); psi4.set_local_option('CFOUR', 'CFOUR_FD_PROJECT', 'OFF'). # When ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:31429,Deployability,update,updated,31429,"equested in list *keys* and that those lines correspond to the; appropriate *linkage* and *item*. Returns *keys* along with their; scanned values in dict *reapings*, along with error and success; messages in *instructions* and a boolean *isOk* indicating whether; all *keys* reaped sucessfully. """"""; isOk = True; instructions = ''; reapings = {}; outfile = dir + '/' + prefix + '-' + item + '.out'. try:; with open(outfile, 'r') as handle:; for line in handle:; if line.find(prefix + ' RESULT:') == 0:; sline = line.split(); if sline[2:7] == ['linkage', str(linkage), 'for', 'item', item]:; yieldsAt = line.find('yields'); beingAt = line.find('being'); if beingAt > yieldsAt > -1:; key = line[yieldsAt + 6:beingAt].strip(); val = line[beingAt + 5:].strip(); if key in keys:; reapings[key] = eval(val); #psi4.print_out(' CFOUR scratch file %s for %s has been read\n' % ('JOBARC', zm12)); else:; isOk = False; instructions += """"""Outfile file %s; has corrupted sowreap result line:\n%s\n\n"""""" % (outfile, line); else:; isOk = False; instructions += """"""Outfile file %s; has sowreap result of either incompatible linkage (observed: %s, expected: %s); or incompatible job affiliation (observed: %s, expected: %s).\n\n"""""" % \; (outfile, sline[3], linkage, sline[6], item); else:; if len(reapings) != len(keys):; isOk = False; instructions += """"""Output file %s; has missing results (observed: %s, expected: %s).\n\n"""""" % \; (outfile, reapings.keys(), keys); except IOError:; isOk = False; instructions += """"""Output file %s; that was judged present and complete at the beginning of this; job is now missing. Replace it and invoke psi4 again.\n\n"""""" % (outfile). # return file contents in instructions; return isOk, instructions, reapings. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:21739,Energy Efficiency,energy,energy,21739,"NT GRADIENT', 'CURRENT MOLECULE']); if not isOk:; raise ValidationError(msg). fje = results['CURRENT ENERGY']; fjgrd = results['CURRENT GRADIENT']; fjdip = [item / p4const.psi_dipmom_au2debye for item in results['CURRENT DIPOLE']]; c4mol = qcdb.Molecule(results['CURRENT MOLECULE']); c4mol.update_geometry(). # C: Run the job and collect results; else:; # Prepare Cfour skeleton calc directory; os.chdir(scrdir + c4scrdir) # psi_scratch/cfour; if os.path.exists('scr.' + item):; shutil.rmtree('scr.' + item); os.mkdir('scr.' + item); os.chdir('scr.' + item) # psi_scratch/cfour/scr.000-004; with open('ZMAT', 'w') as handle:; handle.write(zmat); shutil.copy2('../harm/GENBAS', 'GENBAS'). #os.chdir(scrdir + '/scr.' + item); #run_cfour_module('xja2fja'); #with open('FJOBARC', 'r') as handle:; # fjobarc = handle.read(). # Run Cfour calc using ZMAT & GENBAS in scratch, outdir redirects to outfile; os.chdir(outdir) # current_directory; psi4.get_active_molecule().set_name('blank_molecule_psi4_yo'); energy('cfour', path=c4scrdir + '/scr.' + item); # os.chdir(scrdir + '/scr.' + item). fje = psi4.get_variable('CURRENT ENERGY'); fjgrd = p4util.mat2arr(psi4.get_gradient()); fjdip = [psi4.get_variable('CURRENT DIPOLE X') / p4const.psi_dipmom_au2debye,; psi4.get_variable('CURRENT DIPOLE Y') / p4const.psi_dipmom_au2debye,; psi4.get_variable('CURRENT DIPOLE Z') / p4const.psi_dipmom_au2debye]; c4mol = qcdb.Molecule(psi4.get_active_molecule().create_psi4_string_from_molecule()); c4mol.update_geometry(). # Get map btwn ZMAT and C4 orientation, then use it, grad and dipole to forge FJOBARC file; fjobarc = qcdb.cfour.format_fjobarc(fje,; *qcdb.cfour.backtransform(chgeMol=zmmol, permMol=c4mol), gradient=fjgrd, dipole=fjdip). # Psi4 for gradients; else:; # Prepare Cfour skeleton calc directory; os.chdir(scrdir + c4scrdir) # psi_scratch/cfour; if os.path.exists('scr.' + item):; shutil.rmtree('scr.' + item); os.mkdir('scr.' + item); os.chdir('scr.' + item) # psi_scratch/cfour/scr.000-004; with open",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:1195,Integrability,interface,interface,1195,"r; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import inspect; import glob; import shelve; import datetime; import difflib; #from driver import *; # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. [docs]def run_cfour_module(xmod):; # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:1930,Integrability,wrap,wrappers,1930,"should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import inspect; import glob; import shelve; import datetime; import difflib; #from driver import *; # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. [docs]def run_cfour_module(xmod):; # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:2899,Integrability,message,message,2899,", or aliases into this file. [docs]def run_cfour_module(xmod):; # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message) . c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; #if psi4.outfile_name() == 'stdout':; # sys.stdout.write(data); #else:; # p4out.write(data); # p4out.flush(); c4out += data; #internal_p4c4_info['output'] = c4out; return c4out. [docs]def vpt2(name, **kwargs):; """"""Perform vibrational second-order perturbation computation through; Cfour to get anharmonic frequencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently us",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:3024,Integrability,message,message,3024,"ironment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message) . c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; #if psi4.outfile_name() == 'stdout':; # sys.stdout.write(data); #else:; # p4out.write(data); # p4out.flush(); c4out += data; #internal_p4c4_info['output'] = c4out; return c4out. [docs]def vpt2(name, **kwargs):; """"""Perform vibrational second-order perturbation computation through; Cfour to get anharmonic frequencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4485,Integrability,wrap,wrapper,4485,"d pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_directory + '/' + os.path.splitext(psi4.outfil",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4857,Integrability,rout,route,4857,"y a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_directory + '/' + os.path.splitext(psi4.outfile_name())[0] + '.shelf', writeback=True). # Cfour keywords to request vpt2 analysis through findif gradients; psi4.set_local_option('CFOUR', 'CFOUR_VIBRATION', 'FINDIF'); psi4.set_local_option('CFOUR', 'CFOUR_FREQ_ALGORITHM', 'PARALLEL'); psi4.set_local_option('CFOUR', 'CFOUR_ANH_ALGORITHM', 'PARALLEL'); psi4.set_local_option('CFOUR', 'CFOUR_ANHARMONIC', 'VPT2'); psi4.set_local_option('CFOUR', 'CFOUR_FD_PROJECT', 'OFF'). # When ",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:29699,Integrability,message,messages,29699,"leted'; if reap_job_validate is not None:; isOkJob, msg, temp = reap_job_validate(dir, prefix, job, linkage, keys); if isOkJob:; formatArgs[4] = '& Validated'; else:; isOk = False; msgError += msg; formatArgs[4] = 'INVALID'; break; else:; isOk = False; formatArgs[2] = 'Running'; elif os.path.isfile(fjafile):; formatArgs[3] = 'Completed'; else:; isOk = False; formatArgs[1] = 'Waiting'; instructions += """""" {0:<27} {1:^10} {2:^10} {3:^10} {4:^10}\n"""""".format(*formatArgs); instructions += '\n' + msgError + '\n\n'. return isOk, instructions. [docs]def reap_job_validate(dir, prefix, item, linkage, keys):; """"""For a given output file whose path is constructed with; *dir* + '/' + *prefix* + '-' + *item* + '.out', tests that the file; exists and has *prefix* RESULTS lines for each piece of information; requested in list *keys* and that those lines correspond to the; appropriate *linkage* and *item*. Returns *keys* along with their; scanned values in dict *reapings*, along with error and success; messages in *instructions* and a boolean *isOk* indicating whether; all *keys* reaped sucessfully. """"""; isOk = True; instructions = ''; reapings = {}; outfile = dir + '/' + prefix + '-' + item + '.out'. try:; with open(outfile, 'r') as handle:; for line in handle:; if line.find(prefix + ' RESULT:') == 0:; sline = line.split(); if sline[2:7] == ['linkage', str(linkage), 'for', 'item', item]:; yieldsAt = line.find('yields'); beingAt = line.find('being'); if beingAt > yieldsAt > -1:; key = line[yieldsAt + 6:beingAt].strip(); val = line[beingAt + 5:].strip(); if key in keys:; reapings[key] = eval(val); #psi4.print_out(' CFOUR scratch file %s for %s has been read\n' % ('JOBARC', zm12)); else:; isOk = False; instructions += """"""Outfile file %s; has corrupted sowreap result line:\n%s\n\n"""""" % (outfile, line); else:; isOk = False; instructions += """"""Outfile file %s; has sowreap result of either incompatible linkage (observed: %s, expected: %s); or incompatible job affiliation (observed: %s, exp",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:2061,Modifiability,variab,variables,2061,"to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import inspect; import glob; import shelve; import datetime; import difflib; #from driver import *; # Relative hack for now; import os, sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); from p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. [docs]def run_cfour_module(xmod):; # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_srcdir() + '/share/basis',; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(messag",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:4426,Safety,recover,recovery,4426,"uencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad. - S/R C4grad. - C P4grad. - C C4grad. - switch C --> S/R with recovery using shelf. - pure C mode where only need P4 for wrapper. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['BASIS']). # Option mode of operation- whether vpt2 run in one job or files farmed out; if not('vpt2_mode' in kwargs):; if ('mode' in kwargs):; kwargs['vpt2_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['vpt2_mode'] = 'continuous'. # Switches for route through code- S/R or continuous & Psi4 or Cfour gradients; isSowReap = True if kwargs['vpt2_mode'].lower() == 'sowreap' else False; isC4notP4 = bool(re.match('cfour', lowername)) or bool(re.match('c4-', lowername)); isC4fully = True if ('c4full' in kwargs and yes.match(str(kwargs['c4full'])) and isC4notP4 and isSowReap) else False. # Save submission directory and basis set; current_directory = os.getcwd(); user_basis = psi4.get_global_option('BASIS'). # Open data persistence shelf- vital for sowreap, checkpoint for continuouw; shelf = shelve.open(current_",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:28151,Security,validat,validated,28151,"be as given below (default). """"""; step4 = """"""; (4) Reap; ---------; Gather all the resulting output files in this directory along with the; three read-only files from (0). Invoke psi4 again. The job will be; trivial in length (unless sto-3g integrals on the molecule are costly); and give results for the harmonic and anharmonic frequency stages in this; output file. psi4 %-27s %-27s. """""" % (os.path.splitext(psi4.outfile_name())[0] + '.in', psi4.outfile_name()). if stage == 'harmonic':; instructions = step0 + step1 + stepFiles + step2; elif stage == 'anharmonic':; instructions = step0 + step3 + stepFiles + step4. return instructions. [docs]def sown_jobs_status(dir, prefix, zmats, validate_func=None, linkage=None, keys=None):; """"""Evaluate the output file status of jobs in *zmats* which should; exist at *dir* + '/' + prefix + '-' + job + '.out'. Returns string with; formatted summary of job status and boolean of whether all complete.; Return boolean *isOk* signals whether all *zmats* have completed and,; if *validate_func* present, are validated. """"""; isOk = True; msgError = ''; instructions = '\n'; instructions += p4util.banner(prefix + ' Status: ' + datetime.datetime.now().strftime(""%Y-%m-%d %H:%M""), strNotOutfile=True); instructions += '\n'; for job in sorted(zmats):; outfile = dir + '/' + prefix + '-' + job + '.out'; fjafile = dir + '/' + prefix + '-' + job + '.fja'; formatArgs = [prefix + '-' + job, '', '', '', '']; if os.path.isfile(outfile):; with open(outfile, 'r') as handle:; for line in handle:; if line.find('Buy a developer a beer!') > -1:; formatArgs[3] = 'Completed'; if reap_job_validate is not None:; isOkJob, msg, temp = reap_job_validate(dir, prefix, job, linkage, keys); if isOkJob:; formatArgs[4] = '& Validated'; else:; isOk = False; msgError += msg; formatArgs[4] = 'INVALID'; break; else:; isOk = False; formatArgs[2] = 'Running'; elif os.path.isfile(fjafile):; formatArgs[3] = 'Completed'; else:; isOk = False; formatArgs[1] = 'Waiting'; instructions += """"",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:29412,Testability,test,tests,29412," = [prefix + '-' + job, '', '', '', '']; if os.path.isfile(outfile):; with open(outfile, 'r') as handle:; for line in handle:; if line.find('Buy a developer a beer!') > -1:; formatArgs[3] = 'Completed'; if reap_job_validate is not None:; isOkJob, msg, temp = reap_job_validate(dir, prefix, job, linkage, keys); if isOkJob:; formatArgs[4] = '& Validated'; else:; isOk = False; msgError += msg; formatArgs[4] = 'INVALID'; break; else:; isOk = False; formatArgs[2] = 'Running'; elif os.path.isfile(fjafile):; formatArgs[3] = 'Completed'; else:; isOk = False; formatArgs[1] = 'Waiting'; instructions += """""" {0:<27} {1:^10} {2:^10} {3:^10} {4:^10}\n"""""".format(*formatArgs); instructions += '\n' + msgError + '\n\n'. return isOk, instructions. [docs]def reap_job_validate(dir, prefix, item, linkage, keys):; """"""For a given output file whose path is constructed with; *dir* + '/' + *prefix* + '-' + *item* + '.out', tests that the file; exists and has *prefix* RESULTS lines for each piece of information; requested in list *keys* and that those lines correspond to the; appropriate *linkage* and *item*. Returns *keys* along with their; scanned values in dict *reapings*, along with error and success; messages in *instructions* and a boolean *isOk* indicating whether; all *keys* reaped sucessfully. """"""; isOk = True; instructions = ''; reapings = {}; outfile = dir + '/' + prefix + '-' + item + '.out'. try:; with open(outfile, 'r') as handle:; for line in handle:; if line.find(prefix + ' RESULT:') == 0:; sline = line.split(); if sline[2:7] == ['linkage', str(linkage), 'for', 'item', item]:; yieldsAt = line.find('yields'); beingAt = line.find('being'); if beingAt > yieldsAt > -1:; key = line[yieldsAt + 6:beingAt].strip(); val = line[beingAt + 5:].strip(); if key in keys:; reapings[key] = eval(val); #psi4.print_out(' CFOUR scratch file %s for %s has been read\n' % ('JOBARC', zm12)); else:; isOk = False; instructions += """"""Outfile file %s; has corrupted sowreap result line:\n%s\n\n"""""" % (outfile",MatchSource.WIKI,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:4974,Deployability,install,installed,4974,"to add basis *fit* as associated fitting basis; member *jdef* to a BasisFamily object. """"""; self.jdef = sanitize_basisname(fit). [docs] def add_jkfit_default(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *jkdef* to a BasisFamily object. """"""; self.jkdef = sanitize_basisname(fit). [docs] def add_rifit_default(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *ridef* to a BasisFamily object. """"""; self.ridef = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:5379,Deployability,install,installed,5379," *fit* as associated fitting basis; member *ridef* to a BasisFamily object. """"""; self.ridef = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if role == 'ORNATE':; return fam.ornate; elif role == 'BASIS' or role == 'ORBITAL':; return fam.orbital; elif role == 'JFIT':; return fam.jfit; elif role == 'JKFIT':; return fam.jkfit; elif role == 'RIFIT':; return fam.rifit; elif role == 'DUALFIT':; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:5670,Deployability,install,installed,5670,"return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if role == 'ORNATE':; return fam.ornate; elif role == 'BASIS' or role == 'ORBITAL':; return fam.orbital; elif role == 'JFIT':; return fam.jfit; elif role == 'JKFIT':; return fam.jkfit; elif role == 'RIFIT':; return fam.rifit; elif role == 'DUALFIT':; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:6391,Deployability,update,updated,6391,"return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if role == 'ORNATE':; return fam.ornate; elif role == 'BASIS' or role == 'ORBITAL':; return fam.orbital; elif role == 'JFIT':; return fam.jfit; elif role == 'JKFIT':; return fam.jkfit; elif role == 'RIFIT':; return fam.rifit; elif role == 'DUALFIT':; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:4888,Performance,load,load,4888,"to add basis *fit* as associated fitting basis; member *jdef* to a BasisFamily object. """"""; self.jdef = sanitize_basisname(fit). [docs] def add_jkfit_default(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *jkdef* to a BasisFamily object. """"""; self.jkdef = sanitize_basisname(fit). [docs] def add_rifit_default(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *ridef* to a BasisFamily object. """"""; self.ridef = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:5586,Security,validat,validate,5586,"return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if role == 'ORNATE':; return fam.ornate; elif role == 'BASIS' or role == 'ORBITAL':; return fam.orbital; elif role == 'JFIT':; return fam.jfit; elif role == 'JKFIT':; return fam.jkfit; elif role == 'RIFIT':; return fam.rifit; elif role == 'DUALFIT':; return fam.dualfit; return None. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislist.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislistdunning.html:29959,Deployability,update,updated,29959,"); basisfamily_list.append(basis_marccpcv_6pd_z); basis_febccpv6z = BasisFamily('feb-cc-pV6Z'); basisfamily_list.append(basis_febccpv6z); basis_febccpv_6pd_z = BasisFamily('feb-cc-pV(6+d)Z'); basisfamily_list.append(basis_febccpv_6pd_z); basis_febccpcv6z = BasisFamily('feb-cc-pCV6Z'); basisfamily_list.append(basis_febccpcv6z); basis_febccpcv_6pd_z = BasisFamily('feb-cc-pCV(6+d)Z'); basisfamily_list.append(basis_febccpcv_6pd_z); basis_daugccpv6z = BasisFamily('d-aug-cc-pV6Z'); basisfamily_list.append(basis_daugccpv6z); basis_daugccpcv6z = BasisFamily('d-aug-cc-pCV6Z'); basisfamily_list.append(basis_daugccpcv6z); basis_ccpv6z.add_rifit('cc-pV6Z-RI'); basis_ccpv_6pd_z.add_rifit('cc-pV6Z-RI'); basis_augccpv6z.add_rifit('aug-cc-pV6Z-RI'); basis_augccpv_6pd_z.add_rifit('aug-cc-pV6Z-RI'); basis_heavyaugccpv6z.add_rifit('heavy-aug-cc-pV6Z-RI'); basis_heavyaugccpv_6pd_z.add_rifit('heavy-aug-cc-pV6Z-RI'); basis_junccpv6z.add_rifit('jun-cc-pV6Z-RI'); basis_junccpv_6pd_z.add_rifit('jun-cc-pV6Z-RI'); basis_mayccpv6z.add_rifit('may-cc-pV6Z-RI'); basis_mayccpv_6pd_z.add_rifit('may-cc-pV6Z-RI'); basis_aprccpv6z.add_rifit('apr-cc-pV6Z-RI'); basis_aprccpv_6pd_z.add_rifit('apr-cc-pV6Z-RI'); basis_marccpv6z.add_rifit('mar-cc-pV6Z-RI'); basis_marccpv_6pd_z.add_rifit('mar-cc-pV6Z-RI'); basis_febccpv6z.add_rifit('feb-cc-pV6Z-RI'); basis_febccpv_6pd_z.add_rifit('feb-cc-pV6Z-RI'); basis_ccpvtz.add_dualfit('cc-pvtz-dual'); basis_ccpvqz.add_dualfit('cc-pvqz-dual'); basis_augccpvdz.add_dualfit('aug-cc-pvdz-dual'); basis_augccpvtz.add_dualfit('aug-cc-pvtz-dual'); basis_augccpvqz.add_dualfit('aug-cc-pvqz-dual'); basis_heavyaugccpvtz.add_dualfit('heavy-aug-cc-pvtz-dual'); basis_heavyaugccpvqz.add_dualfit('heavy-aug-cc-pvqz-dual'). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislistdunning.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislistdunning.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislistother.html:17809,Deployability,update,updated,17809,"t('heavy-aug-cc-pvtz-ri'). basis_6311ppg.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_d_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_d_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppgs.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppgss.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2d_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_2df_2pd_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_2p_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_2pd_.add_jkfit('aug-cc-pvtz-jkfit'); basis_6311ppg_3df_3pd_.add_jkfit('aug-cc-pvtz-jkfit'). basis_6311ppg.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_d_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_d_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppgs.add_rifit('aug-cc-pvtz-ri'); basis_6311ppgss.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2d_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_2df_2pd_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_2p_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_2pd_.add_rifit('aug-cc-pvtz-ri'); basis_6311ppg_3df_3pd_.add_rifit('aug-cc-pvtz-ri'). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislistother.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislistother.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislistother.html:10973,Security,validat,validated,10973,d(basis_def2qzvpd); basisfamily_list.append(basis_def2qzvpp); basisfamily_list.append(basis_def2qzvppd). # Others; basis_dz = BasisFamily('DZ'); basis_dzp = BasisFamily('DZP'); basis_dzvp = BasisFamily('DZVP'); basis_psi3dzp = BasisFamily('psi3-DZP'); basis_psi3tz2p = BasisFamily('psi3-TZ2P'); basis_psi3tz2pf = BasisFamily('psi3-TZ2PF'); basis_sadlejlpoldl = BasisFamily('sadlej-lpol-dl'); basis_sadlejlpolds = BasisFamily('sadlej-lpol-ds'); basis_sadlejlpolfl = BasisFamily('sadlej-lpol-fl'); basis_sadlejlpolfs = BasisFamily('sadlej-lpol-fs'). basisfamily_list.append(basis_dz); basisfamily_list.append(basis_dzp); basisfamily_list.append(basis_dzvp); basisfamily_list.append(basis_psi3dzp); basisfamily_list.append(basis_psi3tz2p); basisfamily_list.append(basis_psi3tz2pf); basisfamily_list.append(basis_sadlejlpoldl); basisfamily_list.append(basis_sadlejlpolds); basisfamily_list.append(basis_sadlejlpolfl); basisfamily_list.append(basis_sadlejlpolfs). # Here lie practical (non-validated) fitting bases for; # Pople orbital basis sets. basis_sto3g.add_jkfit('cc-pvdz-ri'); basis_sto3g.add_rifit('cc-pvdz-ri'); basis_321g.add_jkfit('cc-pvdz-ri'); basis_321g.add_rifit('cc-pvdz-ri'). basis_631g.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_p_.add_jkfit('cc-pvdz-jkfit'); basis_631gs.add_jkfit('cc-pvdz-jkfit'); basis_631gss.add_jkfit('cc-pvdz-jkfit'); basis_631g.add_rifit('cc-pvdz-ri'); basis_631g_d_.add_rifit('cc-pvdz-ri'); basis_631g_d_p_.add_rifit('cc-pvdz-ri'); basis_631gs.add_rifit('cc-pvdz-ri'); basis_631gss.add_rifit('cc-pvdz-ri'). basis_631pg.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_p_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgs.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgss.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_p_.add_rifit('heavy-aug-cc-pvdz-ri'); basi,MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/basislistother.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislistother.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:17855,Availability,error,error,17855,"ymbol Number X Y Z' + r'\s*' +; r'^\s+(?:-+)\s*' +; r'((?:\s+[A-Z]+\s+[0-9]+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s*\n)+)' +; r'^\s+(?:-+)\s*',; outtext, re.MULTILINE); if mobj:; print('matched geom'); molxyz = '%d bohr\n\n' % len(mobj.group(1).splitlines()); for line in mobj.group(1).splitlines():; lline = line.split(); molxyz += '%s %16s %16s %16s\n' % (lline[0], lline[-3], lline[-2], lline[-1]); # Rather a dinky Molecule as no ghost, charge, or multiplicity; psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process atom geometry; mobj = re.search(; r'^\s+' + r'@GETXYZ-I, 1 atoms read from ZMAT.' + r'\s*' +; r'^\s+' + r'[0-9]+\s+([A-Z]+)\s+[0-9]+\s+' + NUMBER + r'\s*',; outtext, re.MULTILINE); if mobj:; print('matched atom'); # Dinky Molecule; molxyz = '1 bohr\n\n%s 0.0 0.0 0.0\n' % (mobj.group(1)); psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process error codes; mobj = re.search(; r'^\s*' + r'--executable ' + r'(\w+)' + r' finished with status' + r'\s+' + r'([1-9][0-9]*)',; outtext, re.MULTILINE); if mobj:; print('matched error'); psivar['CFOUR ERROR CODE'] = mobj.group(2). # Process CURRENT energies (TODO: needs better way); if 'SCF TOTAL ENERGY' in psivar:; psivar['CURRENT REFERENCE ENERGY'] = psivar['SCF TOTAL ENERGY']; psivar['CURRENT ENERGY'] = psivar['SCF TOTAL ENERGY']. if 'MP2 TOTAL ENERGY' in psivar and 'MP2 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP2 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP2 TOTAL ENERGY']. if 'MP3 TOTAL ENERGY' in psivar and 'MP3 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP3 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP3 TOTAL ENERGY']. if 'MP4 TOTAL ENERGY' in psivar and 'MP4 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP4 CORRELATION ENERGY']; psivar['CURRENT ENERGY",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:18031,Availability,error,error,18031,"LINE); if mobj:; print('matched geom'); molxyz = '%d bohr\n\n' % len(mobj.group(1).splitlines()); for line in mobj.group(1).splitlines():; lline = line.split(); molxyz += '%s %16s %16s %16s\n' % (lline[0], lline[-3], lline[-2], lline[-1]); # Rather a dinky Molecule as no ghost, charge, or multiplicity; psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process atom geometry; mobj = re.search(; r'^\s+' + r'@GETXYZ-I, 1 atoms read from ZMAT.' + r'\s*' +; r'^\s+' + r'[0-9]+\s+([A-Z]+)\s+[0-9]+\s+' + NUMBER + r'\s*',; outtext, re.MULTILINE); if mobj:; print('matched atom'); # Dinky Molecule; molxyz = '1 bohr\n\n%s 0.0 0.0 0.0\n' % (mobj.group(1)); psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process error codes; mobj = re.search(; r'^\s*' + r'--executable ' + r'(\w+)' + r' finished with status' + r'\s+' + r'([1-9][0-9]*)',; outtext, re.MULTILINE); if mobj:; print('matched error'); psivar['CFOUR ERROR CODE'] = mobj.group(2). # Process CURRENT energies (TODO: needs better way); if 'SCF TOTAL ENERGY' in psivar:; psivar['CURRENT REFERENCE ENERGY'] = psivar['SCF TOTAL ENERGY']; psivar['CURRENT ENERGY'] = psivar['SCF TOTAL ENERGY']. if 'MP2 TOTAL ENERGY' in psivar and 'MP2 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP2 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP2 TOTAL ENERGY']. if 'MP3 TOTAL ENERGY' in psivar and 'MP3 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP3 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP3 TOTAL ENERGY']. if 'MP4 TOTAL ENERGY' in psivar and 'MP4 CORRELATION ENERGY' in psivar:; psivar['CURRENT CORRELATION ENERGY'] = psivar['MP4 CORRELATION ENERGY']; psivar['CURRENT ENERGY'] = psivar['MP4 TOTAL ENERGY']. # if ('%s TOTAL ENERGY' % (mobj.group('fullCC')) in psivar) and \; # ('%s CORRELATION ENERGY' % (mobj.group('fullCC')) in psivar):; # psivar",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:31094,Availability,avail,available,31094,"rumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'ZERO'; elif dertype == 1:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'FIRST'; elif dertype == 2:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'SECOND'; else:; raise ValidationError(""""""Requested Cfour dertype %d is not available."""""" % (dertype)). if lowername == 'cfour':; pass; elif lowername == 'c4-scf':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'SCF'. elif lowername == 'c4-mp2':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP2'. elif lowername == 'c4-mp3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP3'. elif lowername == 'c4-mp4(sdq)':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'SDQ-MP4'. elif lowername == 'c4-mp4':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP4'. elif lowername == 'c4-cc2':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC2'. elif lowername == 'c4-ccsd':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-cc3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC3'. elif lowername ==",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:32370,Availability,avail,available,32370,"me == 'c4-mp3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP3'. elif lowername == 'c4-mp4(sdq)':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'SDQ-MP4'. elif lowername == 'c4-mp4':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'MP4'. elif lowername == 'c4-cc2':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC2'. elif lowername == 'c4-ccsd':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-cc3':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CC3'. elif lowername == 'c4-ccsd(t)':; # Can't use (T) b/c bug in xsymcor lops it off; #options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD(T)'; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD[T]'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-ccsdt':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSDT'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # Set clobbering; if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. [docs]def cfour_list():; """"""Return an array of Cfour methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_gradient_list():; """"""Return an array of Cfour methods with ana",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:40293,Deployability,update,updated,40293,"t)); # oriElem = p4c4.transform_elementlist(p4Elem); # oriElemMap = p4c4.Catommap; # oriDip = p4c4.transform_vector(p4Dip); #; # #print p4c4; # #print ' <<< Input C4 Mol >>>'; # #c4Mol.print_out(); # #print ' <<< Input P4 Mol >>>'; # #p4Mol.print_out(); # #print ' <<< Input P4 Grad >>>'; # #if p4Grd is not None:; # # for item in p4Grd:; # # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); # #print ' <<< Rotated P4 Coord >>>'; # #if oriCoord is not None:; # # for item in oriCoord:; # # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); # #print ' <<< Rotated P4 Elem >>>'; # #if oriElem is not None:; # # for item in oriElem :; # # print(' %16.8f' % (item)); # #print ' <<< Rotated P4 Dip >>>'; # #if oriDip is not None:; # # print(' %16.8f %16.8f %16.8f' % (oriDip[0], oriDip[1], oriDip[2])); # #print ' <<< Rotated P4 Grad >>>'; # #if oriGrad is not None:; # # for item in oriGrad:; # # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); #; # return oriElemMap, oriElem, oriCoord, oriGrad, oriDip; # #return oriElem, oriCoord, oriGrad, oriElemMap, oriDip. [docs]def jajo2mol(jajodic):; """"""Returns a Molecule from entries in dictionary *jajodic* extracted; from JAINDX and JOBARC. """"""; map = jajodic['MAP2ZMAT']; elem = jajodic['ATOMCHRG']; coord = jajodic['COORD ']; Nat = len(elem). molxyz = '%d bohr\n\n' % (Nat); # TODO chgmult, though not really necessary for reorientation; for at in range(Nat):; posn = map[at] - 1; el = 'GH' if elem[posn] == 0 else z2el[elem[posn]]; posn *= 3; molxyz += '%s %21.15f %21.15f %21.15f\n' % (el, coord[posn], coord[posn + 1], coord[posn + 2]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:2867,Energy Efficiency,energy,energy,2867,"var, c4grad; #print '\n\nxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n'. retindx = -1 if pass_coord[-1] else -2. # print ' <<< C4 PSIVAR >>>'; # for item in pass_psivar[retindx]:; # print(' %30s %16.8f' % (item, pass_psivar[retindx][item])); # print ' <<< C4 COORD >>>'; # for item in pass_coord[retindx]:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); # print ' <<< C4 GRAD >>>'; # for item in pass_grad[retindx]:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). return pass_psivar[retindx], pass_coord[retindx], pass_grad[retindx]. [docs]def harvest_outfile_pass(outtext):; """"""Function to read CFOUR output file *outtext* and parse important; quantum chemical information from it in. """"""; psivar = PreservingDict(); psivar_coord = None; psivar_grad = None. # TODO: BCC; # CI; # QCISD(T); # other ROHF tests; # vcc/ecc. NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))"". # Process NRE; mobj = re.search(r'^\s+' + r'(?:Nuclear repulsion energy :)' + r'\s+' + NUMBER + r'\s+a\.u\.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched nre'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # Process SCF; mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched scf1'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\)=)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; print('matched scf2'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). mobj = re.search(; r'^\s+' + r'(?:SCF has converged.)' + r'\s*$' +; r'(?:.*?)' +; r'^\s+' + r'(?:\d+)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched scf3'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:3949,Energy Efficiency,energy,energy,3949,"rint('matched nre'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # Process SCF; mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched scf1'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\)=)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; print('matched scf2'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). mobj = re.search(; r'^\s+' + r'(?:SCF has converged.)' + r'\s*$' +; r'(?:.*?)' +; r'^\s+' + r'(?:\d+)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched scf3'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2r'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = 2 * Decimal(mobj.group(1)); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = mobj.group(2); psivar['MP2 CORRELATION ENERGY'] = 2 * Decimal(mobj.group(1)) + Decimal(mobj.group(2)); psivar['MP2 TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(BB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2u'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(2)); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 CORRELATION ENERGY'] = Decimal(mobj.gr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:4638,Energy Efficiency,energy,energy,4638,"); psivar['SCF TOTAL ENERGY'] = mobj.group(1). # Process MP2; mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2r'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = 2 * Decimal(mobj.group(1)); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = mobj.group(2); psivar['MP2 CORRELATION ENERGY'] = 2 * Decimal(mobj.group(1)) + Decimal(mobj.group(2)); psivar['MP2 TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(BB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2u'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(2)); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 CORRELATION ENERGY'] = Decimal(mobj.group(1)) + \; Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['MP2 TOTAL ENERGY'] = mobj.group(5). mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(BB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(SINGLE\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2ro'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(2)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:5443,Energy Efficiency,energy,energy,5443,"s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2u'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(2)); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 CORRELATION ENERGY'] = Decimal(mobj.group(1)) + \; Decimal(mobj.group(2)) + Decimal(mobj.group(3)); psivar['MP2 TOTAL ENERGY'] = mobj.group(5). mobj = re.search(; r'^\s+' + r'(?:E2\(AA\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(BB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(AB\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(SINGLE\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:E2\(TOT\))' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'(?:Total MP2 energy)' + r'\s+=\s+' + NUMBER + r'\s+a.u.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched mp2ro'); psivar['MP2 SAME-SPIN CORRELATION ENERGY'] = Decimal(mobj.group(1)) + Decimal(mobj.group(2)); psivar['MP2 OPPOSITE-SPIN CORRELATION ENERGY'] = mobj.group(3); psivar['MP2 SINGLES ENERGY'] = mobj.group(4); psivar['MP2 CORRELATION ENERGY'] = Decimal(mobj.group(1)) + \; Decimal(mobj.group(2)) + Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['MP2 TOTAL ENERGY'] = mobj.group(6). # Process MP3; mobj = re.search(; r'^\s+' + r'(?:D-MBPT\(2\))' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*' +; r'^\s+' + r'(?:D-MBPT\(3\))' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched mp3r'); dmp2 = Decimal(mobj.group(1)); dmp3 = Decimal(mobj.group(3)); psivar['MP2 CORRELATION ENERGY'] = dmp2; psivar['MP2 TOTAL ENERGY'] = mobj.group(2); psivar['MP3 CORRELATION ENERGY'] = dmp2 + dmp3; psivar['MP3 TOTAL ENERGY'] = mobj.group(4); psivar['MP2.5 C",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:11755,Energy Efficiency,energy,energy,11755," +; r'^\s+' + r'(?:NL-MBPT\(4\))' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*' +; r'^\s+' + r'(?:WT12-MBPT\(4\))' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*' +; r'^\s+' + r'(?:T-MBPT\(4\))' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched mp4tro'); dmp4sdq = Decimal(mobj.group(1)) + Decimal(mobj.group(3)); dmp4t = Decimal(mobj.group(5)) + Decimal(mobj.group(7)) # TODO: WT12 with T, not SDQ?; psivar['MP4(SDQ) CORRELATION ENERGY'] = psivar['MP3 CORRELATION ENERGY'] + dmp4sdq; psivar['MP4(SDQ) TOTAL ENERGY'] = mobj.group(4); psivar['MP4(T) CORRECTION ENERGY'] = dmp4t; psivar['MP4(SDTQ) CORRELATION ENERGY'] = psivar['MP3 CORRELATION ENERGY'] + dmp4sdq + dmp4t; psivar['MP4(SDTQ) TOTAL ENERGY'] = mobj.group(8); psivar['MP4 CORRELATION ENERGY'] = psivar['MP4(SDTQ) CORRELATION ENERGY']; psivar['MP4 TOTAL ENERGY'] = psivar['MP4(SDTQ) TOTAL ENERGY']. # Process CC Iterations; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:\d+)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+DIIS\s*' +; r'^\s*(?:-+)\s*' +; r'^\s*(?:A miracle (?:has come|come) to pass. The CC iterations have converged.)\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched cc with full %s iterating %s' % (mobj.group('fullCC'), mobj.group('iterCC'))); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(3); psivar['%s TOTAL ENERGY' % (mobj.group('iterCC'))] = mobj.group(4). # Process CC(T); mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\))' + r'\s+=\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\(T\)\))' + r'\s+=\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) vcc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = D",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13036,Energy Efficiency,energy,energy,13036,"ched cc with full %s iterating %s' % (mobj.group('fullCC'), mobj.group('iterCC'))); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(3); psivar['%s TOTAL ENERGY' % (mobj.group('iterCC'))] = mobj.group(4). # Process CC(T); mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\))' + r'\s+=\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\(T\)\))' + r'\s+=\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) vcc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['S",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13131,Energy Efficiency,energy,energy,13131,"iterCC'))] = mobj.group(3); psivar['%s TOTAL ENERGY' % (mobj.group('iterCC'))] = mobj.group(4). # Process CC(T); mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\))' + r'\s+=\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\(T\)\))' + r'\s+=\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) vcc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13216,Energy Efficiency,energy,energy,13216,"iterCC'))] = mobj.group(3); psivar['%s TOTAL ENERGY' % (mobj.group('iterCC'))] = mobj.group(4). # Process CC(T); mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\))' + r'\s+=\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\(T\)\))' + r'\s+=\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) vcc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13644,Energy Efficiency,energy,energy,13644,"ivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4))",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13728,Energy Efficiency,energy,energy,13728,"ivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4))",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:14216,Energy Efficiency,energy,energy,14216,"r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The B",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:14947,Energy Efficiency,energy,energy,14947," Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The BB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The AB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The total correlation energy is\s+' + NUMBER + r'\s+a.u.\s*' +; r'(?:.*?)' +; #r'^\s+' + r'The CC iterations have converged.' + r'\s*$',; r'^\s+' + r'(?:A miracle come to pass. )?' + r'The CC iterations have converged.' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS components; print('matched scscc2'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:15131,Energy Efficiency,energy,energy,15131,"ess SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The BB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The AB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The total correlation energy is\s+' + NUMBER + r'\s+a.u.\s*' +; r'(?:.*?)' +; #r'^\s+' + r'The CC iterations have converged.' + r'\s*$',; r'^\s+' + r'(?:A miracle come to pass. )?' + r'The CC iterations have converged.' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS components; print('matched scscc2'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). # Process gradient; mobj = re.search(; r'\s+' + r'Molecular gradient' + r'\s*' +; r'\s+' + r'------------------' + r'\s*' +; r'\s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:15225,Energy Efficiency,energy,energy,15225,"+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The BB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The AB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The total correlation energy is\s+' + NUMBER + r'\s+a.u.\s*' +; r'(?:.*?)' +; #r'^\s+' + r'The CC iterations have converged.' + r'\s*$',; r'^\s+' + r'(?:A miracle come to pass. )?' + r'The CC iterations have converged.' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS components; print('matched scscc2'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). # Process gradient; mobj = re.search(; r'\s+' + r'Molecular gradient' + r'\s*' +; r'\s+' + r'------------------' + r'\s*' +; r'\s+' + r'\n' +; r'(?:(?:\s+[A-Z]+\s*#\d+\s+[xyz]\s+[-+]?\d+\.\d+\s*\n)+)' + # optional, it seems",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:15319,Energy Efficiency,energy,energy,15319,"rgies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The BB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The AB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The total correlation energy is\s+' + NUMBER + r'\s+a.u.\s*' +; r'(?:.*?)' +; #r'^\s+' + r'The CC iterations have converged.' + r'\s*$',; r'^\s+' + r'(?:A miracle come to pass. )?' + r'The CC iterations have converged.' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS components; print('matched scscc2'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). # Process gradient; mobj = re.search(; r'\s+' + r'Molecular gradient' + r'\s*' +; r'\s+' + r'------------------' + r'\s*' +; r'\s+' + r'\n' +; r'(?:(?:\s+[A-Z]+\s*#\d+\s+[xyz]\s+[-+]?\d+\.\d+\s*\n)+)' + # optional, it seems; r'\n\n' + # optional, it seems; r'((?:\s+[A-Z]+\s*#\d+\s+\d?\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:15396,Energy Efficiency,energy,energy,15396,"*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The BB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The AB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The total correlation energy is\s+' + NUMBER + r'\s+a.u.\s*' +; r'(?:.*?)' +; #r'^\s+' + r'The CC iterations have converged.' + r'\s*$',; r'^\s+' + r'(?:A miracle come to pass. )?' + r'The CC iterations have converged.' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS components; print('matched scscc2'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). # Process gradient; mobj = re.search(; r'\s+' + r'Molecular gradient' + r'\s*' +; r'\s+' + r'------------------' + r'\s*' +; r'\s+' + r'\n' +; r'(?:(?:\s+[A-Z]+\s*#\d+\s+[xyz]\s+[-+]?\d+\.\d+\s*\n)+)' + # optional, it seems; r'\n\n' + # optional, it seems; r'((?:\s+[A-Z]+\s*#\d+\s+\d?\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s*\n)+)' +; r'\n\n' +; r'\s+' + 'Molecular gradient norm',; outtext,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:17313,Energy Efficiency,charge,charge,17313,"\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s*\n)+)' +; r'\n\n' +; r'\s+' + 'Molecular gradient norm',; outtext, re.MULTILINE); if mobj:; print('matched molgrad'); atoms = []; psivar_grad = []; for line in mobj.group(1).splitlines():; lline = line.split(); atoms.append(lline[0]); #psivar_gradient.append([Decimal(lline[-3]), Decimal(lline[-2]), Decimal(lline[-1])]); psivar_grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]). # Process geometry; mobj = re.search(; # r'\s+(?:-+)\s*' +; # r'^\s+' + r'Z-matrix Atomic Coordinates (in bohr)' + r'\s*' +; r'^\s+' + r'Symbol Number X Y Z' + r'\s*' +; r'^\s+(?:-+)\s*' +; r'((?:\s+[A-Z]+\s+[0-9]+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s+[-+]?\d+\.\d+\s*\n)+)' +; r'^\s+(?:-+)\s*',; outtext, re.MULTILINE); if mobj:; print('matched geom'); molxyz = '%d bohr\n\n' % len(mobj.group(1).splitlines()); for line in mobj.group(1).splitlines():; lline = line.split(); molxyz += '%s %16s %16s %16s\n' % (lline[0], lline[-3], lline[-2], lline[-1]); # Rather a dinky Molecule as no ghost, charge, or multiplicity; psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process atom geometry; mobj = re.search(; r'^\s+' + r'@GETXYZ-I, 1 atoms read from ZMAT.' + r'\s*' +; r'^\s+' + r'[0-9]+\s+([A-Z]+)\s+[0-9]+\s+' + NUMBER + r'\s*',; outtext, re.MULTILINE); if mobj:; print('matched atom'); # Dinky Molecule; molxyz = '1 bohr\n\n%s 0.0 0.0 0.0\n' % (mobj.group(1)); psivar_coord = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). # Process error codes; mobj = re.search(; r'^\s*' + r'--executable ' + r'(\w+)' + r' finished with status' + r'\s+' + r'([1-9][0-9]*)',; outtext, re.MULTILINE); if mobj:; print('matched error'); psivar['CFOUR ERROR CODE'] = mobj.group(2). # Process CURRENT energies (TODO: needs better way); if 'SCF TOTAL ENERGY' in psivar:; psivar['CURRENT REFERENCE ENERGY'] = psivar['SCF TOTAL ENERGY']; psivar['CURRENT ENERGY'] = psivar['SCF",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:24036,Energy Efficiency,charge,charge,24036,"r item in oriCoord:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); #; # print ' <<< [1] C4-GRD-GRAD >>>'; # if grdGrad is not None:; # for item in grdGrad:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); # print ' <<< [2] C4-ORI-GRAD >>>'; # if oriGrad is not None:; # for item in oriGrad:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). retMol = None if p4Mol else grdMol. if oriDip:; outPsivar['CURRENT DIPOLE X'] = str(oriDip[0] * psi_dipmom_au2debye); outPsivar['CURRENT DIPOLE Y'] = str(oriDip[1] * psi_dipmom_au2debye); outPsivar['CURRENT DIPOLE Z'] = str(oriDip[2] * psi_dipmom_au2debye). if oriGrad:; retGrad = oriGrad; elif grdGrad:; retGrad = grdGrad; else:; retGrad = None. return outPsivar, retGrad, retMol. [docs]def harvest_GRD(grd):; """"""Parses the contents *grd* of the Cfour GRD file into the gradient; array and coordinate information. The coordinate info is converted; into a rather dinky Molecule (no charge, multiplicity, or fragment),; but this is these coordinates that govern the reading of molecule; orientation by Cfour. Return qcdb.Molecule and gradient array. """"""; grd = grd.splitlines(); Nat = int(grd[0].split()[0]); molxyz = '%d bohr\n\n' % (Nat). grad = []; for at in range(Nat):; mline = grd[at + 1].split(); el = 'GH' if int(float(mline[0])) == 0 else z2el[int(float(mline[0]))]; molxyz += '%s %16s %16s %16s\n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitline",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:24927,Energy Efficiency,charge,charge,24927,"d* of the Cfour GRD file into the gradient; array and coordinate information. The coordinate info is converted; into a rather dinky Molecule (no charge, multiplicity, or fragment),; but this is these coordinates that govern the reading of molecule; orientation by Cfour. Return qcdb.Molecule and gradient array. """"""; grd = grd.splitlines(); Nat = int(grd[0].split()[0]); molxyz = '%d bohr\n\n' % (Nat). grad = []; for at in range(Nat):; mline = grd[at + 1].split(); el = 'GH' if int(float(mline[0])) == 0 else z2el[int(float(mline[0]))]; molxyz += '%s %16s %16s %16s\n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25134,Energy Efficiency,charge,charge,25134,"lecule; orientation by Cfour. Return qcdb.Molecule and gradient array. """"""; grd = grd.splitlines(); Nat = int(grd[0].split()[0]); molxyz = '%d bohr\n\n' % (Nat). grad = []; for at in range(Nat):; mline = grd[at + 1].split(); el = 'GH' if int(float(mline[0])) == 0 else z2el[int(float(mline[0]))]; molxyz += '%s %16s %16s %16s\n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25379,Energy Efficiency,charge,charge,25379," == 0 else z2el[int(float(mline[0]))]; molxyz += '%s %16s %16s %16s\n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25411,Energy Efficiency,charge,charge,25411," == 0 else z2el[int(float(mline[0]))]; molxyz += '%s %16s %16s %16s\n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25444,Energy Efficiency,charge,charge,25444,"n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25453,Energy Efficiency,charge,charge,25453,"n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25468,Energy Efficiency,charge,charge,25468,"n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25481,Energy Efficiency,charge,charge,25481,"n' % (el, mline[-3], mline[-2], mline[-1]); lline = grd[at + 1 + Nat].split(); grad.append([float(lline[-3]), float(lline[-2]), float(lline[-1])]); mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol, grad. [docs]def harvest_zmat(zmat):; """"""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:25752,Energy Efficiency,charge,charge,25752,"""""""Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. """"""; zmat = zmat.splitlines()[1:] # skip comment line; Nat = 0; readCoord = True; isBohr = ''; charge = 0; mult = 1; molxyz = ''; cgeom = []; for line in zmat:; if line.strip() == '':; readCoord = False; elif readCoord:; lline = line.split(); molxyz += line + '\n'; Nat += 1; else:; if line.find('CHARGE') > -1:; idx = line.find('CHARGE'); charge = line[idx + 7:]; idxc = charge.find(','); if idxc > -1:; charge = charge[:idxc]; charge = int(charge); if line.find('MULTIPLICITY') > -1:; idx = line.find('MULTIPLICITY'); mult = line[idx + 13:]; idxc = mult.find(','); if idxc > -1:; mult = mult[:idxc]; mult = int(mult); if line.find('UNITS=BOHR') > -1:; isBohr = ' bohr'. molxyz = '%d%s\n%d %d\n' % (Nat, isBohr, charge, mult) + molxyz; mol = Molecule.init_with_xyz(molxyz, no_com=True, no_reorient=True, contentsNotFilename=True). return mol. [docs]def harvest_FCM(fcm):; """"""Parses the contents *fcm* of the Cfour FCMFINAL file into a hessian array. """"""; fcm = fcm.splitlines(); Nat = int(fcm[0].split()[0]); Ndof = int(fcm[0].split()[1]). empty = True; hess = []; for df in range(Ndof):; for at in range(Nat):; lline = fcm[Ndof * at + at + 1].split(); if empty:; if (abs(float(lline[0])) > 1.0e-8) or \; (abs(float(lline[1])) > 1.0e-8) or \; (abs(float(lline[2])) > 1.0e-8):; empty = False; fcm.append([float(lline[0]), float(lline[1]), float(lline[2])]). return None if empty else hess. [docs]def harvest_DIPOL(dipol):; """"""Parses the contents *dipol* of the Cfour DIPOL file into a dipol vector. """"""; dipol = dipol.splitlines(); lline = dipol[0].split(); dip = [float(lline[0]), float(lline[1]), float(lline[2])]. #return None if empty else dip; return dip. [docs]def muster_memory(mem):; """"""Transform input *",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:29976,Energy Efficiency,energy,energy,29976,"]['value']. if 'DAMPING_PERCENTAGE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_DAMPING']['value'] = \; int(10 * opt['SCF']['DAMPING_PERCENTAGE']['value']). for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = False; return text, options. # Philosophy break:; # Specification options; # Massaging options. # * No program's defaults should be tampered with w/o provokation. # want all defaults applied to all programs, so p4 scf_conv is 5 and c4 scf_conv is 5; # want separate regimes, so conv 6 covers all the p4 parts and cfour_conv = 8 covers the c4 parts; # want mixture, so basis gets applied to c4 but others don't; # first case, when options specified explicitly. # [scf][d_convergence] [cfour][cfour_scf_conv] what happens?; # 8 from opt() 7 by default; # 6 from set {...} 7 by default 6 (guideline that psi4 format converts when clear); # 8 from opt() 5 from set {...} 5 (local trumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'ZERO'; elif dertype == 1:; options['CFOUR']['CFOUR_DERIV_LEVEL']['value'] = 'FIRST'; elif dertype == 2:; options['CFOUR']['CFOUR_DERIV_LEVEL']['v",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:32967,Energy Efficiency,energy,energy,32967,"r lops it off; #options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD(T)'; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSD[T]'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. elif lowername == 'c4-ccsdt':; options['CFOUR']['CFOUR_CALC_LEVEL']['value'] = 'CCSDT'; options['CFOUR']['CFOUR_CC_PROGRAM']['value'] = 'ECC'. else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # Set clobbering; if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. [docs]def cfour_list():; """"""Return an array of Cfour methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_gradient_list():; """"""Return an array of Cfour methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_psivar_list():; """"""Return a dict with keys of most Cfour methods and values of dicts; with the PSI Variables returned by those methods. Used by cbs(); wrapper to avoid unnecessary computations in compound methods.; Result is appended to ``VARH``. """"""; VARH = {}; VARH['c4-",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:35752,Energy Efficiency,energy,energy,35752,"c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['c4-ccsd'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['c4-cc3'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['c4-ccsd(t)'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY',; 'c4-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['c4-ccsdt'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY',; 'c4-ccsdtcorl': 'CCSDT CORRELATION ENERGY'}. return VARH. #def backtransform(chgeMol, permMol, chgeGrad=None, chgeDip=None):; #def format_fjobarc(fje, fjelem, fjcoord, fjgrd, map, fjdip):; [docs]def format_fjobarc(energy, map, elem, coordinates, gradient, dipole):; """"""Takes the key results from a gradient computation (*energy*,; element Z list *elem*, *coordinates*, *gradient*,; *dipole*, and atom ordering *map*) and writes a string *fja*; that exactly mimics the contents of a Cfour FJOBARC file. """"""; fja = 'TOTENERG\n'; fja += '%15d%15d\n' % (struct.unpack(""ii"", struct.pack(""d"", energy))); fja += 'COORD\n'; Nat = len(coordinates); flatcoord = []; for at in range(Nat):; for xyz in range(3):; flatcoord.append(coordinates[map[at]][xyz]); for idx in range(len(flatcoord)):; if abs(flatcoord[idx]) < 1.0E-14: # TODO; flatcoord[idx] = 0.0; fja += '%15d%15d' % (struct.unpack(""ii"", struct.pack(""d"", flatcoord[idx]))); if idx % 2 == 1:; fja += '\n'; if len(flatcoord) % 2 == 1:; fja += '\n'; fja += 'MAP2ZMAT\n'; for idx in range(Nat):; fja += '%15d%15d' % (struct.unpack(""ii"", struct.pack(""l"", map[idx] + 1))); if idx % 2 == 1:; fja += '\n'; if Nat % 2 == 1:; fja += '\n'; fja += 'GRD FILE\n'; fja += '%5d%20.10f\n' % (Nat, 0.0); for at in range(Nat):; fja += '%20.10f%20.10f",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:35859,Energy Efficiency,energy,energy,35859,"c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['c4-ccsd'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['c4-cc3'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['c4-ccsd(t)'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY',; 'c4-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['c4-ccsdt'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY',; 'c4-ccsdtcorl': 'CCSDT CORRELATION ENERGY'}. return VARH. #def backtransform(chgeMol, permMol, chgeGrad=None, chgeDip=None):; #def format_fjobarc(fje, fjelem, fjcoord, fjgrd, map, fjdip):; [docs]def format_fjobarc(energy, map, elem, coordinates, gradient, dipole):; """"""Takes the key results from a gradient computation (*energy*,; element Z list *elem*, *coordinates*, *gradient*,; *dipole*, and atom ordering *map*) and writes a string *fja*; that exactly mimics the contents of a Cfour FJOBARC file. """"""; fja = 'TOTENERG\n'; fja += '%15d%15d\n' % (struct.unpack(""ii"", struct.pack(""d"", energy))); fja += 'COORD\n'; Nat = len(coordinates); flatcoord = []; for at in range(Nat):; for xyz in range(3):; flatcoord.append(coordinates[map[at]][xyz]); for idx in range(len(flatcoord)):; if abs(flatcoord[idx]) < 1.0E-14: # TODO; flatcoord[idx] = 0.0; fja += '%15d%15d' % (struct.unpack(""ii"", struct.pack(""d"", flatcoord[idx]))); if idx % 2 == 1:; fja += '\n'; if len(flatcoord) % 2 == 1:; fja += '\n'; fja += 'MAP2ZMAT\n'; for idx in range(Nat):; fja += '%15d%15d' % (struct.unpack(""ii"", struct.pack(""l"", map[idx] + 1))); if idx % 2 == 1:; fja += '\n'; if Nat % 2 == 1:; fja += '\n'; fja += 'GRD FILE\n'; fja += '%5d%20.10f\n' % (Nat, 0.0); for at in range(Nat):; fja += '%20.10f%20.10f",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:36125,Energy Efficiency,energy,energy,36125,"C3 CORRELATION ENERGY'}; VARH['c4-ccsd(t)'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY',; 'c4-ccsd(t)corl': 'CCSD(T) CORRELATION ENERGY'}; VARH['c4-ccsdt'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-ccsdcorl': 'CCSD CORRELATION ENERGY',; 'c4-ccsdtcorl': 'CCSDT CORRELATION ENERGY'}. return VARH. #def backtransform(chgeMol, permMol, chgeGrad=None, chgeDip=None):; #def format_fjobarc(fje, fjelem, fjcoord, fjgrd, map, fjdip):; [docs]def format_fjobarc(energy, map, elem, coordinates, gradient, dipole):; """"""Takes the key results from a gradient computation (*energy*,; element Z list *elem*, *coordinates*, *gradient*,; *dipole*, and atom ordering *map*) and writes a string *fja*; that exactly mimics the contents of a Cfour FJOBARC file. """"""; fja = 'TOTENERG\n'; fja += '%15d%15d\n' % (struct.unpack(""ii"", struct.pack(""d"", energy))); fja += 'COORD\n'; Nat = len(coordinates); flatcoord = []; for at in range(Nat):; for xyz in range(3):; flatcoord.append(coordinates[map[at]][xyz]); for idx in range(len(flatcoord)):; if abs(flatcoord[idx]) < 1.0E-14: # TODO; flatcoord[idx] = 0.0; fja += '%15d%15d' % (struct.unpack(""ii"", struct.pack(""d"", flatcoord[idx]))); if idx % 2 == 1:; fja += '\n'; if len(flatcoord) % 2 == 1:; fja += '\n'; fja += 'MAP2ZMAT\n'; for idx in range(Nat):; fja += '%15d%15d' % (struct.unpack(""ii"", struct.pack(""l"", map[idx] + 1))); if idx % 2 == 1:; fja += '\n'; if Nat % 2 == 1:; fja += '\n'; fja += 'GRD FILE\n'; fja += '%5d%20.10f\n' % (Nat, 0.0); for at in range(Nat):; fja += '%20.10f%20.10f%20.10f%20.10f\n' % (elem[at], coordinates[at][0], coordinates[at][1], coordinates[at][2]); for at in range(Nat):; fja += '%20.10f%20.10f%20.10f%20.10f\n' % (elem[at], gradient[at][0], gradient[at][1], gradient[at][2]); fja += 'DIPOL FILE\n'; fja += '%20.10f%20.10f%20.10f\n' % (dipole[0], dipole[1], dipole[2]). return fja. [docs]def backtransform(chgeMol, permMol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:27297,Integrability,interface,interface,27297,"st_DIPOL(dipol):; """"""Parses the contents *dipol* of the Cfour DIPOL file into a dipol vector. """"""; dipol = dipol.splitlines(); lline = dipol[0].split(); dip = [float(lline[0]), float(lline[1]), float(lline[2])]. #return None if empty else dip; return dip. [docs]def muster_memory(mem):; """"""Transform input *mem* in MB into psi4-type options for cfour. """"""; text = ''. # prepare memory keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['CFOUR']['CFOUR_MEMORY_SIZE']['value'] = int(mem); options['CFOUR']['CFOUR_MEM_UNIT']['value'] = 'MB'. for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = True; return text, options. # Ways of modifying a computation; # global: set global c-side option; # local: set local c-side option; # kwarg: set kwarg; # i-local: set global=local c-side option to an interface module; # ro-def: code uses default entirely specified by read_options; # module-def: code uses default that is complex mixture of read_options settings; # i-def: interfaced code uses defaults not entirely expressed in read_options; # driver-def: driver code sets complex defaults; #; # Pure psi4 operation; # kwarg ~= local > global > driver-def > module-def > ro-def; #; # Interfaced psi4 operation; # kwarg ~= i-local > local > global > driver-def > i-def. # P4 infrastructure replacing interfaced infrastructure (mol, basis, mem) where unavoidable overlap in how things are specified (mult in mol{} vs keyword) is treated as a clobber & complain if conflict VS P4 infrastructure as an aliased/convenient leak into interfaced infrastructure (psi) and is strictly no clobber or complain. [docs]def muster_psi4options(opt):; """"""Translate psi4 keywords *opt* that have been explicitly set into; their Cfour counterparts. Since explicitly set Cfour module keyword; values will always be used preferentially to these inferred from; psi4, the 'clobber' property is set to False. """"""; text = ''; options = defaultdict(lambda: defaultdict(dict",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:27470,Integrability,interface,interfaced,27470,"st_DIPOL(dipol):; """"""Parses the contents *dipol* of the Cfour DIPOL file into a dipol vector. """"""; dipol = dipol.splitlines(); lline = dipol[0].split(); dip = [float(lline[0]), float(lline[1]), float(lline[2])]. #return None if empty else dip; return dip. [docs]def muster_memory(mem):; """"""Transform input *mem* in MB into psi4-type options for cfour. """"""; text = ''. # prepare memory keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['CFOUR']['CFOUR_MEMORY_SIZE']['value'] = int(mem); options['CFOUR']['CFOUR_MEM_UNIT']['value'] = 'MB'. for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = True; return text, options. # Ways of modifying a computation; # global: set global c-side option; # local: set local c-side option; # kwarg: set kwarg; # i-local: set global=local c-side option to an interface module; # ro-def: code uses default entirely specified by read_options; # module-def: code uses default that is complex mixture of read_options settings; # i-def: interfaced code uses defaults not entirely expressed in read_options; # driver-def: driver code sets complex defaults; #; # Pure psi4 operation; # kwarg ~= local > global > driver-def > module-def > ro-def; #; # Interfaced psi4 operation; # kwarg ~= i-local > local > global > driver-def > i-def. # P4 infrastructure replacing interfaced infrastructure (mol, basis, mem) where unavoidable overlap in how things are specified (mult in mol{} vs keyword) is treated as a clobber & complain if conflict VS P4 infrastructure as an aliased/convenient leak into interfaced infrastructure (psi) and is strictly no clobber or complain. [docs]def muster_psi4options(opt):; """"""Translate psi4 keywords *opt* that have been explicitly set into; their Cfour counterparts. Since explicitly set Cfour module keyword; values will always be used preferentially to these inferred from; psi4, the 'clobber' property is set to False. """"""; text = ''; options = defaultdict(lambda: defaultdict(dict",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:27797,Integrability,interface,interfaced,27797,"R']['CFOUR_MEMORY_SIZE']['value'] = int(mem); options['CFOUR']['CFOUR_MEM_UNIT']['value'] = 'MB'. for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = True; return text, options. # Ways of modifying a computation; # global: set global c-side option; # local: set local c-side option; # kwarg: set kwarg; # i-local: set global=local c-side option to an interface module; # ro-def: code uses default entirely specified by read_options; # module-def: code uses default that is complex mixture of read_options settings; # i-def: interfaced code uses defaults not entirely expressed in read_options; # driver-def: driver code sets complex defaults; #; # Pure psi4 operation; # kwarg ~= local > global > driver-def > module-def > ro-def; #; # Interfaced psi4 operation; # kwarg ~= i-local > local > global > driver-def > i-def. # P4 infrastructure replacing interfaced infrastructure (mol, basis, mem) where unavoidable overlap in how things are specified (mult in mol{} vs keyword) is treated as a clobber & complain if conflict VS P4 infrastructure as an aliased/convenient leak into interfaced infrastructure (psi) and is strictly no clobber or complain. [docs]def muster_psi4options(opt):; """"""Translate psi4 keywords *opt* that have been explicitly set into; their Cfour counterparts. Since explicitly set Cfour module keyword; values will always be used preferentially to these inferred from; psi4, the 'clobber' property is set to False. """"""; text = ''; options = defaultdict(lambda: defaultdict(dict)). if 'GLOBALS' in opt:; if 'PUREAM' in opt['GLOBALS']:; options['CFOUR']['CFOUR_SPHERICAL']['value'] = \; opt['MINTS']['PUREAM']['value']. if 'SCF' in opt:; if 'REFERENCE' in opt['SCF']:; options['CFOUR']['CFOUR_REFERENCE']['value'] = \; {'RHF': 'RHF',; 'UHF': 'UHF',; 'ROHF': 'ROHF'}[opt['SCF']['REFERENCE']['value']]. if 'D_CONVERGENCE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_CONV']['value'] = \; conv_float2negexp(opt['SCF']['D_CONVERGENCE']['value']). if 'MAXITER' in opt['SC",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:28025,Integrability,interface,interfaced,28025,"R']['CFOUR_MEMORY_SIZE']['value'] = int(mem); options['CFOUR']['CFOUR_MEM_UNIT']['value'] = 'MB'. for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = True; return text, options. # Ways of modifying a computation; # global: set global c-side option; # local: set local c-side option; # kwarg: set kwarg; # i-local: set global=local c-side option to an interface module; # ro-def: code uses default entirely specified by read_options; # module-def: code uses default that is complex mixture of read_options settings; # i-def: interfaced code uses defaults not entirely expressed in read_options; # driver-def: driver code sets complex defaults; #; # Pure psi4 operation; # kwarg ~= local > global > driver-def > module-def > ro-def; #; # Interfaced psi4 operation; # kwarg ~= i-local > local > global > driver-def > i-def. # P4 infrastructure replacing interfaced infrastructure (mol, basis, mem) where unavoidable overlap in how things are specified (mult in mol{} vs keyword) is treated as a clobber & complain if conflict VS P4 infrastructure as an aliased/convenient leak into interfaced infrastructure (psi) and is strictly no clobber or complain. [docs]def muster_psi4options(opt):; """"""Translate psi4 keywords *opt* that have been explicitly set into; their Cfour counterparts. Since explicitly set Cfour module keyword; values will always be used preferentially to these inferred from; psi4, the 'clobber' property is set to False. """"""; text = ''; options = defaultdict(lambda: defaultdict(dict)). if 'GLOBALS' in opt:; if 'PUREAM' in opt['GLOBALS']:; options['CFOUR']['CFOUR_SPHERICAL']['value'] = \; opt['MINTS']['PUREAM']['value']. if 'SCF' in opt:; if 'REFERENCE' in opt['SCF']:; options['CFOUR']['CFOUR_REFERENCE']['value'] = \; {'RHF': 'RHF',; 'UHF': 'UHF',; 'ROHF': 'ROHF'}[opt['SCF']['REFERENCE']['value']]. if 'D_CONVERGENCE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_CONV']['value'] = \; conv_float2negexp(opt['SCF']['D_CONVERGENCE']['value']). if 'MAXITER' in opt['SC",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:33838,Integrability,wrap,wrapper,33838,"ons. [docs]def cfour_list():; """"""Return an array of Cfour methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_gradient_list():; """"""Return an array of Cfour methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_psivar_list():; """"""Return a dict with keys of most Cfour methods and values of dicts; with the PSI Variables returned by those methods. Used by cbs(); wrapper to avoid unnecessary computations in compound methods.; Result is appended to ``VARH``. """"""; VARH = {}; VARH['c4-scf'] = {; 'c4-scftot': 'SCF TOTAL ENERGY'}; VARH['c4-mp2'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['c4-mp3'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'c4-mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['c4-mp4(sdq)'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'c4-mp3corl': 'MP3 CORRELATION ENERGY',; 'c4-mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['c4-mp4'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'c4-mp3corl': 'MP3 CORRELATION ENERGY',; 'c4-mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'c4-mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['c4-cc2'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:33849,Safety,avoid,avoid,33849,"ons. [docs]def cfour_list():; """"""Return an array of Cfour methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_gradient_list():; """"""Return an array of Cfour methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('cfour'); val.append('c4-scf'); val.append('c4-mp2'); val.append('c4-mp3'); val.append('c4-mp4(sdq)'); val.append('c4-mp4'); val.append('c4-cc2'); val.append('c4-ccsd'); val.append('c4-cc3'); val.append('c4-ccsd(t)'); val.append('c4-ccsdt'); return val. [docs]def cfour_psivar_list():; """"""Return a dict with keys of most Cfour methods and values of dicts; with the PSI Variables returned by those methods. Used by cbs(); wrapper to avoid unnecessary computations in compound methods.; Result is appended to ``VARH``. """"""; VARH = {}; VARH['c4-scf'] = {; 'c4-scftot': 'SCF TOTAL ENERGY'}; VARH['c4-mp2'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['c4-mp3'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'c4-mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['c4-mp4(sdq)'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'c4-mp3corl': 'MP3 CORRELATION ENERGY',; 'c4-mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['c4-mp4'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl': 'MP2 CORRELATION ENERGY',; 'c4-mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'c4-mp3corl': 'MP3 CORRELATION ENERGY',; 'c4-mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY',; 'c4-mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'}; VARH['c4-cc2'] = {; 'c4-scftot': 'SCF TOTAL ENERGY',; 'c4-mp2corl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:2688,Testability,test,tests,2688,"pass); pass_psivar.append(psivar); pass_coord.append(c4coord); pass_grad.append(c4grad). #print '\n\nXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n'; #print outpass; #print psivar, c4coord, c4grad; #print psivar, c4grad; #print '\n\nxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n'. retindx = -1 if pass_coord[-1] else -2. # print ' <<< C4 PSIVAR >>>'; # for item in pass_psivar[retindx]:; # print(' %30s %16.8f' % (item, pass_psivar[retindx][item])); # print ' <<< C4 COORD >>>'; # for item in pass_coord[retindx]:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); # print ' <<< C4 GRAD >>>'; # for item in pass_grad[retindx]:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). return pass_psivar[retindx], pass_coord[retindx], pass_grad[retindx]. [docs]def harvest_outfile_pass(outtext):; """"""Function to read CFOUR output file *outtext* and parse important; quantum chemical information from it in. """"""; psivar = PreservingDict(); psivar_coord = None; psivar_grad = None. # TODO: BCC; # CI; # QCISD(T); # other ROHF tests; # vcc/ecc. NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))"". # Process NRE; mobj = re.search(r'^\s+' + r'(?:Nuclear repulsion energy :)' + r'\s+' + NUMBER + r'\s+a\.u\.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched nre'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1). # Process SCF; mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*$',; outtext, re.MULTILINE); if mobj:; print('matched scf1'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\)=)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE); if mobj:; print('matched scf2'); psivar['SCF TOTAL ENERGY'] = mobj.group(1). mobj = re.search(; r'^\s+' + r'(?:SCF has converged.)' + r'\s*$' +; r'(?:.*?)' +; r'^\s+' + r'(?:\d+)' + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched scf3'); psivar['SCF TOTAL ENERGY'] = m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:29818,Usability,guid,guideline,29818," \; conv_float2negexp(opt['SCF']['D_CONVERGENCE']['value']). if 'MAXITER' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_MAXCYC']['value'] = \; opt['SCF']['MAXITER']['value']. if 'DAMPING_PERCENTAGE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_DAMPING']['value'] = \; int(10 * opt['SCF']['DAMPING_PERCENTAGE']['value']). for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = False; return text, options. # Philosophy break:; # Specification options; # Massaging options. # * No program's defaults should be tampered with w/o provokation. # want all defaults applied to all programs, so p4 scf_conv is 5 and c4 scf_conv is 5; # want separate regimes, so conv 6 covers all the p4 parts and cfour_conv = 8 covers the c4 parts; # want mixture, so basis gets applied to c4 but others don't; # first case, when options specified explicitly. # [scf][d_convergence] [cfour][cfour_scf_conv] what happens?; # 8 from opt() 7 by default; # 6 from set {...} 7 by default 6 (guideline that psi4 format converts when clear); # 8 from opt() 5 from set {...} 5 (local trumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVE",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:29859,Usability,clear,clear,29859," \; conv_float2negexp(opt['SCF']['D_CONVERGENCE']['value']). if 'MAXITER' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_MAXCYC']['value'] = \; opt['SCF']['MAXITER']['value']. if 'DAMPING_PERCENTAGE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_DAMPING']['value'] = \; int(10 * opt['SCF']['DAMPING_PERCENTAGE']['value']). for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = False; return text, options. # Philosophy break:; # Specification options; # Massaging options. # * No program's defaults should be tampered with w/o provokation. # want all defaults applied to all programs, so p4 scf_conv is 5 and c4 scf_conv is 5; # want separate regimes, so conv 6 covers all the p4 parts and cfour_conv = 8 covers the c4 parts; # want mixture, so basis gets applied to c4 but others don't; # first case, when options specified explicitly. # [scf][d_convergence] [cfour][cfour_scf_conv] what happens?; # 8 from opt() 7 by default; # 6 from set {...} 7 by default 6 (guideline that psi4 format converts when clear); # 8 from opt() 5 from set {...} 5 (local trumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVE",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:11415,Availability,avail,available,11415," up dispersion correction parameters in whatever form needed.; When *mode* is 'dftd3', returns a string suitable for writing to ./dftd3_parameters; to calculuate the correction at *dashlvl* with the default parameters for functional; *func*. When *mode* is 'psi4', returns a tuple of arguments suitable for building; a Dispersion object with *dashlvl* parameters for functional *func*. There are four computational *dashlvl* choices. 'd2p4' calls the -D2 correction; within psi4 (hence, faked for mode='dftd3'). The other three, 'd2gr', 'd3zero',; and 'd3bj' call the three dftd3 modes of operation (corresponding to -old, -zero, -bj).; Additionally, there are three aliased *dashlvl* choices since the aliases in dash_alias; above are imposed. """"""; # Validate input arguments; dashlvl = dashlvl.lower(); dashlvleff = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl. func = func.lower(); if func not in dashcoeff[dashlvleff].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)). # Return strings for dftd3 program parameter file; # s6 rs6 s18 rs8 alpha6 version; # d2p4: s6 sr6=1.1 s8=0.0 a2=None alpha6=20.0 version=2; # d2gr: s6 sr6=1.1 s8=0.0 a2=None alpha6 version=2; # d3zero: s6 sr6 s8 a2=None alpha6 version=3; # d3bj: s6 a1 s8 a2 alpha6=None version=4; # d3mzero: s6 sr6 s8 beta alpha6=14.0 version=5; # d3mbj: s6 a1 s8 a2 alpha6=None version=6. if mode.lower() == 'dftd3':; if dashlvleff.lower() == 'd2p4':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0, 20.0, 2); elif dashlvleff.lower() == 'd2gr':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0,; dashcoeff[dashlvleff][func]['alpha6'],; 2); elif dashlvleff.lower() == 'd3zero':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; da",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dashparam.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:13314,Availability,avail,available,13314," %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; dashcoeff[dashlvleff][func]['s8'],; 1.0,; dashcoeff[dashlvleff][func]['alpha6'],; 3); elif dashlvleff.lower() == 'd3bj':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['a1'],; dashcoeff[dashlvleff][func]['s8'],; dashcoeff[dashlvleff][func]['a2'],; 0.0, 4); elif dashlvleff.lower() == 'd3mzero':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; dashcoeff[dashlvleff][func]['s8'],; dashcoeff[dashlvleff][func]['beta'],; 14.0, 5); elif dashlvleff.lower() == 'd3mbj':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['a1'],; dashcoeff[dashlvleff][func]['s8'],; dashcoeff[dashlvleff][func]['a2'],; 0.0, 6); else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2. # d3mzero: name=-D3M s6=s6 p1=sr6 p2=s8 beta alpha6=14.0 version=5; # d3mbj: name=-D3MBJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif da",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dashparam.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:14939,Availability,avail,available,14939,")); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2. # d3mzero: name=-D3M s6=s6 p1=sr6 p2=s8 beta alpha6=14.0 version=5; # d3mbj: name=-D3MBJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; elif dashlvleff == 'd3mzero':; return '-D3MZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['beta']; elif dashlvleff == 'd3mbj':; return '-D3MBJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dashparam.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:15061,Availability,avail,available,15061,")); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2. # d3mzero: name=-D3M s6=s6 p1=sr6 p2=s8 beta alpha6=14.0 version=5; # d3mbj: name=-D3MBJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; elif dashlvleff == 'd3mzero':; return '-D3MZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['beta']; elif dashlvleff == 'd3mbj':; return '-D3MBJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dashparam.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:15299,Deployability,update,updated,15299,")); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2. # d3mzero: name=-D3M s6=s6 p1=sr6 p2=s8 beta alpha6=14.0 version=5; # d3mbj: name=-D3MBJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; elif dashlvleff == 'd3mzero':; return '-D3MZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['beta']; elif dashlvleff == 'd3mbj':; return '-D3MBJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dashparam.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:3106,Availability,avail,available,3106,"th.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:3681,Deployability,update,updated,3681,"th.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:1193,Security,access,accessed,1193,"PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File to. """"""; from __future__ import absolute_import; from __future__ import print_function; import sys; import os; import glob; import ast. [docs]def useful():; print(""in qcdb.useful()""); return 'qcdb successfully accessed'. [docs]def drop_duplicates(seq):; """"""Function that given an array or array of arrays *seq*, returns an; array without any duplicate entries. There is no guarantee of which; duplicate entry is dropped. """"""; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def dictify_database_docstrings():; """""". """"""; db_path = os.path.dirname(__file__) + '/../databases'. DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[base",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:2519,Testability,benchmark,benchmark,2519,"fy_database_docstrings():; """""". """"""; db_path = os.path.dirname(__file__) + '/../databases'. DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, clas",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:2584,Testability,benchmark,benchmark,2584,"/databases'. DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:2636,Testability,benchmark,benchmark,2636,"/databases'. DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:3310,Testability,benchmark,benchmark,3310,"th.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[basename]['general'] = lst[0].split('\n'). try:; DSD[basename]['cp'] = [section for section in lst if section.startswith(""cp"")][0]; except IndexError:; DSD[basename]['cp'] = None. try:; DSD[basename]['rlxd'] = [section for section in lst if section.startswith(""rlxd"")][0]; except IndexError:; DSD[basename]['rlxd'] = None. try:; DSD[basename]['benchmark'] = [section for section in lst if section.startswith(""benchmark"")][0]; except IndexError:; DSD[basename]['benchmark'] = None. try:; #DSD[basename]['subset'] = [section for section in lst if section.startswith(""subset"")][0]; temp = [section for section in lst if section.startswith(""subset"")][0].splitlines(); temp = temp[2:]. result = {}; for item in temp:; item = item.lstrip("" -""); try:; key, val = item.split("" "", 1); result[key] = val; except ValueError:; result[item] = """". DSD[basename]['subset'] = result. except IndexError:; DSD[basename]['subset'] = {"""": 'No subsets available'}. return DSD. # print '\ngeneral\n\n', DSD[basename]['general']; # print '\ncp\n\n', DSD[basename]['cp']; # print '\nrlxd\n\n', DSD[basename]['rlxd']; # print '\nbenchmark\n\n', DSD[basename]['benchmark']; # print '\nsubset\n\n', DSD[basename]['subset']. #print ' %-12s %s' % ('[' + basename + ']', DSD[basename]['general'][0]). #print 'DSD2\n', DSD['S22']['subset']. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbproc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:620,Availability,error,errors,620,"﻿. qcdb.dbwrap — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rm",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:787,Availability,error,error,787,"﻿. qcdb.dbwrap — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rm",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:912,Availability,error,error,912,"﻿. qcdb.dbwrap — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rm",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:940,Availability,error,error,940,"﻿. qcdb.dbwrap — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rm",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1038,Availability,error,error,1038,"[1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1061,Availability,error,error,1061,"[1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1128,Availability,error,error,1128,"[1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1195,Availability,error,error,1195,"[1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.dbwrap; from __future__ import absolute_import; from __future__ import print_function; import os; import sys; import math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1245,Availability,error,error,1245,"ort math. try:; import cPickle as pickle; except ImportError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = No",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1296,Availability,error,error,1296,"ortError:; import pickle; import itertools; # from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1348,Availability,error,error,1348,"ollections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from oldpymodules import OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspc",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1392,Availability,error,error,1392,"t OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def av",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1462,Availability,error,error,1462,"t OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def av",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1532,Availability,error,error,1532,"t OrderedDict; from .exceptions import *; from .molecule import Molecule; from .modelchems import Method, BasisSet, Error, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def av",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1584,Availability,error,error,1584,"ror, methods, bases, errors, pubs; from . import psiutil; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1637,Availability,error,error,1637,"il; from . import textables. [docs]def initialize_errors():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1691,Availability,error,error,1691,"rs():; """"""Form OrderedDict of all possible statistical measures set to None""""""; error = OrderedDict(); for e in ['e', 'pe', 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1737,Availability,error,error,1737," 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1810,Availability,error,error,1810," 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1883,Availability,error,error,1883," 'pbe', 'pce']:; for m in ['pex', 'nex', 'max', 'min', 'm', 'ma', 'rms', 'std']:; error[m + e] = None; return error. [docs]def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1937,Availability,error,error,1937,"def initialize_errors_elaborate(e=None, pe=None, pbe=None, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:1992,Availability,error,error,1992,"e, pce=None, extrema=True):; error = OrderedDict(); error['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=l",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2048,Availability,error,error,2048,"r['maxe'] = None if (e is None or not extrema) else e # LD_XA; error['mine'] = None if (e is None or not extrema) else e # LD_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2096,Availability,error,error,2096,"D_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2169,Availability,error,error,2169,"D_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2242,Availability,error,error,2242,"D_XI; error['me'] = None if e is None else 0.0 # LD_MS; error['mae'] = None if e is None else 0.0 # LD_MA; error['rmse'] = None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2296,Availability,error,error,2296,"None if e is None else 0.0 # LD_RA; error['stde'] = None if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] =",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2351,Availability,error,error,2351," if e is None else 0.0; error['maxpe'] = None if (pe is None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] = math.sqrt(sum([x['stde'] ** 2 for x in args]) / Ndb). ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2407,Availability,error,error,2407,"None or not extrema) else pe # FD_XA; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] = math.sqrt(sum([x['stde'] ** 2 for x in args]) / Ndb). avgerror['pexpe'] = max([x['pexpe'] for x in args]); avg",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2462,Availability,error,error,2462,"; error['minpe'] = None if (pe is None or not extrema) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] = math.sqrt(sum([x['stde'] ** 2 for x in args]) / Ndb). avgerror['pexpe'] = max([x['pexpe'] for x in args]); avgerror['nexpe'] = min([x['nexpe'] for",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2539,Availability,error,error,2539,"a) else pe # FD_XI; error['mpe'] = None if pe is None else 0.0 # FD_MS; error['mape'] = None if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] = math.sqrt(sum([x['stde'] ** 2 for x in args]) / Ndb). avgerror['pexpe'] = max([x['pexpe'] for x in args]); avgerror['nexpe'] = min([x['nexpe'] for x in args]); avgerror['maxpe'] = max([x['maxpe'] fo",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2622,Availability,error,error,2622," if pe is None else 0.0 # FD_MA; error['rmspe'] = None if pe is None else 0.0 # FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] = math.sqrt(sum([x['stde'] ** 2 for x in args]) / Ndb). avgerror['pexpe'] = max([x['pexpe'] for x in args]); avgerror['nexpe'] = min([x['nexpe'] for x in args]); avgerror['maxpe'] = max([x['maxpe'] for x in args], key=lambda x: abs(x)); avgerror['minpe'] = min([x['minpe'] for x in args], key=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:2701,Availability,error,error,2701,"FD_RA; error['stdpe'] = None if pe is None else 0.0; error['maxpbe'] = None if (pbe is None or not extrema) else pbe # BD_XA; error['minpbe'] = None if (pbe is None or not extrema) else pbe # BD_XI; error['mpbe'] = None if pbe is None else 0.0 # BD_MS; error['mapbe'] = None if pbe is None else 0.0 # BD_MA; error['rmspbe'] = None if pbe is None else 0.0 # BD_RA; error['stdpbe'] = None if pbe is None else 0.0; error['maxpce'] = None if (pce is None or not extrema) else pce # BD_XA; error['minpce'] = None if (pce is None or not extrema) else pce # BD_XI; error['mpce'] = None if pce is None else 0.0 # BD_MS; error['mapce'] = None if pce is None else 0.0 # BD_MA; error['rmspce'] = None if pce is None else 0.0 # BD_RA; error['stdpce'] = None if pce is None else 0.0; return error. [docs]def average_errors(*args):; """"""Each item in *args* should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in *args*. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. """"""; Ndb = float(len(args)); avgerror = initialize_errors(); try:; avgerror['pexe'] = max([x['pexe'] for x in args]); avgerror['nexe'] = min([x['nexe'] for x in args]); avgerror['maxe'] = max([x['maxe'] for x in args], key=lambda x: abs(x)); avgerror['mine'] = min([x['mine'] for x in args], key=lambda x: abs(x)); avgerror['me'] = sum([x['me'] for x in args]) / Ndb; avgerror['mae'] = sum([x['mae'] for x in args]) / Ndb; avgerror['rmse'] = sum([x['rmse'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stde'] = math.sqrt(sum([x['stde'] ** 2 for x in args]) / Ndb). avgerror['pexpe'] = max([x['pexpe'] for x in args]); avgerror['nexpe'] = min([x['nexpe'] for x in args]); avgerror['maxpe'] = max([x['maxpe'] for x in args], key=lambda x: abs(x)); avgerror['minpe'] = min([x['minpe'] for x in args], key=lambda x: abs(x)); avgerror['mpe'] = sum([x['mpe'] for x in args]) / Ndb; avgerr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:5111,Availability,error,error,5111,"'] for x in args], key=lambda x: abs(x)); avgerror['mpbe'] = sum([x['mpbe'] for x in args]) / Ndb; avgerror['mapbe'] = sum([x['mapbe'] for x in args]) / Ndb; avgerror['rmspbe'] = sum([x['rmspbe'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stdpbe'] = math.sqrt(sum([x['stdpbe'] * x['stdpbe'] for x in args]) / Ndb). avgerror['pexpce'] = max([x['pexpce'] for x in args]); avgerror['nexpce'] = min([x['nexpce'] for x in args]); avgerror['maxpce'] = max([x['maxpce'] for x in args], key=lambda x: abs(x)); avgerror['minpce'] = min([x['minpce'] for x in args], key=lambda x: abs(x)); avgerror['mpce'] = sum([x['mpce'] for x in args]) / Ndb; avgerror['mapce'] = sum([x['mapce'] for x in args]) / Ndb; avgerror['rmspce'] = sum([x['rmspce'] for x in args]) / Ndb # TODO: unsure of op validity; avgerror['stdpce'] = math.sqrt(sum([x['stdpce'] * x['stdpce'] for x in args]) / Ndb); except TypeError:; pass; return avgerror. [docs]def format_errors(err, mode=1):; """"""From error dictionary *err*, returns a LaTeX-formatted string,; after handling None entries. """"""; onedecimal = r""""""{0:8.1f}""""""; twodecimal = r""""""{0:8.2f}""""""; threedecimal = r""""""{0:12.3f}""""""; fourdecimal = r""""""{0:12.4f}""""""; shortblank = r""""""{0:8s}"""""".format(''); longblank = r""""""{0:12s}"""""".format(''). if mode == 1:; me = ' ----' if err['me'] is None else '%+.2f' % (err['me']); stde = '----' if err['stde'] is None else '%.2f' % (err['stde']); mae = ' ----' if err['mae'] is None else '%6.2f' % (err['mae']); mape = ' ---- ' if err['mape'] is None else '%6.1f\%%' % (100 * err['mape']); mapbe = ' ---- ' if err['mapbe'] is None else '%6.1f\%%' % (100 * err['mapbe']); mapce = ' ---- ' if err['mapce'] is None else '%6.1f\%%' % (100 * err['mapce']); text = """"""$\{%s; %s\}$ %s %s %s"""""" % \; (me, stde, mae, mape, mapce); return text. if mode == 2:; sdict = OrderedDict(); for lbl in ['pexe', 'nexe', 'maxe', 'mine', 'me', 'mae', 'rmse', 'stde']:; sdict[lbl] = ' ----' if err[lbl] is None else fourdecimal.format(err[lbl]); for ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:9121,Availability,mask,mask,9121,"]. return prefix, suffix, middle. [docs]def oxcom(lst):; """"""Returns gramatical comma separated string of *lst*.""""""; lst = [str(l) for l in lst]. if not lst:; return ''; elif len(lst) == 1:; return lst[0]; elif len(lst) == 2:; return ' and '.join(lst); else:; return ', and '.join([', '.join(lst[:-1]), lst[-1]]). [docs]def cure_weight(refrxn, refeq, rrat, xi=0.2):; """"""; :param refeq: value of benchmark for equilibrium Reaction; :param rrat: ratio of intermonomer separation for Reaction to equilibrium Reaction; :param xi: parameter; :return: weight for CURE. """"""; sigma = xi * abs(refeq) / (rrat ** 3); weight = max(abs(refrxn), sigma); return weight. [docs]def balanced_error(refrxn, refeq, rrat, m=0.03, p=10.0):; """"""; :param refrxn:; :param refeq:; :param rrat:; :param m: minimum permitted weight for a point; :param p: multiples of abs(refeq) above refeq to which zero-line in head is displaced; :return:. """"""; one = float(1); q = one if rrat >= one else p; qm1perat = q - 1 + refrxn / refeq; weight = max(m, qm1perat / q); mask = weight * q / abs(qm1perat); return mask, weight. [docs]def fancify_mc_tag(mc, latex=False):; """"""From the usual MTD-opt1_opt2-bas model chemistry identifier, return; string based on fullname, if *latex* is False or latex if *latex* is True. """"""; try:; mtd, mod, bas = mc.split('-'); except ValueError:; text = mc; else:; if latex:; text = r""""""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); else:; text = r""""""%20s / %s, %s"""""" % (methods[mtd].fullname, bases[bas].fullname, mod); return text. [docs]class ReactionDatum(object):; """"""Piece of quantum chemical information that describes a qcdb.Reaction object. """""". def __init__(self, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None):; # geometry; self.dbrxn = dbse + '-' + str(rxn); # qcdb.Method; self.method = method; # mode, e.g., unCP, CP, RLX, etc.; self.mode = mode; # qcdb.BasisSet; self.basis = basis; # numerical value for reaction; self.va",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:9163,Availability,mask,mask,9163,"]. return prefix, suffix, middle. [docs]def oxcom(lst):; """"""Returns gramatical comma separated string of *lst*.""""""; lst = [str(l) for l in lst]. if not lst:; return ''; elif len(lst) == 1:; return lst[0]; elif len(lst) == 2:; return ' and '.join(lst); else:; return ', and '.join([', '.join(lst[:-1]), lst[-1]]). [docs]def cure_weight(refrxn, refeq, rrat, xi=0.2):; """"""; :param refeq: value of benchmark for equilibrium Reaction; :param rrat: ratio of intermonomer separation for Reaction to equilibrium Reaction; :param xi: parameter; :return: weight for CURE. """"""; sigma = xi * abs(refeq) / (rrat ** 3); weight = max(abs(refrxn), sigma); return weight. [docs]def balanced_error(refrxn, refeq, rrat, m=0.03, p=10.0):; """"""; :param refrxn:; :param refeq:; :param rrat:; :param m: minimum permitted weight for a point; :param p: multiples of abs(refeq) above refeq to which zero-line in head is displaced; :return:. """"""; one = float(1); q = one if rrat >= one else p; qm1perat = q - 1 + refrxn / refeq; weight = max(m, qm1perat / q); mask = weight * q / abs(qm1perat); return mask, weight. [docs]def fancify_mc_tag(mc, latex=False):; """"""From the usual MTD-opt1_opt2-bas model chemistry identifier, return; string based on fullname, if *latex* is False or latex if *latex* is True. """"""; try:; mtd, mod, bas = mc.split('-'); except ValueError:; text = mc; else:; if latex:; text = r""""""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); else:; text = r""""""%20s / %s, %s"""""" % (methods[mtd].fullname, bases[bas].fullname, mod); return text. [docs]class ReactionDatum(object):; """"""Piece of quantum chemical information that describes a qcdb.Reaction object. """""". def __init__(self, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None):; # geometry; self.dbrxn = dbse + '-' + str(rxn); # qcdb.Method; self.method = method; # mode, e.g., unCP, CP, RLX, etc.; self.mode = mode; # qcdb.BasisSet; self.basis = basis; # numerical value for reaction; self.va",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:15847,Availability,error,errors,15847,"= color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:15918,Availability,error,error,15918,"ndx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s.""",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16088,Availability,error,error,16088,"self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:17618,Availability,error,errors,17618,"lf.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.com",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:18254,Availability,avail,available,18254,"rr[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; # ixpre, ixsuf, ixmid = string_contrast(index); # title = self.dbse + ' ' + ixpre + '[]' + ixsuf; title = self.dbrxn; labels = ['']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as pl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:18533,Availability,error,errors,18533,"one,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; # ixpre, ixsuf, ixmid = string_contrast(index); # title = self.dbse + ' ' + ixpre + '[]' + ixsuf; title = self.dbrxn; labels = ['']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:18856,Availability,error,errors,18856,"g. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; # ixpre, ixsuf, ixmid = string_contrast(index); # title = self.dbse + ' ' + ixpre + '[]' + ixsuf; title = self.dbrxn; labels = ['']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:18924,Availability,error,errors,18924,"; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; # ixpre, ixsuf, ixmid = string_contrast(index); # title = self.dbse + ' ' + ixpre + '[]' + ixsuf; title = self.dbrxn; labels = ['']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:20390,Availability,error,error,20390,"m Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=labels, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs]class WrappedDatabase(object):; """"""Wrapper class for raw Psi4 database modules that does some validation; of contents, creates member data and accessors for database structures,; defines error computation, and handles database subsets. Not to be used; directly-- see qcdb.Database for handling single or multiple; qdcb.WrappedDatabase objects and defining nice statistics, plotting, and; table functionalities. >>> asdf = qcdb.WrappedDatabase('Nbc10'); """""". def __init__(self, dbname, pythonpath=None):; """"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:31799,Availability,error,errors,31799,"str(rxn), self.dbse)). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a function; *func* that filters *self.hrxn*. """"""; sname = name.lower().split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslis",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:31870,Availability,error,error,31870,"split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:32040,Availability,error,error,32040,"func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise Validat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:32292,Availability,avail,available,32292,". self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cur",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:33306,Availability,error,error,33306,"ror(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cureinfo[rxn]; # try:; # mcGreaterCrvmin = self.hrxn[rxncureinfo['eq']].data[lbench].value; # except KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34489,Availability,error,error,34489,"xcept KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34578,Availability,error,error,34578,"d_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34902,Availability,error,error,34902,"er - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35018,Availability,error,error,35018,"esser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35061,Availability,error,error,35061,"esser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35111,Availability,error,error,35111,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35140,Availability,error,error,35140,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35169,Availability,error,error,35169,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35220,Availability,error,error,35220,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35271,Availability,error,error,35271,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35305,Availability,error,error,35305,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35350,Availability,error,error,35350,", 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35420,Availability,error,error,35420,"e=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35544,Availability,error,error,35544,"n single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x:",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35596,Availability,error,error,35596,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35628,Availability,error,error,35628,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35660,Availability,error,error,35660,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35714,Availability,error,error,35714,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35768,Availability,error,error,35768,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35805,Availability,error,error,35805,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35853,Availability,error,error,35853,"onary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:35926,Availability,error,error,35926,"nitialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36053,Availability,error,error,36053,"or = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36191,Availability,error,error,36191,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36224,Availability,error,error,36224,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36257,Availability,error,error,36257,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36312,Availability,error,error,36312,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36367,Availability,error,error,36367,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36412,Availability,error,error,36412,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36468,Availability,error,error,36468,"bs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36550,Availability,error,error,36550,"ative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36591,Availability,error,errors,36591,"ative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36739,Availability,error,error,36739,"mbda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(map(lambda x: x ** 2, relative)) / Nrxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonp",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36789,Availability,error,error,36789,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36820,Availability,error,error,36820,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36851,Availability,error,error,36851,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36904,Availability,error,error,36904,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36957,Availability,error,error,36957,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:36993,Availability,error,error,36993,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37040,Availability,error,error,37040,"rxn); error['stdpe'] = math.sqrt((sum(map(lambda x: x ** 2, relative)) - (sum(relative) ** 2) / Nrxn) / Nrxn); # balanced (relative) error; balanced = [val[3] for val in err.values()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37112,Availability,error,error,37112,"s()]; balwt = sum([val[4] for val in err.values()]) # get the wt fn. highly irregular TODO; error['pexpbe'] = max(balanced); error['nexpbe'] = min(balanced); error['maxpbe'] = max(balanced, key=lambda x: abs(x)); error['minpbe'] = min(balanced, key=lambda x: abs(x)); error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.pat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37353,Availability,error,error,37353," error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37395,Availability,error,error,37395," error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37421,Availability,error,error,37421," error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39390,Availability,error,error,39390,"Error(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:40123,Availability,avail,available,40123,"f path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:56883,Availability,error,errors,56883,"in range(len(self.dbdict))]; print(""""""Database %s: Subset %s promoted: %s"""""" % (self.dbse, ss, self.sset[ss])). def _intersect_subsets(self):; """"""Examine component database subsets and collect common names as; Database subset. """"""; sss = [set(odb.sset.keys()) for db, odb in self.dbdict.items()]; new = sorted(set.intersection(*sss)); for ss in new:; self.sset[ss] = [ss] * len(self.dbdict.keys()). def _intersect_modelchems(self):; """"""Examine component database qcdata and collect common names as; Database modelchem. """"""; mcs = [set(odb.available_modelchems()) for odb in self.dbdict.itervalues()]; new = sorted(set.intersection(*mcs)); for mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57083,Availability,error,error,57083,"t.intersection(*sss)); for ss in new:; self.sset[ss] = [ss] * len(self.dbdict.keys()). def _intersect_modelchems(self):; """"""Examine component database qcdata and collect common names as; Database modelchem. """"""; mcs = [set(odb.available_modelchems()) for odb in self.dbdict.itervalues()]; new = sorted(set.intersection(*mcs)); for mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subs",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57283,Availability,error,errors,57283,"mon names as; Database modelchem. """"""; mcs = [set(odb.available_modelchems()) for odb in self.dbdict.itervalues()]; new = sorted(set.intersection(*mcs)); for mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmar",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57452,Availability,error,errors,57452,"or mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57497,Availability,error,errors,57497,"or mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57747,Availability,error,errors,57747,"',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57760,Availability,error,errors,57760,"',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57829,Availability,error,errors,57829,"atistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbd",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57858,Availability,error,errors,57858,"atistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbd",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58043,Availability,error,error,58043,"rly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul el",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58134,Availability,avail,available,58134,"rly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul el",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58168,Availability,error,errors,58168,"eturns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58176,Availability,error,errors,58176,"eturns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58211,Availability,error,errors,58211,"eturns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58257,Availability,error,errors,58257,"ls and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58401,Availability,error,errors,58401,".dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def pl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:59142,Availability,error,errors,59142,"available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def plot_bars(self, modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned co",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60234,Availability,avail,available,60234,"errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def plot_bars(self, modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60449,Availability,error,errors,60449," 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60457,Availability,error,errors,60457," 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60512,Availability,error,errors,60512," 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60546,Availability,error,errors,60546," 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60870,Availability,error,errors,60870,"name for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix([u, v]))); #; # dbdat = {}; # for db, odb in self.dbdict.iteritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62393,Availability,error,errors,62393,"g from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix([u, v]))); #; # dbdat = {}; # for db, odb in self.dbdict.iteritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; # for rxnix, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmprese",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62401,Availability,error,errors,62401,"g from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix([u, v]))); #; # dbdat = {}; # for db, odb in self.dbdict.iteritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; # for rxnix, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmprese",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:63401,Availability,error,error,63401,"self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancify_mc_tag(mc).strip()] = dbdat. pre, suf, mid = string_contrast(modelchem); title = """"""%s[%s]%s vs %s axis %s for %s subset %s"""""" % (pre, str(len(mid)), suf, benchmark, axis, self.dbse, sset); print(title); #for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d['mcdata'] is None else d['mcdata']); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:63446,Availability,error,error,63446,"self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancify_mc_tag(mc).strip()] = dbdat. pre, suf, mid = string_contrast(modelchem); title = """"""%s[%s]%s vs %s axis %s for %s subset %s"""""" % (pre, str(len(mid)), suf, benchmark, axis, self.dbse, sset); print(title); #for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d['mcdata'] is None else d['mcdata']); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:67691,Availability,error,errors,67691,"ry diagram. """"""; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath=pythonpath,; failoninc=failoninc). dbdat = []; mcs = []; for dat in saptdata.values():; dbdat.append([dat['elst'], dat['ind'], dat['disp']]); if dat['mc'] not in mcs:; mcs.append(dat['mc']). title = ' '.join([self.dbse, sset, ' '.join(mcs)]). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; pass; # if not running from Canopy, print line to execute from Canopy; else:; # if running from Canopy, call mpl directly; filedict = mpl.ternary(dbdat, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68332,Availability,avail,available,68332,"t, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s'",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68497,Availability,error,errors,68497,"ark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s',\n title='%s',\n mae=%s,\n mape=%s,\n xlimit=%s,\n xlines=%s,\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, mc, mae, mape, xlimit, repr(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68521,Availability,error,errors,68521,"ark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s',\n title='%s',\n mae=%s,\n mape=%s,\n xlimit=%s,\n xlines=%s,\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, mc, mae, mape, xlimit, repr(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68979,Availability,error,errors,68979,"or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s',\n title='%s',\n mae=%s,\n mape=%s,\n xlimit=%s,\n xlines=%s,\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, mc, mae, mape, xlimit, repr(xlines), view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.flat(dbdat, color=color, title=mc, mae=mae, mape=mape,; xlimit=xlimit, xlines=xlines, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def write_xyz_files(self, path=None):; """"""Writes xyz files for every reagent in the Database to directory; in *path* or to directory dbse_xyzfiles tha",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:69033,Availability,error,errors,69033," is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s',\n title='%s',\n mae=%s,\n mape=%s,\n xlimit=%s,\n xlines=%s,\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, mc, mae, mape, xlimit, repr(xlines), view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.flat(dbdat, color=color, title=mc, mae=mae, mape=mape,; xlimit=xlimit, xlines=xlines, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def write_xyz_files(self, path=None):; """"""Writes xyz files for every reagent in the Database to directory; in *path* or to directory dbse_xyzfiles that it createsin cwd if; *path* is None. Additionally, write",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:71273,Availability,avail,available,71273,"else:; xyzdir = os.path.abspath(path) + os.sep; if not os.path.exists(xyzdir):; os.mkdir(xyzdir). for rgt, orgt in self.hrgt.iteritems():; omol = Molecule(orgt.mol); omol.update_geometry(); omol.save_xyz(xyzdir + rgt + '.xyz'). with open(xyzdir + 'pymol_xyz2png_script.pml', 'w') as handle:; handle.write(""""""; # Launch PyMOL and run from its command line:; # PyMOL> cd {}; # PyMOL> @{}; """""".format(xyzdir, 'pymol_xyz2png_script.pml')); for rgt in self.hrgt.keys():; handle.write(""""""; load {xyzfile}; hide lines; show sticks; color grey, name c; cmd.set('''opaque_background''','''0''',quiet=0); reset; orient; cmd.zoom(buffer=0.3, complete=1); ray; png {pngfile}; reinitialize; """""".format(; xyzfile=xyzdir + rgt + '.xyz',; pngfile=xyzdir + rgt + '.png')). [docs] def plot_all_flats(self, modelchem=None, sset='default', xlimit=4.0,; failoninc=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from *modelchem*, otherwise defaults to; all those available. Can modify subset *sset* and plotting; range *xlimit*. >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0); """"""; mcs = self.mcs.keys() if modelchem is None else modelchem; filedict = OrderedDict(); for mc in sorted(mcs):; minifiledict = self.plot_flat(mc, sset=sset, xlimit=xlimit, view=False,; failoninc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritem",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:73842,Availability,avail,available,73842,"ark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(self, modelchem, sset='default'):; """"""Returns a dictionary (keys self.dbse and all component; WrappedDatabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:74722,Availability,error,errors,74722,"atabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not No",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:74884,Availability,error,errors,74884,"rk not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75331,Availability,avail,available,75331," None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75449,Availability,error,errors,75449," counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75473,Availability,error,errors,75473," counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75834,Availability,error,errors,75834,"over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75866,Availability,error,errors,75866,"omputes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:76895,Availability,error,errors,76895,"elf.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:77702,Availability,avail,available,77702,"lor='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:78697,Availability,error,errors,78697,"sible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:78717,Availability,error,errors,78717,"sible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:78846,Availability,error,errors,78846," specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data or all(item is None for item in data):; pass # filter out empty reactions; else:; dbdat.append({'db': db,; 'sys': str(rxn),; 'show': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': data}); mae = [errors[ix][self.dbse]['mae'] for ix in index]; mape = [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; ixpre, ixsuf, ixmid = string_contrast(index); title = self.dbse + ' ' + ixpre + '[]' + ixsuf; # generate matplotlib instruc",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:79599,Availability,error,errors,79599,"able among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data or all(item is None for item in data):; pass # filter out empty reactions; else:; dbdat.append({'db': db,; 'sys': str(rxn),; 'show': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': data}); mae = [errors[ix][self.dbse]['mae'] for ix in index]; mape = [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; ixpre, ixsuf, ixmid = string_contrast(index); title = self.dbse + ' ' + ixpre + '[]' + ixsuf; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, col",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:79660,Availability,error,errors,79660,"= msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data or all(item is None for item in data):; pass # filter out empty reactions; else:; dbdat.append({'db': db,; 'sys': str(rxn),; 'show': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': data}); mae = [errors[ix][self.dbse]['mae'] for ix in index]; mape = [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; ixpre, ixsuf, ixmid = string_contrast(index); title = self.dbse + ' ' + ixpre + '[]' + ixsuf; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=map",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81258,Availability,error,errors,81258,"%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81282,Availability,error,errors,81282,"%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81324,Availability,error,errors,81324," str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['p",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81789,Availability,error,errors,81789,"div=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbos",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81975,Availability,avail,avail,81975,"inc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82360,Availability,error,errors,82360,"e_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82564,Availability,avail,available,82564,"None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82651,Availability,error,errors,82651,"None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; sav",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82675,Availability,error,errors,82675,"None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; sav",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:83072,Availability,error,errors,83072,"h=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as np. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYC",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:89322,Availability,error,errors,89322,"degraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mcs.keys()); else:; mcs = [modelchem]; else:; mcs = modelchem. # commence to generate LaTeX code; tablelines = []; indexlines = []. if standalone:; tablelines += textables.begin_latex_document(). # iterate to produce one LaTeX table per modelchem; for mc in mcs:; # prepare summary statistics; perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tmp['dbrxn'] = dbrxn.replace('_', '\\_'); tmp['indx'] = r""""""\textit{"""""" + str(orxn.indx) + """"""}""""""; tmp['tagl'] = dbrxn.split('-')[0] + ' ' + \; (orxn.latex if orxn.latex else orxn.tagl.replace('_', '\\_')); tmp['imag'] = None # name of primary rgt; bmdatum = orxn.data[lbm].value if lbm else None; mcdatum = orxn.data[lmc].value if lmc else None; tmp['bm'] = bmdatum; tmp['mc'] = mcdatum; if lmc and lbm:; tmp['e'] = mcdatum - bmdatum; tmp['pe'] = 100 * (mcdatum - bmdatum) / abs(bmdatum); # TODO redefining errors not good practice; else:; isComplete = False; tmp['e'] = None; tmp['pe'] = None. terrors[dbrxn] = {}; for c in columnreservoir.keys():; terrors[dbrxn][c] = '' if tmp[c] is None else \; columnreservoir[c][2].format(tmp[c]). fancymodelchem = self.fancy_mcs(latex=True)[mc]; thistitle = title.format(dbse=self.dbse, mc=fancym",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:90016,Availability,error,errors,90016," perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tmp['dbrxn'] = dbrxn.replace('_', '\\_'); tmp['indx'] = r""""""\textit{"""""" + str(orxn.indx) + """"""}""""""; tmp['tagl'] = dbrxn.split('-')[0] + ' ' + \; (orxn.latex if orxn.latex else orxn.tagl.replace('_', '\\_')); tmp['imag'] = None # name of primary rgt; bmdatum = orxn.data[lbm].value if lbm else None; mcdatum = orxn.data[lmc].value if lmc else None; tmp['bm'] = bmdatum; tmp['mc'] = mcdatum; if lmc and lbm:; tmp['e'] = mcdatum - bmdatum; tmp['pe'] = 100 * (mcdatum - bmdatum) / abs(bmdatum); # TODO redefining errors not good practice; else:; isComplete = False; tmp['e'] = None; tmp['pe'] = None. terrors[dbrxn] = {}; for c in columnreservoir.keys():; terrors[dbrxn][c] = '' if tmp[c] is None else \; columnreservoir[c][2].format(tmp[c]). fancymodelchem = self.fancy_mcs(latex=True)[mc]; thistitle = title.format(dbse=self.dbse, mc=fancymodelchem,; sset='All' if sset == 'default' else sset.upper()); lref = [r""""""tbl:qcdb""""""]; if theme:; lref.append(theme); lref.append(self.dbse); if sset != 'default':; lref.append(sset); lref.append(mc); ref = '-'.join(lref). # table intro; tablelines.append(r""""""\begingroup""""""); tablelines.append(r""""""\squeezetable""""""); tablelines.append(r""""""\LTcapwidth=\textwidth""""""); tablelines.append(r""""""\begin{longtable}{%s}"""""" % (''.join([columnreservoir[col][0] for col in columnplan]))); tablelines.append(r""""""\caption{%s"""""" % (thistitle)); tablelines.append(r""""""\label{%s}} \\ """""" % (ref)); tablelines.append(r""""""\hline\hline"""""")",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:95026,Availability,error,errors,95026,"lename is None:; return tablelines, indexlines; else:; if filename.endswith('.tex'):; filename = filename[:-4]; with open(filename + '.tex', 'w') as handle:; handle.write('\n'.join(tablelines)); with open(filename + '_index.tex', 'w') as handle:; handle.write('\n'.join(indexlines) + '\n'); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filename + '_index.tex')}; return filedict. [docs] def table_wrapper(self, mtd, bas, tableplan, benchmark='default',; opt=['CP'], err=['mae'], sset=['default'], dbse=None,; opttarget=None,; failoninc=True,; xlimit=4.0, xlines=[0.0, 0.3, 1.0],; ialimit=2.0,; plotpath='autogen',; subjoin=True,; title=None, indextitle=None,; suppressblanks=False,; standalone=True, theme=None, filename=None):; """"""Prepares dictionary of errors for all combinations of *mtd*, *opt*,; *bas* with respect to model chemistry *benchmark*, mindful of *failoninc*.; The general plan for the table, as well as defaults for landscape,; footnotes, *title*, *indextitle, and *theme* are got from function; *tableplan*. Once error dictionary is ready, it and all other arguments; are passed along to textables.table_generic. Two arrays, one of table; lines and one of index lines are returned unless *filename* is given,; in which case they're written to file and a filedict returned. """"""; # get plan for table from *tableplan* and some default values; kwargs = {'plotpath': plotpath,; 'subjoin': subjoin,; 'xlines': xlines,; 'xlimit': xlimit,; 'ialimit': ialimit}; rowplan, columnplan, landscape, footnotes, \; suggestedtitle, suggestedtheme = tableplan(**kwargs); #suggestedtitle, suggestedtheme = tableplan(plotpath=plotpath, subjoin=subjoin). # make figure files write themselves; autothread = {}; autoliliowa = {}; if plot",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:95302,Availability,error,error,95302,"ndex.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filename + '_index.tex')}; return filedict. [docs] def table_wrapper(self, mtd, bas, tableplan, benchmark='default',; opt=['CP'], err=['mae'], sset=['default'], dbse=None,; opttarget=None,; failoninc=True,; xlimit=4.0, xlines=[0.0, 0.3, 1.0],; ialimit=2.0,; plotpath='autogen',; subjoin=True,; title=None, indextitle=None,; suppressblanks=False,; standalone=True, theme=None, filename=None):; """"""Prepares dictionary of errors for all combinations of *mtd*, *opt*,; *bas* with respect to model chemistry *benchmark*, mindful of *failoninc*.; The general plan for the table, as well as defaults for landscape,; footnotes, *title*, *indextitle, and *theme* are got from function; *tableplan*. Once error dictionary is ready, it and all other arguments; are passed along to textables.table_generic. Two arrays, one of table; lines and one of index lines are returned unless *filename* is given,; in which case they're written to file and a filedict returned. """"""; # get plan for table from *tableplan* and some default values; kwargs = {'plotpath': plotpath,; 'subjoin': subjoin,; 'xlines': xlines,; 'xlimit': xlimit,; 'ialimit': ialimit}; rowplan, columnplan, landscape, footnotes, \; suggestedtitle, suggestedtheme = tableplan(**kwargs); #suggestedtitle, suggestedtheme = tableplan(plotpath=plotpath, subjoin=subjoin). # make figure files write themselves; autothread = {}; autoliliowa = {}; if plotpath == 'autogen':; for col in columnplan:; if col[3].__name__ == 'flat':; if col[4] and autothread:; print('TODO: merge not handled'); elif col[4] or autothread:; autothread.update(col[4]); else:; autothread = {'dummy': True}; elif col[3].__name__ == 'liliowa':; autoliliowa = {'dummy': True}. # negotiate some defaults; dbse = [self.dbs",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:97736,Availability,error,errors,97736,"de at the end. """"""; opt_combos = []; for oreq in orequired:; for opos in opossible:; pieces = sorted(set(oreq.split('_') + opos.split('_'))); if '' in pieces:; pieces.remove(''); for mode in ['CP', 'unCP', 'SA']:; if mode in pieces:; pieces.remove(mode); pieces.append(mode); pieces = '_'.join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product(mtd, opt, bas)]; mc_translator = {}; for m, o, b in itertools.product(mtd, opt, bas):; nominal_mc = '-'.join([m, o, b]); for oo in unify_options([o], opttarget['default']):; trial_mc = '-'.join([m, oo, b]); try:; perr = self.compute_statistics(trial_mc, benchmark=benchmark, sset='default', # prob. too restrictive by choosing subset; failoninc=False, verbose=False, returnindiv=False); except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39473,Deployability,update,update,39473,"e))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.not",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47570,Deployability,configurat,configuration,47570,"""""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:87347,Deployability,toggle,toggle,87347," except KeyError as e:; # reaction not in modelchem; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (key, str(e))); else:; print(mc, str(e), 'not found'); continue; listodicts.append(dictorxn). df = pd.DataFrame(listodicts); pd.set_option('display.width', 500); print(df.head(5)); print(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to toggle between full; compilable document and suitable for inclusion in another LaTeX document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}"""""", """"""{0:50s}""""""],; 'bm': ['d', r""""""\multicolumn{1}{c}{\textbf{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0c",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:87424,Deployability,toggle,toggle,87424,"action %s missing datum %s."""""" % (key, str(e))); else:; print(mc, str(e), 'not found'); continue; listodicts.append(dictorxn). df = pd.DataFrame(listodicts); pd.set_option('display.width', 500); print(df.head(5)); print(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to toggle between full; compilable document and suitable for inclusion in another LaTeX document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}"""""", """"""{0:50s}""""""],; 'bm': ['d', r""""""\multicolumn{1}{c}{\textbf{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:96179,Deployability,update,update,96179,"pe,; footnotes, *title*, *indextitle, and *theme* are got from function; *tableplan*. Once error dictionary is ready, it and all other arguments; are passed along to textables.table_generic. Two arrays, one of table; lines and one of index lines are returned unless *filename* is given,; in which case they're written to file and a filedict returned. """"""; # get plan for table from *tableplan* and some default values; kwargs = {'plotpath': plotpath,; 'subjoin': subjoin,; 'xlines': xlines,; 'xlimit': xlimit,; 'ialimit': ialimit}; rowplan, columnplan, landscape, footnotes, \; suggestedtitle, suggestedtheme = tableplan(**kwargs); #suggestedtitle, suggestedtheme = tableplan(plotpath=plotpath, subjoin=subjoin). # make figure files write themselves; autothread = {}; autoliliowa = {}; if plotpath == 'autogen':; for col in columnplan:; if col[3].__name__ == 'flat':; if col[4] and autothread:; print('TODO: merge not handled'); elif col[4] or autothread:; autothread.update(col[4]); else:; autothread = {'dummy': True}; elif col[3].__name__ == 'liliowa':; autoliliowa = {'dummy': True}. # negotiate some defaults; dbse = [self.dbse] if dbse is None else dbse; theme = suggestedtheme if theme is None else theme; title = suggestedtitle if title is None else title; indextitle = title if indextitle is None else indextitle; opttarget = {'default': ['']} if opttarget is None else opttarget. def unify_options(orequired, opossible):; """"""Perform a merge of options tags in *orequired* and *opossible* so; that the result is free of duplication and has the mode at the end. """"""; opt_combos = []; for oreq in orequired:; for opos in opossible:; pieces = sorted(set(oreq.split('_') + opos.split('_'))); if '' in pieces:; pieces.remove(''); for mode in ['CP', 'unCP', 'SA']:; if mode in pieces:; pieces.remove(mode); pieces.append(mode); pieces = '_'.join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:135909,Deployability,update,updated,135909,"atzadtz'] = ['CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz', 'CCSD-CP-atzadtz']; self.mc['CCSD-CP-atqzadtz'] = ['CCSD-CP-atqzadtz', 'CCSD-CP-atqzhadtz', 'CCSD-CP-atqzadtz']; self.mc['CCSD-CP-atqzatz'] = ['CCSD-CP-atqzatz', 'CCSD-CP-atqzhatz', 'CCSD-CP-atqzatz']. self.mc['CCSDT-CP-adz'] = ['CCSDT-CP-adz', 'CCSDT-CP-hadz', 'CCSDT-CP-adz']; self.mc['CCSDT-CP-atz'] = ['CCSDT-CP-atz', 'CCSDT-CP-hatz', 'CCSDT-CP-atz']; self.mc['CCSDT-CP-adtz'] = ['CCSDT-CP-adtz', 'CCSDT-CP-hadtz', 'CCSDT-CP-adtz']; self.mc['CCSDT-CP-adtzadz'] = ['CCSDT-CP-adtzadz', 'CCSDT-CP-adtzhadz', 'CCSDT-CP-adtzadz']; self.mc['CCSDT-CP-atzadz'] = ['CCSDT-CP-atzadz', 'CCSDT-CP-atzhadz', 'CCSDT-CP-atzadz']; self.mc['CCSDT-CP-atqzadz'] = ['CCSDT-CP-atqzadz', 'CCSDT-CP-atqzhadz', 'CCSDT-CP-atqzadz']; self.mc['CCSDT-CP-atzadtz'] = ['CCSDT-CP-atzadtz', 'CCSDT-CP-atzhadtz', 'CCSDT-CP-atzadtz']; self.mc['CCSDT-CP-atqzadtz'] = ['CCSDT-CP-atqzadtz', 'CCSDT-CP-atqzhadtz', 'CCSDT-CP-atqzadtz']; self.mc['CCSDT-CP-atqzatz'] = ['CCSDT-CP-atqzatz', 'CCSDT-CP-atqzhatz', 'CCSDT-CP-atqzatz']. # print certain statistic for all 4 db and summary and indiv sys if min or max. fnreservoir = {}; fnreservoir['blankslat'] = r""""""Errors with respect to Benchmark. Guide lines are at 0, 0.3, and 1.0 kcal/mol overbound ($-$) and underbound ($+$).""""""; fnreservoir['5min'] = r""""""Only equilibrium and near-equilibrium systems included. (All S22 and HSG, 50/194 NBC10, 28/118 HBC6.)""""""; fnreservoir['liliowa'] = r""""""{0}MAE (dark by {1} kcal/mol) for subsets in residue classes cation, anion, polar, aliphatic, \& aromatic (L to R).""""""; fnreservoir['flat'] = r""""""{0}Errors with respect to benchmark within $\pm${1} kcal/mol. Guide lines are at {2} overbound ($-$) and underbound ($+$)."""""". Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:10111,Energy Efficiency,energy,energy,10111,"weight * q / abs(qm1perat); return mask, weight. [docs]def fancify_mc_tag(mc, latex=False):; """"""From the usual MTD-opt1_opt2-bas model chemistry identifier, return; string based on fullname, if *latex* is False or latex if *latex* is True. """"""; try:; mtd, mod, bas = mc.split('-'); except ValueError:; text = mc; else:; if latex:; text = r""""""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); else:; text = r""""""%20s / %s, %s"""""" % (methods[mtd].fullname, bases[bas].fullname, mod); return text. [docs]class ReactionDatum(object):; """"""Piece of quantum chemical information that describes a qcdb.Reaction object. """""". def __init__(self, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None):; # geometry; self.dbrxn = dbse + '-' + str(rxn); # qcdb.Method; self.method = method; # mode, e.g., unCP, CP, RLX, etc.; self.mode = mode; # qcdb.BasisSet; self.basis = basis; # numerical value for reaction; self.value = float(value); # energy unit attached to value, defaults to kcal/mol; self.units = units; # publication citation of value; self.citation = citation; # digital object identifier for publication (maybe this should be doi of datum, not of pub?); self.doi = doi; # addl comments; self.comment = comment. @classmethod; [docs] def library_modelchem(cls, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None,; comment=None):; """"""Constructor when method and basis are strings corresponding to; qcdb.Method and qcdb.BasisSet already defined in methods and bases. """"""; # computational method; try:; tmp_method = methods[method.upper()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum method %s: %s"""""" % (method, e)); # computational basis set; try:; tmp_basis = bases[basis.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum basis %s: %s"""""" % (basis, e)); # publication; if citation is None:; tmp_pub = citation; else:; try:; tmp_pub = pubs[citation.lower()]; exce",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:13300,Energy Efficiency,charge,charge,13300,"lf.tagl); text += """""" %20s"""""" % ('Reactions'); for ax in self.axis.keys():; text += """""" %8s"""""" % (ax); text += """"""\n""""""; for ix in range(len(self.hrxn)):; text += """""" %20s"""""" % (str(self.hrxn[ix])); for ax in self.axis.values():; text += """""" %8.3f"""""" % (ax[ix]); text += """"""\n""""""; text += """"""\n""""""; return text. [docs]class Reagent(object):; """"""Chemical entity only slightly dresed up from qcdb.Molecule. """""". def __init__(self, name, mol, tagl=None, comment=None):; # full name, e.g., 'S22-2-dimer' or 'NBC1-BzMe-8.0-monoA-CP' or 'HTBH-HCl-reagent'; self.name = name; # qcdb.Molecule; try:; self.NRE = mol.nuclear_repulsion_energy(); except AttributeError:; raise ValidationError(""""""Reagent must be instantiated with qcdb.Molecule object.""""""); else:; self.mol = mol.create_psi4_string_from_molecule(); # description line; self.tagl = tagl; # # addl comments; # self.comment = comment; # # fragmentation; # self.fragments = mol.fragments; # # frag activation; # self.frtype = mol.fragment_types; # # frag charge; # self.frchg = mol.fragment_charges; # # frag multiplicity; # self.frmult = mol.fragment_multiplicities; self.charge = mol.molecular_charge(). def __str__(self):; text = ''; text += """""" ==> %s Reagent <==\n\n"""""" % (self.name); text += """""" Tagline: %s\n"""""" % (self.tagl); # text += """""" Comment: %s\n"""""" % (self.comment); text += """""" NRE: %f\n"""""" % (self.NRE); # text += """""" Charge: %+d\n""""""; # text += """""" Fragments: %d\n"""""" % (len(self.fragments)); # text += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr], self.frmult[fr], self.fragments[fr]); text += """""" Molecule: \n%s"""""" % (self.mol); text += """"""\n""""""; return text. [docs]class Reaction(object):; """""". """""". def __init__(self, name, dbse, indx, tagl=None, latex=None, color='black', comment=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:13418,Energy Efficiency,charge,charge,13418,"n range(len(self.hrxn)):; text += """""" %20s"""""" % (str(self.hrxn[ix])); for ax in self.axis.values():; text += """""" %8.3f"""""" % (ax[ix]); text += """"""\n""""""; text += """"""\n""""""; return text. [docs]class Reagent(object):; """"""Chemical entity only slightly dresed up from qcdb.Molecule. """""". def __init__(self, name, mol, tagl=None, comment=None):; # full name, e.g., 'S22-2-dimer' or 'NBC1-BzMe-8.0-monoA-CP' or 'HTBH-HCl-reagent'; self.name = name; # qcdb.Molecule; try:; self.NRE = mol.nuclear_repulsion_energy(); except AttributeError:; raise ValidationError(""""""Reagent must be instantiated with qcdb.Molecule object.""""""); else:; self.mol = mol.create_psi4_string_from_molecule(); # description line; self.tagl = tagl; # # addl comments; # self.comment = comment; # # fragmentation; # self.fragments = mol.fragments; # # frag activation; # self.frtype = mol.fragment_types; # # frag charge; # self.frchg = mol.fragment_charges; # # frag multiplicity; # self.frmult = mol.fragment_multiplicities; self.charge = mol.molecular_charge(). def __str__(self):; text = ''; text += """""" ==> %s Reagent <==\n\n"""""" % (self.name); text += """""" Tagline: %s\n"""""" % (self.tagl); # text += """""" Comment: %s\n"""""" % (self.comment); text += """""" NRE: %f\n"""""" % (self.NRE); # text += """""" Charge: %+d\n""""""; # text += """""" Fragments: %d\n"""""" % (len(self.fragments)); # text += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr], self.frmult[fr], self.fragments[fr]); text += """""" Molecule: \n%s"""""" % (self.mol); text += """"""\n""""""; return text. [docs]class Reaction(object):; """""". """""". def __init__(self, name, dbse, indx, tagl=None, latex=None, color='black', comment=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22-2' or 'NBC1-BzMe-8.0'; self.dbrxn = dbse + '-' + str(name); # numerical index of reaction; self.indx = indx; # description line; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:21642,Energy Efficiency,reduce,reduce,21642,"); """""". def __init__(self, dbname, pythonpath=None):; """"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n""""""",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82439,Energy Efficiency,green,green-to-purple,82439,"age; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, r",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:102462,Energy Efficiency,energy,energy,102462,"n(indexlines)); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filename + '_index.tex')}; return filedict. [docs] def table_scrunch(self, plotpath, subjoin):; rowplan = ['mtd']; columnplan = [; ['l', r'Method', '', textables.label, {}],; ['c', r'Description', '', textables.empty, {}],; ['d', r'aug-cc-pVDZ', 'unCP', textables.val, {'bas': 'adz', 'opt': 'unCP'}],; ['d', r'aug-cc-pVDZ', 'CP', textables.val, {'bas': 'adz', 'opt': 'CP'}],; ['d', r'aug-cc-pVTZ', 'unCP', textables.val, {'bas': 'atz', 'opt': 'unCP'}],; ['d', r'aug-cc-pVTZ', 'CP', textables.val, {'bas': 'atz', 'opt': 'CP'}]]. footnotes = []; landscape = False; theme = 'summavg'; title = r""""""Classification and Performance of model chemistries. Interaction energy [kcal/mol] {{err}} statistics."""""".format(); return rowplan, columnplan, landscape, footnotes, title, theme. [docs] def table_merge_abbr(self, plotpath, subjoin):; """"""Specialization of table_generic into table with minimal statistics; (three S22 and three overall) plus embedded slat diagram as suitable; for main paper. A single table is formed in sections by *bas* with; lines *mtd* within each section. """"""; rowplan = ['bas', 'mtd']; columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; ['d', r'S22', 'HB', textables.val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', r'S22', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'S22'}],; ['d', r'S22', 'TT', textables.val, {'sset': 'tt', 'dbse': 'S22'}],; ['d', r'Overall', 'HB', textables.val, {'sset': 'hb', 'dbse': 'DB4'}],; ['d', r'Overall', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'DB4'}],; ['d', r'Overall', 'TT', textables.val, {'sset': 'tt', 'dbse': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\include",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:103754,Energy Efficiency,energy,energy,103754,"mbedded slat diagram as suitable; for main paper. A single table is formed in sections by *bas* with; lines *mtd* within each section. """"""; rowplan = ['bas', 'mtd']; columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; ['d', r'S22', 'HB', textables.val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', r'S22', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'S22'}],; ['d', r'S22', 'TT', textables.val, {'sset': 'tt', 'dbse': 'S22'}],; ['d', r'Overall', 'HB', textables.val, {'sset': 'hb', 'dbse': 'DB4'}],; ['d', r'Overall', 'MX/DD', textables.val, {'sset': 'mxdd', 'dbse': 'DB4'}],; ['d', r'Overall', 'TT', textables.val, {'sset': 'tt', 'dbse': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', r'Time', '', textables.empty, {}]]; # TODO Time column not right at all. footnotes = [fnreservoir['blankslat']]; landscape = False; theme = 'smmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs] def table_merge_suppmat(self, plotpath, subjoin):; """"""Specialization of table_generic into table with as many statistics; as will fit (mostly fullcurve and a few 5min) plus embedded slat; diagram as suitable for supplementary material. Multiple tables are; formed, one for each in *bas* with lines *mtd* within each table. """"""; rowplan = ['bas', 'mtd']; columnplan = [; ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; ['d', 'S22', 'HB', textables.val, {'sset': 'hb', 'dbse': 'S22'}],; ['d', 'S22', 'MX', textables.val, {'sset': 'mx', 'dbse': 'S22'}],; ['d', 'S22', 'DD', textables.val, {'sset': 'dd', 'dbse': 'S22'}],; ['d', 'S22', 'TT', textables.val, {'sset': 'tt', 'dbse': 'S22'}],; ['d', 'NBC10', 'MX', textables.val, {'sset': 'mx', 'dbse': 'NBC1'}],; ['d', 'NBC10', 'DD',",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:105836,Energy Efficiency,energy,energy,105836,"textables.val, {'sset': 'tt', 'dbse': 'NBC1'}],; ['d', 'HBC6', 'HB/TT', textables.val, {'sset': 'tt', 'dbse': 'HBC1'}],; ['d', 'HSG', 'HB', textables.val, {'sset': 'hb', 'dbse': 'HSG'}],; ['d', 'HSG', 'MX', textables.val, {'sset': 'mx', 'dbse': 'HSG'}],; ['d', 'HSG', 'DD', textables.val, {'sset': 'dd', 'dbse': 'HSG'}],; ['d', 'HSG', 'TT', textables.val, {'sset': 'tt', 'dbse': 'HSG'}],; ['d', 'Avg', 'TT ', textables.val, {'sset': 'tt', 'dbse': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mx",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62731,Integrability,wrap,wrappeddbs,62731,"ritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; # for rxnix, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancify_mc_tag(mc).strip()] = dbdat. pre, suf, mid = string_contrast(modelchem); title = """"""%s[%s]%s vs %s axis %s for %s subset %s"""""" % (pre, str(len(mid)), suf, benchmark, axis, self.dbse, sset); print(title); #for mc, dbdat in dbdatdict.iterite",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47570,Modifiability,config,configuration,47570,"""""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:87704,Modifiability,variab,variables,87704,"int(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to toggle between full; compilable document and suitable for inclusion in another LaTeX document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}"""""", """"""{0:50s}""""""],; 'bm': ['d', r""""""\multicolumn{1}{c}{\textbf{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mc",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:21807,Performance,load,load,21807,"internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for da",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:22064,Performance,load,load,22064," OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for database %s"""""" % (self.dbse)). # form array of database contents to process through; pieces = []; for item in dir(database):; if item in ['qcdb', 'rxn', 'dbse', 'TAGL']:; pass; elif item.startswith('__'):; pass; else:; pieces.ap",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:22204,Performance,load,loading,22204,"n = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for database %s"""""" % (self.dbse)). # form array of database contents to process through; pieces = []; for item in dir(database):; if item in ['qcdb', 'rxn', 'dbse', 'TAGL']:; pass; elif item.startswith('__'):; pass; else:; pieces.append(item). # form qcdb.Reagent objects from all defined geometries, GEOS; oHRGT = {}; for rgt, mol in database.GEOS.iteritems():; mol.update_geometr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37995,Performance,load,load,37995,"r['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:38144,Performance,load,loading,38144,"if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise Valida",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:38450,Performance,load,loading,38450,"r. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:38528,Performance,load,loaded,38528,"oads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39254,Performance,load,loading,39254,"tributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.ge",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39371,Performance,load,load,39371,"Error(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39949,Performance,load,loading,39949,"f path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41202,Performance,load,loading,41202,"rror:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # retu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41508,Performance,load,load,41508,"'-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41654,Performance,load,loaded,41654,".library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.a",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42746,Performance,load,load,42746,"union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42893,Performance,load,loading,42893,"*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:43133,Performance,load,loaded,43133,"y:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # ]; #; # def table_simple2(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='def",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:46848,Performance,load,loadfrompickle,46848,"']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # # ['l', r""""""Error Distribution\footnotemark[1]"""""", r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'), textables.graphics, {}],; # ['l', r""""""Error Distribution\footnotemark[1]"""""", r"""""""""""", textables.graphics, {}],; # ]. [docs]class Database(object):; """"""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [od",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47614,Performance,load,load,47614,"ng statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47656,Performance,load,loadfrompickle,47656,"ng statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:51090,Performance,load,loads,51090,""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: defaultdict(dict)); # for mc in self.mcs.keys():; # try:; # mtd, mod, bas = mc.split('-'); # except ValueError:; # fmcs['All']['All'][mc] = mc; # fmcs['Method']['Others'][mc] = mc; # fmcs['Options']['Others'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All']['All'][mc] = fancyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options'][mod][mc] = fancyrepr; # fmcs['Basis Treatment'][bases[bas].latex][mc] = fancyrepr; # return fmcs. [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; return {db: odb.integer_reactions() for db, odb in self.dbdict.items()}. [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""For each component database, loads qcdb.ReactionDatums from; standard location for *project* :module dbse_project and function; load_project. Module search path can be prepended with *pythonpath*. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_byproject(project, pythonpath=pythonpath); self._intersect_modelchems(). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:51485,Performance,load,loads,51485,"hers'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All']['All'][mc] = fancyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options'][mod][mc] = fancyrepr; # fmcs['Basis Treatment'][bases[bas].latex][mc] = fancyrepr; # return fmcs. [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; return {db: odb.integer_reactions() for db, odb in self.dbdict.items()}. [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""For each component database, loads qcdb.ReactionDatums from; standard location for *project* :module dbse_project and function; load_project. Module search path can be prepended with *pythonpath*. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_byproject(project, pythonpath=pythonpath); self._intersect_modelchems(). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path is None:; path = os.path.dirname(__file__) + '/../data'. projects = []; for pjfn in glob.glob(path + '/*_hrxn_*.pickle'):; pj = pjfn[:-7].split('_')[-1]; projects.append(pj). complete_projects = []; for pj in set(projects):; if all([os.path.isfile(path + '/' + db + '_hrxn_' + pj + '.pickle') for db in self.dbdict.keys()]):; complete_projects.append(pj). return complete_projects. [docs] def loa",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:52536,Performance,load,loads,52536,"ms from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path is None:; path = os.path.dirname(__file__) + '/../data'. projects = []; for pjfn in glob.glob(path + '/*_hrxn_*.pickle'):; pj = pjfn[:-7].split('_')[-1]; projects.append(pj). complete_projects = []; for pj in set(projects):; if all([os.path.isfile(path + '/' + db + '_hrxn_' + pj + '.pickle') for db in self.dbdict.keys()]):; complete_projects.append(pj). return complete_projects. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""For each component database, loads subsets from all functions; in module *modname*. Default *modname* usues standard generators. """"""; for db, odb in self.dbdict.items():; odb.load_subsets(modname=modname, pythonpath=pythonpath); self._intersect_subsets(). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a database; *func* whose keys are the keys of dbdict and whose values are a; function that filters each WrappedDatabase's *self.hrxn*. """"""; label = name.lower(); merged = []; for db, odb in self.dbdict.iteritems():; if callable(func[db]):; ssfunc = func[db]; else:; ssfunc = lambda x: func[db]; odb.add_Subset(name=name, func=ssfunc); if name in odb.sset:; merged.append(name); else:; merged.append(None); if any(merged):; self.sset[label] = merged; print(""""""Database %s: Subset %s formed: %s"""""" % (self.dbse, label, self.sset[label])); else:; print(""""""Database %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)). [docs] def add_Subset_union(self,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:64770,Performance,load,loads,64770,"for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d['mcdata'] is None else d['mcdata']); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:65168,Performance,load,load,65168,"int(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.sset[lss]:; dbrxn = orxn.dbrxn; try:; elst = saptdata['SAPT ELST ENERGY'][dbrxn]; exch = saptdata['SAPT EXCH ENERGY'][dbrxn]; ind = saptdata['SAPT IND ENERGY'][dbrxn]; disp = saptdata['SAPT DISP ENERGY'][dbrxn]; except (KeyError, AttributeError):; print(""""""Warning: DATA['SAPT * ENERGY'] missing for reaction %s"""""" % (dbrxn)); if failoninc:; break; else:; if not all([elst, ind, disp]): # exch sometimes physically zero; print(""""""Warning: ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:65315,Performance,load,loading,65315,"pr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.sset[lss]:; dbrxn = orxn.dbrxn; try:; elst = saptdata['SAPT ELST ENERGY'][dbrxn]; exch = saptdata['SAPT EXCH ENERGY'][dbrxn]; ind = saptdata['SAPT IND ENERGY'][dbrxn]; disp = saptdata['SAPT DISP ENERGY'][dbrxn]; except (KeyError, AttributeError):; print(""""""Warning: DATA['SAPT * ENERGY'] missing for reaction %s"""""" % (dbrxn)); if failoninc:; break; else:; if not all([elst, ind, disp]): # exch sometimes physically zero; print(""""""Warning: DATA['SAPT * ENERGY'] missing piece for reaction %s: %s"""""" % (dbrxn, [elst, exch, ind, disp])); if failoninc:; break; saptpackage[dbrxn] = {'mc': saptmc,; 'elst': elst,; 'exch':",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:66626,Performance,load,loads,66626,"PT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.sset[lss]:; dbrxn = orxn.dbrxn; try:; elst = saptdata['SAPT ELST ENERGY'][dbrxn]; exch = saptdata['SAPT EXCH ENERGY'][dbrxn]; ind = saptdata['SAPT IND ENERGY'][dbrxn]; disp = saptdata['SAPT DISP ENERGY'][dbrxn]; except (KeyError, AttributeError):; print(""""""Warning: DATA['SAPT * ENERGY'] missing for reaction %s"""""" % (dbrxn)); if failoninc:; break; else:; if not all([elst, ind, disp]): # exch sometimes physically zero; print(""""""Warning: DATA['SAPT * ENERGY'] missing piece for reaction %s: %s"""""" % (dbrxn, [elst, exch, ind, disp])); if failoninc:; break; saptpackage[dbrxn] = {'mc': saptmc,; 'elst': elst,; 'exch': exch,; 'ind': ind,; 'disp': disp}; return saptpackage. [docs] def plot_ternary(self, sset='default', labeled=True,; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True, # pythonpath=None; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo, then formats it to plot a ternary diagram. """"""; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath=pythonpath,; failoninc=failoninc). dbdat = []; mcs = []; for dat in saptdata.values():; dbdat.append([dat['elst'], dat['ind'], dat['disp']]); if dat['mc'] not in mcs:; mcs.append(dat['mc']). title = ' '.join([self.dbse, sset, ' '.join(mcs)]). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; pass; # if not running from Canopy, print line to execute from Canopy; else:; # if running from Canopy, call mpl directly; filedict = mpl.ternary(dbdat, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, c",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:70715,Performance,load,load,70715,"th=relpath, graphicsformat=graphicsformat); return filedict. [docs] def write_xyz_files(self, path=None):; """"""Writes xyz files for every reagent in the Database to directory; in *path* or to directory dbse_xyzfiles that it createsin cwd if; *path* is None. Additionally, writes a script to that directory; that will generate transparent-background ray-traced png files for; every reagent with PyMol. """"""; if path is None:; xyzdir = os.getcwd() + os.sep + self.dbse + '_xyzfiles' + os.sep; else:; xyzdir = os.path.abspath(path) + os.sep; if not os.path.exists(xyzdir):; os.mkdir(xyzdir). for rgt, orgt in self.hrgt.iteritems():; omol = Molecule(orgt.mol); omol.update_geometry(); omol.save_xyz(xyzdir + rgt + '.xyz'). with open(xyzdir + 'pymol_xyz2png_script.pml', 'w') as handle:; handle.write(""""""; # Launch PyMOL and run from its command line:; # PyMOL> cd {}; # PyMOL> @{}; """""".format(xyzdir, 'pymol_xyz2png_script.pml')); for rgt in self.hrgt.keys():; handle.write(""""""; load {xyzfile}; hide lines; show sticks; color grey, name c; cmd.set('''opaque_background''','''0''',quiet=0); reset; orient; cmd.zoom(buffer=0.3, complete=1); ray; png {pngfile}; reinitialize; """""".format(; xyzfile=xyzdir + rgt + '.xyz',; pngfile=xyzdir + rgt + '.png')). [docs] def plot_all_flats(self, modelchem=None, sset='default', xlimit=4.0,; failoninc=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from *modelchem*, otherwise defaults to; all those available. Can modify subset *sset* and plotting; range *xlimit*. >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0); """"""; mcs = self.mcs.keys() if modelchem is None else modelchem; filedict = OrderedDict(); for mc in sorted(mcs):; minifiledict = self.plot_flat(mc, sset=sset, xlimit=xlimit, view=False,; failoninc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:106090,Performance,load,loadfrompickle,106090," 'dd', 'dbse': 'HSG'}],; ['d', 'HSG', 'TT', textables.val, {'sset': 'tt', 'dbse': 'HSG'}],; ['d', 'Avg', 'TT ', textables.val, {'sset': 'tt', 'dbse': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:106276,Performance,load,loadfrompickle,106276,"': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:106291,Performance,load,loadfrompickle,106291,"': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:106323,Performance,load,load,106323,"width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5min'] = ['mxddpp', 'mxddpp-5min', None, None]; self.sset['np-5min'] = ['mxddnp', 'mxd",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:132277,Performance,load,load,132277,"adz', 'M08SO-CP-adz', 'M08SO-unCP-atz', 'M08SO-CP-atz',; 'M11-unCP-adz', 'M11-CP-adz', 'M11-unCP-atz', 'M11-CP-atz',; 'VV10-unCP-adz', 'VV10-CP-adz', 'VV10-unCP-atz', 'VV10-CP-atz',; 'LCVV10-unCP-adz', 'LCVV10-CP-adz', 'LCVV10-unCP-atz', 'LCVV10-CP-atz',; 'WB97XV-unCP-adz', 'WB97XV-CP-adz', 'WB97XV-unCP-atz', 'WB97XV-CP-atz',; 'PBE02-unCP-adz', 'PBE02-CP-adz', 'PBE02-unCP-atz', 'PBE02-CP-atz',; 'WB97X2-unCP-adz', 'WB97X2-CP-adz', 'WB97X2-unCP-atz', 'WB97X2-CP-atz',; 'DSDPBEP86D2OPT-unCP-adz', 'DSDPBEP86D2OPT-CP-adz', 'DSDPBEP86D2OPT-unCP-atz', 'DSDPBEP86D2OPT-CP-atz',; 'B2PLYPD3-unCP-adz', 'B2PLYPD3-CP-adz', 'B2PLYPD3-unCP-atz', 'B2PLYPD3-CP-atz'],; # 'MP2-unCP-adz', 'MP2-CP-adz', 'MP2-unCP-atz', 'MP2-CP-atz'],; standalone=False, filename='tblrxn_all'). [docs]class ThreeDatabases(Database):; """""". """""". def __init__(self, pythonpath=None):; """"""Initialize ThreeDatabases object from Database""""""; Database.__init__(self, ['s22', 'a24', 'hsg'], dbse='DB3', pythonpath=None). # load up data and definitions; self.load_qcdata_byproject('pt2'); self.load_qcdata_byproject('dilabio'); self.load_qcdata_byproject('f12dilabio'); self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default']; self.sset['hb'] = ['hb', 'hb', 'hb']; self.sset['mx'] = ['mx', 'mx', 'mx']; self.sset['dd'] = ['dd', 'dd', 'dd']; self.sset['mxdd'] = ['mxdd', 'mxdd', 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', 'mxddpp']; self.sset['np'] = ['mxddnp', 'mxddnp', 'mxddnp']; self.sset['tt-5min'] = ['default', 'default', 'default']; self.sset['hb-5min'] = ['hb', 'hb', 'hb']; self.sset['mx-5min'] = ['mx', 'mx', 'mx']; self.sset['dd-5min'] = ['dd', 'dd', 'dd']; self.sset['mxdd-5min'] = ['mxdd', 'mxdd', 'mxdd']; self.sset['pp-5min'] = ['mxddpp', 'mxddpp', 'mxddpp']; self.sset['np-5min'] = ['mxddnp', 'mxddnp', 'mxddnp']; self.sset['weak'] = ['weak', 'weak', 'weak']; self.sset['weak_hb'] = ['weak_hb',",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72320,Safety,avoid,avoid,72320,"otting; range *xlimit*. >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0); """"""; mcs = self.mcs.keys() if modelchem is None else modelchem; filedict = OrderedDict(); for mc in sorted(mcs):; minifiledict = self.plot_flat(mc, sset=sset, xlimit=xlimit, view=False,; failoninc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:17946,Security,access,accessible,17946," % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:20297,Security,validat,validation,20297,"m Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=labels, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs]class WrappedDatabase(object):; """"""Wrapper class for raw Psi4 database modules that does some validation; of contents, creates member data and accessors for database structures,; defines error computation, and handles database subsets. Not to be used; directly-- see qcdb.Database for handling single or multiple; qdcb.WrappedDatabase objects and defining nice statistics, plotting, and; table functionalities. >>> asdf = qcdb.WrappedDatabase('Nbc10'); """""". def __init__(self, dbname, pythonpath=None):; """"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:20346,Security,access,accessors,20346,"m Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=labels, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs]class WrappedDatabase(object):; """"""Wrapper class for raw Psi4 database modules that does some validation; of contents, creates member data and accessors for database structures,; defines error computation, and handles database subsets. Not to be used; directly-- see qcdb.Database for handling single or multiple; qdcb.WrappedDatabase objects and defining nice statistics, plotting, and; table functionalities. >>> asdf = qcdb.WrappedDatabase('Nbc10'); """""". def __init__(self, dbname, pythonpath=None):; """"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:21716,Security,access,access,21716,"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:22259,Security,validat,validation,22259,"z_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for database %s"""""" % (self.dbse)). # form array of database contents to process through; pieces = []; for item in dir(database):; if item in ['qcdb', 'rxn', 'dbse', 'TAGL']:; pass; elif item.startswith('__'):; pass; else:; pieces.append(item). # form qcdb.Reagent objects from all defined geometries, GEOS; oHRGT = {}; for rgt, mol in database.GEOS.iteritems():; mol.update_geometry(); try:; tagl = database.TAGL[rgt]; except KeyError:; tagl = None; print(""""""Warning: TAGL missing for reagent %s"""""" % (rgt)); oHRGT[rgt] = Reagent(name",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39718,Security,validat,validated,39718,"r *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47325,Security,validat,validation,47325,"""""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:51650,Security,validat,validated,51650,"ncyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options'][mod][mc] = fancyrepr; # fmcs['Basis Treatment'][bases[bas].latex][mc] = fancyrepr; # return fmcs. [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; return {db: odb.integer_reactions() for db, odb in self.dbdict.items()}. [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""For each component database, loads qcdb.ReactionDatums from; standard location for *project* :module dbse_project and function; load_project. Module search path can be prepended with *pythonpath*. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_byproject(project, pythonpath=pythonpath); self._intersect_modelchems(). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path is None:; path = os.path.dirname(__file__) + '/../data'. projects = []; for pjfn in glob.glob(path + '/*_hrxn_*.pickle'):; pj = pjfn[:-7].split('_')[-1]; projects.append(pj). complete_projects = []; for pj in set(projects):; if all([os.path.isfile(path + '/' + db + '_hrxn_' + pj + '.pickle') for db in self.dbdict.keys()]):; complete_projects.append(pj). return complete_projects. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""For each component database, loads subsets from all functions; in module *modname*. Default *modname* usues standard ge",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:59928,Security,access,accessible,59928,"eys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def plot_bars(self, modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' +",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68026,Security,access,accessible,68026,"structions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; pass; # if not running from Canopy, print line to execute from Canopy; else:; # if running from Canopy, call mpl directly; filedict = mpl.ternary(dbdat, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72717,Security,access,access,72717,"inc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72766,Security,access,access,72766,"inc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75021,Security,access,accessible,75021," False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canop",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:77394,Security,access,accessible,77394,"le, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) #",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81080,Security,access,access,81080,"n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, grap",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81167,Security,access,accessible,81167,"t=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81230,Security,access,accessible,81230,"t=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:8483,Testability,benchmark,benchmark,8483," and array of middles. """"""; s = [item + 'q' for item in ss if item is not None]; short = min(s, key=len); for ib in range(len(short)):; if not all([mc[ib] == short[ib] for mc in s]):; preidx = ib; break; else:; preidx = 0; for ib in range(len(short)):; ie = -1 * (ib + 1); if not all([mc[ie] == short[ie] for mc in s]):; sufidx = ie + 1; break; else:; sufidx = -1 * (len(short)). miditer = iter([mc[preidx:sufidx] for mc in s]); prefix = short[:preidx]; suffix = short[sufidx:-1]; middle = ['' if mc is None else next(miditer) for mc in ss]. return prefix, suffix, middle. [docs]def oxcom(lst):; """"""Returns gramatical comma separated string of *lst*.""""""; lst = [str(l) for l in lst]. if not lst:; return ''; elif len(lst) == 1:; return lst[0]; elif len(lst) == 2:; return ' and '.join(lst); else:; return ', and '.join([', '.join(lst[:-1]), lst[-1]]). [docs]def cure_weight(refrxn, refeq, rrat, xi=0.2):; """"""; :param refeq: value of benchmark for equilibrium Reaction; :param rrat: ratio of intermonomer separation for Reaction to equilibrium Reaction; :param xi: parameter; :return: weight for CURE. """"""; sigma = xi * abs(refeq) / (rrat ** 3); weight = max(abs(refrxn), sigma); return weight. [docs]def balanced_error(refrxn, refeq, rrat, m=0.03, p=10.0):; """"""; :param refrxn:; :param refeq:; :param rrat:; :param m: minimum permitted weight for a point; :param p: multiples of abs(refeq) above refeq to which zero-line in head is displaced; :return:. """"""; one = float(1); q = one if rrat >= one else p; qm1perat = q - 1 + refrxn / refeq; weight = max(m, qm1perat / q); mask = weight * q / abs(qm1perat); return mask, weight. [docs]def fancify_mc_tag(mc, latex=False):; """"""From the usual MTD-opt1_opt2-bas model chemistry identifier, return; string based on fullname, if *latex* is False or latex if *latex* is True. """"""; try:; mtd, mod, bas = mc.split('-'); except ValueError:; text = mc; else:; if latex:; text = r""""""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); else:; text = ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:14705,Testability,benchmark,benchmark,14705,"+= """""" Fragments: %d\n"""""" % (len(self.fragments)); # text += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr], self.frmult[fr], self.fragments[fr]); text += """""" Molecule: \n%s"""""" % (self.mol); text += """"""\n""""""; return text. [docs]class Reaction(object):; """""". """""". def __init__(self, name, dbse, indx, tagl=None, latex=None, color='black', comment=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22-2' or 'NBC1-BzMe-8.0'; self.dbrxn = dbse + '-' + str(name); # numerical index of reaction; self.indx = indx; # description line; self.tagl = tagl; # latex description; self.latex = latex; # addl comments; self.comment = comment; # reaction matrices, specifying reagent contributions per reaction; self.rxnm = {}; # qcdb.ReactionDatum objects of quantum chemical data pertaining to reaction; self.data = {}; # benchmark qcdb.ReactionDatum; self.benchmark = None; # color for plotting; self.color = color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:14740,Testability,benchmark,benchmark,14740,"t += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr], self.frmult[fr], self.fragments[fr]); text += """""" Molecule: \n%s"""""" % (self.mol); text += """"""\n""""""; return text. [docs]class Reaction(object):; """""". """""". def __init__(self, name, dbse, indx, tagl=None, latex=None, color='black', comment=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22-2' or 'NBC1-BzMe-8.0'; self.dbrxn = dbse + '-' + str(name); # numerical index of reaction; self.indx = indx; # description line; self.tagl = tagl; # latex description; self.latex = latex; # addl comments; self.comment = comment; # reaction matrices, specifying reagent contributions per reaction; self.rxnm = {}; # qcdb.ReactionDatum objects of quantum chemical data pertaining to reaction; self.data = {}; # benchmark qcdb.ReactionDatum; self.benchmark = None; # color for plotting; self.color = color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, v",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:15139,Testability,benchmark,benchmark,15139,"ent=None):; # name, e.g., '2' or 'BzMe-8.0'; self.name = name; # database reaction name, e.g., 'S22-2' or 'NBC1-BzMe-8.0'; self.dbrxn = dbse + '-' + str(name); # numerical index of reaction; self.indx = indx; # description line; self.tagl = tagl; # latex description; self.latex = latex; # addl comments; self.comment = comment; # reaction matrices, specifying reagent contributions per reaction; self.rxnm = {}; # qcdb.ReactionDatum objects of quantum chemical data pertaining to reaction; self.data = {}; # benchmark qcdb.ReactionDatum; self.benchmark = None; # color for plotting; self.color = color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is func",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:15263,Testability,benchmark,benchmark,15263,"e reaction name, e.g., 'S22-2' or 'NBC1-BzMe-8.0'; self.dbrxn = dbse + '-' + str(name); # numerical index of reaction; self.indx = indx; # description line; self.tagl = tagl; # latex description; self.latex = latex; # addl comments; self.comment = comment; # reaction matrices, specifying reagent contributions per reaction; self.rxnm = {}; # qcdb.ReactionDatum objects of quantum chemical data pertaining to reaction; self.data = {}; # benchmark qcdb.ReactionDatum; self.benchmark = None; # color for plotting; self.color = color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:15708,Testability,benchmark,benchmark,15708,"= color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:15879,Testability,benchmark,benchmark,15879,"= color. def __str__(self):; text = ''; text += """""" ==> %s Reaction <==\n\n"""""" % (self.name); text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Index: %s\n"""""" % (self.indx); text += """""" LaTeX representation: %s\n"""""" % (self.latex); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" Comment: %s\n"""""" % (self.comment); if self.benchmark is None:; text += """""" Benchmark: %s\n"""""" % ('UNDEFINED'); else:; text += """""" Benchmark: %f\n"""""" % (self.data[self.benchmark].value); text += """""" Color: %s\n"""""" % (str(self.color)); text += """""" Reaction matrix:\n""""""; for mode, rxnm in self.rxnm.iteritems():; text += """""" %s\n"""""" % (mode); for rgt, coeff in rxnm.iteritems():; text += """""" %3d %s\n"""""" % (coeff, rgt.name); text += """""" Data:\n""""""; for label, datum in sorted(self.data.iteritems()):; text += """""" %8.2f %s\n"""""" % (datum.value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16593,Testability,benchmark,benchmark,16593,"value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16606,Testability,benchmark,benchmark,16606,"value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16634,Testability,benchmark,benchmark,16634,"value, label); text += """"""\n""""""; return text. [docs] def compute_errors(self, benchmark='default', mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16756,Testability,benchmark,benchmark,16756," mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:17337,Testability,benchmark,benchmark,17337,"stries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:17738,Testability,benchmark,benchmark,17738,"lf.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.com",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:18602,Testability,benchmark,benchmark,18602,"odel chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; # ixpre, ixsuf, ixmid = string_contrast(index); # title = self.dbse + ' ' + ixpre + '[]' + ixsuf; title = self.dbrxn; labels = ['']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:18612,Testability,benchmark,benchmark,18612,"odel chemistries in *mcset* (which; may be default or an array or a function generating an array) versus; *benchmark*. Thread *color* can be 'rgb' for old coloring, a color; name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # compute errors; dbse = self.dbrxn.split('-')[0]; indiv = self.compute_errors(benchmark=benchmark, mcset=mcset,; failoninc=failoninc, verbose=verbose). # repackage; dbdat = []; for mc in indiv.keys():; dbdat.append({'db': dbse,; 'show': fancify_mc_tag(mc),; 'sys': mc,; 'color': self.color,; 'data': [indiv[mc][0]]}); mae = None # [errors[ix][self.dbse]['mae'] for ix in index]; mape = None # [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; # ixpre, ixsuf, ixmid = string_contrast(index); # title = self.dbse + ' ' + ixpre + '[]' + ixsuf; title = self.dbrxn; labels = ['']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, labels, mae, mape",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:27194,Testability,benchmark,benchmark,27194,".iteritems():; bindval = getattr(database, info[3])[dbrxn]; if info[5] is None:; methodfeed = info[0]; modefeed = info[1]; basisfeed = info[2]; citationkey = 'anon'; else:; bindinforxn = getattr(database, info[5])[dbrxn]; methodfeed = methods[bindinforxn['method'].upper()] if 'method' in bindinforxn else info[0]; modefeed = bindinforxn['mode'] if 'mode' in bindinforxn else info[1]; basisfeed = bases[bindinforxn['basis'].lower()] if 'basis' in bindinforxn else info[2]; citationkey = bindinforxn['citation'].lower() if 'citation' in bindinforxn else 'anon'; citationfeed = pubs[citationkey]. if bindval is not None:; oHRXN[rxn].data[ref] = ReactionDatum(dbse=database.dbse, rxn=rxn,; method=methodfeed, mode=modefeed,; basis=basisfeed, citation=citationfeed,; value=bindval); # oHRXN[rxn].data[ref] = ReactionDatum(dbse=database.dbse,; # rxn=rxn,; # method=info[0],; # mode=info[1],; # basis=info[2],; # value=bindval); # #value=getattr(database, info[3])[dbrxn]); if info[4]:; oHRXN[rxn].benchmark = ref. # Process subsets; oSSET = {}; fsHRXN = frozenset(database.HRXN); for sset in pieces:; if not sset.startswith('AXIS_'):; try:; fssset = frozenset(getattr(database, sset)); except TypeError:; continue; if fssset.issubset(fsHRXN):; oSSET[sset] = getattr(database, sset); for item in oSSET.keys():; pieces.remove(item); oSSET['HRXN'] = database.HRXN. self.sset = OrderedDict(); self.oss = OrderedDict() # just in case oss replaces sset someday; for item in oSSET.keys():; if item == 'HRXN_SM':; label = 'small'; elif item == 'HRXN_LG':; label = 'large'; elif item == 'HRXN_EQ':; label = 'equilibrium'; elif item == 'HRXN':; label = 'default'; elif item.startswith('HRXN_'):; label = item.replace('HRXN_', '').lower(); else:; label = item.lower(). # subsets may have different ordering from HRXN; self.sset[label] = OrderedDict(); for rxn in oSSET[item]:; self.sset[label][rxn] = oHRXN[rxn]. # initialize subset objects with light info; try:; sstagl = database.TAGL[item]; except KeyError:; try:",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:29405,Testability,benchmark,benchmark,29405,"for axis in [item for item in pieces if item.startswith('AXIS_')]:; label = axis.replace('AXIS_', ''); try:; defn = getattr(database, axis); except AttributeError:; raise ValidationError(""""""Axis %s not importable."""""" % (label)); axisrxns = frozenset(defn.keys()); attached = False; for ss, rxns in self.sset.iteritems():; if frozenset(rxns).issubset(axisrxns):; ordered_floats = []; for rx in self.oss[ss].hrxn:; ordered_floats.append(defn[rx]); self.oss[ss].axis[label] = ordered_floats; attached = True; if not attached:; print(""""""Warning: AXIS %s not affiliated with a subset"""""" % (label)); pieces.remove(axis). print(""""""WrappedDatabase %s: Unparsed attributes"""""" % (self.dbse), pieces). def __str__(self):; text = ''; text += """""" ==> %s WrappedDatabase <==\n\n"""""" % (self.dbse); text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); text += """""" Reference: %s\n"""""" % (self.benchmark()); text += """"""\n""""""; return text. [docs] def add_ReactionDatum(self, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, comment=None,; overwrite=False):; """"""Add a new quantum chemical value to *rxn* by creating a; qcdb.ReactionDatum from same arguments as that class's; object-less constructor. *rxn* may be actual Reaction.name; or Reaction.indx. """"""; if (self.dbse == dbse):; if rxn in self.hrxn:; rxnname = rxn # rxn is proper reaction name; else:; try:; if (rxn + 1 > 0) and (rxn == self.hrxn.items()[rxn - 1][1].indx):; rxnname = self.hrxn.items()[rxn - 1][1].name # rxn is reaction index (maybe dangerous?); except (TypeError, IndexError):; raise ValidationError(; """"""Inconsistent to add ReactionDatum for %s to database %s with reactions %s."""""" %; (dbse + '-' + str(rxn), self.dbse, self.hrxn.keys())); label = '-'.join([method, mode, basis]); if overwrite or (label not in self.hrxn[rxnname].data):; self.hrxn[rxnname].data[label] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rx",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:31667,Testability,benchmark,benchmark,31667,"str(rxn), self.dbse)). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a function; *func* that filters *self.hrxn*. """"""; sname = name.lower().split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslis",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:31831,Testability,benchmark,benchmark,31831,"str(rxn), self.dbse)). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a function; *func* that filters *self.hrxn*. """"""; sname = name.lower().split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslis",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:32876,Testability,benchmark,benchmark,32876,"any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cureinfo[rxn]; # try:; # mcGreaterCrvmin = self.hrxn[rxncureinfo['eq']].data[lbench].value; # except KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreate",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:32889,Testability,benchmark,benchmark,32889,"any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cureinfo[rxn]; # try:; # mcGreaterCrvmin = self.hrxn[rxncureinfo['eq']].data[lbench].value; # except KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreate",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:32917,Testability,benchmark,benchmark,32917,"any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cureinfo[rxn]; # try:; # mcGreaterCrvmin = self.hrxn[rxncureinfo['eq']].data[lbench].value; # except KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreate",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:33240,Testability,benchmark,benchmark,33240,"ror(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cureinfo[rxn]; # try:; # mcGreaterCrvmin = self.hrxn[rxncureinfo['eq']].data[lbench].value; # except KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:33486,Testability,benchmark,benchmark,33486,".sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cureinfo[rxn]; # try:; # mcGreaterCrvmin = self.hrxn[rxncureinfo['eq']].data[lbench].value; # except KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34346,Testability,benchmark,benchmark,34346,"xcept KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34539,Testability,benchmark,benchmark,34539,"xcept KeyError as e:; # print """"""Reaction %s missing benchmark"""""" % (str(eqrxn)). # cure_denom = cure_weight(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']); # balanced_mask, balwt = balanced_error(refrxn=mcGreater, refeq=mcGreaterCrvmin, rrat=rxncureinfo['Rrat']). if lbench == 'ZEROS':; err[rxn] = [mcLesser,; 0.0, 0.0, 0.0, 1.0] # FAKE; else:; err[rxn] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34812,Testability,benchmark,benchmark,34812,"er - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:34822,Testability,benchmark,benchmark,34822,"er - mcGreater) / abs(mcGreater), # FAKE; (mcLesser - mcGreater) / abs(mcGreater), # FKAE; 1.0 # FAKE; ]; # (mcLesser - mcGreater) / abs(cure_denom),; # (mcLesser - mcGreater) * balanced_mask / abs(mcGreaterCrvmin),; # balwt]; if verbose:; print(""""""p = %8.4f, pe = %8.3f%%, pbe = %8.3f%% pce = %8.3f%% reaction %s."""""" %; (err[rxn][0], 100 * err[rxn][1], 100 * err[rxn][3], 100 * err[rxn][2], str(rxn))); return err. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""For full database or subset *sset*, computes many error; statistics between single *modelchem* and *benchmark* model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless *failoninc* set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. """"""; err = self.compute_errors(modelchem, benchmark=benchmark, sset=sset, failoninc=failoninc, verbose=verbose); if len(err) == 0:; error = initialize_errors(); if verbose:; print(""""""Warning: nothing to compute.""""""); else:; Nrxn = float(len(err)); error = OrderedDict(); # linear (absolute) error; linear = [val[0] for val in err.values()]; error['pexe'] = max(linear); error['nexe'] = min(linear); error['maxe'] = max(linear, key=lambda x: abs(x)); error['mine'] = min(linear, key=lambda x: abs(x)); error['me'] = sum(linear) / Nrxn; error['mae'] = sum(map(abs, linear)) / Nrxn; error['rmse'] = math.sqrt(sum(map(lambda x: x ** 2, linear)) / Nrxn); error['stde'] = math.sqrt((sum(map(lambda x: x ** 2, linear)) - (sum(linear) ** 2) / Nrxn) / Nrxn); # fractional (relative) error; relative = [val[1] for val in err.values()]; error['pexpe'] = max(relative); error['nexpe'] = min(relative); error['maxpe'] = max(relative, key=lambda x: abs(x)); error['minpe'] = min(relative, key=lambda x: abs(x)); error['mpe'] = sum(relative) / Nrxn; error['mape'] = sum(map(abs, relative)) / Nrxn; error['rmspe'] = math.sqrt(sum(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:37322,Testability,benchmark,benchmark,37322," error['mpbe'] = sum(balanced) / balwt #Nrxn; error['mapbe'] = sum(map(abs, balanced)) / balwt #Nrxn; error['rmspbe'] = math.sqrt(sum(map(lambda x: x ** 2, balanced)) / balwt) #Nrxn); error['stdpbe'] = None # get math domain errors w/wt in denom math.sqrt((sum(map(lambda x: x ** 2, balanced)) - (sum(balanced) ** 2) / balwt) / balwt) #/ Nrxn) / Nrxn); # capped (relative) error; capped = [val[2] for val in err.values()]; error['pexpce'] = max(capped); error['nexpce'] = min(capped); error['maxpce'] = max(capped, key=lambda x: abs(x)); error['minpce'] = min(capped, key=lambda x: abs(x)); error['mpce'] = sum(capped) / Nrxn; error['mapce'] = sum(map(abs, capped)) / Nrxn; error['rmspce'] = math.sqrt(sum(map(lambda x: x ** 2, capped)) / Nrxn); error['stdpce'] = math.sqrt((sum(map(lambda x: x ** 2, capped)) - (sum(capped) ** 2) / Nrxn) / Nrxn); if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41967,Testability,benchmark,benchmark,41967,".dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42041,Testability,benchmark,benchmark,42041,".dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42139,Testability,benchmark,benchmark,42139,"ationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_p",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42229,Testability,benchmark,benchmark,42229,"le')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbda",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:43610,Testability,benchmark,benchmark,43610,"pt ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # ]; #; # def table_simple2(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'MAE', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'MAE', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'MAE', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'MAE', 'TT', textables.val, {'sset': 'default'}],; # ['d', r'MA\%E', 'HB', textables.val, {'sset': 'hb', 'err': 'mape'}],; # ['d', r'MA\%E', 'MX', textables.val, {'sset': 'mx', 'err': 'mape'}],",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:44105,Testability,benchmark,benchmark,44105,".dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # ]; #; # def table_simple2(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'MAE', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'MAE', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'MAE', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'MAE', 'TT', textables.val, {'sset': 'default'}],; # ['d', r'MA\%E', 'HB', textables.val, {'sset': 'hb', 'err': 'mape'}],; # ['d', r'MA\%E', 'MX', textables.val, {'sset': 'mx', 'err': 'mape'}],; # ['d', r'MA\%E', 'DD', textables.val, {'sset': 'dd', 'err': 'mape'}],; # ['d', r'MA\%E', 'TT', textables.val, {'sset': 'default', 'err': 'mape'}],; # ['d', r'maxE', 'TT ', textables.val, {'sset': 'default', 'err': 'maxe'}],; # ['d', r'min\%E', ' TT', textables.val, {'sset': 'default', 'err': 'minpe'}],; # ['d', r'rmsE', 'TT ', textables.val, {'sset': 'default', 'err': 'rmse'}],; # ['d', r'devE', ' TT', textables.val, {'sset': 'default', 'err': 'stde'}],; # ]; #; # def ta",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:45204,Testability,benchmark,benchmark,45204,"['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'MAE', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'MAE', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'MAE', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'MAE', 'TT', textables.val, {'sset': 'default'}],; # ['d', r'MA\%E', 'HB', textables.val, {'sset': 'hb', 'err': 'mape'}],; # ['d', r'MA\%E', 'MX', textables.val, {'sset': 'mx', 'err': 'mape'}],; # ['d', r'MA\%E', 'DD', textables.val, {'sset': 'dd', 'err': 'mape'}],; # ['d', r'MA\%E', 'TT', textables.val, {'sset': 'default', 'err': 'mape'}],; # ['d', r'maxE', 'TT ', textables.val, {'sset': 'default', 'err': 'maxe'}],; # ['d', r'min\%E', ' TT', textables.val, {'sset': 'default', 'err': 'minpe'}],; # ['d', r'rmsE', 'TT ', textables.val, {'sset': 'default', 'err': 'rmse'}],; # ['d', r'devE', ' TT', textables.val, {'sset': 'default', 'err': 'stde'}],; # ]; #; # def table_simple3(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['err', 'bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'MAE', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'MAE', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'MAE', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'MAE', 'TT', textables.val, {'sset': 'default'}],; # ]; #; # def table_simple4(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # plotpath = 'autogen' # TODO handle better; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # # ['l', r""""""Error Distribution\footnotemark[1]"""""", r""""""\includegrap",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:45706,Testability,benchmark,benchmark,45706,"tables.val, {'sset': 'default', 'err': 'mape'}],; # ['d', r'maxE', 'TT ', textables.val, {'sset': 'default', 'err': 'maxe'}],; # ['d', r'min\%E', ' TT', textables.val, {'sset': 'default', 'err': 'minpe'}],; # ['d', r'rmsE', 'TT ', textables.val, {'sset': 'default', 'err': 'rmse'}],; # ['d', r'devE', ' TT', textables.val, {'sset': 'default', 'err': 'stde'}],; # ]; #; # def table_simple3(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['err', 'bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'MAE', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'MAE', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'MAE', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'MAE', 'TT', textables.val, {'sset': 'default'}],; # ]; #; # def table_simple4(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # plotpath = 'autogen' # TODO handle better; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # # ['l', r""""""Error Distribution\footnotemark[1]"""""", r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'), textables.graphics, {}],; # ['l', r""""""Error Distribution\footnotemark[1]"""""", r"""""""""""", textables.graphics, {}],; # ]. [docs]class Database(object):; """"""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Databas",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47298,Testability,benchmark,benchmark,47298,"lank'), textables.graphics, {}],; # ['l', r""""""Error Distribution\footnotemark[1]"""""", r"""""""""""", textables.graphics, {}],; # ]. [docs]class Database(object):; """"""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets();",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47869,Testability,benchmark,benchmark,47869,"#: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = '';",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47959,Testability,benchmark,benchmark,47959," ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrg",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:48006,Testability,benchmark,benchmark,48006,"ects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reacti",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:48061,Testability,benchmark,benchmark,48061,"edDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n""""""",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:48235,Testability,benchmark,benchmark,48235,"nt asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); # text += """""" Reference: %s\n"""""" % ('default: ' + ' + '.join(self.mcs['default'])); try:; text += """""" Reference: %s\n"""""" % (self.benchmark + ': ' + '",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:49229,Testability,benchmark,benchmark,49229,"ark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); # text += """""" Reference: %s\n"""""" % ('default: ' + ' + '.join(self.mcs['default'])); try:; text += """""" Reference: %s\n"""""" % (self.benchmark + ': ' + ' + '.join(self.mcs[self.benchmark])); except TypeError:; text += """""" Reference: %s\n"""""" % ('UNDEFINED'); text += """""" Model Chemistries: %s\n"""""" % (; ', '.join(sorted([mc for mc in self.mcs.keys() if mc is not None]))); text += """"""\n""""""; for db in self.dbdict.keys():; text += self.dbdict[db].__str__(); return text. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return self.benchmark #TODO not sure if right way to go about this self.mcs['default']. [docs] def fancy_mcs(self, latex=False):; """""". """"""; fmcs = {}; for mc in self.mcs.keys():; try:; mtd, mod, bas = mc.split('-'); except ValueError:; fmcs[mc] = mc; else:; if latex:; tmp = """"""%s/%s, %s"""""" % \; (methods[mtd].latex, bases[bas].latex, mod.replace('_', '\\_')); fmcs[mc] = """"""%45s"""""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: de",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:49273,Testability,benchmark,benchmark,49273,"# complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); # text += """""" Reference: %s\n"""""" % ('default: ' + ' + '.join(self.mcs['default'])); try:; text += """""" Reference: %s\n"""""" % (self.benchmark + ': ' + ' + '.join(self.mcs[self.benchmark])); except TypeError:; text += """""" Reference: %s\n"""""" % ('UNDEFINED'); text += """""" Model Chemistries: %s\n"""""" % (; ', '.join(sorted([mc for mc in self.mcs.keys() if mc is not None]))); text += """"""\n""""""; for db in self.dbdict.keys():; text += self.dbdict[db].__str__(); return text. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return self.benchmark #TODO not sure if right way to go about this self.mcs['default']. [docs] def fancy_mcs(self, latex=False):; """""". """"""; fmcs = {}; for mc in self.mcs.keys():; try:; mtd, mod, bas = mc.split('-'); except ValueError:; fmcs[mc] = mc; else:; if latex:; tmp = """"""%s/%s, %s"""""" % \; (methods[mtd].latex, bases[bas].latex, mod.replace('_', '\\_')); fmcs[mc] = """"""%45s"""""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: defaultdict(dict)); # for mc in self.mcs.keys():; # try:; # mtd, mod, bas = mc.split('-'); # excep",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:49571,Testability,benchmark,benchmark,49571,"xn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); # text += """""" Reference: %s\n"""""" % ('default: ' + ' + '.join(self.mcs['default'])); try:; text += """""" Reference: %s\n"""""" % (self.benchmark + ': ' + ' + '.join(self.mcs[self.benchmark])); except TypeError:; text += """""" Reference: %s\n"""""" % ('UNDEFINED'); text += """""" Model Chemistries: %s\n"""""" % (; ', '.join(sorted([mc for mc in self.mcs.keys() if mc is not None]))); text += """"""\n""""""; for db in self.dbdict.keys():; text += self.dbdict[db].__str__(); return text. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return self.benchmark #TODO not sure if right way to go about this self.mcs['default']. [docs] def fancy_mcs(self, latex=False):; """""". """"""; fmcs = {}; for mc in self.mcs.keys():; try:; mtd, mod, bas = mc.split('-'); except ValueError:; fmcs[mc] = mc; else:; if latex:; tmp = """"""%s/%s, %s"""""" % \; (methods[mtd].latex, bases[bas].latex, mod.replace('_', '\\_')); fmcs[mc] = """"""%45s"""""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: defaultdict(dict)); # for mc in self.mcs.keys():; # try:; # mtd, mod, bas = mc.split('-'); # except ValueError:; # fmcs['All']['All'][mc] = mc; # fmcs['Method']['Others'][mc] = mc; # fmcs['Options']['Others'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All'][",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:49647,Testability,benchmark,benchmark,49647,"xn] = orxn. # merge Reagent-s; self.hrgt = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); # text += """""" Reference: %s\n"""""" % ('default: ' + ' + '.join(self.mcs['default'])); try:; text += """""" Reference: %s\n"""""" % (self.benchmark + ': ' + ' + '.join(self.mcs[self.benchmark])); except TypeError:; text += """""" Reference: %s\n"""""" % ('UNDEFINED'); text += """""" Model Chemistries: %s\n"""""" % (; ', '.join(sorted([mc for mc in self.mcs.keys() if mc is not None]))); text += """"""\n""""""; for db in self.dbdict.keys():; text += self.dbdict[db].__str__(); return text. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return self.benchmark #TODO not sure if right way to go about this self.mcs['default']. [docs] def fancy_mcs(self, latex=False):; """""". """"""; fmcs = {}; for mc in self.mcs.keys():; try:; mtd, mod, bas = mc.split('-'); except ValueError:; fmcs[mc] = mc; else:; if latex:; tmp = """"""%s/%s, %s"""""" % \; (methods[mtd].latex, bases[bas].latex, mod.replace('_', '\\_')); fmcs[mc] = """"""%45s"""""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: defaultdict(dict)); # for mc in self.mcs.keys():; # try:; # mtd, mod, bas = mc.split('-'); # except ValueError:; # fmcs['All']['All'][mc] = mc; # fmcs['Method']['Others'][mc] = mc; # fmcs['Options']['Others'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All'][",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:49676,Testability,benchmark,benchmark,49676,":; for rgt, orgt in odb.hrgt.iteritems():; self.hrgt[orgt.name] = orgt. print(""""""Database %s: %s"""""" % (self.dbse, ', '.join(self.dbdict.keys()))). def __str__(self):; text = ''; text += """""" ===> %s Database <===\n\n"""""" % (self.dbse); # text += """""" Reagents: %s\n"""""" % (self.hrgt.keys()); # text += """""" Reactions: %s\n"""""" % (self.hrxn.keys()); text += """""" Subsets: %s\n"""""" % (self.sset.keys()); # text += """""" Reference: %s\n"""""" % ('default: ' + ' + '.join(self.mcs['default'])); try:; text += """""" Reference: %s\n"""""" % (self.benchmark + ': ' + ' + '.join(self.mcs[self.benchmark])); except TypeError:; text += """""" Reference: %s\n"""""" % ('UNDEFINED'); text += """""" Model Chemistries: %s\n"""""" % (; ', '.join(sorted([mc for mc in self.mcs.keys() if mc is not None]))); text += """"""\n""""""; for db in self.dbdict.keys():; text += self.dbdict[db].__str__(); return text. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return self.benchmark #TODO not sure if right way to go about this self.mcs['default']. [docs] def fancy_mcs(self, latex=False):; """""". """"""; fmcs = {}; for mc in self.mcs.keys():; try:; mtd, mod, bas = mc.split('-'); except ValueError:; fmcs[mc] = mc; else:; if latex:; tmp = """"""%s/%s, %s"""""" % \; (methods[mtd].latex, bases[bas].latex, mod.replace('_', '\\_')); fmcs[mc] = """"""%45s"""""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: defaultdict(dict)); # for mc in self.mcs.keys():; # try:; # mtd, mod, bas = mc.split('-'); # except ValueError:; # fmcs['All']['All'][mc] = mc; # fmcs['Method']['Others'][mc] = mc; # fmcs['Options']['Others'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All']['All'][mc] = fancyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options']",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:56722,Testability,benchmark,benchmark,56722,"in range(len(self.dbdict))]; print(""""""Database %s: Subset %s promoted: %s"""""" % (self.dbse, ss, self.sset[ss])). def _intersect_subsets(self):; """"""Examine component database subsets and collect common names as; Database subset. """"""; sss = [set(odb.sset.keys()) for db, odb in self.dbdict.items()]; new = sorted(set.intersection(*sss)); for ss in new:; self.sset[ss] = [ss] * len(self.dbdict.keys()). def _intersect_modelchems(self):; """"""Examine component database qcdata and collect common names as; Database modelchem. """"""; mcs = [set(odb.available_modelchems()) for odb in self.dbdict.itervalues()]; new = sorted(set.intersection(*mcs)); for mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:56938,Testability,benchmark,benchmark,56938,"in range(len(self.dbdict))]; print(""""""Database %s: Subset %s promoted: %s"""""" % (self.dbse, ss, self.sset[ss])). def _intersect_subsets(self):; """"""Examine component database subsets and collect common names as; Database subset. """"""; sss = [set(odb.sset.keys()) for db, odb in self.dbdict.items()]; new = sorted(set.intersection(*sss)); for ss in new:; self.sset[ss] = [ss] * len(self.dbdict.keys()). def _intersect_modelchems(self):; """"""Examine component database qcdata and collect common names as; Database modelchem. """"""; mcs = [set(odb.available_modelchems()) for odb in self.dbdict.itervalues()]; new = sorted(set.intersection(*mcs)); for mc in new:; self.mcs[mc] = [mc] * len(self.dbdict.keys()). # def reaction_generator(self):; # """""". # """"""; # for db, odb in self.dbdict.items():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57601,Testability,benchmark,benchmark,57601,"s():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57622,Testability,benchmark,benchmark,57622,"s():; # for rxn, orxn in odb.hrxn.items():; # yield orxn. [docs] def compute_statistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57657,Testability,benchmark,benchmark,57657,"atistics(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, returnindiv=False):; """"""Computes summary statistics and, if *returnindiv* True,; individual errors for single model chemistry *modelchem* versus; *benchmark* over subset *sset* over all component databases.; Particularly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:57913,Testability,benchmark,benchmark,57913,"rly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul el",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58115,Testability,benchmark,benchmark,58115,"rly, imposes cross-database definitions for sset and; modelchem.; #Returns error if model chemistries are missing; #for any reaction in subset unless *failoninc* set to False,; #whereupon returns partial statistics. Returns dictionary of; #statistics labels and values. """"""; errors = OrderedDict(); indiv = OrderedDict(); actvdb = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul el",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58302,Testability,benchmark,benchmark,58302,".dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def pl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:58312,Testability,benchmark,benchmark,58312,".dbdict.keys().index(db); if self.sset[sset][dbix] is None:; errors[db], indiv[db] = (None, None); else:; errors[db], indiv[db] = odb.compute_statistics(self.mcs[modelchem][dbix],; sset=self.sset[sset][dbix],; benchmark='ZEROS' if benchmark == 'ZEROS' else self.mcs[benchmark][dbix],; failoninc=failoninc, verbose=verbose, returnindiv=True); actvdb.append(errors[db]); errors[self.dbse] = average_errors(*actvdb). if returnindiv:; return errors, indiv; else:; return errors. [docs] def analyze_modelchems(self, modelchem, benchmark='default', failoninc=True, verbose=False):; """"""For each component database, compute and print nicely formatted; summary error statistics for each model chemistry in array; *modelchem* versus *benchmark* for all available subsets. """"""; # compute errors; errors = {}; for mc in modelchem:; errors[mc] = {}; for ss in self.sset.keys():; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # present errors; pre, suf, mid = string_contrast(modelchem); text = """"""\n ==> %s %s[]%s Errors <==\n"""""" % (self.dbse, pre, suf); text += """"""%20s %44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def pl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:59417,Testability,benchmark,benchmark,59417,"44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def plot_bars(self, modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:59659,Testability,benchmark,benchmark,59659,"44s"""""" % ('', '==> ' + self.dbse + ' <=='); for db, odb in self.dbdict.items():; text += """"""%44s"""""" % ('=> ' + odb.dbse + ' <='); text += '\n'. collabel = """""" {:5} {:4} {:6} {:6} {:6}"""""".format(; 'ME', 'STDE', 'MAE', 'MA%E', 'MA%BE'). text += """"""{:20} """""".format('') + collabel; for db in self.dbdict.keys():; text += collabel; text += '\n'. text += """"""{:20} {}"""""".format('', '=' * 44); ul = False; for db in self.dbdict.keys():; text += """"""{}"""""".format('_' * 44 if ul else ' ' * 44); ul = not ul; text += '\n'. for ss in self.sset.keys():; text += """""" => %s <=\n"""""" % (ss); for mc in modelchem:; perr = errors[mc][ss]; text += """"""%20s %44s"""""" % (mid[modelchem.index(mc)],; format_errors(perr[self.dbse])); for db in self.dbdict.keys():; text += """"""%44s"""""" % ('' if perr[db] is None else format_errors(perr[db])); text += '\n'; print(text). [docs] def plot_bars(self, modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'],; failoninc=True, verbose=False, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Prepares 'grey bars' diagram for each model chemistry in array; *modelchem* versus *benchmark* over all component databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60591,Testability,benchmark,benchmark,60591,"omponent databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:60601,Testability,benchmark,benchmark,60601,"omponent databases. A wide bar; is plotted with three smaller bars, corresponding to the 'mae'; summary statistic of the four subsets in *sset*. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares bars diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>> asdf.plot_bars(['MP2-CP-adz', 'MP2-CP-adtz'], sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']); """"""; # compute errors; errors = {}; for mc in modelchem:; if mc is not None:; errors[mc] = {}; for ss in sset:; errors[mc][ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=False); # repackage; pre, suf, mid = string_contrast(modelchem); dbdat = []; for mc in modelchem:; if mc is None:; dbdat.append(None); else:; dbdat.append({'mc': mid[modelchem.index(mc)],; 'data': [errors[mc][ss][self.dbse]['mae'] for ss in sset]}); title = self.dbse + ' ' + pre + '[]' + suf + ' ' + ','.join(sset); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.bars(%s,\n title='%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62175,Testability,benchmark,benchmark,62175,"%s'\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.bars(dbdat, title=title,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix([u, v]))); #; # dbdat = {}; # for db, odb in self.dbdict.iteritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; # for rxnix, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62445,Testability,benchmark,benchmark,62445,"sformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix([u, v]))); #; # dbdat = {}; # for db, odb in self.dbdict.iteritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; # for rxnix, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancif",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62455,Testability,benchmark,benchmark,62455,"sformat=graphicsformat); return filedict. # def get_pec_weightinfo(self):; # """"""; #; # """"""; # def closest(u, options):; # return max(options, key=lambda v: len(os.path.commonprefix([u, v]))); #; # dbdat = {}; # for db, odb in self.dbdict.iteritems():; # #dbix = self.dbdict.keys().index(db); # oss = odb.oss['default']; # eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; # for rxnix, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancif",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:62877,Testability,benchmark,benchmark,62877,"x, rxn in enumerate(oss.hrxn):; # dbrxn = '-'.join([db, rxn]); # rrat = oss.axis['Rrat'][rxnix]; # eq = closest(rxn, eqrxns); # print rxn, rxnix, eq, rrat, dbrxn; # dbdat[dbrxn] = {'eq': eq, 'Rrat': rrat}; # return dbdat. [docs] def plot_axis(self, axis, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancify_mc_tag(mc).strip()] = dbdat. pre, suf, mid = string_contrast(modelchem); title = """"""%s[%s]%s vs %s axis %s for %s subset %s"""""" % (pre, str(len(mid)), suf, benchmark, axis, self.dbse, sset); print(title); #for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:63213,Testability,benchmark,benchmark,63213,"nc=True, verbose=False, color='sapt', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". """"""; dbdatdict = OrderedDict(); for mc in modelchem:; # compute errors; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.iteritems():; dbix = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancify_mc_tag(mc).strip()] = dbdat. pre, suf, mid = string_contrast(modelchem); title = """"""%s[%s]%s vs %s axis %s for %s subset %s"""""" % (pre, str(len(mid)), suf, benchmark, axis, self.dbse, sset); print(title); #for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d['mcdata'] is None else d['mcdata']); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s'",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:63658,Testability,benchmark,benchmark,63658," = self.dbdict.keys().index(db); oss = odb.oss[self.sset[sset][dbix]]; # TODO may need to make axis name distributable across wrappeddbs; # TODO not handling mc present bm absent; if indiv[db] is not None:; for rxn in oss.hrxn:; rxnix = oss.hrxn.index(rxn); bm = self.mcs[benchmark][dbix]; bmpresent = False if (bm is None or bm not in odb.hrxn[rxn].data) else True; mcpresent = False if (self.mcs[mc][dbix] not in odb.hrxn[rxn].data) else True; entry = {'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'axis': oss.axis[axis][rxnix]}. if bmpresent:; entry['bmdata'] = odb.hrxn[rxn].data[self.mcs[benchmark][dbix]].value; else:; entry['bmdata'] = None. if mcpresent:; entry['mcdata'] = odb.hrxn[rxn].data[self.mcs[mc][dbix]].value; else:; continue. if bmpresent and mcpresent:; entry['error'] = [indiv[db][rxn][0]]; else:; entry['error'] = [None]; dbdat.append(entry); dbdatdict[fancify_mc_tag(mc).strip()] = dbdat. pre, suf, mid = string_contrast(modelchem); title = """"""%s[%s]%s vs %s axis %s for %s subset %s"""""" % (pre, str(len(mid)), suf, benchmark, axis, self.dbse, sset); print(title); #for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d['mcdata'] is None else d['mcdata']); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def lo",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:67482,Testability,benchmark,benchmark,67482,"pythonpath=None; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo, then formats it to plot a ternary diagram. """"""; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath=pythonpath,; failoninc=failoninc). dbdat = []; mcs = []; for dat in saptdata.values():; dbdat.append([dat['elst'], dat['ind'], dat['disp']]); if dat['mc'] not in mcs:; mcs.append(dat['mc']). title = ' '.join([self.dbse, sset, ' '.join(mcs)]). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; pass; # if not running from Canopy, print line to execute from Canopy; else:; # if running from Canopy, call mpl directly; filedict = mpl.ternary(dbdat, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc =",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:67769,Testability,benchmark,benchmark,67769,"ry diagram. """"""; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath=pythonpath,; failoninc=failoninc). dbdat = []; mcs = []; for dat in saptdata.values():; dbdat.append([dat['elst'], dat['ind'], dat['disp']]); if dat['mc'] not in mcs:; mcs.append(dat['mc']). title = ' '.join([self.dbse, sset, ' '.join(mcs)]). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; pass; # if not running from Canopy, print line to execute from Canopy; else:; # if running from Canopy, call mpl directly; filedict = mpl.ternary(dbdat, title=title, labeled=labeled,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_flat(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0],; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68565,Testability,benchmark,benchmark,68565,"None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s',\n title='%s',\n mae=%s,\n mape=%s,\n xlimit=%s,\n xlines=%s,\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, mc, mae, mape, xlimit, repr(xlines), view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:68575,Testability,benchmark,benchmark,68575,"None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Thread *color* can be; 'rgb' for old coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. asdf.plot_flat('CCSD-CP-atqzadz', failoninc=False); """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append({'db': db,; 'sys': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': [indiv[db][rxn][0]]}); pre, suf, mid = string_contrast(mc); title = self.dbse + '-' + sset + ' ' + pre + '[]' + suf; mae = errors[self.dbse]['mae']; mape = None; # mape = 100 * errors[self.dbse]['mape']; mapbe = None; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.flat(%s,\n color='%s',\n title='%s',\n mae=%s,\n mape=%s,\n xlimit=%s,\n xlines=%s,\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, mc, mae, mape, xlimit, repr(xlines), view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72418,Testability,benchmark,benchmark,72418,"inc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72559,Testability,benchmark,benchmark,72559,"inc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:72774,Testability,benchmark,benchmark,72774,"inc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset='default'):; """""". """"""; rhrxn = OrderedDict(); for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); lss = self.sset[sset][dbix]; if lss is not None:; for rxn in odb.hrxn:; if rxn in odb.sset[lss]:; orxn = odb.hrxn[rxn]; rhrxn[orxn.dbrxn] = orxn # this is a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:73003,Testability,benchmark,benchmark,73003,"s a change and conflict with vergil version; return rhrxn. [docs] def get_hrgt(self, sset='default', actv='default'):; """""". """"""; rhrxn = self.get_hrxn(sset=sset); rhrgt = OrderedDict(); for rxn, orxn in rhrxn.iteritems():; for orgt in orxn.rxnm[actv].keys():; rhrgt[orgt.name] = orgt; # TODO prob need to avoid duplicates or pass. return rhrgt. [docs] def get_reactions(self, modelchem, sset='default', benchmark='default',; failoninc=True):; """"""Collects the reactions present in *sset* from each WrappedDatabase,; checks that *modelchem* and *benchmark* ReactionDatum are present; (fails if *failoninc* True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; *modelchem*, the modelchem key needed to access *benchmark*, and; the Reaction object. """"""; dbdat = []; rhrxn = self.get_hrxn(sset=sset); for orxn in rhrxn.itervalues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(self, modelchem, sset='default'):; """"""Returns a dictionary (keys self.dbse and all component; WrappedDatabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.db",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:73881,Testability,benchmark,benchmark,73881,"lues():; dbix = self.dbdict.keys().index(orxn.dbrxn.split('-')[0]); lmc = self.mcs[modelchem][dbix]; lbm = self.mcs[benchmark][dbix]; try:; orxn.data[lbm]; except KeyError as e:; # not sure if should treat bm differently; lbm = None; try:; orxn.data[lmc]; except KeyError as e:; if failoninc:; raise e; else:; lmc = None; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(self, modelchem, sset='default'):; """"""Returns a dictionary (keys self.dbse and all component; WrappedDatabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of err",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:74184,Testability,benchmark,benchmark,74184,"ne; dbdat.append((lmc, lbm, orxn)); # this is diff in that returning empties not just pass over- may break bfdb; # try:; # orxn.data[lmc]; # orxn.data[lbm]; # except KeyError as e:; # if failoninc:; # raise e; # else:; # # not sure yet if should return empties or just pass over; # pass; # else:; # dbdat.append((lmc, lbm, orxn)); return dbdat. [docs] def get_missing_reactions(self, modelchem, sset='default'):; """"""Returns a dictionary (keys self.dbse and all component; WrappedDatabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolut",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:74553,Testability,benchmark,benchmark,74553,"atabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not No",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:74800,Testability,benchmark,benchmark,74800,"atabase.dbse) of two elements, the first being the number; of reactions *sset* should contain and the second being a list of; the reaction names (dbrxn) not available for *modelchem*. Absence; of benchmark not considered. """"""; counts = OrderedDict(); counts[self.dbse] = [0, []]; soledb = True if (len(self.dbdict) == 1 and self.dbdict.items()[0][0] == self.dbse) else False; if not soledb:; for db in self.dbdict.keys():; counts[db] = [0, []]; for (lmc, lbm, orxn) in self.get_reactions(modelchem, benchmark='default',; sset=sset, failoninc=False):; db, rxn = orxn.dbrxn.split('-', 1); mcdatum = orxn.data[lmc].value if lmc else None; counts[self.dbse][0] += 1; if not soledb:; counts[db][0] += 1; if mcdatum is None:; counts[self.dbse][1].append(orxn.dbrxn); if not soledb:; counts[db][1].append(orxn.dbrxn); return counts. [docs] def plot_disthist(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not No",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75517,Testability,benchmark,benchmark,75517,"t', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75527,Testability,benchmark,benchmark,75527,"t', sset='default',; failoninc=True, verbose=False, xtitle='', view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics for single; model chemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:75800,Testability,benchmark,benchmark,75800,"hemistry *modelchem* versus *benchmark* over; subset *sset* over all component databases. Computes histogram; of errors and gaussian distribution. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. >>>; """"""; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mo",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:76586,Testability,benchmark,benchmark,76586,"t = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; stde = errors[self.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:77009,Testability,benchmark,benchmark,77009,"elf.dbse]['stde']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.disthist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:77129,Testability,benchmark,benchmark,77129,"thist(%s,\n title='%s',\n xtitle='%s'\n me=%s,\n stde=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, title, xtitle, me, stde, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.disthist(dbdat, title=title, xtitle=xtitle, me=me, stde=stde,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_modelchems(self, modelchem, benchmark='default', mbenchmark=None,; sset='default', msset=None, failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors and summary statistics over all component; databases for each model chemistry in array *modelchem* versus *benchmark*; over subset *sset*. *mbenchmark* and *msset* are array options (same; length as *modelchem*) that override *benchmark* and *sset*, respectively,; for non-uniform specification. Thread *color* can be 'rgb' for old; coloring, a color name or 'sapt' for spectrum coloring. *saveas* conveys directory ('/') and/or filename for saving the; resulting plot. File extension is not accessible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmar",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:77984,Testability,benchmark,benchmark,77984,"sible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:78033,Testability,benchmark,benchmark,78033,"sible, but *graphicsformat*; array requests among 'png', 'pdf', and 'eps' formats. *relpath*; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary. Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of *mousetext*, *mouselink*,; or *mouseimag* is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:78898,Testability,benchmark,benchmark,78898,"e, respectively. """"""; # distribute benchmark; if mbenchmark is None:; lbenchmark = [benchmark] * len(modelchem) # normal bm modelchem name; else:; if isinstance(mbenchmark, basestring) or len(mbenchmark) != len(modelchem):; raise ValidationError(; """"""mbenchmark must be array of length distributable among modelchem"""""" % (str(mbenchmark))); else:; lbenchmark = mbenchmark # array of bm for each modelchem; # distribute sset; if msset is None:; lsset = [sset] * len(modelchem) # normal ss name like 'MX'; else:; if isinstance(msset, basestring) or len(msset) != len(modelchem):; raise ValidationError(""""""msset must be array of length distributable among modelchem"""""" % (str(msset))); else:; lsset = msset # array of ss for each modelchem; # compute errors; index = []; errors = {}; indiv = {}; for mc, bm, ss in zip(modelchem, lbenchmark, lsset):; ix = '%s_%s_%s' % (ss, mc, bm); index.append(ix); errors[ix], indiv[ix] = self.compute_statistics(mc, benchmark=bm, sset=ss,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; for db, odb in self.dbdict.items():; dbix = self.dbdict.keys().index(db); for rxn in odb.hrxn:; data = []; for ix in index:; if indiv[ix][db] is not None:; if rxn in odb.sset[self.sset[lsset[index.index(ix)]][dbix]]:; try:; data.append(indiv[ix][db][rxn][0]); except KeyError as e:; if failoninc:; raise e; else:; data.append(None); else:; data.append(None); else:; data.append(None); if not data or all(item is None for item in data):; pass # filter out empty reactions; else:; dbdat.append({'db': db,; 'sys': str(rxn),; 'show': str(rxn),; 'color': odb.hrxn[rxn].color,; 'data': data}); mae = [errors[ix][self.dbse]['mae'] for ix in index]; mape = [100 * errors[ix][self.dbse]['mape'] for ix in index]; # form unique filename; ixpre, ixsuf, ixmid = string_contrast(index); title = self.dbse + ' ' + ixpre + '[]' + ixsuf; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except Impor",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:80933,Testability,benchmark,benchmark,80933,"t; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict, htmlcode = mpl.threads(%s,\n color='%s',\n title='%s',\n labels=%s,\n mae=%s,\n mape=%s\n xlimit=%s\n labeled=%s\n saveas=%s\n mousetext=%s\n mouselink=%s\n mouseimag=%s\n mousetitle=%s,\n mousediv=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, ixmid, mae, mape, str(xlimit),; repr(labeled), repr(saveas), repr(mousetext), repr(mouselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; exce",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81365,Testability,benchmark,benchmark,81365,"uselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:81375,Testability,benchmark,benchmark,81375,"uselink), repr(mouseimag),; repr(mousetitle), repr(mousediv), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict, htmlcode = mpl.threads(dbdat, color=color, title=title, labels=ixmid, mae=mae, mape=mape,; xlimit=xlimit, labeled=labeled, view=view,; mousetext=mousetext, mouselink=mouselink,; mouseimag=mouseimag, mousetitle=mousetitle, mousediv=mousediv,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict, htmlcode. [docs] def plot_liliowa(self, modelchem, benchmark='default',; failoninc=True, xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """""". Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82167,Testability,benchmark,benchmark,82167,"BBI, but SSI-only neutral is not accessible.; """"""; # compute errors; mc = modelchem; errors = {}; for ss in self.sset.keys():; errors[ss] = self.compute_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pypl",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82399,Testability,benchmark,benchmark,82399,"e_statistics(mc, benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False). # repackage; dbdat = []; ssarray = ['pospos', 'posneg', 'pospolar', 'posaliph', 'posaryl',; None, 'negneg', 'negpolar', 'negaliph', 'negaryl',; None, None, 'polarpolar', 'polaraliph', 'polararyl',; None, None, None, 'aliphaliph', 'alipharyl',; None, None, None, None, 'arylaryl']; for ss in ssarray:; dbdat.append(0.0 if ss is None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82719,Testability,benchmark,benchmark,82719," None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[],",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:82729,Testability,benchmark,benchmark,82729," None else errors[ss][self.dbse]['mae']). # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; print('Matplotlib not avail'); else:; filedict = mpl.liliowa(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[],",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:83038,Testability,benchmark,benchmark,83038,"(dbdat, xlimit=xlimit, view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def plot_iowa(self, modelchem, benchmark='default', sset='default',; failoninc=True, verbose=False,; title='', xtitle='', xlimit=2.0,; view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors for single *modelchem* versus; *benchmark* over subset *sset*. Coloring green-to-purple with; maximum intensity at *xlimit*. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. """"""; title = self.dbse + ' ' + modelchem; # compute errors; mc = modelchem; errors, indiv = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=verbose, returnindiv=True); # repackage; dbdat = []; dblbl = []; for db in self.dbdict.keys():; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as n",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:83780,Testability,benchmark,benchmark,83780,"; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as np. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath='/Users/loriab/linux/bfdb/sapt_punt',; failoninc=failoninc). listodicts = []; rhrxn = self.get_hrxn(sset=sset); for dbrxn, orxn in rhrxn.iteritems():; wdb = dbrxn.split('-')[0]; dbix = self.dbdict.keys().index(wdb); wbm = self.mcs[benchmark][dbix]; wss = self.sset[sset][dbix]; woss = self.dbdict[wdb].oss[wss]; try:; Rrat = woss.axis['Rrat'][woss.hrxn.index(orxn.name)]; except KeyError:; Rrat = 1.0 # TODO generic soln?. dictorxn = {}; dictorxn['DB'] = wdb; dictorxn['System'] = orxn.tagl; dictorxn['Name'] = orxn.name; dictorxn['R'] = Rrat; dictorxn['System #'] = orxn.indx; dictorxn['Benchmark'] = np.NaN if orxn.benchmark is None else orxn.data[; wbm].value # this NaN exception is new and experimental; dictorxn['QcdbSys'] = orxn.d",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:83938,Testability,benchmark,benchmark,83938,"; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as np. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath='/Users/loriab/linux/bfdb/sapt_punt',; failoninc=failoninc). listodicts = []; rhrxn = self.get_hrxn(sset=sset); for dbrxn, orxn in rhrxn.iteritems():; wdb = dbrxn.split('-')[0]; dbix = self.dbdict.keys().index(wdb); wbm = self.mcs[benchmark][dbix]; wss = self.sset[sset][dbix]; woss = self.dbdict[wdb].oss[wss]; try:; Rrat = woss.axis['Rrat'][woss.hrxn.index(orxn.name)]; except KeyError:; Rrat = 1.0 # TODO generic soln?. dictorxn = {}; dictorxn['DB'] = wdb; dictorxn['System'] = orxn.tagl; dictorxn['Name'] = orxn.name; dictorxn['R'] = Rrat; dictorxn['System #'] = orxn.indx; dictorxn['Benchmark'] = np.NaN if orxn.benchmark is None else orxn.data[; wbm].value # this NaN exception is new and experimental; dictorxn['QcdbSys'] = orxn.d",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:83952,Testability,benchmark,benchmark,83952,"; if indiv[db] is not None:; for rxn in indiv[db].keys():; dbdat.append(indiv[db][rxn][0]); dblbl.append(str(rxn)); title = """"""%s vs %s for %s subset %s"""""" % (mc, benchmark, self.dbse, sset); me = errors[self.dbse]['me']; # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""mpl.iowa(%s,\n %s,\n title='%s',\n xtitle='%s'\n xlimit=%s,\n saveas=%s,\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as np. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath='/Users/loriab/linux/bfdb/sapt_punt',; failoninc=failoninc). listodicts = []; rhrxn = self.get_hrxn(sset=sset); for dbrxn, orxn in rhrxn.iteritems():; wdb = dbrxn.split('-')[0]; dbix = self.dbdict.keys().index(wdb); wbm = self.mcs[benchmark][dbix]; wss = self.sset[sset][dbix]; woss = self.dbdict[wdb].oss[wss]; try:; Rrat = woss.axis['Rrat'][woss.hrxn.index(orxn.name)]; except KeyError:; Rrat = 1.0 # TODO generic soln?. dictorxn = {}; dictorxn['DB'] = wdb; dictorxn['System'] = orxn.tagl; dictorxn['Name'] = orxn.name; dictorxn['R'] = Rrat; dictorxn['System #'] = orxn.indx; dictorxn['Benchmark'] = np.NaN if orxn.benchmark is None else orxn.data[; wbm].value # this NaN exception is new and experimental; dictorxn['QcdbSys'] = orxn.d",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:84369,Testability,benchmark,benchmark,84369,"lpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, dblbl, title, xtitle, xlimit, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.iowa(dbdat, dblbl, title=title, xtitle=xtitle, xlimit=xlimit,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def export_pandas(self, modelchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as np. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath='/Users/loriab/linux/bfdb/sapt_punt',; failoninc=failoninc). listodicts = []; rhrxn = self.get_hrxn(sset=sset); for dbrxn, orxn in rhrxn.iteritems():; wdb = dbrxn.split('-')[0]; dbix = self.dbdict.keys().index(wdb); wbm = self.mcs[benchmark][dbix]; wss = self.sset[sset][dbix]; woss = self.dbdict[wdb].oss[wss]; try:; Rrat = woss.axis['Rrat'][woss.hrxn.index(orxn.name)]; except KeyError:; Rrat = 1.0 # TODO generic soln?. dictorxn = {}; dictorxn['DB'] = wdb; dictorxn['System'] = orxn.tagl; dictorxn['Name'] = orxn.name; dictorxn['R'] = Rrat; dictorxn['System #'] = orxn.indx; dictorxn['Benchmark'] = np.NaN if orxn.benchmark is None else orxn.data[; wbm].value # this NaN exception is new and experimental; dictorxn['QcdbSys'] = orxn.dbrxn. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; dictorxn['SAPT ELST ENERGY'] = saptdata[dbrxn]['elst']; dictorxn['SAPT EXCH ENERGY'] = saptdata[dbrxn]['exch']; dictorxn['SAPT IND ENERGY'] = saptdata[dbrxn]['ind']; dictorxn['SAPT DISP ENERGY'] = saptdata[dbrxn]['disp']; dictorxn['SAPT TOTAL ENERGY'] = dictorxn['SAPT ELST ENERGY'] + dictorxn['SAPT EXCH ENERGY'] + \; dictorxn['SAPT IND ENERGY'] + dictorxn['SAPT DISP ENERGY']. orgts = orxn.rxnm['default'].keys(); omolD = Molecule(orgts[0]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:84755,Testability,benchmark,benchmark,84755,"elchem=[], benchmark='default', sset='default', modelchemlabels=None,; failoninc=True):; """"""; *modelchem* is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?; """"""; import pandas as pd; import numpy as np. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; saptdata = self.load_saptdata_frombfdb(sset=sset, pythonpath='/Users/loriab/linux/bfdb/sapt_punt',; failoninc=failoninc). listodicts = []; rhrxn = self.get_hrxn(sset=sset); for dbrxn, orxn in rhrxn.iteritems():; wdb = dbrxn.split('-')[0]; dbix = self.dbdict.keys().index(wdb); wbm = self.mcs[benchmark][dbix]; wss = self.sset[sset][dbix]; woss = self.dbdict[wdb].oss[wss]; try:; Rrat = woss.axis['Rrat'][woss.hrxn.index(orxn.name)]; except KeyError:; Rrat = 1.0 # TODO generic soln?. dictorxn = {}; dictorxn['DB'] = wdb; dictorxn['System'] = orxn.tagl; dictorxn['Name'] = orxn.name; dictorxn['R'] = Rrat; dictorxn['System #'] = orxn.indx; dictorxn['Benchmark'] = np.NaN if orxn.benchmark is None else orxn.data[; wbm].value # this NaN exception is new and experimental; dictorxn['QcdbSys'] = orxn.dbrxn. if self.dbse not in ['ACONF', 'SCONF', 'PCONF', 'CYCONF']:; dictorxn['SAPT ELST ENERGY'] = saptdata[dbrxn]['elst']; dictorxn['SAPT EXCH ENERGY'] = saptdata[dbrxn]['exch']; dictorxn['SAPT IND ENERGY'] = saptdata[dbrxn]['ind']; dictorxn['SAPT DISP ENERGY'] = saptdata[dbrxn]['disp']; dictorxn['SAPT TOTAL ENERGY'] = dictorxn['SAPT ELST ENERGY'] + dictorxn['SAPT EXCH ENERGY'] + \; dictorxn['SAPT IND ENERGY'] + dictorxn['SAPT DISP ENERGY']. orgts = orxn.rxnm['default'].keys(); omolD = Molecule(orgts[0].mol) # TODO this is only going to work with Reaction ~= Reagent databases; npmolD = omolD.format_molecule_for_numpy(); omolA = Molecule(orgts[1].mol) # TODO this is only going to work with Reaction ~= Reagent databases; omolA.update_geometry(); dictorxn['MonA'] = omolA.natom(). # this whole member fn not well defined for db of varying stoichiometry; if self.dbse in ['ACONF', 'SCONF',",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:86748,Testability,benchmark,benchmark,86748,"(); # print '\nD', npmolD.shape[0], npmolA.shape[0], dictorxn['MonA'], npmolD, npmolA, dictorxn['Geometry']. for mc in modelchem:; try:; wmc = self.mcs[mc][dbix]; except KeyError:; # modelchem not in Database at all; print(mc, 'not found'); continue; key = mc if modelchemlabels is None else modelchemlabels[modelchem.index(mc)]; try:; dictorxn[key] = orxn.data[wmc].value; except KeyError as e:; # reaction not in modelchem; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (key, str(e))); else:; print(mc, str(e), 'not found'); continue; listodicts.append(dictorxn). df = pd.DataFrame(listodicts); pd.set_option('display.width', 500); print(df.head(5)); print(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to toggle between full; compilable document and suitable for inclusion in another LaTeX document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:87316,Testability,benchmark,benchmark,87316,"lchem.index(mc)]; try:; dictorxn[key] = orxn.data[wmc].value; except KeyError as e:; # reaction not in modelchem; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (key, str(e))); else:; print(mc, str(e), 'not found'); continue; listodicts.append(dictorxn). df = pd.DataFrame(listodicts); pd.set_option('display.width', 500); print(df.head(5)); print(df.tail(5)); return df. [docs] def table_reactions(self, modelchem, benchmark='default', sset='default',; failoninc=True,; columnplan=['indx', 'tagl', 'bm', 'mc', 'e', 'pe'],; title=""""""Reaction energies [kcal/mol] for {sset} $\subset$ {dbse} with {mc}"""""",; indextitle=""""""Detailed results for {sset} $\subset$ {dbse} with {mc}"""""",; plotpath='analysis/mols/',; standalone=True, theme='rxns', filename=None):; r""""""Prepare single LaTeX table to *filename* or return lines if None showing; the per-reaction results for reactions in *sset* for single or array; or 'all' *modelchem*, where the last uses self.mcs(), model chemistries; versus *benchmark*. Use *failoninc* to toggle between command failing; or blank lines in table. Use *standalone* to toggle between full; compilable document and suitable for inclusion in another LaTeX document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}"""""", """"""{0:50s}""""""],; 'bm': ['d', r""""""\multicolumn{1}{c}{\textbf{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:89003,Testability,benchmark,benchmark,89003,"f{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mcs.keys()); else:; mcs = [modelchem]; else:; mcs = modelchem. # commence to generate LaTeX code; tablelines = []; indexlines = []. if standalone:; tablelines += textables.begin_latex_document(). # iterate to produce one LaTeX table per modelchem; for mc in mcs:; # prepare summary statistics; perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tmp['dbrxn'] = dbrxn.replace('_', '\\_'); tmp['indx'] = r""""""\textit{"""""" + str(orxn.indx) + """"""}""""""; tmp['tagl'] = dbrxn.split('-')[0] + ' ' + \; (orxn.latex if orxn.latex else orxn.tagl.replace('_', '\\_')); tmp['imag'] = None # name of primary rgt; bmdatum = orxn.data[lbm].value if lbm else None; mcdatum = orxn.data[lmc].value if lmc else None; tmp['bm'] = bmdatum; tmp['mc'] = mcdatum; if lmc and lbm:; tmp['e'] = mcdatum - bmdatum; tmp['pe'] = 100 * (mcdatum - bmdatum) / abs(bmdatum); # TODO redefining errors not good practice; else:; isComple",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:89013,Testability,benchmark,benchmark,89013,"f{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mcs.keys()); else:; mcs = [modelchem]; else:; mcs = modelchem. # commence to generate LaTeX code; tablelines = []; indexlines = []. if standalone:; tablelines += textables.begin_latex_document(). # iterate to produce one LaTeX table per modelchem; for mc in mcs:; # prepare summary statistics; perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tmp['dbrxn'] = dbrxn.replace('_', '\\_'); tmp['indx'] = r""""""\textit{"""""" + str(orxn.indx) + """"""}""""""; tmp['tagl'] = dbrxn.split('-')[0] + ' ' + \; (orxn.latex if orxn.latex else orxn.tagl.replace('_', '\\_')); tmp['imag'] = None # name of primary rgt; bmdatum = orxn.data[lbm].value if lbm else None; mcdatum = orxn.data[lmc].value if lmc else None; tmp['bm'] = bmdatum; tmp['mc'] = mcdatum; if lmc and lbm:; tmp['e'] = mcdatum - bmdatum; tmp['pe'] = 100 * (mcdatum - bmdatum) / abs(bmdatum); # TODO redefining errors not good practice; else:; isComple",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:89421,Testability,benchmark,benchmark,89421,"f col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mcs.keys()); else:; mcs = [modelchem]; else:; mcs = modelchem. # commence to generate LaTeX code; tablelines = []; indexlines = []. if standalone:; tablelines += textables.begin_latex_document(). # iterate to produce one LaTeX table per modelchem; for mc in mcs:; # prepare summary statistics; perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tmp['dbrxn'] = dbrxn.replace('_', '\\_'); tmp['indx'] = r""""""\textit{"""""" + str(orxn.indx) + """"""}""""""; tmp['tagl'] = dbrxn.split('-')[0] + ' ' + \; (orxn.latex if orxn.latex else orxn.tagl.replace('_', '\\_')); tmp['imag'] = None # name of primary rgt; bmdatum = orxn.data[lbm].value if lbm else None; mcdatum = orxn.data[lmc].value if lmc else None; tmp['bm'] = bmdatum; tmp['mc'] = mcdatum; if lmc and lbm:; tmp['e'] = mcdatum - bmdatum; tmp['pe'] = 100 * (mcdatum - bmdatum) / abs(bmdatum); # TODO redefining errors not good practice; else:; isComplete = False; tmp['e'] = None; tmp['pe'] = None. terrors[dbrxn] = {}; for c in columnreservoir.keys():; terrors[dbrxn][c] = '' if tmp[c] is None else \; columnreservoir[c][2].format(tmp[c]). fancymodelchem = self.fancy_mcs(latex=True)[mc]; thistitle = title.format(dbse=self.dbse, mc=fancymodelchem,; sset='All' if sset == 'default' else sset.upper()); lref = [r""""""tbl:qcdb""""""]; if theme:; lref.ap",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:89431,Testability,benchmark,benchmark,89431,"f col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mcs.keys()); else:; mcs = [modelchem]; else:; mcs = modelchem. # commence to generate LaTeX code; tablelines = []; indexlines = []. if standalone:; tablelines += textables.begin_latex_document(). # iterate to produce one LaTeX table per modelchem; for mc in mcs:; # prepare summary statistics; perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tmp['dbrxn'] = dbrxn.replace('_', '\\_'); tmp['indx'] = r""""""\textit{"""""" + str(orxn.indx) + """"""}""""""; tmp['tagl'] = dbrxn.split('-')[0] + ' ' + \; (orxn.latex if orxn.latex else orxn.tagl.replace('_', '\\_')); tmp['imag'] = None # name of primary rgt; bmdatum = orxn.data[lbm].value if lbm else None; mcdatum = orxn.data[lmc].value if lmc else None; tmp['bm'] = bmdatum; tmp['mc'] = mcdatum; if lmc and lbm:; tmp['e'] = mcdatum - bmdatum; tmp['pe'] = 100 * (mcdatum - bmdatum) / abs(bmdatum); # TODO redefining errors not good practice; else:; isComplete = False; tmp['e'] = None; tmp['pe'] = None. terrors[dbrxn] = {}; for c in columnreservoir.keys():; terrors[dbrxn][c] = '' if tmp[c] is None else \; columnreservoir[c][2].format(tmp[c]). fancymodelchem = self.fancy_mcs(latex=True)[mc]; thistitle = title.format(dbse=self.dbse, mc=fancymodelchem,; sset='All' if sset == 'default' else sset.upper()); lref = [r""""""tbl:qcdb""""""]; if theme:; lref.ap",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:94703,Testability,benchmark,benchmark,94703,"strip(),; sset='All' if sset == 'default' else sset.upper()); indexlines.append(r""""""\scriptsize \ref{%s} & \scriptsize %s \\ """""" % \; (ref, thisindextitle)). if standalone:; tablelines += textables.end_latex_document(). # form table and index return structures; if filename is None:; return tablelines, indexlines; else:; if filename.endswith('.tex'):; filename = filename[:-4]; with open(filename + '.tex', 'w') as handle:; handle.write('\n'.join(tablelines)); with open(filename + '_index.tex', 'w') as handle:; handle.write('\n'.join(indexlines) + '\n'); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filename + '_index.tex')}; return filedict. [docs] def table_wrapper(self, mtd, bas, tableplan, benchmark='default',; opt=['CP'], err=['mae'], sset=['default'], dbse=None,; opttarget=None,; failoninc=True,; xlimit=4.0, xlines=[0.0, 0.3, 1.0],; ialimit=2.0,; plotpath='autogen',; subjoin=True,; title=None, indextitle=None,; suppressblanks=False,; standalone=True, theme=None, filename=None):; """"""Prepares dictionary of errors for all combinations of *mtd*, *opt*,; *bas* with respect to model chemistry *benchmark*, mindful of *failoninc*.; The general plan for the table, as well as defaults for landscape,; footnotes, *title*, *indextitle, and *theme* are got from function; *tableplan*. Once error dictionary is ready, it and all other arguments; are passed along to textables.table_generic. Two arrays, one of table; lines and one of index lines are returned unless *filename* is given,; in which case they're written to file and a filedict returned. """"""; # get plan for table from *tableplan* and some default values; kwargs = {'plotpath': plotpath,; 'subjoin': subjoin,; 'xlines': xlines,; 'xlimit': xlimit,; 'ialimit': iali",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:95111,Testability,benchmark,benchmark,95111,"lename is None:; return tablelines, indexlines; else:; if filename.endswith('.tex'):; filename = filename[:-4]; with open(filename + '.tex', 'w') as handle:; handle.write('\n'.join(tablelines)); with open(filename + '_index.tex', 'w') as handle:; handle.write('\n'.join(indexlines) + '\n'); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filename + '_index.tex')}; return filedict. [docs] def table_wrapper(self, mtd, bas, tableplan, benchmark='default',; opt=['CP'], err=['mae'], sset=['default'], dbse=None,; opttarget=None,; failoninc=True,; xlimit=4.0, xlines=[0.0, 0.3, 1.0],; ialimit=2.0,; plotpath='autogen',; subjoin=True,; title=None, indextitle=None,; suppressblanks=False,; standalone=True, theme=None, filename=None):; """"""Prepares dictionary of errors for all combinations of *mtd*, *opt*,; *bas* with respect to model chemistry *benchmark*, mindful of *failoninc*.; The general plan for the table, as well as defaults for landscape,; footnotes, *title*, *indextitle, and *theme* are got from function; *tableplan*. Once error dictionary is ready, it and all other arguments; are passed along to textables.table_generic. Two arrays, one of table; lines and one of index lines are returned unless *filename* is given,; in which case they're written to file and a filedict returned. """"""; # get plan for table from *tableplan* and some default values; kwargs = {'plotpath': plotpath,; 'subjoin': subjoin,; 'xlines': xlines,; 'xlimit': xlimit,; 'ialimit': ialimit}; rowplan, columnplan, landscape, footnotes, \; suggestedtitle, suggestedtheme = tableplan(**kwargs); #suggestedtitle, suggestedtheme = tableplan(plotpath=plotpath, subjoin=subjoin). # make figure files write themselves; autothread = {}; autoliliowa = {}; if plot",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:97467,Testability,benchmark,benchmark,97467,"; indextitle = title if indextitle is None else indextitle; opttarget = {'default': ['']} if opttarget is None else opttarget. def unify_options(orequired, opossible):; """"""Perform a merge of options tags in *orequired* and *opossible* so; that the result is free of duplication and has the mode at the end. """"""; opt_combos = []; for oreq in orequired:; for opos in opossible:; pieces = sorted(set(oreq.split('_') + opos.split('_'))); if '' in pieces:; pieces.remove(''); for mode in ['CP', 'unCP', 'SA']:; if mode in pieces:; pieces.remove(mode); pieces.append(mode); pieces = '_'.join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product(mtd, opt, bas)]; mc_translator = {}; for m, o, b in itertools.product(mtd, opt, bas):; nominal_mc = '-'.join([m, o, b]); for oo in unify_options([o], opttarget['default']):; trial_mc = '-'.join([m, oo, b]); try:; perr = self.compute_statistics(trial_mc, benchmark=benchmark, sset='default', # prob. too restrictive by choosing subset; failoninc=False, verbose=False, returnindiv=False); except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:97477,Testability,benchmark,benchmark,97477,"; indextitle = title if indextitle is None else indextitle; opttarget = {'default': ['']} if opttarget is None else opttarget. def unify_options(orequired, opossible):; """"""Perform a merge of options tags in *orequired* and *opossible* so; that the result is free of duplication and has the mode at the end. """"""; opt_combos = []; for oreq in orequired:; for opos in opossible:; pieces = sorted(set(oreq.split('_') + opos.split('_'))); if '' in pieces:; pieces.remove(''); for mode in ['CP', 'unCP', 'SA']:; if mode in pieces:; pieces.remove(mode); pieces.append(mode); pieces = '_'.join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product(mtd, opt, bas)]; mc_translator = {}; for m, o, b in itertools.product(mtd, opt, bas):; nominal_mc = '-'.join([m, o, b]); for oo in unify_options([o], opttarget['default']):; trial_mc = '-'.join([m, oo, b]); try:; perr = self.compute_statistics(trial_mc, benchmark=benchmark, sset='default', # prob. too restrictive by choosing subset; failoninc=False, verbose=False, returnindiv=False); except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or (",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:98020,Testability,benchmark,benchmark,98020,"join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product(mtd, opt, bas)]; mc_translator = {}; for m, o, b in itertools.product(mtd, opt, bas):; nominal_mc = '-'.join([m, o, b]); for oo in unify_options([o], opttarget['default']):; trial_mc = '-'.join([m, oo, b]); try:; perr = self.compute_statistics(trial_mc, benchmark=benchmark, sset='default', # prob. too restrictive by choosing subset; failoninc=False, verbose=False, returnindiv=False); except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotflat'] = mcssplots['pdf']; if autoliliowa and ss == 'default':; mcssplots = self.plot_liliowa(mc_translator[mc], benchmark=benchmark,; failoninc=failoninc, xlimit=ialimit, view=False,; saveas='liliowa_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); ser",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:98030,Testability,benchmark,benchmark,98030,"join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product(mtd, opt, bas)]; mc_translator = {}; for m, o, b in itertools.product(mtd, opt, bas):; nominal_mc = '-'.join([m, o, b]); for oo in unify_options([o], opttarget['default']):; trial_mc = '-'.join([m, oo, b]); try:; perr = self.compute_statistics(trial_mc, benchmark=benchmark, sset='default', # prob. too restrictive by choosing subset; failoninc=False, verbose=False, returnindiv=False); except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotflat'] = mcssplots['pdf']; if autoliliowa and ss == 'default':; mcssplots = self.plot_liliowa(mc_translator[mc], benchmark=benchmark,; failoninc=failoninc, xlimit=ialimit, view=False,; saveas='liliowa_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); ser",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:98549,Testability,benchmark,benchmark,98549," except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotflat'] = mcssplots['pdf']; if autoliliowa and ss == 'default':; mcssplots = self.plot_liliowa(mc_translator[mc], benchmark=benchmark,; failoninc=failoninc, xlimit=ialimit, view=False,; saveas='liliowa_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotliliowa'] = mcssplots['pdf']; for db in self.dbdict.keys():; if perr[db] is None:; serrors[mc][ss][db] = None; else:; serrors[mc][ss][db] = format_errors(perr[db], mode=3); if not failoninc:; serrors[mc][ss][db]['tgtcnt'] = mcsscounts[db][0]; serrors[mc][ss][db]['misscnt'] = len(mcsscounts[db][1]); else:; serrors[mc][ss][self.dbse] = format_errors(initialize_errors(), mode=3); for db in self.dbdict.keys():; serrors[mc][ss][db] = format_errors(initialize_errors(), mode=3); for key in serrors.keys():; print(""""""{:",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:98559,Testability,benchmark,benchmark,98559," except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:; mc_translator[nominal_mc] = None. # compute errors; serrors = {}; for mc in mcs:; serrors[mc] = {}; for ss in self.sset.keys():; serrors[mc][ss] = {}; if mc_translator[mc] in self.mcs:; # Note: not handling when one component Wdb has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotflat'] = mcssplots['pdf']; if autoliliowa and ss == 'default':; mcssplots = self.plot_liliowa(mc_translator[mc], benchmark=benchmark,; failoninc=failoninc, xlimit=ialimit, view=False,; saveas='liliowa_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotliliowa'] = mcssplots['pdf']; for db in self.dbdict.keys():; if perr[db] is None:; serrors[mc][ss][db] = None; else:; serrors[mc][ss][db] = format_errors(perr[db], mode=3); if not failoninc:; serrors[mc][ss][db]['tgtcnt'] = mcsscounts[db][0]; serrors[mc][ss][db]['misscnt'] = len(mcsscounts[db][1]); else:; serrors[mc][ss][self.dbse] = format_errors(initialize_errors(), mode=3); for db in self.dbdict.keys():; serrors[mc][ss][db] = format_errors(initialize_errors(), mode=3); for key in serrors.keys():; print(""""""{:",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:98890,Testability,benchmark,benchmark,98890,"has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotflat'] = mcssplots['pdf']; if autoliliowa and ss == 'default':; mcssplots = self.plot_liliowa(mc_translator[mc], benchmark=benchmark,; failoninc=failoninc, xlimit=ialimit, view=False,; saveas='liliowa_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotliliowa'] = mcssplots['pdf']; for db in self.dbdict.keys():; if perr[db] is None:; serrors[mc][ss][db] = None; else:; serrors[mc][ss][db] = format_errors(perr[db], mode=3); if not failoninc:; serrors[mc][ss][db]['tgtcnt'] = mcsscounts[db][0]; serrors[mc][ss][db]['misscnt'] = len(mcsscounts[db][1]); else:; serrors[mc][ss][self.dbse] = format_errors(initialize_errors(), mode=3); for db in self.dbdict.keys():; serrors[mc][ss][db] = format_errors(initialize_errors(), mode=3); for key in serrors.keys():; print(""""""{:>35}{:>35}{}"""""".format(key, mc_translator[key], serrors[key]['default'][self.dbse]['mae'])). # find indices that would be neglected in a single sweep over table_generic; keysinplan = set(sum([col[-1].keys() for col in columnplan], rowplan)); obvious = {'dbse': dbse, 'sset': sset, 'mtd': mtd, 'opt': opt, 'bas': bas, 'err'",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:98900,Testability,benchmark,benchmark,98900,"has one translated pattern and another another; perr = self.compute_statistics(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, verbose=False, returnindiv=False); serrors[mc][ss][self.dbse] = format_errors(perr[self.dbse], mode=3); if not failoninc:; mcsscounts = self.get_missing_reactions(mc_translator[mc], sset=ss); serrors[mc][ss][self.dbse]['tgtcnt'] = mcsscounts[self.dbse][0]; serrors[mc][ss][self.dbse]['misscnt'] = len(mcsscounts[self.dbse][1]); if autothread:; if ('sset' in autothread and ss in autothread['sset']) or ('sset' not in autothread):; mcssplots = self.plot_flat(mc_translator[mc], benchmark=benchmark, sset=ss,; failoninc=failoninc, color='sapt', xlimit=xlimit, xlines=xlines, view=False,; saveas='flat_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotflat'] = mcssplots['pdf']; if autoliliowa and ss == 'default':; mcssplots = self.plot_liliowa(mc_translator[mc], benchmark=benchmark,; failoninc=failoninc, xlimit=ialimit, view=False,; saveas='liliowa_' + '-'.join([self.dbse, ss, mc]), relpath=True, graphicsformat=['pdf']); serrors[mc][ss][self.dbse]['plotliliowa'] = mcssplots['pdf']; for db in self.dbdict.keys():; if perr[db] is None:; serrors[mc][ss][db] = None; else:; serrors[mc][ss][db] = format_errors(perr[db], mode=3); if not failoninc:; serrors[mc][ss][db]['tgtcnt'] = mcsscounts[db][0]; serrors[mc][ss][db]['misscnt'] = len(mcsscounts[db][1]); else:; serrors[mc][ss][self.dbse] = format_errors(initialize_errors(), mode=3); for db in self.dbdict.keys():; serrors[mc][ss][db] = format_errors(initialize_errors(), mode=3); for key in serrors.keys():; print(""""""{:>35}{:>35}{}"""""".format(key, mc_translator[key], serrors[key]['default'][self.dbse]['mae'])). # find indices that would be neglected in a single sweep over table_generic; keysinplan = set(sum([col[-1].keys() for col in columnplan], rowplan)); obvious = {'dbse': dbse, 'sset': sset, 'mtd': mtd, 'opt': opt, 'bas': bas, 'err'",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:107371,Testability,benchmark,benchmark,107371,"yproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5min'] = ['mxddpp', 'mxddpp-5min', None, None]; self.sset['np-5min'] = ['mxddnp', 'mxddnp-5min', None, 'mxdd']. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return 'C2001BENCH'. [docs] def define_supermodelchems(self):; """""". """"""; self.benchmark = 'C2011BENCH'; self.mcs['C2010BENCH'] = ['S22A', 'NBC100', 'HBC60', 'HSG0']; self.mcs['C2011BENCH'] = ['S22B', 'NBC10A', 'HBC6A', 'HSGA']. self.mcs['CCSD-CP-adz'] = ['CCSD-CP-adz', 'CCSD-CP-hadz', 'CCSD-CP-adz', 'CCSD-CP-hadz']; self.mcs['CCSD-CP-atz'] = ['CCSD-CP-atz', 'CCSD-CP-hatz', 'CCSD-CP-atz', 'CCSD-CP-hatz']; self.mcs['CCSD-CP-adtz'] = ['CCSD-CP-adtz', 'CCSD-CP-hadtz', 'CCSD-CP-adtz', 'CCSD-CP-hadtz']; self.mcs['CCSD-CP-adtzadz'] = ['CCSD-CP-adtzadz', 'CCSD-CP-adtzhadz', 'CCSD-CP-adtzadz', 'CCSD-CP-adtzhadz']; self.mcs['CCSD-CP-atzadz'] = ['CCSD-CP-atzadz', 'CCSD-CP-atzhadz', 'CCSD-CP-atzadz', 'CCSD-CP-atzhadz']; self.mcs['CCSD-CP-atqzadz'] = ['CCSD-CP-atqzadz', 'CCSD-CP-atqzhadz', 'CCSD-CP-atqzadz', 'CCSD-CP-atqzhadz']; self.mcs['CCSD-CP-atzadtz'] = ['CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz', 'CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz']; self.mcs[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:107447,Testability,benchmark,benchmark,107447,"yproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5min'] = ['mxddpp', 'mxddpp-5min', None, None]; self.sset['np-5min'] = ['mxddnp', 'mxddnp-5min', None, 'mxdd']. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return 'C2001BENCH'. [docs] def define_supermodelchems(self):; """""". """"""; self.benchmark = 'C2011BENCH'; self.mcs['C2010BENCH'] = ['S22A', 'NBC100', 'HBC60', 'HSG0']; self.mcs['C2011BENCH'] = ['S22B', 'NBC10A', 'HBC6A', 'HSGA']. self.mcs['CCSD-CP-adz'] = ['CCSD-CP-adz', 'CCSD-CP-hadz', 'CCSD-CP-adz', 'CCSD-CP-hadz']; self.mcs['CCSD-CP-atz'] = ['CCSD-CP-atz', 'CCSD-CP-hatz', 'CCSD-CP-atz', 'CCSD-CP-hatz']; self.mcs['CCSD-CP-adtz'] = ['CCSD-CP-adtz', 'CCSD-CP-hadtz', 'CCSD-CP-adtz', 'CCSD-CP-hadtz']; self.mcs['CCSD-CP-adtzadz'] = ['CCSD-CP-adtzadz', 'CCSD-CP-adtzhadz', 'CCSD-CP-adtzadz', 'CCSD-CP-adtzhadz']; self.mcs['CCSD-CP-atzadz'] = ['CCSD-CP-atzadz', 'CCSD-CP-atzhadz', 'CCSD-CP-atzadz', 'CCSD-CP-atzhadz']; self.mcs['CCSD-CP-atqzadz'] = ['CCSD-CP-atqzadz', 'CCSD-CP-atqzhadz', 'CCSD-CP-atqzadz', 'CCSD-CP-atqzhadz']; self.mcs['CCSD-CP-atzadtz'] = ['CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz', 'CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz']; self.mcs[",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:107542,Testability,benchmark,benchmark,107542,"ef define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5min'] = ['mxddpp', 'mxddpp-5min', None, None]; self.sset['np-5min'] = ['mxddnp', 'mxddnp-5min', None, 'mxdd']. # def benchmark(self):; # """"""Returns the model chemistry label for the database's benchmark.""""""; # return 'C2001BENCH'. [docs] def define_supermodelchems(self):; """""". """"""; self.benchmark = 'C2011BENCH'; self.mcs['C2010BENCH'] = ['S22A', 'NBC100', 'HBC60', 'HSG0']; self.mcs['C2011BENCH'] = ['S22B', 'NBC10A', 'HBC6A', 'HSGA']. self.mcs['CCSD-CP-adz'] = ['CCSD-CP-adz', 'CCSD-CP-hadz', 'CCSD-CP-adz', 'CCSD-CP-hadz']; self.mcs['CCSD-CP-atz'] = ['CCSD-CP-atz', 'CCSD-CP-hatz', 'CCSD-CP-atz', 'CCSD-CP-hatz']; self.mcs['CCSD-CP-adtz'] = ['CCSD-CP-adtz', 'CCSD-CP-hadtz', 'CCSD-CP-adtz', 'CCSD-CP-hadtz']; self.mcs['CCSD-CP-adtzadz'] = ['CCSD-CP-adtzadz', 'CCSD-CP-adtzhadz', 'CCSD-CP-adtzadz', 'CCSD-CP-adtzhadz']; self.mcs['CCSD-CP-atzadz'] = ['CCSD-CP-atzadz', 'CCSD-CP-atzhadz', 'CCSD-CP-atzadz', 'CCSD-CP-atzhadz']; self.mcs['CCSD-CP-atqzadz'] = ['CCSD-CP-atqzadz', 'CCSD-CP-atqzhadz', 'CCSD-CP-atqzadz', 'CCSD-CP-atqzhadz']; self.mcs['CCSD-CP-atzadtz'] = ['CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz', 'CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz']; self.mcs['CCSD-CP-atqzadtz'] = ['CCSD-CP-atqzadtz', 'CCSD-CP-atqzhadtz', 'CCSD-CP-atqzadtz',; 'CCSD-CP-atqzhadtz']; self.mcs['CCSD-CP-atqzatz'] = ['CCSD-CP-",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:125420,Testability,benchmark,benchmark,125420,"'VV10-unCP-atz', 'VV10-CP-atz', None, None,; 'LCVV10-unCP-adz', 'LCVV10-CP-adz', 'LCVV10-unCP-atz', 'LCVV10-CP-atz', None, None,; 'WB97XV-unCP-adz', 'WB97XV-CP-adz', 'WB97XV-unCP-atz', 'WB97XV-CP-atz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). # Fig. bars (d); self.plot_bars([; 'PBE02-unCP-adz', 'PBE02-CP-adz', 'PBE02-unCP-atz', 'PBE02-CP-atz', None,; 'WB97X2-unCP-adz', 'WB97X2-CP-adz', 'WB97X2-unCP-atz', 'WB97X2-CP-atz', None,; 'B2PLYPD3-unCP-adz', 'B2PLYPD3-CP-adz', 'B2PLYPD3-unCP-atz', 'B2PLYPD3-CP-atz', None,; 'DSDPBEP86D2OPT-unCP-adz', 'DSDPBEP86D2OPT-CP-adz', 'DSDPBEP86D2OPT-unCP-atz', 'DSDPBEP86D2OPT-CP-atz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). # Fig. bars (e); self.plot_bars([; 'MP2-unCP-adz', 'MP2-CP-adz', 'MP2-unCP-atz', 'MP2-CP-atz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). [docs] def make_dhdft_Figure_2(self):; """"""Plot all the graphics needed for the SAPT/DFT/WFN; comparison plot in Fig. 2 of DHDFT. Note that benchmark set as reminder, not necessity, since default. """"""; self.plot_bars([; 'SAPT0S-CP-jadz', 'SAPTDFT-CP-atz', 'SAPT2P-CP-adz', 'SAPT3M-CP-atz',; 'SAPT2PCM-CP-atz', None, 'B97D3-unCP-atz', 'B3LYPD3-CP-adz',; 'M052X-unCP-adz', 'WB97XD-CP-atz', 'WB97XV-CP-adz', 'WB97X2-CP-atz',; 'DSDPBEP86D2OPT-CP-atz', 'B2PLYPD3-CP-atz', None, 'MP2-CP-atz',; 'SCSMP2-CP-atz', 'SCSMIMP2-CP-qz', 'MP2C-CP-atqzadz',; 'MP2CF12-CP-adz', 'SCMICCSDAF12-CP-adz', 'CCSDT-CP-atz',; 'CCSDT-CP-atqzatz', 'DWCCSDTF12-CP-adz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min'],; benchmark='C2011BENCH'). [docs] def plot_dhdft_modelchems(self):; self.plot_modelchems(; ['B97D3-CP-adz', 'PBED3-CP-adz', 'M11L-CP-adz', 'DLDFD-CP-adz', 'B3LYPD3-CP-adz', 'PBE0D3-CP-adz',; 'WB97XD-CP-adz', 'M052X-CP-adz', 'M062X-CP-adz', 'M08HX-CP-adz', 'M08SO-CP-adz', 'M11-CP-adz',; 'VV10-CP-adz',; 'LCVV10-CP-adz', 'WB97XV-CP-adz', 'PBE02-CP-adz', 'WB97X2-CP-adz', 'B2PLYPD3-CP-adz',; 'DSDPBEP86D2OPT-CP-adz', 'MP2-CP-adz'], sset='tt-5min'); self.plot_modelchems([",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:125976,Testability,benchmark,benchmark,125976,"P-adz', 'PBE02-CP-adz', 'PBE02-unCP-atz', 'PBE02-CP-atz', None,; 'WB97X2-unCP-adz', 'WB97X2-CP-adz', 'WB97X2-unCP-atz', 'WB97X2-CP-atz', None,; 'B2PLYPD3-unCP-adz', 'B2PLYPD3-CP-adz', 'B2PLYPD3-unCP-atz', 'B2PLYPD3-CP-atz', None,; 'DSDPBEP86D2OPT-unCP-adz', 'DSDPBEP86D2OPT-CP-adz', 'DSDPBEP86D2OPT-unCP-atz', 'DSDPBEP86D2OPT-CP-atz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). # Fig. bars (e); self.plot_bars([; 'MP2-unCP-adz', 'MP2-CP-adz', 'MP2-unCP-atz', 'MP2-CP-atz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min']). [docs] def make_dhdft_Figure_2(self):; """"""Plot all the graphics needed for the SAPT/DFT/WFN; comparison plot in Fig. 2 of DHDFT. Note that benchmark set as reminder, not necessity, since default. """"""; self.plot_bars([; 'SAPT0S-CP-jadz', 'SAPTDFT-CP-atz', 'SAPT2P-CP-adz', 'SAPT3M-CP-atz',; 'SAPT2PCM-CP-atz', None, 'B97D3-unCP-atz', 'B3LYPD3-CP-adz',; 'M052X-unCP-adz', 'WB97XD-CP-atz', 'WB97XV-CP-adz', 'WB97X2-CP-atz',; 'DSDPBEP86D2OPT-CP-atz', 'B2PLYPD3-CP-atz', None, 'MP2-CP-atz',; 'SCSMP2-CP-atz', 'SCSMIMP2-CP-qz', 'MP2C-CP-atqzadz',; 'MP2CF12-CP-adz', 'SCMICCSDAF12-CP-adz', 'CCSDT-CP-atz',; 'CCSDT-CP-atqzatz', 'DWCCSDTF12-CP-adz'],; sset=['tt-5min', 'hb-5min', 'mx-5min', 'dd-5min'],; benchmark='C2011BENCH'). [docs] def plot_dhdft_modelchems(self):; self.plot_modelchems(; ['B97D3-CP-adz', 'PBED3-CP-adz', 'M11L-CP-adz', 'DLDFD-CP-adz', 'B3LYPD3-CP-adz', 'PBE0D3-CP-adz',; 'WB97XD-CP-adz', 'M052X-CP-adz', 'M062X-CP-adz', 'M08HX-CP-adz', 'M08SO-CP-adz', 'M11-CP-adz',; 'VV10-CP-adz',; 'LCVV10-CP-adz', 'WB97XV-CP-adz', 'PBE02-CP-adz', 'WB97X2-CP-adz', 'B2PLYPD3-CP-adz',; 'DSDPBEP86D2OPT-CP-adz', 'MP2-CP-adz'], sset='tt-5min'); self.plot_modelchems(['B97D3-unCP-adz', 'PBED3-unCP-adz', 'M11L-unCP-adz', 'DLDFD-unCP-adz', 'B3LYPD3-unCP-adz',; 'PBE0D3-unCP-adz',; 'WB97XD-unCP-adz', 'M052X-unCP-adz', 'M062X-unCP-adz', 'M08HX-unCP-adz', 'M08SO-unCP-adz',; 'M11-unCP-adz', 'VV10-unCP-adz',; 'LCVV10-unCP-adz', 'WB97XV-unCP-adz', 'PBE02-unCP-adz', 'WB97X2",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:135612,Testability,benchmark,benchmark,135612,"atzadtz'] = ['CCSD-CP-atzadtz', 'CCSD-CP-atzhadtz', 'CCSD-CP-atzadtz']; self.mc['CCSD-CP-atqzadtz'] = ['CCSD-CP-atqzadtz', 'CCSD-CP-atqzhadtz', 'CCSD-CP-atqzadtz']; self.mc['CCSD-CP-atqzatz'] = ['CCSD-CP-atqzatz', 'CCSD-CP-atqzhatz', 'CCSD-CP-atqzatz']. self.mc['CCSDT-CP-adz'] = ['CCSDT-CP-adz', 'CCSDT-CP-hadz', 'CCSDT-CP-adz']; self.mc['CCSDT-CP-atz'] = ['CCSDT-CP-atz', 'CCSDT-CP-hatz', 'CCSDT-CP-atz']; self.mc['CCSDT-CP-adtz'] = ['CCSDT-CP-adtz', 'CCSDT-CP-hadtz', 'CCSDT-CP-adtz']; self.mc['CCSDT-CP-adtzadz'] = ['CCSDT-CP-adtzadz', 'CCSDT-CP-adtzhadz', 'CCSDT-CP-adtzadz']; self.mc['CCSDT-CP-atzadz'] = ['CCSDT-CP-atzadz', 'CCSDT-CP-atzhadz', 'CCSDT-CP-atzadz']; self.mc['CCSDT-CP-atqzadz'] = ['CCSDT-CP-atqzadz', 'CCSDT-CP-atqzhadz', 'CCSDT-CP-atqzadz']; self.mc['CCSDT-CP-atzadtz'] = ['CCSDT-CP-atzadtz', 'CCSDT-CP-atzhadtz', 'CCSDT-CP-atzadtz']; self.mc['CCSDT-CP-atqzadtz'] = ['CCSDT-CP-atqzadtz', 'CCSDT-CP-atqzhadtz', 'CCSDT-CP-atqzadtz']; self.mc['CCSDT-CP-atqzatz'] = ['CCSDT-CP-atqzatz', 'CCSDT-CP-atqzhatz', 'CCSDT-CP-atqzatz']. # print certain statistic for all 4 db and summary and indiv sys if min or max. fnreservoir = {}; fnreservoir['blankslat'] = r""""""Errors with respect to Benchmark. Guide lines are at 0, 0.3, and 1.0 kcal/mol overbound ($-$) and underbound ($+$).""""""; fnreservoir['5min'] = r""""""Only equilibrium and near-equilibrium systems included. (All S22 and HSG, 50/194 NBC10, 28/118 HBC6.)""""""; fnreservoir['liliowa'] = r""""""{0}MAE (dark by {1} kcal/mol) for subsets in residue classes cation, anion, polar, aliphatic, \& aromatic (L to R).""""""; fnreservoir['flat'] = r""""""{0}Errors with respect to benchmark within $\pm${1} kcal/mol. Guide lines are at {2} overbound ($-$) and underbound ($+$)."""""". Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:93605,Usability,clear,clearpage,93605,"end(r""""""\textit{Minimal Absolute Error} """"""); summlines[3].append(r""""""\textit{Maximal Signed Error} """"""); summlines[4].append(r""""""\textit{Maximal Absolute Error} """"""); summlines[5].append(r""""""\textit{Mean Signed Error} """"""); summlines[6].append(r""""""\textit{Mean Absolute Error} """"""); summlines[7].append(r""""""\textit{Root-Mean-Square Error} """"""); elif col in ['e', 'pe']:; summlines[0].append(''); summlines[1].append(blkerrors['nex' + col]); summlines[2].append(blkerrors['min' + col]); summlines[3].append(blkerrors['pex' + col]); summlines[4].append(blkerrors['max' + col]); summlines[5].append(blkerrors['m' + col]); summlines[6].append(blkerrors['ma' + col]); summlines[7].append(blkerrors['rms' + col]); else:; for ln in range(len(summlines)):; summlines[ln].append(''); for ln in range(len(summlines)):; tablelines.append(' & '.join(summlines[ln]) + r"""""" \\ """"""). # table conclusion; tablelines.append(r""""""\end{longtable}""""""); tablelines.append(r""""""\endgroup""""""); tablelines.append(r""""""\clearpage""""""); tablelines.append('\n\n'). # form table index; thisindextitle = indextitle.format(dbse=self.dbse, mc=fancymodelchem.strip(),; sset='All' if sset == 'default' else sset.upper()); indexlines.append(r""""""\scriptsize \ref{%s} & \scriptsize %s \\ """""" % \; (ref, thisindextitle)). if standalone:; tablelines += textables.end_latex_document(). # form table and index return structures; if filename is None:; return tablelines, indexlines; else:; if filename.endswith('.tex'):; filename = filename[:-4]; with open(filename + '.tex', 'w') as handle:; handle.write('\n'.join(tablelines)); with open(filename + '_index.tex', 'w') as handle:; handle.write('\n'.join(indexlines) + '\n'); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filen",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1582,Availability,error,error,1582,"ut even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1985,Availability,error,error,1985,"1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:2207,Availability,error,error,2207,"s defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg, silent=False):; QcdbException.__init__(self, msg); self.msg = msg; if not silent:; print('\nQcdbException BasisSetNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotDefined(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:2501,Availability,error,error,2501,"; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg, silent=False):; QcdbException.__init__(self, msg); self.msg = msg; if not silent:; print('\nQcdbException BasisSetNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotDefined(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetNotDefined: %s\n\n' % (msg)). [docs]class Dftd3Error(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:3653,Deployability,update,updated,3653,"eption: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg, silent=False):; QcdbException.__init__(self, msg); self.msg = msg; if not silent:; print('\nQcdbException BasisSetNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotDefined(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetNotDefined: %s\n\n' % (msg)). [docs]class Dftd3Error(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1588,Integrability,message,message,1588,"ut even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1935,Integrability,message,message,1935,"1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:2213,Integrability,message,message,2213,"s defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg, silent=False):; QcdbException.__init__(self, msg); self.msg = msg; if not silent:; print('\nQcdbException BasisSetNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotDefined(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = m",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:2507,Integrability,message,message,2507,"; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetFileNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotFound(QcdbException):; """""". """"""; def __init__(self, msg, silent=False):; QcdbException.__init__(self, msg); self.msg = msg; if not silent:; print('\nQcdbException BasisSetNotFound: %s\n\n' % (msg)). [docs]class BasisSetNotDefined(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException BasisSetNotDefined: %s\n\n' % (msg)). [docs]class Dftd3Error(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nDftd3Error: %s\n\n' % (msg)). Quick search. Enter search terms or a module, class or function",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1831,Modifiability,variab,variables,1831,"ith this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; #print('\nQcdbException: %s\n\n' % (msg)). [docs]class BasisSetFileNotFound(QcdbException):; """""". """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbExce",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/exceptions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:3109,Availability,avail,available,3109," :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Para",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:4267,Availability,avail,available,4267,"; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:5268,Availability,fault,fault,5268,"l %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch details and such; try:; psi4.version(); except NameError:; isP4regime = False; else:; isP4regime = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); if isP4regime:; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randint(0, 99999)); else:; dftd3_tmpdir = os.environ['HOME'] + os.sep + 'dftd3_' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramcontents = dash_server(func, dashlvl, 'dftd3'); paramfile1 = 'dftd3_parameters' # older patched name; with open(paramfile1, 'w') as handle:; handle.write(paramcontents); paramfile2 = '.df",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:7723,Availability,avail,available,7723,") + '\n'; geomfile = './dftd3_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call dftd3 program; command = ['dftd3', geomfile]; if dertype != 0:; command.append('-grad'); try:; dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; psi4.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if isP4regime:; verbose = True if psi4.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out; if dertype != 0:; with open(derivfile, 'r') as handle:; text ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:2367,Deployability,update,update,2367,"om .molecule import Molecule. # DGAS This should be removed!; import psi4. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:6156,Deployability,patch,patched,6156,"lit(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch details and such; try:; psi4.version(); except NameError:; isP4regime = False; else:; isP4regime = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); if isP4regime:; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randint(0, 99999)); else:; dftd3_tmpdir = os.environ['HOME'] + os.sep + 'dftd3_' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramcontents = dash_server(func, dashlvl, 'dftd3'); paramfile1 = 'dftd3_parameters' # older patched name; with open(paramfile1, 'w') as handle:; handle.write(paramcontents); paramfile2 = '.dftd3par.local' # new mainline name; with open(paramfile2, 'w') as handle:; handle.write(paramcontents). # Write dftd3_geometry file that supplies geometry to dispersion calc; numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './dftd3_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call dftd3 program; command = ['dftd3', geomfile]; if dertype !=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:9793,Deployability,update,updated,9793," = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; psi4.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if isP4regime:; verbose = True if psi4.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out; if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; psi4.print_out(text); else:; print(text). # Clean up files and remove scratch directory; os.unlink(paramfile1); os.unlink(paramfile2); os.unlink(geomfile); if dertype != 0:; os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e); os.chdir(current_directory). # return -D & d(-D)/dx; if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. try:; # Attach method to libmints psi4.Molecule class; psi4.Molecule.run_dftd3 = run_dftd3; except (NameError, AttributeError):; # But don't worry if that doesn't work b/c; # it'll get attached to qcdb.Molecule class; pass. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:1883,Energy Efficiency,energy,energy,1883,"Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that interface with Grimme's DFTD3 code.""""""; from __future__ import absolute_import; from __future__ import print_function; import os; import re; import sys; import math; import shutil; import socket; import random; import subprocess; try:; from p4xcpt import *; except ImportError:; from .exceptions import *; from .dashparam import *; from .molecule import Molecule. # DGAS This should be removed!; import psi4. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = das",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:1952,Energy Efficiency,energy,energy,1952,"Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that interface with Grimme's DFTD3 code.""""""; from __future__ import absolute_import; from __future__ import print_function; import os; import re; import sys; import math; import shutil; import socket; import random; import subprocess; try:; from p4xcpt import *; except ImportError:; from .exceptions import *; from .dashparam import *; from .molecule import Molecule. # DGAS This should be removed!; import psi4. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = das",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:1022,Integrability,interface,interface,1022,"— Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.interface_dftd3; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that interface with Grimme's DFTD3 code.""""""; from __future__ import absolute_import; from __future__ import print_function; import os; import re; import sys; import math; import shutil; import socket; import random; import subprocess; try:; from p4xcpt import *; except ImportError:; from .exceptions import *; from .dashparam import *; from .molecule import Molecule. # DGAS This should be removed!; import psi4. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:2254,Integrability,interface,interface,2254,":; from p4xcpt import *; except ImportError:; from .exceptions import *; from .dashparam import *; from .molecule import Molecule. # DGAS This should be removed!; import psi4. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; el",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:2205,Modifiability,extend,extended,2205,":; from p4xcpt import *; except ImportError:; from .exceptions import *; from .dashparam import *; from .molecule import Molecule. # DGAS This should be removed!; import psi4. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; el",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:5010,Modifiability,variab,variables,5010,"; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch details and such; try:; psi4.version(); except NameError:; isP4regime = False; else:; isP4regime = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); if isP4regime:; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randint(0, 99999)); else:; dftd3_tmpdir = os.environ['HOME'] + os.sep + 'dftd3_' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmp",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/jajo.html:14728,Deployability,update,updated,14728,"ck(istr, fileContent[poss:posf]); if verbose:; print('%10s%10d%10d' % ('mid', poss, posf)). poss = posf; posf = poss + srcrecs; istr = intlen2format[srcrecs]; jaend = struct.unpack(istr, fileContent[poss:posf]); if verbose:; print('%10s%10d%10d' % ('end', poss, posf)). nrecs = jaindx.index('OPENSLOT') # number of active records. if verbose:; print('\n'); print('%20s%10d' % ('File Length:', fileLength)); print('%20s%10d' % ('srcints Int Length:', srcints)); print('%20s%10d' % ('srcrecs Int Length:', srcrecs)); print('%20s%10d' % ('First Rec:', jastart[0])); print('%20s%10d' % ('Second Rec:', jamid[0])); print('%20s%10d' % ('Last Rec:', jaend[0])); print('%20s%10d' % ('Full Records:', nrecs)); print('\n'). print('\n<<< JOBARC >>>\n'). with open('JOBARC', mode='rb') as file: # b is important -> binary; fileContent = file.read(). returnRecords = {}; poss = 0; for item in range(nrecs):; posf = poss + type2len[knownlabels[jaindx[item]]] * jaindx3[item]; istr = type2format[knownlabels[jaindx[item]]] * jaindx3[item]; if knownlabels[jaindx[item]] == 'CHARACTER':; bound = type2len[knownlabels[jaindx[item]]] * jaindx3[item] * 8; posf = poss + bound; istr = str(bound) + 's'; jobarc = struct.unpack(istr, fileContent[poss:posf]). if verbose:; #print item, istr, poss, posf, '\t', jaindx[item], jaindx2[item], jaindx3[item], jobarc; if jaindx3[item] < 120:; print(jaindx[item], jaindx2[item], jaindx3[item], jobarc). poss = posf; if jaindx[item] in reclabelarray:; returnRecords[jaindx[item]] = jobarc. return returnRecords. #if __name__ == ""__main__"":; # want = ['NATOMS ', 'AU_LENGT', 'COORD ', 'HBAR ', 'ATOMCHRG']; ## got = get_jajo_record(want); # got = getrec(want); # for item in got.keys():; # print item, got[item]. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/jajo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/jajo.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/jajo.html:9676,Energy Efficiency,charge,charge,9676,"; ""I4CDCALC"": 'DOUBLE',; ""FREQUENC"": 'DOUBLE',; ""RATMMASS"": 'DOUBLE',; ""RATMPOSN"": 'INTEGER',; ""DEGENERT"": 'INTEGER',; ""REFSHILD"": 'DOUBLE',; ""CORIZETA"": 'DOUBLE',; ""NMPOINTX"": 'INTEGER',; ""REFD3EDX"": 'DOUBLE',; ""BPPTOB "": 'DOUBLE',; ""BPTOB "": 'DOUBLE',; ""BSRTOB "": 'DOUBLE',; ""BARTOB "": 'DOUBLE',; ""VRTOTAL "": 'DOUBLE',; ""D2DIPOLE"": 'DOUBLE',; ""D3DIPOLE"": 'DOUBLE',; ""D1DIPOLE"": 'DOUBLE',; ""REFNORM2"": 'DOUBLE',; ""NUSECOR2"": 'INTEGER',; ""FCMDISP2"": 'DOUBLE',; ""RGTDISPL"": 'DOUBLE',; ""CUBCOOR1"": 'INTEGER',; ""CUBCOOR2"": 'INTEGER',; ""REFFPEM2"": 'INTEGER',; ""RGTTENSO"": 'DOUBLE',; ""REFFPER2"": 'INTEGER',; ""REFD4EDX"": 'DOUBLE',; ""ZPE_ANHA"": 'DOUBLE',; ""OPENSLOT"": 'INTEGER',. ""BOLTZMAN"": 'DOUBLE',; ""MRCCOCC "": 'INTEGER',; ""ABELPTGP"": 'CHARACTER',; ""ABELORDR"": 'INTEGER',; ""ABELNIRR"": 'INTEGER',; ""ABELNORB"": 'INTEGER',; ""ABELSYOP"": 'DOUBLE',; ""ABELPERM"": 'INTEGER',; ""ABELMEMB"": 'INTEGER',; ""ABELPOPV"": 'INTEGER',; ""ABELCLSS"": 'INTEGER',; ""ABELSTGP"": 'CHARACTER',; ""REALCHRG"": 'INTEGER', # atom/mol? charge taking into acct edp; ""NSOSCF "": 'INTEGER', # whether is spin orbital calc?; ""SCFVCFLA"": 'DOUBLE', # scf vector expanded from sph to cart basis for symm anal - determin orb sym; ""EFG_SYM1"": 'INTEGER', # symmetry property of components of electric field gradient integrals; ""EFG_SYM2"": 'INTEGER', # symm prop of comp of EFG. ""DCTDISPL"": 'DOUBLE',; ""DANGERUS"": 'INTEGER', #?; ""FULLCHAR"": 'CHARACTER', #?; ""FULLDEGN"": 'CHARACTER', #?; ""FULLLABL"": 'CHARACTER', #?; ""FULLNIRX"": 'CHARACTER', #?; ""COMPCHAR"": 'CHARACTER', #?; ""COMPDEGN"": 'CHARACTER', #?; ""COMPLABL"": 'CHARACTER', #?; ""COMPNIRX"": 'CHARACTER', #?; ""ROTVECX "": 'CHARACTER', #?; ""ROTVECY "": 'CHARACTER', #?; ""ROTVECZ "": 'CHARACTER', #?; ""COMPNSYQ"": 'CHARACTER', #?; ""COMPSYQT"": 'CHARACTER', #?; ""COMPSYMQ"": 'CHARACTER', #?; ""TRAVECX "": 'CHARACTER', #?; ""TRAVECY "": 'CHARACTER', #?; ""TRAVECZ "": 'CHARACTER', #?; ""NVIBSYM "": 'CHARACTER', #?; ""NUMVIBRT"": 'CHARACTER', #?; ""SBGRPSYM"": 'CHARACTER', #?; ""ORDERREF"": 'CHARACTER', #?; ""OPERSREF"": ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/jajo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/jajo.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:918,Availability,checkpoint,checkpoint,918,"﻿. qcdb.libmintsbasisset — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.libmintsbasisset; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; import string; import hashlib; import itertools; from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .exceptions import *; from .psiutil import search_file; from .molecule import Molecule; from .periodictable import *; from .libmintsgshell import GaussianShell; from .libmintsbasissetparser import Gaussian94BasisSetParser; from .basislist import corresponding_basis; if sys.version_info >= (3,0):; basestring = str. [docs]class BasisSet(object):; """"""Basis set container class; Reads the basis set from a checkpoint file object. Also reads the molecule; from the checkpoint file storing the information in an internal Molecule class; which can be accessed using molecule(). """""". # <<< Globals >>>. # Has static information been initialized?; initialized_shared = False; # Global arrays of x, y, z exponents (Need libmint for max ang mom); LIBINT_MAX_AM = 6 # TODO; exp_ao = [[] for l in range(LIBINT_MAX_AM)]. def __init__(self, *args):. # <<< Basic BasisSet Information >>>. # The name of this basis set (e.g. ""BASIS"", ""RI BASIS""); self.name = None; # Array of gaussian shells; self.shells = None; # Molecule object.; self.molecule = None; # Shell information; self.atom_basis_shell = None. # <<< Scalars >>>. # Number of atomic orbitals (Cartesian); self.PYnao = None; # Number of basis functions (either cartesian or spherical); self.PYnbf = None; # The number of unique primitives; self.n_uprimitive = None; # The number of shells; self.n_shells = None; # The number of primitives; self.PYnprimitive = None; # The maximum angular momentum; self.PYmax_am = None; # The maximum number o",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:976,Availability,checkpoint,checkpoint,976,"ntsbasisset — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.libmintsbasisset; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; import string; import hashlib; import itertools; from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .exceptions import *; from .psiutil import search_file; from .molecule import Molecule; from .periodictable import *; from .libmintsgshell import GaussianShell; from .libmintsbasissetparser import Gaussian94BasisSetParser; from .basislist import corresponding_basis; if sys.version_info >= (3,0):; basestring = str. [docs]class BasisSet(object):; """"""Basis set container class; Reads the basis set from a checkpoint file object. Also reads the molecule; from the checkpoint file storing the information in an internal Molecule class; which can be accessed using molecule(). """""". # <<< Globals >>>. # Has static information been initialized?; initialized_shared = False; # Global arrays of x, y, z exponents (Need libmint for max ang mom); LIBINT_MAX_AM = 6 # TODO; exp_ao = [[] for l in range(LIBINT_MAX_AM)]. def __init__(self, *args):. # <<< Basic BasisSet Information >>>. # The name of this basis set (e.g. ""BASIS"", ""RI BASIS""); self.name = None; # Array of gaussian shells; self.shells = None; # Molecule object.; self.molecule = None; # Shell information; self.atom_basis_shell = None. # <<< Scalars >>>. # Number of atomic orbitals (Cartesian); self.PYnao = None; # Number of basis functions (either cartesian or spherical); self.PYnbf = None; # The number of unique primitives; self.n_uprimitive = None; # The number of shells; self.n_shells = None; # The number of primitives; self.PYnprimitive = None; # The maximum angular momentum; self.PYmax_am = None; # The maximum number of primitives ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:19365,Availability,error,error,19365,"that orbital hints can be; used to look up a suitable default basis in BasisFamily.; ``pyconstruct(smol, ""DF_BASIS_MP2"", basisspec_psi4_yo_ccpvdzri, 'RIFIT', basisspec_psi4_yo_631pg_d_p_)``; ``pyconstruct(mol, ""DF_BASIS_MP2"", """", ""RIFIT"", ""6-31+G(d,p)"")``. """"""; #print type(mol), type(key), type(target), type(fitrole), type(other); orbonly = True if (fitrole == 'BASIS' and other is None) else False; if orbonly:; orb = target; aux = None; else:; orb = other; aux = target. #print 'BasisSet::pyconstructP', 'key =', key, 'aux =', aux, 'fitrole =', fitrole, 'orb =', orb, 'orbonly =', orbonly #, mol. # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:3826,Deployability,configurat,configuration,3826,"; self.center_to_nshell = None; # What's the first shell on each center?; self.center_to_shell = None. # The flattened lists of unique exponents; self.uexponents = None; # The flattened lists of unique contraction coefficients (normalized); self.ucoefficients = None; # The flattened lists of unique contraction coefficients (as provided by the user); self.uoriginal_coefficients = None; # The flattened lists of ERD normalized contraction coefficients; self.uerd_coefficients = None; # The flattened list of Cartesian coordinates for each atom; self.xyz = None. # Divert to constructor functions; if len(args) == 0:; self.constructor_zero_ao_basis(); elif len(args) == 2 and \; isinstance(args[0], BasisSet) and \; isinstance(args[1], int):; self.constructor_basisset_center(*args); elif len(args) == 3 and \; isinstance(args[0], basestring) and \; isinstance(args[1], Molecule) and \; isinstance(args[2], OrderedDict):; self.constructor_role_mol_shellmap(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def initialize_singletons(self):; """"""Initialize singleton values that are shared by all basis set objects.""""""; # Populate the exp_ao arrays; for l in range(self.LIBINT_MAX_AM):; for i in range(l + 1):; x = l - i; for j in range(i + 1):; y = i - j; z = j; self.exp_ao[l].append([x, y, z]). [docs] def constructor_zero_ao_basis(self):; """"""Constructs a zero AO basis set"""""". if not self.initialized_shared:; self.initialize_singletons(); self.initialized_shared = True. # Add a dummy atom at the origin, to hold this basis function; self.molecule = Molecule(); self.molecule.add_atom(0, 0.0, 0.0, 0.0); # Fill with data representing a single S function, at the origin, with 0 exponent; self.n_uprimitive = 1; self.n_shells = 1; self.PYnprimitive = 1; self.PYnao = 1; self.PYnbf = 1; self.uerd_coefficients = [1.0]; self.n_prim_per_shell = [1]; self.uexponents = [0.0]; self.ucoefficient",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:15263,Deployability,update,update,15263,"efault constructor; return BasisSet(). [docs] def atomic_basis_set(self, center):; """"""Return a BasisSet object containing all shells at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # load in the basis sets; sets = []; name = """"; for at in range(len(keys)):; bas = BasisSet.pyconstruct(mol, keys[at], targets[at], fitroles[at], others[at]); name += targets[at] + "" + ""; sets.append(bas). name = name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:18960,Deployability,update,update,18960,", ""BASIS"", basisspec_psi4_yo_631pg_d_p_)``; ``pyconstruct(mol, ""BASIS"", ""6-31+G**"")``; When building an auxiliary basis, *key* is again the keyword,; *target* is the string or function for the fitting basis (this; may also be an empty string). In case the fitting basis isn't; fully specified, also provide a *fitrole* and the string/function; of the orbital basis as *other*, so that orbital hints can be; used to look up a suitable default basis in BasisFamily.; ``pyconstruct(smol, ""DF_BASIS_MP2"", basisspec_psi4_yo_ccpvdzri, 'RIFIT', basisspec_psi4_yo_631pg_d_p_)``; ``pyconstruct(mol, ""DF_BASIS_MP2"", """", ""RIFIT"", ""6-31+G(d,p)"")``. """"""; #print type(mol), type(key), type(target), type(fitrole), type(other); orbonly = True if (fitrole == 'BASIS' and other is None) else False; if orbonly:; orb = target; aux = None; else:; orb = other; aux = target. #print 'BasisSet::pyconstructP', 'key =', key, 'aux =', aux, 'fitrole =', fitrole, 'orb =', orb, 'orbonly =', orbonly #, mol. # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:41104,Deployability,update,updated,41104," basisname = basisname.replace(')', '_'). # Replace all ',' with '_'; basisname = basisname.replace(',', '_'). # Replace all '*' with 's'; basisname = basisname.replace('*', 's'). # Replace all '+' with 'p'; basisname = basisname.replace('+', 'p'). # Add file extension; basisname += '.gbs'. return basisname. # <<< Methods not Implemented >>>. [docs] def zero_so_basis_set(cls, factory):; """""" **NYI** Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. """"""; raise FeatureNotImplemented('BasisSet::zero_so_basis_set') # FINAL. @staticmethod; [docs] def test_basis_set(max_am):; """"""Returns a shell-labeled test basis set object; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.nao(); ao = 0; for ns in range(self.nshell()):; shell = self.shells[ns]; am = shell.am(); nprim = shell.nprimitive(); a = shell.exps(); c = shell.coefs(). xyz = shell.center(); dx = x - xyz[0]; dy = y - xyz[1]; dz = z - xyz[2]; rr = dx * dx + dy * dy + dz * dz. cexpr = 0; for np in range(nprim):; cexpr += c[np] * math.exp(-a[np] * rr). for l in range(INT_NCART(am)):; components = exp_ao[am][l]; phi_ao[ao + l] += pow(dx, components[0]) * \; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:43017,Deployability,update,updated,43017,"to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.nao(); ao = 0; for ns in range(self.nshell()):; shell = self.shells[ns]; am = shell.am(); nprim = shell.nprimitive(); a = shell.exps(); c = shell.coefs(). xyz = shell.center(); dx = x - xyz[0]; dy = y - xyz[1]; dz = z - xyz[2]; rr = dx * dx + dy * dy + dz * dz. cexpr = 0; for np in range(nprim):; cexpr += c[np] * math.exp(-a[np] * rr). for l in range(INT_NCART(am)):; components = exp_ao[am][l]; phi_ao[ao + l] += pow(dx, components[0]) * \; pow(dy, components[1]) * \; pow(dz, components[2]) * \; cexpr. ao += INT_NCART(am). [docs] def concatenate(self, b):; """"""Concatenates two basis sets together into a new basis without; reordering anything. Unless you know what you're doing, you should; use the '+' operator instead of this method. Appears defunct. """"""; raise FeatureNotImplemented('BasisSet::concatenate'). [docs] def add(self, b):; """"""Adds this plus another basis set and returns the result.; Equivalent to the '+' operator. Appears defunct. """"""; raise FeatureNotImplemented('BasisSet::add'). @staticmethod; [docs] def shell_sorter_ncenter(d1, d2):; return d1.ncenter() < d2.ncenter(). @staticmethod; [docs] def shell_sorter_am(d1, d2):; return d1.am() < d2.am(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:11392,Energy Efficiency,charge,charge,11392,"this point, but just in case; if not self.initialized_shared:; self.initialize_singletons(); self.initialized_shared = True. # First, find the shells we need, and grab the data; uexps = []; ucoefs = []; uoriginal_coefs = []; uerd_coefs = []; self.name = bs.name; self.n_shells = 0; self.n_uprimitive = 0; self.PYnao = 0; self.PYnbf = 0; for shelln in range(bs.nshell()):; shell = bs.shell(shelln); if shell.ncenter() == center:; nprim = shell.nprimitive(); for prim in range(nprim):; uexps.append(shell.exp(prim)); ucoefs.append(shell.coef(prim)); uoriginal_coefs.append(shell.original_coef(prim)); uerd_coefs.append(shell.erd_coef(prim)); self.n_uprimitive += 1; self.n_shells += 1; self.PYnao += shell.ncartesian(); self.PYnbf += shell.nfunction(); self.PYnprimitive = self.n_uprimitive. # Create a ""molecule"", i.e., an atom, with 1 fragment; mol = bs.molecule; self.molecule = Molecule(); self.molecule.add_atom(mol.Z(center), 0.0, 0.0, 0.0, \; mol.label(center), mol.mass(center), mol.charge(center)); self.molecule.fragments.append([0, 0]); self.molecule.fragment_types.append('Real'); self.molecule.fragment_charges.append(0); self.molecule.fragment_multiplicities.append(1); self.molecule.update_geometry(). # Allocate arrays; self.n_prim_per_shell = [0] * self.n_shells; # The unique primitives; self.uexponents = [0.0] * self.n_uprimitive; self.ucoefficients = [0.0] * self.n_uprimitive; self.uoriginal_coefficients = [0.0] * self.n_uprimitive; self.uerd_coefficients = [0.0] * self.n_uprimitive; for i in range(self.n_uprimitive):; self.uexponents[i] = uexps[i]; self.ucoefficients[i] = ucoefs[i]; self.uoriginal_coefficients[i] = uoriginal_coefs[i]; self.uerd_coefficients[i] = uerd_coefs[i]. self.shell_first_ao = [0] * self.n_shells; self.shell_first_basis_function = [0] * self.n_shells; self.shells = [None] * self.n_shells; self.ao_to_shell = [0] * self.PYnao; self.function_to_shell = [0] * self.PYnbf; self.function_center = [0] * self.PYnbf; self.shell_center = [0] * self.n_shells",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:2996,Integrability,contract,contraction,2996," number of primitives in a shell; self.PYmax_nprimitive = None; # Whether the basis set is uses spherical basis functions or not; self.puream = None. # <<< Arrays >>>. # The number of primitives (and exponents) in each shell; self.n_prim_per_shell = None; # The first (Cartesian) atomic orbital in each shell; self.shell_first_ao = None; # The first (Cartesian / spherical) basis function in each shell; self.shell_first_basis_function = None; # Shell number to atomic center.; self.shell_center = None; # Which shell does a given (Cartesian / spherical) function belong to?; self.function_to_shell = None; # Which shell does a given Cartesian function belong to?; self.ao_to_shell = None; # Which center is a given function on?; self.function_center = None; # How many shells are there on each center?; self.center_to_nshell = None; # What's the first shell on each center?; self.center_to_shell = None. # The flattened lists of unique exponents; self.uexponents = None; # The flattened lists of unique contraction coefficients (normalized); self.ucoefficients = None; # The flattened lists of unique contraction coefficients (as provided by the user); self.uoriginal_coefficients = None; # The flattened lists of ERD normalized contraction coefficients; self.uerd_coefficients = None; # The flattened list of Cartesian coordinates for each atom; self.xyz = None. # Divert to constructor functions; if len(args) == 0:; self.constructor_zero_ao_basis(); elif len(args) == 2 and \; isinstance(args[0], BasisSet) and \; isinstance(args[1], int):; self.constructor_basisset_center(*args); elif len(args) == 3 and \; isinstance(args[0], basestring) and \; isinstance(args[1], Molecule) and \; isinstance(args[2], OrderedDict):; self.constructor_role_mol_shellmap(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def initialize_singletons(self):; """"""Initialize singleton values that are shared b",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:3094,Integrability,contract,contraction,3094,"al basis functions or not; self.puream = None. # <<< Arrays >>>. # The number of primitives (and exponents) in each shell; self.n_prim_per_shell = None; # The first (Cartesian) atomic orbital in each shell; self.shell_first_ao = None; # The first (Cartesian / spherical) basis function in each shell; self.shell_first_basis_function = None; # Shell number to atomic center.; self.shell_center = None; # Which shell does a given (Cartesian / spherical) function belong to?; self.function_to_shell = None; # Which shell does a given Cartesian function belong to?; self.ao_to_shell = None; # Which center is a given function on?; self.function_center = None; # How many shells are there on each center?; self.center_to_nshell = None; # What's the first shell on each center?; self.center_to_shell = None. # The flattened lists of unique exponents; self.uexponents = None; # The flattened lists of unique contraction coefficients (normalized); self.ucoefficients = None; # The flattened lists of unique contraction coefficients (as provided by the user); self.uoriginal_coefficients = None; # The flattened lists of ERD normalized contraction coefficients; self.uerd_coefficients = None; # The flattened list of Cartesian coordinates for each atom; self.xyz = None. # Divert to constructor functions; if len(args) == 0:; self.constructor_zero_ao_basis(); elif len(args) == 2 and \; isinstance(args[0], BasisSet) and \; isinstance(args[1], int):; self.constructor_basisset_center(*args); elif len(args) == 3 and \; isinstance(args[0], basestring) and \; isinstance(args[1], Molecule) and \; isinstance(args[2], OrderedDict):; self.constructor_role_mol_shellmap(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def initialize_singletons(self):; """"""Initialize singleton values that are shared by all basis set objects.""""""; # Populate the exp_ao arrays; for l in range(self.LIBINT_MAX_AM):; for i i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:3222,Integrability,contract,contraction,3222," in each shell; self.n_prim_per_shell = None; # The first (Cartesian) atomic orbital in each shell; self.shell_first_ao = None; # The first (Cartesian / spherical) basis function in each shell; self.shell_first_basis_function = None; # Shell number to atomic center.; self.shell_center = None; # Which shell does a given (Cartesian / spherical) function belong to?; self.function_to_shell = None; # Which shell does a given Cartesian function belong to?; self.ao_to_shell = None; # Which center is a given function on?; self.function_center = None; # How many shells are there on each center?; self.center_to_nshell = None; # What's the first shell on each center?; self.center_to_shell = None. # The flattened lists of unique exponents; self.uexponents = None; # The flattened lists of unique contraction coefficients (normalized); self.ucoefficients = None; # The flattened lists of unique contraction coefficients (as provided by the user); self.uoriginal_coefficients = None; # The flattened lists of ERD normalized contraction coefficients; self.uerd_coefficients = None; # The flattened list of Cartesian coordinates for each atom; self.xyz = None. # Divert to constructor functions; if len(args) == 0:; self.constructor_zero_ao_basis(); elif len(args) == 2 and \; isinstance(args[0], BasisSet) and \; isinstance(args[1], int):; self.constructor_basisset_center(*args); elif len(args) == 3 and \; isinstance(args[0], basestring) and \; isinstance(args[1], Molecule) and \; isinstance(args[2], OrderedDict):; self.constructor_role_mol_shellmap(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def initialize_singletons(self):; """"""Initialize singleton values that are shared by all basis set objects.""""""; # Populate the exp_ao arrays; for l in range(self.LIBINT_MAX_AM):; for i in range(l + 1):; x = l - i; for j in range(i + 1):; y = i - j; z = j; self.exp_ao[l].append([x, y, z]). [d",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:14140,Integrability,contract,contraction,14140,"e; self.PYmax_am = max(self.PYmax_am, am); self.shell_center[shell_count] = center; self.puream = shell.is_pure(); tst = prim_count; tsp = prim_count + shell_nprim; self.shells[shell_count] = GaussianShell(am, shell_nprim,; self.uoriginal_coefficients[tst:tsp],; self.ucoefficients[tst:tsp],; self.uerd_coefficients[tst:tsp],; self.uexponents[tst:tsp],; 'Pure' if self.puream else 'Cartesian',; center, self.xyz, bf_count); self.shells[shell_count].pyprint(); for thisbf in range(shell.nfunction()):; self.function_to_shell[bf_count] = shell_count; self.function_center[bf_count] = center; bf_count += 1; for thisao in range(shell.ncartesian()):; self.ao_to_shell[ao_count] = shell_count; ao_count += 1; shell_count += 1; prim_count += shell_nprim. # <<< Methods for Construction by Another Name >>>. @staticmethod; [docs] def zero_ao_basis_set():; """"""Returns an empty basis set object.; Returns a BasisSet object that actually has a single s-function; at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty BasisSet object. """"""; # In the new implementation, we simply call the default constructor; return BasisSet(). [docs] def atomic_basis_set(self, center):; """"""Return a BasisSet object containing all shells at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitrol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:17231,Integrability,message,message,17231,"r label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_shell[label][name], key=lambda shell: she. # Molecule and parser prepped, call the constructor; mol.set_basis_all_atoms(name, ""CABS""). # Construct the grand BasisSet for mol; basisset = BasisSet(""CABS"", mol, combined_atom_basis_shell). # Construct all the one-atom BasisSet-s for mol's CoordEntry-s; for at in range(mol.natom()):; oneatombasis = BasisSet(basisset, at); oneatombasishash = hashlib.sha1(oneatombasis.print_detail(numbersonly=True).encode('utf-8')).hexdigest(); mol.set_shell_by_number(at, oneatombasishash, role=""CABS""); mol.update_geometry() # re-evaluate symmetry taking basissets into account. text = """""" => Creating Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitroles); text += """""" Keyword: %s\n"""""" % (keys); text += """""" Name: %s\n"""""" % (name). if returnBasisSet:; print(text); return basisset; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = basisset.name; bsdict['puream'] = int(basisset.has_puream()); bsdict['shell_map'] = basisset.export_for_libmints(""CABS""); return bsdict. @staticmethod; [docs] def pyconstruct(mol, key, target, fitrole='BASIS', other=None):; """"""Builds a BasisSet object for *mol* (either a qcdb.Molecule or; a string that can be instantiated into one) from basis set; specifications passed in as python functions or as a string that; names a basis to be applied to all atoms. Always required is the; keyword *key* and string/function *target* of the basis to be; constructed. For orbital basis sets, *key* will likely be 'BASIS'; and, together with *target*, these arguments suffice.; ``pyconstruct(smol, ""BASIS"", basisspec_psi4_yo_631pg_d_p_)``; ``pyconstruct(mol, ""BASIS"", ""6-31+G**"")``; When building an auxiliary basis, *key* is again the keyword,; *target* is the string or function for the fitting basis (this; may also be an empty string). In case the fitting",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:20780,Integrability,message,message,20780,"ole='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]). text = """""" => Loading Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitrole); text += """""" Keyword: %s\n"""""" % (key); text += """""" Name: %s\n"""""" % (target); text += msg. if returnBasisSet:; #print text; return bs; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = bs.name; bsdict['puream'] = int(bs.has_puream()); bsdict['shell_map'] = bs.export_for_libmints(fitrole); return bsdict. @classmethod; [docs] def construct(cls, parser, mol, role, deffit=None, basstrings=None):; """"""Returns a new BasisSet object configured from the *mol*; Molecule object for *role* (generally a Psi4 keyword: BASIS,; DF_BASIS_SCF, etc.). Fails utterly if a basis has not been set for; *role* for every atom in *mol*, unless *deffit* is set (JFIT,; JKFIT, or RIFIT), whereupon empty atoms are assigned to *role*; from the :py:class:`~BasisFamily`. This function is significantly; re-worked from its libmints analog. """"""; # Update geometry in molecule, if there is a problem an exception is thrown.; mol.update_geometry(). # Paths to search for gbs files: here + PSIPATH + library; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:27284,Integrability,contract,contractions,27284,"maxsats = 0; for item in sorted(tmp.values()):; for msg, ats in tmp.items():; if item == ats:; G = (list(x) for _, x in itertools.groupby(ats, lambda x, c=itertools.count(): next(c) - x)); sats = "", "".join(""-"".join(map(str, (g[0], g[-1])[:len(g)])) for g in G); maxsats = max(maxsats, len(sats)); tmp2[sats] = msg; #text = """""" ==> Loading Basis Set <==\n\n""""""; #text += """""" Role: %s\n"""""" % (role); #text += """""" Basis Set: %s\n"""""" % (basisset.name); text = ''; for ats, msg in tmp2.items():; text += """""" atoms %s %s\n"""""" % (ats.ljust(maxsats), msg). #print text; return basisset, text. # <<< Simple Methods for Basic BasisSet Information >>>. [docs] def name(self):; """"""Returns the name of this basis set""""""; return self.name. [docs] def set_name(self, name):; """"""Sets the name of this basis set""""""; self.name = name. # JET added but I think should fail; #+ def atom_shell_map(self):; #+ return self.atom_shell_map. [docs] def nprimitive(self):; """"""Number of primitives.; * @return The total number of primitives in all contractions. """"""; return self.PYnprimitive. [docs] def max_nprimitive(self):; """"""Maximum number of primitives in a shell.; * Examines each shell and find the shell with the maximum number of primitives returns that; * number of primitives.; * @return Maximum number of primitives. """"""; return self.PYmax_nprimitive. [docs] def nshell(self):; """"""Number of shells.; * @return Number of shells. """"""; return self.n_shells. [docs] def nao(self):; """"""Number of atomic orbitals (Cartesian).; * @return The number of atomic orbitals (Cartesian orbitals, always). """"""; return self.PYnao. [docs] def nbf(self):; """"""Number of basis functions (Spherical).; * @return The number of basis functions (Spherical, if has_puream() == true). """"""; return self.PYnbf. [docs] def max_am(self):; """"""Maximum angular momentum used in the basis set.; * @return Maximum angular momentum. """"""; return self.PYmax_am. [docs] def has_puream(self):; """"""Spherical harmonics?; * @return true if using spherical harm",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:31010,Integrability,contract,contraction,31010,"number; * @return A shared pointer to the GaussianShell object for the i'th shell. """"""; if center is not None:; si += self.center_to_shell[center]; if si < 0 or si > self.nshell():; text = """"""BasisSet::shell(si = %d), requested a shell out-of-bound.\n Max shell size: %d\n Name: %s\n"""""" % \; (si, self.nshell(), self.name()); raise ValidationError(""BasisSet::shell: requested shell is out-of-bounds:\n%s"" % (text)); return self.shells[si]. [docs] def nshell_on_center(self, i):; """"""Return the number of shells on a given center.""""""; return self.center_to_nshell[i]. [docs] def shell_on_center(self, center, shell):; """"""Return the overall shell number""""""; return self.center_to_shell[center] + shell. # <<< Methods for Printing >>>. [docs] def print_by_level(self, out=None, level=2):; """"""Print basis set information according to the level of detail in print_level; @param out The file stream to use for printing. Defaults to outfile.; @param print_level: defaults to 2; * < 1: Nothing ; * 1: Brief summary ; * 2: Summary and contraction details ; * > 2: Full details. """"""; if level < 1:; return; elif level == 1:; text = self.pyprint(out=None); elif level == 2:; text = self.print_summary(out=None); elif level > 2:; text = self.print_detail(out=None). if out is None:; print(text); else:; with open(out, mode='w') as handle:; handle.write(text). [docs] def pyprint(self, out=None):; """"""Print the basis set.; * @param out The file stream to use for printing. Defaults to outfile. """"""; text = ''; text += """""" Basis Set: %s\n"""""" % (self.name); text += """""" Number of shells: %d\n"""""" % (self.nshell()); text += """""" Number of basis function: %d\n"""""" % (self.nbf()); text += """""" Number of Cartesian functions: %d\n"""""" % (self.nao()); text += """""" Spherical Harmonics?: %s\n"""""" % ('true' if self.has_puream() else 'false'); text += """""" Max angular momentum: %d\n\n"""""" % (self.max_am()); #text += """""" Source:\n%s\n"""""" % (self.source()) # TODO. if out is None:; return text; else:; with open(outfile, mode='w')",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:37588,Integrability,contract,contracted,37588,"ni-mainz.de/cfour/index.php?n=Main.OldFormatOfAnEntryInTheGENBASFile. """"""; text = ''. for uA in range(self.molecule.nunique()):; A = self.molecule.unique(uA); text += """"""%s:P4_%d\n"""""" % (self.molecule.symbol(A), A + 1); text += """"""Psi4 basis %s for element %s atom %d\n\n"""""" % \; (self.name.upper(), self.molecule.symbol(A), A + 1). first_shell = self.center_to_shell[A]; n_shell = self.center_to_nshell[A]. max_am_center = 0; for Q in range(n_shell):; max_am_center = self.shells[Q + first_shell].am() if \; self.shells[Q + first_shell].am() > max_am_center else max_am_center. shell_per_am = [[] for i in range(max_am_center + 1)]; for Q in range(n_shell):; shell_per_am[self.shells[Q + first_shell].am()].append(Q). # Write number of shells in the basis set; text += """"""%3d\n"""""" % (max_am_center + 1). # Write angular momentum for each shell; for am in range(max_am_center + 1):; text += """"""%5d"""""" % (am); text += '\n'. # Write number of contracted basis functions for each shell; for am in range(max_am_center + 1):; text += """"""%5d"""""" % (len(shell_per_am[am])); text += '\n'. exp_per_am = [[] for i in range(max_am_center + 1)]; coef_per_am = [[] for i in range(max_am_center + 1)]; for am in range(max_am_center + 1):; # Collect unique exponents among all functions; for Q in range(len(shell_per_am[am])):; for K in range(self.shells[shell_per_am[am][Q] + first_shell].nprimitive()):; if self.shells[shell_per_am[am][Q] + first_shell].exp(K) not in exp_per_am[am]:; exp_per_am[am].append(self.shells[shell_per_am[am][Q] + first_shell].exp(K)). # Collect coefficients for each exp among all functions, zero otherwise; for Q in range(len(shell_per_am[am])):; K = 0; for ep in range(len(exp_per_am[am])):; if abs(exp_per_am[am][ep] - self.shells[shell_per_am[am][Q] + first_shell].exp(K)) < 1.0e-8:; coef_per_am[am].append(self.shells[shell_per_am[am][Q] + first_shell].original_coef(K)); if (K + 1) != self.shells[shell_per_am[am][Q] + first_shell].nprimitive():; K += 1; else:; coef_per_am[am].app",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:39051,Integrability,contract,contraction,39051,"]:; exp_per_am[am].append(self.shells[shell_per_am[am][Q] + first_shell].exp(K)). # Collect coefficients for each exp among all functions, zero otherwise; for Q in range(len(shell_per_am[am])):; K = 0; for ep in range(len(exp_per_am[am])):; if abs(exp_per_am[am][ep] - self.shells[shell_per_am[am][Q] + first_shell].exp(K)) < 1.0e-8:; coef_per_am[am].append(self.shells[shell_per_am[am][Q] + first_shell].original_coef(K)); if (K + 1) != self.shells[shell_per_am[am][Q] + first_shell].nprimitive():; K += 1; else:; coef_per_am[am].append(0.0). # Write number of exponents for each shell; for am in range(max_am_center + 1):; text += """"""%5d"""""" % (len(exp_per_am[am])); text += '\n\n'. for am in range(max_am_center + 1):; # Write exponents for each shell; for ep in range(len(exp_per_am[am])):; text += """"""%14.7f"""""" % (exp_per_am[am][ep]); if ((ep + 1) % 5 == 0) or ((ep + 1) == len(exp_per_am[am])):; text += '\n'; text += '\n'. # Write contraction coefficients for each shell; for ep in range(len(exp_per_am[am])):; for bf in range(len(shell_per_am[am])):; text += """"""%10.7f """""" % (coef_per_am[am][bf * len(exp_per_am[am]) + ep]); text += '\n'; text += '\n'. if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). # <<< Misc. Methods >>>. [docs] def refresh(self):; """"""Refresh internal basis set data. Useful if someone has pushed; to shells. Pushing to shells happens in the BasisSetParsers, so; the parsers will call refresh(). This function is now defunct. """"""; raise FeatureNotImplemented('BasisSet::refresh'). @staticmethod; [docs] def make_filename(name):; """"""Converts basis set name to a compatible filename.; * @param basisname Basis name; * @return Compatible file name. """"""; # Modify the name of the basis set to generate a filename: STO-3G -> sto-3g; basisname = name. # First make it lower case; basisname = basisname.lower(). # Replace all '(' with '_'; basisname = basisname.replace('(', '_'). # Replace all ')' with '_'; basisname = basisname.rep",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:40641,Integrability,contract,contraction,40641,"('BasisSet::refresh'). @staticmethod; [docs] def make_filename(name):; """"""Converts basis set name to a compatible filename.; * @param basisname Basis name; * @return Compatible file name. """"""; # Modify the name of the basis set to generate a filename: STO-3G -> sto-3g; basisname = name. # First make it lower case; basisname = basisname.lower(). # Replace all '(' with '_'; basisname = basisname.replace('(', '_'). # Replace all ')' with '_'; basisname = basisname.replace(')', '_'). # Replace all ',' with '_'; basisname = basisname.replace(',', '_'). # Replace all '*' with 's'; basisname = basisname.replace('*', 's'). # Replace all '+' with 'p'; basisname = basisname.replace('+', 'p'). # Add file extension; basisname += '.gbs'. return basisname. # <<< Methods not Implemented >>>. [docs] def zero_so_basis_set(cls, factory):; """""" **NYI** Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. """"""; raise FeatureNotImplemented('BasisSet::zero_so_basis_set') # FINAL. @staticmethod; [docs] def test_basis_set(max_am):; """"""Returns a shell-labeled test basis set object; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.n",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:3826,Modifiability,config,configuration,3826,"; self.center_to_nshell = None; # What's the first shell on each center?; self.center_to_shell = None. # The flattened lists of unique exponents; self.uexponents = None; # The flattened lists of unique contraction coefficients (normalized); self.ucoefficients = None; # The flattened lists of unique contraction coefficients (as provided by the user); self.uoriginal_coefficients = None; # The flattened lists of ERD normalized contraction coefficients; self.uerd_coefficients = None; # The flattened list of Cartesian coordinates for each atom; self.xyz = None. # Divert to constructor functions; if len(args) == 0:; self.constructor_zero_ao_basis(); elif len(args) == 2 and \; isinstance(args[0], BasisSet) and \; isinstance(args[1], int):; self.constructor_basisset_center(*args); elif len(args) == 3 and \; isinstance(args[0], basestring) and \; isinstance(args[1], Molecule) and \; isinstance(args[2], OrderedDict):; self.constructor_role_mol_shellmap(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def initialize_singletons(self):; """"""Initialize singleton values that are shared by all basis set objects.""""""; # Populate the exp_ao arrays; for l in range(self.LIBINT_MAX_AM):; for i in range(l + 1):; x = l - i; for j in range(i + 1):; y = i - j; z = j; self.exp_ao[l].append([x, y, z]). [docs] def constructor_zero_ao_basis(self):; """"""Constructs a zero AO basis set"""""". if not self.initialized_shared:; self.initialize_singletons(); self.initialized_shared = True. # Add a dummy atom at the origin, to hold this basis function; self.molecule = Molecule(); self.molecule.add_atom(0, 0.0, 0.0, 0.0); # Fill with data representing a single S function, at the origin, with 0 exponent; self.n_uprimitive = 1; self.n_shells = 1; self.PYnprimitive = 1; self.PYnao = 1; self.PYnbf = 1; self.uerd_coefficients = [1.0]; self.n_prim_per_shell = [1]; self.uexponents = [0.0]; self.ucoefficient",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:16194,Modifiability,extend,extend,16194,", and fitroles must be equal""""""). # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # load in the basis sets; sets = []; name = """"; for at in range(len(keys)):; bas = BasisSet.pyconstruct(mol, keys[at], targets[at], fitroles[at], others[at]); name += targets[at] + "" + ""; sets.append(bas). name = name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_shell[label][name], key=lambda shell: she. # Molecule and parser prepped, call the constructor; mol.set_basis_all_atoms(name, ""CABS""). # Construct the grand BasisSet for mol; basisset = BasisSet(""CABS"", mol, combined_atom_basis_shell). # Construct all the one-atom BasisSet-s for mol's CoordEntry-s; for at in range(mol.natom()):; oneatombasis = BasisSet(basisset, at); oneatombasishash = hashlib.sha1(oneatombasis.print_detail(numbersonly=True).encode('utf-8')).hexdigest(); mol.set_shell_by_number(at, oneatombasishash, role=""CABS""); mol.update_geometry() # re-evaluate symmetry taking basissets into account. text = """""" => Creating Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitroles); text += """""" Keyword: %s\n"""""" % (keys); text += """""" Name: %s\n"""""" % (name). if returnBasisSet:; print(text); return basisset;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:21059,Modifiability,config,configured,21059,"tance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]). text = """""" => Loading Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitrole); text += """""" Keyword: %s\n"""""" % (key); text += """""" Name: %s\n"""""" % (target); text += msg. if returnBasisSet:; #print text; return bs; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = bs.name; bsdict['puream'] = int(bs.has_puream()); bsdict['shell_map'] = bs.export_for_libmints(fitrole); return bsdict. @classmethod; [docs] def construct(cls, parser, mol, role, deffit=None, basstrings=None):; """"""Returns a new BasisSet object configured from the *mol*; Molecule object for *role* (generally a Psi4 keyword: BASIS,; DF_BASIS_SCF, etc.). Fails utterly if a basis has not been set for; *role* for every atom in *mol*, unless *deffit* is set (JFIT,; JKFIT, or RIFIT), whereupon empty atoms are assigned to *role*; from the :py:class:`~BasisFamily`. This function is significantly; re-worked from its libmints analog. """"""; # Update geometry in molecule, if there is a problem an exception is thrown.; mol.update_geometry(). # Paths to search for gbs files: here + PSIPATH + library; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/basis'; basisPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath. # Validate deffit for role; univdef = {'JFIT': 'def2-qzvpp-jfit',; 'JKFIT': 'def2-qzvpp-jkfit',; 'RIFIT': 'def2-",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:15530,Performance,load,load,15530,"enter. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # load in the basis sets; sets = []; name = """"; for at in range(len(keys)):; bas = BasisSet.pyconstruct(mol, keys[at], targets[at], fitroles[at], others[at]); name += targets[at] + "" + ""; sets.append(bas). name = name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_shell[label][name], key=lambda shell: she. # Molecule and parser prepped, call the constructor; mol.set_basis_all_atoms(name, ""CABS""). # Construct the grand BasisSet for mol; basisset = BasisS",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:342,Security,hash,hashlib,342,"﻿. qcdb.libmintsbasisset — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.libmintsbasisset; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; import string; import hashlib; import itertools; from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .exceptions import *; from .psiutil import search_file; from .molecule import Molecule; from .periodictable import *; from .libmintsgshell import GaussianShell; from .libmintsbasissetparser import Gaussian94BasisSetParser; from .basislist import corresponding_basis; if sys.version_info >= (3,0):; basestring = str. [docs]class BasisSet(object):; """"""Basis set container class; Reads the basis set from a checkpoint file object. Also reads the molecule; from the checkpoint file storing the information in an internal Molecule class; which can be accessed using molecule(). """""". # <<< Globals >>>. # Has static information been initialized?; initialized_shared = False; # Global arrays of x, y, z exponents (Need libmint for max ang mom); LIBINT_MAX_AM = 6 # TODO; exp_ao = [[] for l in range(LIBINT_MAX_AM)]. def __init__(self, *args):. # <<< Basic BasisSet Information >>>. # The name of this basis set (e.g. ""BASIS"", ""RI BASIS""); self.name = None; # Array of gaussian shells; self.shells = None; # Molecule object.; self.molecule = None; # Shell information; self.atom_basis_shell = None. # <<< Scalars >>>. # Number of atomic orbitals (Cartesian); self.PYnao = None; # Number of basis functions (either cartesian or spherical); self.PYnbf = None; # The number of unique primitives; self.n_uprimitive = None; # The number of shells; self.n_shells = None; # The number of primitives; self.PYnprimitive = None; # The maximum angular momentum; self.PYmax_am = None; # The maximum number o",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:1060,Security,access,accessed,1060,"ntsbasisset — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.libmintsbasisset; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; import string; import hashlib; import itertools; from collections import defaultdict; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .exceptions import *; from .psiutil import search_file; from .molecule import Molecule; from .periodictable import *; from .libmintsgshell import GaussianShell; from .libmintsbasissetparser import Gaussian94BasisSetParser; from .basislist import corresponding_basis; if sys.version_info >= (3,0):; basestring = str. [docs]class BasisSet(object):; """"""Basis set container class; Reads the basis set from a checkpoint file object. Also reads the molecule; from the checkpoint file storing the information in an internal Molecule class; which can be accessed using molecule(). """""". # <<< Globals >>>. # Has static information been initialized?; initialized_shared = False; # Global arrays of x, y, z exponents (Need libmint for max ang mom); LIBINT_MAX_AM = 6 # TODO; exp_ao = [[] for l in range(LIBINT_MAX_AM)]. def __init__(self, *args):. # <<< Basic BasisSet Information >>>. # The name of this basis set (e.g. ""BASIS"", ""RI BASIS""); self.name = None; # Array of gaussian shells; self.shells = None; # Molecule object.; self.molecule = None; # Shell information; self.atom_basis_shell = None. # <<< Scalars >>>. # Number of atomic orbitals (Cartesian); self.PYnao = None; # Number of basis functions (either cartesian or spherical); self.PYnbf = None; # The number of unique primitives; self.n_uprimitive = None; # The number of shells; self.n_shells = None; # The number of primitives; self.PYnprimitive = None; # The maximum angular momentum; self.PYmax_am = None; # The maximum number of primitives ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:16771,Security,hash,hashlib,16771," name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_shell[label][name], key=lambda shell: she. # Molecule and parser prepped, call the constructor; mol.set_basis_all_atoms(name, ""CABS""). # Construct the grand BasisSet for mol; basisset = BasisSet(""CABS"", mol, combined_atom_basis_shell). # Construct all the one-atom BasisSet-s for mol's CoordEntry-s; for at in range(mol.natom()):; oneatombasis = BasisSet(basisset, at); oneatombasishash = hashlib.sha1(oneatombasis.print_detail(numbersonly=True).encode('utf-8')).hexdigest(); mol.set_shell_by_number(at, oneatombasishash, role=""CABS""); mol.update_geometry() # re-evaluate symmetry taking basissets into account. text = """""" => Creating Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitroles); text += """""" Keyword: %s\n"""""" % (keys); text += """""" Name: %s\n"""""" % (name). if returnBasisSet:; print(text); return basisset; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = basisset.name; bsdict['puream'] = int(basisset.has_puream()); bsdict['shell_map'] = basisset.export_for_libmints(""CABS""); return bsdict. @staticmethod; [docs] def pyconstruct(mol, key, target, fitrole='BASIS', other=None):; """"""Builds a BasisSet object for *mol* (either a qcdb.Molecule or; a string that can be instantiated into one) from basis set; specifications passed in as python functions or as a string that; names a basis to be applied to all atoms. Always required i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:25869,Security,hash,hashlib,25869,"seek['entry']:. # Seek entry in lines, else skip to next entry; shells, msg = parser.parse(entry, lines); if shells is None:; continue. # Found!; atom_basis_shell[label][bas] = shells; mol.set_basis_by_number(at, bas, role=role); summary.append(""""""entry %-10s %s %s"""""" % (entry, msg, index)); break. # Break from outer loop if inner loop breaks; else:; continue; break. else:; # Ne'er found :-(; text2 = """""" Shell Entries: %s\n"""""" % (seek['entry']); text2 += """""" Basis Sets: %s\n"""""" % (seek['basis']); text2 += """""" File Path: %s\n"""""" % (', '.join(map(str, seek['path'].split(':')))); text2 += """""" Input Blocks: %s\n"""""" % (', '.join(seek['strings'])); raise BasisSetNotFound('BasisSet::construct: Unable to find a basis set for atom %d for role %s among:\n%s' % \; (at + 1, role, text2)). # Construct the grand BasisSet for mol; basisset = BasisSet(role, mol, atom_basis_shell). # Construct all the one-atom BasisSet-s for mol's CoordEntry-s; for at in range(mol.natom()):; oneatombasis = BasisSet(basisset, at); oneatombasishash = hashlib.sha1(oneatombasis.print_detail(numbersonly=True).encode('utf-8')).hexdigest(); mol.set_shell_by_number(at, oneatombasishash, role=role); mol.update_geometry() # re-evaluate symmetry taking basissets into account. #TODO fix name; basisset.name = ' + '.join(names). # Summary printing; tmp = defaultdict(list); for at, v in enumerate(summary):; tmp[v].append(at + 1); tmp2 = OrderedDict(); maxsats = 0; for item in sorted(tmp.values()):; for msg, ats in tmp.items():; if item == ats:; G = (list(x) for _, x in itertools.groupby(ats, lambda x, c=itertools.count(): next(c) - x)); sats = "", "".join(""-"".join(map(str, (g[0], g[-1])[:len(g)])) for g in G); maxsats = max(maxsats, len(sats)); tmp2[sats] = msg; #text = """""" ==> Loading Basis Set <==\n\n""""""; #text += """""" Role: %s\n"""""" % (role); #text += """""" Basis Set: %s\n"""""" % (basisset.name); text = ''; for ats, msg in tmp2.items():; text += """""" atoms %s %s\n"""""" % (ats.ljust(maxsats), msg). #print text; return basis",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:34855,Security,hash,hash,34855,"mbersonly=False):; """"""Prints a detailed PSI3-style summary of the basis (per-atom); * @param out The file stream to use for printing. Defaults to outfile. """"""; text = ''; if not numbersonly:; text += self.print_summary(out=None); text += """""" ==> AO Basis Functions <==\n""""""; text += '\n'; text += """""" [ %s ]\n"""""" % (self.name); text += """""" spherical\n"""""" if self.has_puream() else """""" cartesian\n""""""; text += """""" ****\n"""""". for uA in range(self.molecule.nunique()):; A = self.molecule.unique(uA); if not numbersonly:; text += """""" %2s %3d\n"""""" % (self.molecule.symbol(A), A + 1); first_shell = self.center_to_shell[A]; n_shell = self.center_to_nshell[A]. for Q in range(n_shell):; text += self.shells[Q + first_shell].pyprint(outfile=None); text += """""" ****\n""""""; text += """"""\n"""""". if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). [docs] def export_for_libmints(self, role):; """"""From complete BasisSet object, returns array where; triplets of elements are each unique atom label, the hash; of the string shells entry in gbs format and the; shells entry in gbs format for that label. This packaging is; intended for return to libmints BasisSet::pyconstruct for; instantiation of a libmints BasisSet clone of *self*. """"""; basstrings = []; tally = []; for A in range(self.molecule.natom()):; if self.molecule.label(A) not in tally:; label = self.molecule.label(A); first_shell = self.center_to_shell[A]; n_shell = self.center_to_nshell[A]. basstrings.append(label); basstrings.append(self.molecule.atoms[A].shell(key=role)); text = """""" %s 0\n"""""" % (label); for Q in range(n_shell):; text += self.shells[Q + first_shell].pyprint(outfile=None); text += """""" ****\n""""""; basstrings.append(text). return basstrings. [docs] def print_detail_gamess(self, out=None, numbersonly=False):; """"""Prints a detailed PSI3-style summary of the basis (per-atom); * @param out The file stream to use for printing. Defaults to outfile. """"""; text = ''; if not numbersonly:; text += ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:40851,Testability,test,test,40851,"sto-3g; basisname = name. # First make it lower case; basisname = basisname.lower(). # Replace all '(' with '_'; basisname = basisname.replace('(', '_'). # Replace all ')' with '_'; basisname = basisname.replace(')', '_'). # Replace all ',' with '_'; basisname = basisname.replace(',', '_'). # Replace all '*' with 's'; basisname = basisname.replace('*', 's'). # Replace all '+' with 'p'; basisname = basisname.replace('+', 'p'). # Add file extension; basisname += '.gbs'. return basisname. # <<< Methods not Implemented >>>. [docs] def zero_so_basis_set(cls, factory):; """""" **NYI** Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. """"""; raise FeatureNotImplemented('BasisSet::zero_so_basis_set') # FINAL. @staticmethod; [docs] def test_basis_set(max_am):; """"""Returns a shell-labeled test basis set object; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.nao(); ao = 0; for ns in range(self.nshell()):; shell = self.shells[ns]; am = shell.am(); nprim = shell.nprimitive(); a = shell.exps(); c = shell.coefs(). xyz = shell.center(); dx = x - xyz[0]; dy = y - xyz[1]; dz = z - xyz[2]; rr = dx * dx + dy * dy + dz * dz. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:40983,Testability,test,test,40983,"sto-3g; basisname = name. # First make it lower case; basisname = basisname.lower(). # Replace all '(' with '_'; basisname = basisname.replace('(', '_'). # Replace all ')' with '_'; basisname = basisname.replace(')', '_'). # Replace all ',' with '_'; basisname = basisname.replace(',', '_'). # Replace all '*' with 's'; basisname = basisname.replace('*', 's'). # Replace all '+' with 'p'; basisname = basisname.replace('+', 'p'). # Add file extension; basisname += '.gbs'. return basisname. # <<< Methods not Implemented >>>. [docs] def zero_so_basis_set(cls, factory):; """""" **NYI** Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. """"""; raise FeatureNotImplemented('BasisSet::zero_so_basis_set') # FINAL. @staticmethod; [docs] def test_basis_set(max_am):; """"""Returns a shell-labeled test basis set object; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.nao(); ao = 0; for ns in range(self.nshell()):; shell = self.shells[ns]; am = shell.am(); nprim = shell.nprimitive(); a = shell.exps(); c = shell.coefs(). xyz = shell.center(); dx = x - xyz[0]; dy = y - xyz[1]; dz = z - xyz[2]; rr = dx * dx + dy * dy + dz * dz. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:41005,Testability,benchmark,benchmarking,41005,"sto-3g; basisname = name. # First make it lower case; basisname = basisname.lower(). # Replace all '(' with '_'; basisname = basisname.replace('(', '_'). # Replace all ')' with '_'; basisname = basisname.replace(')', '_'). # Replace all ',' with '_'; basisname = basisname.replace(',', '_'). # Replace all '*' with 's'; basisname = basisname.replace('*', 's'). # Replace all '+' with 'p'; basisname = basisname.replace('+', 'p'). # Add file extension; basisname += '.gbs'. return basisname. # <<< Methods not Implemented >>>. [docs] def zero_so_basis_set(cls, factory):; """""" **NYI** Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. """"""; raise FeatureNotImplemented('BasisSet::zero_so_basis_set') # FINAL. @staticmethod; [docs] def test_basis_set(max_am):; """"""Returns a shell-labeled test basis set object; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.nao(); ao = 0; for ns in range(self.nshell()):; shell = self.shells[ns]; am = shell.am(); nprim = shell.nprimitive(); a = shell.exps(); c = shell.coefs(). xyz = shell.center(); dx = x - xyz[0]; dy = y - xyz[1]; dz = z - xyz[2]; rr = dx * dx + dy * dy + dz * dz. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:41034,Testability,benchmark,benchmark,41034,"sto-3g; basisname = name. # First make it lower case; basisname = basisname.lower(). # Replace all '(' with '_'; basisname = basisname.replace('(', '_'). # Replace all ')' with '_'; basisname = basisname.replace(')', '_'). # Replace all ',' with '_'; basisname = basisname.replace(',', '_'). # Replace all '*' with 's'; basisname = basisname.replace('*', 's'). # Replace all '+' with 'p'; basisname = basisname.replace('+', 'p'). # Add file extension; basisname += '.gbs'. return basisname. # <<< Methods not Implemented >>>. [docs] def zero_so_basis_set(cls, factory):; """""" **NYI** Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. """"""; raise FeatureNotImplemented('BasisSet::zero_so_basis_set') # FINAL. @staticmethod; [docs] def test_basis_set(max_am):; """"""Returns a shell-labeled test basis set object; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. """"""; raise FeatureNotImplemented('BasisSet::test_basis_set'). [docs] def get_ao_sorted_shell(self, i):; """"""Returns the value of the sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_shell'). [docs] def get_ao_sorted_list(self):; """"""Returns the vector of sorted shell list. Defunct""""""; raise FeatureNotImplemented('BasisSet::get_ao_sorted_list'). [docs] def compute_phi(self, phi_ao, x, y, z):; """"""Returns the values of the basis functions at a point"""""". phi_ao = [0.0] * self.nao(); ao = 0; for ns in range(self.nshell()):; shell = self.shells[ns]; am = shell.am(); nprim = shell.nprimitive(); a = shell.exps(); c = shell.coefs(). xyz = shell.center(); dx = x - xyz[0]; dy = y - xyz[1]; dz = z - xyz[2]; rr = dx * dx + dy * dy + dz * dz. ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:14237,Usability,simpl,simply,14237,"ell.is_pure(); tst = prim_count; tsp = prim_count + shell_nprim; self.shells[shell_count] = GaussianShell(am, shell_nprim,; self.uoriginal_coefficients[tst:tsp],; self.ucoefficients[tst:tsp],; self.uerd_coefficients[tst:tsp],; self.uexponents[tst:tsp],; 'Pure' if self.puream else 'Cartesian',; center, self.xyz, bf_count); self.shells[shell_count].pyprint(); for thisbf in range(shell.nfunction()):; self.function_to_shell[bf_count] = shell_count; self.function_center[bf_count] = center; bf_count += 1; for thisao in range(shell.ncartesian()):; self.ao_to_shell[ao_count] = shell_count; ao_count += 1; shell_count += 1; prim_count += shell_nprim. # <<< Methods for Construction by Another Name >>>. @staticmethod; [docs] def zero_ao_basis_set():; """"""Returns an empty basis set object.; Returns a BasisSet object that actually has a single s-function; at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty BasisSet object. """"""; # In the new implementation, we simply call the default constructor; return BasisSet(). [docs] def atomic_basis_set(self, center):; """"""Return a BasisSet object containing all shells at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:19482,Usability,clear,clear,19482,"ct(mol, ""DF_BASIS_MP2"", """", ""RIFIT"", ""6-31+G(d,p)"")``. """"""; #print type(mol), type(key), type(target), type(fitrole), type(other); orbonly = True if (fitrole == 'BASIS' and other is None) else False; if orbonly:; orb = target; aux = None; else:; orb = other; aux = target. #print 'BasisSet::pyconstructP', 'key =', key, 'aux =', aux, 'fitrole =', fitrole, 'orb =', orb, 'orbonly =', orbonly #, mol. # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:8657,Deployability,update,updated,8657,"ian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:3401,Integrability,contract,contraction,3401,"rue. return lines. [docs] def parse(self, symbol, dataset):; """"""Given a string, parse for the basis set needed for atom.; * @param symbol atom symbol to look for in dataset; * @param dataset data set to look through; dataset can be list of lines or a single string which will be converted to list of lines. """"""; if isinstance(dataset, basestring):; lines = dataset.split('\n'); else:; lines = dataset. # Regular expressions that we'll be checking for.; cartesian = re.compile(r'^\s*cartesian\s*', re.IGNORECASE); spherical = re.compile(r'^\s*spherical\s*', re.IGNORECASE); comment = re.compile(r'^\s*\!.*') # line starts with !; separator = re.compile(r'^\s*\*\*\*\*') # line starts with ****; ATOM = '(([A-Z]{1,3}\d*)|([A-Z]{1,3}_\w+))' # match 'C 0', 'Al c 0', 'P p88 p_pass 0' not 'Ofail 0', 'h99_text 0'; atom_array = re.compile(r'^\s*((' + ATOM + '\s+)+)0\s*$', re.IGNORECASE) # array of atomic symbols terminated by 0; shell = re.compile(r'^\s*(\w+)\s*(\d+)\s*(-?\d+\.\d+)') # Match beginning of contraction; blank = re.compile(r'^\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; primitives1 = re.compile(r'^\s*' + NUMBER + '\s+' + NUMBER + '.*') # Match s, p, d, f, g, ... functions; primitives2 = re.compile(r'^\s*' + NUMBER + '\s+' + NUMBER + '\s+' + NUMBER + '.*') # match sp functions. # s, p and s, p, d can be grouped together in Pople-style basis sets; sp = 'SP'; spd = 'SPD'. # a b c d e f g h i j k l m n o p q r s t u v w x y z; #shell_to_am = [-1,-1,-1, 2,-1, 3, 4, 5, 6,-1, 7, 8, 9,10,11, 1,12,13, 0,14,15,16,17,18,19,20]; alpha = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',; 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']; angmo = [-1, -1, -1, 2, -1, 3, 4, 5, 6, -1, 7, 8,; 9, 10, 11, 1, 12, 13, 0, 14, 15, 16, 17, 18, 19, 20]; shell_to_am = dict(zip(alpha, angmo)). # Basis type.; gaussian_type = 'Pure'. if self.force_puream_or_cartesian:; if self.forced_is_puream == False:; gaussia",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6009,Integrability,contract,contractions,6009,"on('PUREAM').has_changed():; #TODO gaussian_type = 'Pure' if int(psi4.get_global('PUREAM')) else 'Cartesian'; continue; #end case where puream setting wasn't forced by caller. # Do some matches; if comment.match(line):; continue; if separator.match(line):; continue. # Match: H 0; # or: H O... 0; if atom_array.match(line):; what = atom_array.match(line).group(1).split(); # Check the captures and see if this basis set is for the atom we need.; found = False; if symbol in [x.upper() for x in what]:; found = True; msg = """"""line %5d"""""" % (lineno). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6374,Integrability,contract,contraction,6374,".match(line):; what = atom_array.match(line).group(1).split(); # Check the captures and see if this basis set is for the atom we need.; found = False; if symbol in [x.upper() for x in what]:; found = True; msg = """"""line %5d"""""" % (lineno). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent wit",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6454,Integrability,contract,contraction,6454,"= False; if symbol in [x.upper() for x in what]:; found = True; msg = """"""line %5d"""""" % (lineno). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contracti",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6502,Integrability,contract,contraction,6502,"no). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6540,Integrability,contract,contraction,6540,"no). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6587,Integrability,contract,contractions,6587,"no). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6605,Integrability,contract,contraction,6605,"no). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6700,Integrability,contract,contractions,6700,"atch(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = co",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7325,Integrability,contract,contractions,7325,"ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetN",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7404,Integrability,contract,contraction,7404,", line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7452,Integrability,contract,contraction,7452,"ontraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a modul",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7490,Integrability,contract,contraction,7490,"ontraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a modul",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7556,Integrability,contract,contraction,7556,"ontraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a modul",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7584,Integrability,contract,contraction,7584,"ions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7597,Integrability,contract,contraction,7597,"ions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b]",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7645,Integrability,contract,contraction,7645,"d(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7683,Integrability,contract,contraction,7683,"d(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7724,Integrability,contract,contraction,7724,"d(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetNotFound(""Gaussian94BasisSetParser::parser: Unable to find the basis set for %s in %s"" % \; # (symbol, self.filename), silent=True); return None, None. return shell_list, msg. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:788,Performance,load,loading,788,"﻿. qcdb.libmintsbasissetparser — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.libmintsbasissetparser; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; from .exceptions import *; from .libmintsgshell import *; if sys.version_info >= (3,0):; basestring = str. [docs]class Gaussian94BasisSetParser(object):; """"""Class for parsing basis sets from a text file in Gaussian 94; format. Translated directly from the Psi4 libmints class written; by Justin M. Turney and Andrew C. Simmonett. """""". def __init__(self, forced_puream=None):; """"""Constructor""""""; # If the parser needs to force spherical or cartesian (e.g., loading old guess); self.force_puream_or_cartesian = False if forced_puream is None else True; # Is the forced value to use puream? (Otherwise force Cartesian).; self.forced_is_puream = False if forced_puream is None else forced_puream; # string filename; self.filename = None. [docs] def load_file(self, filename, basisname=None):; """"""Load and return the file to be used by parse. Return only; portion of *filename* pertaining to *basisname* if specified (for; multi-basisset files) otherwise entire file as list of strings. """"""; # string filename; self.filename = filename. given_basisname = False if basisname is None else True; found_basisname = False; basis_separator = re.compile(r'^\s*\[\s*(.*?)\s*\]\s*$'). # Loads an entire file.; try:; infile = open(filename, 'r'); except IOError:; raise BasisSetFileNotFound(""""""BasisSetParser::parse: Unable to open basis set file: %s"""""" % (filename)); if os.stat(filename).st_size == 0:; raise ValidationError(""""""BasisSetParser::parse: given filename '%s' is blank."""""" % (filename)); contents = infile.readlines(). lines = []; for text in contents:; text = text.strip(); # If no basisname was given always save the line.; if given_basisname is False:; lines.append(te",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:7840,Availability,down,down,7840,"'ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Also compares basis set assignment down to nbf(), has_puream() level; with code borrowed from Robert M. Parrish's SAD guess in Psi4. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; if other.PYshells is not None and self.PYshells is not None:; for bas in self.PYshells: # do we instead care only about orbital basis?; if bas in other.PYshells:; if other.PYshells[bas] != self.PYshells[bas]:; return False; #if other.PYshells[bas].nbf() != self.PYshells[bas].nbf():; # return False; #if other.PYshells[bas].nshell() != self.PYshells[bas].nshell():; # return False; #if other.PYshells[bas].nprimitive() != self.PYshells[bas].nprimitive():; # return False; #if other.PYshells[bas].max_am() != self.PYshells[bas].max_am():; # return False; #if other.PYshells[bas].max_nprimitive() != self.PYshells[bas].max_nprimitive():; # return False; #if other.PYshells[bas].has_puream() != self.PYshells[bas].has_puream():; # return False; else:; raise ValidationError(""""""Ba",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:12284,Deployability,update,updates,12284,"; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def print_in_input_format_cfour(self):; """"""Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:12672,Deployability,update,updated,12672,"ss, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def print_in_input_format_cfour(self):; """"""Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print('\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:12978,Deployability,update,updated,12978,"a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def print_in_input_format_cfour(self):; """"""Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print('\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8))). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """""". def __init__(self, ent",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:14658,Deployability,update,updated,14658,"s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8))). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0, basis=None, shells=None):; """"""Constructor"""""" # note that pos'n of basis arg changed from libmints; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto,",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:15765,Deployability,update,updated,15765,"elf.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %5d %11s %5d %11s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %5d %11s %5d %11s %5d %11s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def print_in_input_format_cfour(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %d %s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %d %s %d %s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); ret",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:16878,Deployability,update,updates,16878,"elf.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %d %s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %d %s %d %s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:17913,Deployability,update,update,17913,"ariables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.compute(). # place third atom pointing upwards; # this rTo rVal aTo aVal; # A B C; elif self.dto == None:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; cosABC =",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:20868,Deployability,update,updated,20868,"os(a); sinABC = math.sin(a); B = self.rto.compute(); C = self.ato.compute(). eCB = sub(B, C); eCB = normalize(eCB); eX = [0.0, 0.0, 0.0]; eY = [0.0, 0.0, 0.0]; if (math.fabs(1.0 - math.fabs(eCB[0])) < 1.0E-5):; # CB is collinear with X, start by finding Y; eY[1] = 1.0; eX = perp_unit(eY, eCB); eY = perp_unit(eX, eCB); else:; # CB is not collinear with X, we can safely find X first; eX[0] = 1.0; eY = perp_unit(eX, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eY[xyz] * sinABC - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. # The fourth, or subsequent, atom; #; # The atom specification is; # this rTo rVal aTo aVal dTo dVal; # A B C D; # which allows us to define the vector from C->B (eCB) as the +z axis, and eDC; # lies in the xz plane. Then eX, eY and eZ (=eBC) are the x, y, and z axes, respecively.; else:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; d = self.dval.compute() * math.pi / 180.0; B = self.rto.compute(); C = self.ato.compute(); D = self.dto.compute(). eDC = sub(C, D); eCB = sub(B, C); eDC = normalize(eDC); eCB = normalize(eCB); cosABC = math.cos(a); sinABC = math.sin(a); cosABCD = math.cos(d); sinABCD = math.sin(d); eY = perp_unit(eDC, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eX[xyz] * sinABC * cosABCD +; eY[xyz] * sinABC * sinABCD - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. self.computed = True; return self.coordinates. [docs] def everything(self):; CoordEntry.everything(self); print('\nZMatrixEntry\n Type = %s\n\n' % (self.type())); print(self.print_in_input_format()). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:5554,Energy Efficiency,charge,charge,5554,"1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print('\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables)). [docs]class CoordEntry(object):; """"""Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label="""", basis=None, shells=None):; """"""Constructor""""""; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]; # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False; # Different types of basis sets that can be assigned to this atom.; self.PYbasissets = basis if basis is not None else OrderedDict(); # Hash of one-atom BasisSet attached to this atom; self.PYshells = shells if shells is not None else OrderedDict(). @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise Valid",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:5944,Energy Efficiency,charge,charge,5944,"ng.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print('\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables)). [docs]class CoordEntry(object):; """"""Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label="""", basis=None, shells=None):; """"""Constructor""""""; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]; # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False; # Different types of basis sets that can be assigned to this atom.; self.PYbasissets = basis if basis is not None else OrderedDict(); # Hash of one-atom BasisSet attached to this atom; self.PYshells = shells if shells is not None else OrderedDict(). @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA)",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:9194,Energy Efficiency,charge,charge,9194,"out orbital basis?; if bas in other.PYshells:; if other.PYshells[bas] != self.PYshells[bas]:; return False; #if other.PYshells[bas].nbf() != self.PYshells[bas].nbf():; # return False; #if other.PYshells[bas].nshell() != self.PYshells[bas].nshell():; # return False; #if other.PYshells[bas].nprimitive() != self.PYshells[bas].nprimitive():; # return False; #if other.PYshells[bas].max_am() != self.PYshells[bas].max_am():; # return False; #if other.PYshells[bas].max_nprimitive() != self.PYshells[bas].max_nprimitive():; # return False; #if other.PYshells[bas].has_puream() != self.PYshells[bas].has_puream():; # return False; else:; raise ValidationError(""""""Basis set %s set for one and not other. This shouldn't happen. Investigate."""""" % (bas)); return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except V",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:9306,Energy Efficiency,charge,charge,9306,"elf.PYshells[bas].nbf():; # return False; #if other.PYshells[bas].nshell() != self.PYshells[bas].nshell():; # return False; #if other.PYshells[bas].nprimitive() != self.PYshells[bas].nprimitive():; # return False; #if other.PYshells[bas].max_am() != self.PYshells[bas].max_am():; # return False; #if other.PYshells[bas].max_nprimitive() != self.PYshells[bas].max_nprimitive():; # return False; #if other.PYshells[bas].has_puream() != self.PYshells[bas].has_puream():; # return False; else:; raise ValidationError(""""""Basis set %s set for one and not other. This shouldn't happen. Investigate."""""" % (bas)); return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basiss",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:9336,Energy Efficiency,charge,charge,9336,"elf.PYshells[bas].nbf():; # return False; #if other.PYshells[bas].nshell() != self.PYshells[bas].nshell():; # return False; #if other.PYshells[bas].nprimitive() != self.PYshells[bas].nprimitive():; # return False; #if other.PYshells[bas].max_am() != self.PYshells[bas].max_am():; # return False; #if other.PYshells[bas].max_nprimitive() != self.PYshells[bas].max_nprimitive():; # return False; #if other.PYshells[bas].has_puream() != self.PYshells[bas].has_puream():; # return False; else:; raise ValidationError(""""""Basis set %s set for one and not other. This shouldn't happen. Investigate."""""" % (bas)); return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basiss",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:11343,Energy Efficiency,charge,charge,11343,"""""""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables th",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:11660,Energy Efficiency,charge,charge,11660,"Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:11768,Energy Efficiency,charge,charge,11768,"sh string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:13988,Energy Efficiency,charge,charge,13988,"m regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print('\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8))). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0, basis=None, shells=None):; """"""Constructor"""""" # note that pos'n of basis arg changed from libmints; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:14216,Energy Efficiency,charge,charge,14216,"17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print('\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8))). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0, basis=None, shells=None):; """"""Constructor"""""" # note that pos'n of basis arg changed from libmints; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %5d %11s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:3435,Integrability,depend,depends,3435,"it__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:12358,Integrability,depend,depend,12358,"; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def print_in_input_format_cfour(self):; """"""Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:16953,Integrability,depend,depend,16953,"elf.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %d %s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %d %s %d %s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:1602,Modifiability,variab,variables,1602,"seful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; from __future__ import absolute_import; from __future__ import print_function; import math; import copy; from .vecutil import *; from .exceptions import *; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print('\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed)). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:3627,Modifiability,variab,variable,3627,"; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:3687,Modifiability,variab,variable,3687," of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets spe",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:3821,Modifiability,variab,variable,3821,"ets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:4311,Modifiability,variab,variable,4311,"ted, self.type(), self.value, self.variable_to_string(4))). [docs]class VariableValue(CoordValue):; """"""Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print('\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_st",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:4398,Modifiability,variab,variable,4398,"alization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. """"""; def __init__(self, name, geometryVariables, negate=False, fixed=False):; CoordValue.__init__(self, fixed, True); # Name of variable; self.PYname = name; # Dictionary from molecule of variable names and values; self.geometryVariables = geometryVariables; # Whether the coordinate value is actually the negative of the variable value; self.negate = negate. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; vstr = self.PYname.upper(); if vstr not in self.geometryVariables:; raise IncompleteAtomError('Variable %s used in geometry specification has not been defined' % (vstr)); if self.negate:; return self.geometryVariables[vstr] * -1.0; else:; return self.geometryVariables[vstr]. [docs] def negated(self):; """"""Gets whether the coordinate value is actually the negative of the variable value""""""; return self.negate. [docs] def name(self):; """"""Gets the name of the variable""""""; return self.PYname. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; if self.negate:; self.geometryVariables[self.PYname] = val * -1.0; else:; self.geometryVariables[self.PYname] = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'VariableType'. [docs] def clone(self):; """"""Returns new, independent VariableValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; if self.negate:; return '-' + self.PYname; else:; return self.PYname. [docs] def everything(self):; print('\nVariableValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n Name = %s\n Negated = %s\n Map = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.compute(), self.variable_to_string(4), self.name(), self.negated(), self.geometryVariables)). [docs]class CoordEntry(object):; """"""Class to",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:12339,Modifiability,variab,variables,12339,"; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label, basis, shells); self.x = x; self.y = y; self.z = z. [docs] def compute(self):; """"""Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. """"""; if self.computed:; return self.coordinates; self.coordinates[0] = self.x.compute(); self.coordinates[1] = self.y.compute(); self.coordinates[2] = self.z.compute(); self.computed = True; return self.coordinates. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates and any variables that may depend on it. """"""; self.coordinates[0] = x; self.coordinates[1] = y; self.coordinates[2] = z. self.x.rset(x); self.y.rset(y); self.z.rset(z). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'CartesianCoord'. [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user.""""""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def print_in_input_format_cfour(self):; """"""Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. """"""; xstr = self.x.variable_to_string(12); ystr = self.y.variable_to_string(12); zstr = self.z.variable_to_string(12); return "" %17s %17s %17s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:16934,Modifiability,variab,variables,16934,"elf.dto == None:; # The first atom; text += ""\n""; elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); text += "" %d %s\n"" % (now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); text += "" %d %s %d %s\n"" % (now_rto, now_rval, now_ato, now_aval); else:; # Remaining atoms; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(10); now_ato = self.ato.entry_number() + 1; now_aval = self.aval.variable_to_string(10); now_dto = self.dto.entry_number() + 1; now_dval = self.dval.variable_to_string(10); text += "" %d %s %d %s %d %s\n"" % \; (now_rto, now_rval, now_ato, now_aval, now_dto, now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compu",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:19306,Safety,safe,safely,19306,"f):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.compute(). # place third atom pointing upwards; # this rTo rVal aTo aVal; # A B C; elif self.dto == None:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; cosABC = math.cos(a); sinABC = math.sin(a); B = self.rto.compute(); C = self.ato.compute(). eCB = sub(B, C); eCB = normalize(eCB); eX = [0.0, 0.0, 0.0]; eY = [0.0, 0.0, 0.0]; if (math.fabs(1.0 - math.fabs(eCB[0])) < 1.0E-5):; # CB is collinear with X, start by finding Y; eY[1] = 1.0; eX = perp_unit(eY, eCB); eY = perp_unit(eX, eCB); else:; # CB is not collinear with X, we can safely find X first; eX[0] = 1.0; eY = perp_unit(eX, eCB); eX = perp_unit(eY, eCB); for xyz in range(3):; self.coordinates[xyz] = B[xyz] + r * (eY[xyz] * sinABC - eCB[xyz] * cosABC); if math.fabs(self.coordinates[xyz]) < 1.E-14:; self.coordinates[xyz] = 0.0. # The fourth, or subsequent, atom; #; # The atom specification is; # this rTo rVal aTo aVal dTo dVal; # A B C D; # which allows us to define the vector from C->B (eCB) as the +z axis, and eDC; # lies in the xz plane. Then eX, eY and eZ (=eBC) are the x, y, and z axes, respecively.; else:; r = self.rval.compute(); a = self.aval.compute() * math.pi / 180.0; d = self.dval.compute() * math.pi / 180.0; B = self.rto.compute(); C = self.ato.compute(); D = self.dto.compute(). eDC = sub(C, D); eCB = sub(B, C); eDC = normalize(eDC); eCB = normalize(eCB); cosABC = math.cos(a); sinABC = math.sin(a); cosABCD = math.cos(d); sinABCD = math.sin(d); eY = perp_unit(eDC, eCB); eX = perp_unit(eY, eCB); for xyz in range",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10473,Security,hash,hash,10473,"urn self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class C",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10570,Security,hash,hash,10570,"] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coord",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10691,Security,hash,hash,10691,"he order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symb",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10775,Security,hash,hash,10775,"_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, ma",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:1645,Usability,simpl,simplifying,1645,"seful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; from __future__ import absolute_import; from __future__ import print_function; import math; import copy; from .vecutil import *; from .exceptions import *; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print('\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed)). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:2375,Usability,simpl,simply,2375,"t *; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print('\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed)). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:12439,Deployability,update,updated,12439," contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; self.PYnprimitive = nprimitive; self.puream = pure; self.PYexp = e; self.PYoriginal_coef = oc; self.PYcoef = c; self.PYerd_coef = ec; self.nc = nc; self.center = center; self.start = start; self.PYncartesian = INT_NCART(self.l); self.PYnfunction = INT_NFUNC(self.puream, self.l). [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return self.PYnprimitive. #GaussianShell(0, nprimitive_,; # uoriginal_coefficients_, ucoefficients_, uerd_coefficients_,; # uexponents_, GaussianType(0), 0, xyz_, 0); #; #GaussianShell(am, shell_nprim,; # &uoriginal_coefficients_[ustart+atom_nprim], &ucoefficients_[ustart+atom_nprim], &uerd_coefficients_[ustart+atom_nprim],; # &uexponents_[ustart+atom_nprim], puream, n, xyz_ptr, bf_count); #; #GaussianShell(am, shell_nprim,; # &uoriginal_coefficients_[prim_count], &ucoefficients_[prim_count], &uerd_coefficients_[prim_count],; # &uexponents_[prim_count], puream, center, xyz_, bf_count); #; #ShellInfo(am, contractions, exponents, gaussian_type, 0, center, 0, Unnormalized). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:2925,Energy Efficiency,efficient,efficient,2925,"esian function.; #define INT_CARTINDEX(am,i,j) (((i) == (am))? 0 : (((((am) - (i) + 1)*((am) - (i)))>>1) + (am) - (i) - (j))). """"""; return 0 if (i == am) else ((((am - i + 1) * (am - i)) >> 1) + am - i - j). [docs]def INT_ICART(a, b, c):; """"""Given a, b, and c compute a cartesian offset.; #define INT_ICART(a, b, c) (((((((a)+(b)+(c)+1)<<1)-(a))*((a)+1))>>1)-(b)-1). """"""; return ((((((a + b + c + 1) << 1) - a) * (a + 1)) >> 1) - b - 1). [docs]def INT_IPURE(l, m):; """"""Given l and m compute a pure function offset.; #define INT_IPURE(l, m) ((l)+(m)). """"""; return l + m. # Lookup array that when you index the angular momentum it returns the corresponding letter; PrimitiveType = ['Normalized', 'Unnormalized']; GaussianType = ['Cartesian', 'Pure'] # Cartesian = 0, Pure = 1. [docs]class ShellInfo(object):; """"""This class has the same behavior as GaussianShell, but implements everything using; slower data structures, which are easier to construct. These are used to build the; basis set, which builds more efficient pointer-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD no",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:3382,Energy Efficiency,reduce,reduce,3382,"l and m compute a pure function offset.; #define INT_IPURE(l, m) ((l)+(m)). """"""; return l + m. # Lookup array that when you index the angular momentum it returns the corresponding letter; PrimitiveType = ['Normalized', 'Unnormalized']; GaussianType = ['Cartesian', 'Pure'] # Cartesian = 0, Pure = 1. [docs]class ShellInfo(object):; """"""This class has the same behavior as GaussianShell, but implements everything using; slower data structures, which are easier to construct. These are used to build the; basis set, which builds more efficient pointer-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD normalized contraction coefficients (of length nprimitives_); self.PYerd_coef = []; # Original (un-normalized) contraction coefficients (of length nprimitives); self.PYoriginal_coef = [c[n] for n in range(len(c))]; # Atom number this shell goes to. Needed when indexing integral derivatives.; self.nc = nc; # Atomic center number in the Molecule; self.center = center; #; self.start = start; # How many cartesian functions? (1=s, 3=p, 6=d, ...); self.PYncartesian = INT_NCART(s",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:10194,Energy Efficiency,efficient,efficient,10194," text; else:; with open(outfile, mode='w') as handle:; handle.write(text). [docs] def pyprint_gamess(self, outfile=None):; """"""Print out the shell in Gamess format""""""; text = """"""%c %3d\n"""""" % (self.AMCHAR(), self.nprimitive()); for K in range(self.nprimitive()):; text += """"""%3d %15.8f %15.8f\n"""""" % (K + 1, self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pyprint(outfile=None). [docs] def normalize(self, l, m, n):; """"""Normalize the angular momentum component""""""; return 1.0. [docs] def function_index(self):; """"""Basis function index where this shell starts.""""""; return self.start. [docs] def set_function_index(self, i):; """"""Set basis function index where this shell starts.""""""; self.start = i. [docs]class GaussianShell(ShellInfo):; """"""Class with same information as :py:class:`ShellInfo`. In C++,; class uses more efficient data structures, but in Python differences; minimal. """""". def __init__(self, am, nprimitive, oc, c, ec, e, pure, nc, center, start):; """"""; * @param am Angular momentum.; * @param pure Pure spherical harmonics, or Cartesian.; * @param oc An array of contraction coefficients.; * @param c An array of normalized contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:10977,Energy Efficiency,reduce,reduce,10977,"self, i):; """"""Set basis function index where this shell starts.""""""; self.start = i. [docs]class GaussianShell(ShellInfo):; """"""Class with same information as :py:class:`ShellInfo`. In C++,; class uses more efficient data structures, but in Python differences; minimal. """""". def __init__(self, am, nprimitive, oc, c, ec, e, pure, nc, center, start):; """"""; * @param am Angular momentum.; * @param pure Pure spherical harmonics, or Cartesian.; * @param oc An array of contraction coefficients.; * @param c An array of normalized contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; self.PYnprimitive = nprimitive; self.puream = pure; self.PYexp = e; self.PYoriginal_coef = oc; self.PYcoef = c; self.PYerd_coef = ec; self.nc = nc; self.center = center; self.start = start; self.PYncartesian = INT_NCART(self.l); self.PYnfunction = INT_NFUNC(self.puream, self.l). [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return self.PYnprimitive. #GaussianShell(0, nprimitive_,; # uoriginal_coefficients_, ucoefficients_, uerd_coefficients_,; # uexponents_, GaussianType(0), 0, xyz_, 0); #; #GaussianShell(am, shell_nprim,; # &uoriginal_coefficients_[ustart+atom_nprim], &ucoefficients_[ustart+atom_nprim], &uerd_coefficients_[ustart+atom_nprim],; # &uexponents_[ustart+atom_nprim], puream, n, xyz_ptr, bf_count); #; #GaussianShell(am, shell_nprim",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:3115,Integrability,contract,contraction,3115,"- i - j). [docs]def INT_ICART(a, b, c):; """"""Given a, b, and c compute a cartesian offset.; #define INT_ICART(a, b, c) (((((((a)+(b)+(c)+1)<<1)-(a))*((a)+1))>>1)-(b)-1). """"""; return ((((((a + b + c + 1) << 1) - a) * (a + 1)) >> 1) - b - 1). [docs]def INT_IPURE(l, m):; """"""Given l and m compute a pure function offset.; #define INT_IPURE(l, m) ((l)+(m)). """"""; return l + m. # Lookup array that when you index the angular momentum it returns the corresponding letter; PrimitiveType = ['Normalized', 'Unnormalized']; GaussianType = ['Cartesian', 'Pure'] # Cartesian = 0, Pure = 1. [docs]class ShellInfo(object):; """"""This class has the same behavior as GaussianShell, but implements everything using; slower data structures, which are easier to construct. These are used to build the; basis set, which builds more efficient pointer-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD normalized contraction coefficients (of length nprimitives_); self.PYerd_coef = []; # Original (un-normalized) contraction coefficients (of length nprimitives); self.PYoriginal_coef = [c[n] for n in ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:3928,Integrability,contract,contraction,3928,"r-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD normalized contraction coefficients (of length nprimitives_); self.PYerd_coef = []; # Original (un-normalized) contraction coefficients (of length nprimitives); self.PYoriginal_coef = [c[n] for n in range(len(c))]; # Atom number this shell goes to. Needed when indexing integral derivatives.; self.nc = nc; # Atomic center number in the Molecule; self.center = center; #; self.start = start; # How many cartesian functions? (1=s, 3=p, 6=d, ...); self.PYncartesian = INT_NCART(self.l); # How many functions? (1=s, 3=p, 5/6=d, ...) * Dependent on the value of puream_; self.PYnfunction = INT_NFUNC(self.puream, self.l). # Compute the normalization constants; if pt == 'Unnormalized':; self.normalize_shell(); self.erd_normalize_shell(). [docs] def primitive_normalization(self, p):; """"""Normalizes a single primitive.; @param p The primitive index to normalize.; @return Normalization constant to be applied to the primitive. """"""; tmp1 = self.l + 1.5; g = 2.0 * self.PYexp[p]; z = pow(g, tmp1); return math.sqrt((pow(2.0, self.l",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:4028,Integrability,contract,contraction,4028,"entum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD normalized contraction coefficients (of length nprimitives_); self.PYerd_coef = []; # Original (un-normalized) contraction coefficients (of length nprimitives); self.PYoriginal_coef = [c[n] for n in range(len(c))]; # Atom number this shell goes to. Needed when indexing integral derivatives.; self.nc = nc; # Atomic center number in the Molecule; self.center = center; #; self.start = start; # How many cartesian functions? (1=s, 3=p, 6=d, ...); self.PYncartesian = INT_NCART(self.l); # How many functions? (1=s, 3=p, 5/6=d, ...) * Dependent on the value of puream_; self.PYnfunction = INT_NFUNC(self.puream, self.l). # Compute the normalization constants; if pt == 'Unnormalized':; self.normalize_shell(); self.erd_normalize_shell(). [docs] def primitive_normalization(self, p):; """"""Normalizes a single primitive.; @param p The primitive index to normalize.; @return Normalization constant to be applied to the primitive. """"""; tmp1 = self.l + 1.5; g = 2.0 * self.PYexp[p]; z = pow(g, tmp1); return math.sqrt((pow(2.0, self.l) * z) / (math.pi * math.sqrt(math.pi) * df(2 * self.l))). [docs] def contraction_normalizat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:5070,Integrability,contract,contraction,5070,"fficients (of length nprimitives); self.PYoriginal_coef = [c[n] for n in range(len(c))]; # Atom number this shell goes to. Needed when indexing integral derivatives.; self.nc = nc; # Atomic center number in the Molecule; self.center = center; #; self.start = start; # How many cartesian functions? (1=s, 3=p, 6=d, ...); self.PYncartesian = INT_NCART(self.l); # How many functions? (1=s, 3=p, 5/6=d, ...) * Dependent on the value of puream_; self.PYnfunction = INT_NFUNC(self.puream, self.l). # Compute the normalization constants; if pt == 'Unnormalized':; self.normalize_shell(); self.erd_normalize_shell(). [docs] def primitive_normalization(self, p):; """"""Normalizes a single primitive.; @param p The primitive index to normalize.; @return Normalization constant to be applied to the primitive. """"""; tmp1 = self.l + 1.5; g = 2.0 * self.PYexp[p]; z = pow(g, tmp1); return math.sqrt((pow(2.0, self.l) * z) / (math.pi * math.sqrt(math.pi) * df(2 * self.l))). [docs] def contraction_normalization(self):; """"""Normalizes an entire contraction set. Applies the normalization to the coefficients; * @param gs The contraction set to normalize. """"""; e_sum = 0.0; for i in range(self.nprimitive()):; for j in range(self.nprimitive()):; g = self.PYexp[i] + self.PYexp[j]; z = pow(g, self.l + 1.5); e_sum += self.PYcoef[i] * self.PYcoef[j] / z. tmp = ((2.0 * math.pi / (2.0 / math.sqrt(math.pi))) * df(2 * self.l)) / pow(2.0, self.l); try:; norm = math.sqrt(1.0 / (tmp * e_sum)); except ZeroDivisionError:; self.PYcoef[i] = [1.0 for i in range(self.nprimitive())]; # Set the normalization; for i in range(self.nprimitive()):; self.PYcoef[i] *= norm. [docs] def normalize_shell(self):; """"""Handles calling primitive_normalization and; contraction_normalization for you. """"""; for i in range(self.nprimitive()):; normalization = self.primitive_normalization(i); self.PYcoef[i] *= normalization; self.contraction_normalization(). [docs] def erd_normalize_shell(self):; """""". """"""; self.PYerd_coef = []; tsum = 0.0; for",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:5150,Integrability,contract,contraction,5150,"# Atom number this shell goes to. Needed when indexing integral derivatives.; self.nc = nc; # Atomic center number in the Molecule; self.center = center; #; self.start = start; # How many cartesian functions? (1=s, 3=p, 6=d, ...); self.PYncartesian = INT_NCART(self.l); # How many functions? (1=s, 3=p, 5/6=d, ...) * Dependent on the value of puream_; self.PYnfunction = INT_NFUNC(self.puream, self.l). # Compute the normalization constants; if pt == 'Unnormalized':; self.normalize_shell(); self.erd_normalize_shell(). [docs] def primitive_normalization(self, p):; """"""Normalizes a single primitive.; @param p The primitive index to normalize.; @return Normalization constant to be applied to the primitive. """"""; tmp1 = self.l + 1.5; g = 2.0 * self.PYexp[p]; z = pow(g, tmp1); return math.sqrt((pow(2.0, self.l) * z) / (math.pi * math.sqrt(math.pi) * df(2 * self.l))). [docs] def contraction_normalization(self):; """"""Normalizes an entire contraction set. Applies the normalization to the coefficients; * @param gs The contraction set to normalize. """"""; e_sum = 0.0; for i in range(self.nprimitive()):; for j in range(self.nprimitive()):; g = self.PYexp[i] + self.PYexp[j]; z = pow(g, self.l + 1.5); e_sum += self.PYcoef[i] * self.PYcoef[j] / z. tmp = ((2.0 * math.pi / (2.0 / math.sqrt(math.pi))) * df(2 * self.l)) / pow(2.0, self.l); try:; norm = math.sqrt(1.0 / (tmp * e_sum)); except ZeroDivisionError:; self.PYcoef[i] = [1.0 for i in range(self.nprimitive())]; # Set the normalization; for i in range(self.nprimitive()):; self.PYcoef[i] *= norm. [docs] def normalize_shell(self):; """"""Handles calling primitive_normalization and; contraction_normalization for you. """"""; for i in range(self.nprimitive()):; normalization = self.primitive_normalization(i); self.PYcoef[i] *= normalization; self.contraction_normalization(). [docs] def erd_normalize_shell(self):; """""". """"""; self.PYerd_coef = []; tsum = 0.0; for j in range(self.nprimitive()):; for k in range(j + 1):; a1 = self.PYexp[j]; a2 = self.PYe",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:7314,Integrability,contract,contraction,7314,"*= temp3; tsum += temp; if j != k:; tsum += temp; prefac = 1.0; if self.l > 1:; prefac = pow(2.0, 2 * self.l) / df(2 * self.l); norm = math.sqrt(prefac / tsum); for j in range(self.nprimitive()):; self.PYerd_coef.append(self.PYoriginal_coef[j] * norm). [docs] def copy(self, nc=None, c=None):; """"""Make a copy of the ShellInfo""""""; if nc is not None and c is not None:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, nc, c,; self.start, 'Unnormalized'); else:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, self.nc, self.center,; self.start, 'Unnormalized'); # better to just deepcopy?. [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return len(self.PYexp). [docs] def nfunction(self):; """"""Total number of basis functions""""""; return INT_NFUNC(self.puream, self.l). [docs] def ncartesian(self):; """"""Total number of functions if this shell was Cartesian""""""; return self.PYncartesian. [docs] def am(self):; """"""The angular momentum of the given contraction""""""; return self.l. [docs] def amchar(self):; """"""The character symbol for the angular momentum of the given contraction""""""; return 'spdfghiklmnopqrtuvwxyz'[self.l]. [docs] def AMCHAR(self):; """"""The character symbol for the angular momentum of the given contraction (upper case)""""""; return 'SPDFGHIKLMNOPQRTUVWXYZ'[self.l]. [docs] def is_cartesian(self):; """"""Returns true if contraction is Cartesian""""""; return True if self.puream == 'Cartesian' else False. [docs] def is_pure(self):; """"""Returns true if contraction is pure""""""; return True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:7433,Integrability,contract,contraction,7433,"* self.l); norm = math.sqrt(prefac / tsum); for j in range(self.nprimitive()):; self.PYerd_coef.append(self.PYoriginal_coef[j] * norm). [docs] def copy(self, nc=None, c=None):; """"""Make a copy of the ShellInfo""""""; if nc is not None and c is not None:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, nc, c,; self.start, 'Unnormalized'); else:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, self.nc, self.center,; self.start, 'Unnormalized'); # better to just deepcopy?. [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return len(self.PYexp). [docs] def nfunction(self):; """"""Total number of basis functions""""""; return INT_NFUNC(self.puream, self.l). [docs] def ncartesian(self):; """"""Total number of functions if this shell was Cartesian""""""; return self.PYncartesian. [docs] def am(self):; """"""The angular momentum of the given contraction""""""; return self.l. [docs] def amchar(self):; """"""The character symbol for the angular momentum of the given contraction""""""; return 'spdfghiklmnopqrtuvwxyz'[self.l]. [docs] def AMCHAR(self):; """"""The character symbol for the angular momentum of the given contraction (upper case)""""""; return 'SPDFGHIKLMNOPQRTUVWXYZ'[self.l]. [docs] def is_cartesian(self):; """"""Returns true if contraction is Cartesian""""""; return True if self.puream == 'Cartesian' else False. [docs] def is_pure(self):; """"""Returns true if contraction is pure""""""; return True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of pi'th primitive""""""; return self.PYcoef[pi]. [docs] def erd_coef(self, pi):; """"""Return ERD normalized coefficient of ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:7578,Integrability,contract,contraction,7578,"(self, nc=None, c=None):; """"""Make a copy of the ShellInfo""""""; if nc is not None and c is not None:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, nc, c,; self.start, 'Unnormalized'); else:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, self.nc, self.center,; self.start, 'Unnormalized'); # better to just deepcopy?. [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return len(self.PYexp). [docs] def nfunction(self):; """"""Total number of basis functions""""""; return INT_NFUNC(self.puream, self.l). [docs] def ncartesian(self):; """"""Total number of functions if this shell was Cartesian""""""; return self.PYncartesian. [docs] def am(self):; """"""The angular momentum of the given contraction""""""; return self.l. [docs] def amchar(self):; """"""The character symbol for the angular momentum of the given contraction""""""; return 'spdfghiklmnopqrtuvwxyz'[self.l]. [docs] def AMCHAR(self):; """"""The character symbol for the angular momentum of the given contraction (upper case)""""""; return 'SPDFGHIKLMNOPQRTUVWXYZ'[self.l]. [docs] def is_cartesian(self):; """"""Returns true if contraction is Cartesian""""""; return True if self.puream == 'Cartesian' else False. [docs] def is_pure(self):; """"""Returns true if contraction is pure""""""; return True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of pi'th primitive""""""; return self.PYcoef[pi]. [docs] def erd_coef(self, pi):; """"""Return ERD normalized coefficient of pi'th primitive""""""; return self.PYerd_coef[pi]. [docs] def original_coef(self, pi):; """"""Return unnormalized coefficient of pi'th primitive""""""; return se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:7699,Integrability,contract,contraction,7699,"Yoriginal_coef, self.PYexp,; self.puream, nc, c,; self.start, 'Unnormalized'); else:; return ShellInfo(self.l, self.PYoriginal_coef, self.PYexp,; self.puream, self.nc, self.center,; self.start, 'Unnormalized'); # better to just deepcopy?. [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return len(self.PYexp). [docs] def nfunction(self):; """"""Total number of basis functions""""""; return INT_NFUNC(self.puream, self.l). [docs] def ncartesian(self):; """"""Total number of functions if this shell was Cartesian""""""; return self.PYncartesian. [docs] def am(self):; """"""The angular momentum of the given contraction""""""; return self.l. [docs] def amchar(self):; """"""The character symbol for the angular momentum of the given contraction""""""; return 'spdfghiklmnopqrtuvwxyz'[self.l]. [docs] def AMCHAR(self):; """"""The character symbol for the angular momentum of the given contraction (upper case)""""""; return 'SPDFGHIKLMNOPQRTUVWXYZ'[self.l]. [docs] def is_cartesian(self):; """"""Returns true if contraction is Cartesian""""""; return True if self.puream == 'Cartesian' else False. [docs] def is_pure(self):; """"""Returns true if contraction is pure""""""; return True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of pi'th primitive""""""; return self.PYcoef[pi]. [docs] def erd_coef(self, pi):; """"""Return ERD normalized coefficient of pi'th primitive""""""; return self.PYerd_coef[pi]. [docs] def original_coef(self, pi):; """"""Return unnormalized coefficient of pi'th primitive""""""; return self.PYoriginal_coef[pi]. [docs] def exps(self):; """"""Returns the exponent of the given primitive""""""; return self.PYexp. [docs] def co",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:7828,Integrability,contract,contraction,7828,"ef, self.PYexp,; self.puream, self.nc, self.center,; self.start, 'Unnormalized'); # better to just deepcopy?. [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return len(self.PYexp). [docs] def nfunction(self):; """"""Total number of basis functions""""""; return INT_NFUNC(self.puream, self.l). [docs] def ncartesian(self):; """"""Total number of functions if this shell was Cartesian""""""; return self.PYncartesian. [docs] def am(self):; """"""The angular momentum of the given contraction""""""; return self.l. [docs] def amchar(self):; """"""The character symbol for the angular momentum of the given contraction""""""; return 'spdfghiklmnopqrtuvwxyz'[self.l]. [docs] def AMCHAR(self):; """"""The character symbol for the angular momentum of the given contraction (upper case)""""""; return 'SPDFGHIKLMNOPQRTUVWXYZ'[self.l]. [docs] def is_cartesian(self):; """"""Returns true if contraction is Cartesian""""""; return True if self.puream == 'Cartesian' else False. [docs] def is_pure(self):; """"""Returns true if contraction is pure""""""; return True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of pi'th primitive""""""; return self.PYcoef[pi]. [docs] def erd_coef(self, pi):; """"""Return ERD normalized coefficient of pi'th primitive""""""; return self.PYerd_coef[pi]. [docs] def original_coef(self, pi):; """"""Return unnormalized coefficient of pi'th primitive""""""; return self.PYoriginal_coef[pi]. [docs] def exps(self):; """"""Returns the exponent of the given primitive""""""; return self.PYexp. [docs] def coefs(self):; """"""Return coefficient of pi'th primitive and ci'th contraction""""""; return self.PYcoef. [docs] def original_coefs(self",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:8761,Integrability,contract,contraction,8761,"rue if self.puream == 'Cartesian' else False. [docs] def is_pure(self):; """"""Returns true if contraction is pure""""""; return True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of pi'th primitive""""""; return self.PYcoef[pi]. [docs] def erd_coef(self, pi):; """"""Return ERD normalized coefficient of pi'th primitive""""""; return self.PYerd_coef[pi]. [docs] def original_coef(self, pi):; """"""Return unnormalized coefficient of pi'th primitive""""""; return self.PYoriginal_coef[pi]. [docs] def exps(self):; """"""Returns the exponent of the given primitive""""""; return self.PYexp. [docs] def coefs(self):; """"""Return coefficient of pi'th primitive and ci'th contraction""""""; return self.PYcoef. [docs] def original_coefs(self):; """"""Return unnormalized coefficient of pi'th primitive and ci'th contraction""""""; return self.PYoriginal_coef. [docs] def pyprint(self, outfile=None):; """"""Print out the shell""""""; text = """""" %c %3d 1.00\n"""""" % (self.AMCHAR(), self.nprimitive()); for K in range(self.nprimitive()):; text += """""" %20.8f %20.8f\n"""""" % (self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). [docs] def pyprint_gamess(self, outfile=None):; """"""Print out the shell in Gamess format""""""; text = """"""%c %3d\n"""""" % (self.AMCHAR(), self.nprimitive()); for K in range(self.nprimitive()):; text += """"""%3d %15.8f %15.8f\n"""""" % (K + 1, self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pypri",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:8895,Integrability,contract,contraction,8895,"True if self.puream == 'Pure' else False. [docs] def center(self):; """"""Returns the center of the Molecule this shell is on""""""; return self.center. [docs] def ncenter(self):; """"""Returns the atom number this shell is on. Used by integral derivatives for indexing.""""""; return self.nc. [docs] def exp(self, prim):; """"""Returns the exponent of the given primitive""""""; return self.PYexp[prim]. [docs] def coef(self, pi):; """"""Return coefficient of pi'th primitive""""""; return self.PYcoef[pi]. [docs] def erd_coef(self, pi):; """"""Return ERD normalized coefficient of pi'th primitive""""""; return self.PYerd_coef[pi]. [docs] def original_coef(self, pi):; """"""Return unnormalized coefficient of pi'th primitive""""""; return self.PYoriginal_coef[pi]. [docs] def exps(self):; """"""Returns the exponent of the given primitive""""""; return self.PYexp. [docs] def coefs(self):; """"""Return coefficient of pi'th primitive and ci'th contraction""""""; return self.PYcoef. [docs] def original_coefs(self):; """"""Return unnormalized coefficient of pi'th primitive and ci'th contraction""""""; return self.PYoriginal_coef. [docs] def pyprint(self, outfile=None):; """"""Print out the shell""""""; text = """""" %c %3d 1.00\n"""""" % (self.AMCHAR(), self.nprimitive()); for K in range(self.nprimitive()):; text += """""" %20.8f %20.8f\n"""""" % (self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). [docs] def pyprint_gamess(self, outfile=None):; """"""Print out the shell in Gamess format""""""; text = """"""%c %3d\n"""""" % (self.AMCHAR(), self.nprimitive()); for K in range(self.nprimitive()):; text += """"""%3d %15.8f %15.8f\n"""""" % (K + 1, self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pyprint(outfile=None). [docs] def normalize(self, l, m, n):; """"""Normalize the angular momentum component""""""; return 1.0. [docs] ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:10453,Integrability,contract,contraction,10453,"e(self.nprimitive()):; text += """"""%3d %15.8f %15.8f\n"""""" % (K + 1, self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pyprint(outfile=None). [docs] def normalize(self, l, m, n):; """"""Normalize the angular momentum component""""""; return 1.0. [docs] def function_index(self):; """"""Basis function index where this shell starts.""""""; return self.start. [docs] def set_function_index(self, i):; """"""Set basis function index where this shell starts.""""""; self.start = i. [docs]class GaussianShell(ShellInfo):; """"""Class with same information as :py:class:`ShellInfo`. In C++,; class uses more efficient data structures, but in Python differences; minimal. """""". def __init__(self, am, nprimitive, oc, c, ec, e, pure, nc, center, start):; """"""; * @param am Angular momentum.; * @param pure Pure spherical harmonics, or Cartesian.; * @param oc An array of contraction coefficients.; * @param c An array of normalized contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; self.PYnprimitive = nprimitive; self.puream = pure; self.PYexp = e; self.PYoriginal_coef = oc; self.PYcoef = c; self.PYerd_coef = ec; self.nc = nc; self.center = center; self.start = start; self.PYncartesian = INT_NCART(self.l); self.PYnfunc",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:10514,Integrability,contract,contraction,10514," % (K + 1, self.PYexp[K], self.PYoriginal_coef[K]). if outfile is None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pyprint(outfile=None). [docs] def normalize(self, l, m, n):; """"""Normalize the angular momentum component""""""; return 1.0. [docs] def function_index(self):; """"""Basis function index where this shell starts.""""""; return self.start. [docs] def set_function_index(self, i):; """"""Set basis function index where this shell starts.""""""; self.start = i. [docs]class GaussianShell(ShellInfo):; """"""Class with same information as :py:class:`ShellInfo`. In C++,; class uses more efficient data structures, but in Python differences; minimal. """""". def __init__(self, am, nprimitive, oc, c, ec, e, pure, nc, center, start):; """"""; * @param am Angular momentum.; * @param pure Pure spherical harmonics, or Cartesian.; * @param oc An array of contraction coefficients.; * @param c An array of normalized contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; self.PYnprimitive = nprimitive; self.puream = pure; self.PYexp = e; self.PYoriginal_coef = oc; self.PYcoef = c; self.PYerd_coef = ec; self.nc = nc; self.center = center; self.start = start; self.PYncartesian = INT_NCART(self.l); self.PYnfunction = INT_NFUNC(self.puream, self.l). [docs] def nprimi",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:10580,Integrability,contract,contraction,10580,"s None:; return text; else:; with open(outfile, mode='w') as handle:; handle.write(text). def __str__(self):; """"""String representation of shell""""""; return self.pyprint(outfile=None). [docs] def normalize(self, l, m, n):; """"""Normalize the angular momentum component""""""; return 1.0. [docs] def function_index(self):; """"""Basis function index where this shell starts.""""""; return self.start. [docs] def set_function_index(self, i):; """"""Set basis function index where this shell starts.""""""; self.start = i. [docs]class GaussianShell(ShellInfo):; """"""Class with same information as :py:class:`ShellInfo`. In C++,; class uses more efficient data structures, but in Python differences; minimal. """""". def __init__(self, am, nprimitive, oc, c, ec, e, pure, nc, center, start):; """"""; * @param am Angular momentum.; * @param pure Pure spherical harmonics, or Cartesian.; * @param oc An array of contraction coefficients.; * @param c An array of normalized contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; self.PYnprimitive = nprimitive; self.puream = pure; self.PYexp = e; self.PYoriginal_coef = oc; self.PYcoef = c; self.PYerd_coef = ec; self.nc = nc; self.center = center; self.start = start; self.PYncartesian = INT_NCART(self.l); self.PYnfunction = INT_NFUNC(self.puream, self.l). [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:12174,Integrability,contract,contractions,12174," contraction coefficients.; * @param ec An array of ERD normalized contraction coefficients.; * @param e An array of exponent values.; * @param pure an enum describing whether this shell uses pure or Cartesian functions.; * @param nc The atomic center that this shell is located on. Must map back to the correct atom in the owning BasisSet molecule_. Used in integral derivatives for indexing.; * @param center The x, y, z position of the shell. This is passed to reduce the number of calls to the molecule.; * @param start The starting index of the first function this shell provides. Used to provide starting positions in matrices.; * @param pt Is the shell already normalized?. """"""; self.l = am; self.PYnprimitive = nprimitive; self.puream = pure; self.PYexp = e; self.PYoriginal_coef = oc; self.PYcoef = c; self.PYerd_coef = ec; self.nc = nc; self.center = center; self.start = start; self.PYncartesian = INT_NCART(self.l); self.PYnfunction = INT_NFUNC(self.puream, self.l). [docs] def nprimitive(self):; """"""The number of primitive Gaussians""""""; return self.PYnprimitive. #GaussianShell(0, nprimitive_,; # uoriginal_coefficients_, ucoefficients_, uerd_coefficients_,; # uexponents_, GaussianType(0), 0, xyz_, 0); #; #GaussianShell(am, shell_nprim,; # &uoriginal_coefficients_[ustart+atom_nprim], &ucoefficients_[ustart+atom_nprim], &uerd_coefficients_[ustart+atom_nprim],; # &uexponents_[ustart+atom_nprim], puream, n, xyz_ptr, bf_count); #; #GaussianShell(am, shell_nprim,; # &uoriginal_coefficients_[prim_count], &ucoefficients_[prim_count], &uerd_coefficients_[prim_count],; # &uexponents_[prim_count], puream, center, xyz_, bf_count); #; #ShellInfo(am, contractions, exponents, gaussian_type, 0, center, 0, Unnormalized). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:34868,Availability,toler,tolerance,34868,"y_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyErr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:38667,Availability,error,error,38667,"tribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Molecule::get_anchor_atom: Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), se",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:51738,Availability,error,error,51738,"ear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2') # FINAL. [docs] def set_basis_all_atoms(self, name, role=""BASIS""):; """"""Assigns basis *name* to all atoms.""""""; uc = name.upper(); if uc in ['SPECIAL', 'GENERAL', 'CUSTOM']:; # These aren't really basis set specifications, just return.; return; for atom in self.full_atoms:; atom.set_basisset(name, role). [docs] def set_basis_by_symbol(self, symbol, name, role=""BASIS""):; """"""Assigns basis *name* to all *symbol* atoms.""""""; for atom in self.full_atoms:; if symbol.upper() == atom.symbol():; atom.set_basisset(name, role). [docs] def clear_basis_all_atoms(self):; """"""Remove all basis information from atoms.""""""; for atom in self.full_atoms:; atom.PYbasissets = OrderedDict(). [docs] def set_basis_by_number(self, number, name, role=""BASIS""):; """"""Assigns basis *name* to atom number *number* (0-indexed, excludes dummies).""""""; # change from libmints to 0-indexing and to real/ghost numbering, dummies not included (libmints >= error); if number >= self.natom():; raise ValidationError(""Molecule::set_basis_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_basisset(name, role). [docs] def set_basis_by_label(self, label, name, role=""BASIS""):; """"""Assigns basis *name* to all atoms with *label*.""""""; for atom in self.full_atoms:; if label.upper() == atom.label():; atom.set_basisset(name, role). [docs] def set_shell_by_number(self, number, bshash, role=""BASIS""):; """"""Assigns BasisSet *bshash* to atom number *number* (0-indexed, excludes dummies).""""""; self.lock_frame = False; if number >= self.natom():; raise ValidationError(""Molecule::set_shell_by_number: Basis specified for atom %d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_shell(bshash, role). [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given f",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:61246,Availability,checkpoint,checkpoint,61246,"000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. N = self.natom(); if not save_ghosts:; N = 0; for i in range(self.natom()):; if self.Z(i):; N += 1; text = ""%d\n\n"" % (N). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); if save_ghosts or self.Z(i):; text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text. [docs] def save_xyz(self, filename, save_ghosts=True):; """"""Save an XYZ file. >>> H2OH2O.save_xyz('h2o.xyz'). """"""; outfile = open(filename, 'w'); outfile.write(self.save_string_xyz(save_ghosts)); outfile.close(). [docs] def save_to_checkpoint(self, chkpt, prefix=""""):; """""" **NYI** Save information to checkpoint file; (method name in libmints is save_to_chkpt). """"""; raise FeatureNotImplemented('Molecule::save_to_checkpoint') # FINAL. # <<< Methods for Symmetry >>>. [docs] def has_symmetry_element(self, op, tol=DEFAULT_SYM_TOL):; """""" **NYI** Whether molecule satisfies the vector symmetry; operation *op*. Not used by libmints. """"""; raise FeatureNotImplemented('Molecule::has_symmetry_element') # FINAL; for i in range(self.natom()):; result = naivemult(self.xyz(i), op); atom = self.atom_at_position(result, tol). if atom != -1:; if not self.atoms[atom].is_equivalent_to(self.atoms[i]):; return False; else:; return False; return True. [docs] def point_group(self):; """"""Returns the point group (object) if set""""""; if self.pg is None:; raise ValidationError(""Molecule::point_group: Molecular point group has not been set.""); return self.pg. [docs] def set_point_group(self, pg):; """"""Set the point group to object *pg* """"""; self.pg = pg; # Call this here, the programmer will forget to",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:48814,Deployability,update,updated,48814,"2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; self.set_point_group(self.find_point_group()); self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:59998,Deployability,release,release,59998,"[0,-1,0],[-1,0,0],[0,0,1]]). """"""; new_geom = zero(3, self.nallatom()); geom = self.full_geometry(); new_geom = mult(geom, R); self.set_full_geometry(new_geom). [docs] def orientation_fixed(self):; """"""Get whether or not orientation is fixed. >>> H2OH2O.orientation_fixed(); True. """"""; return self.PYfix_orientation. [docs] def fix_orientation(self, _fix=True):; """"""Fix the orientation at its current frame; (method name in libmints is set_orientation_fixed). """"""; if _fix:; self.PYfix_orientation = True # tells update_geometry() not to change orientation; # Compute original cartesian coordinates - code coped from update_geometry(); self.atoms = []; for item in self.full_atoms:; item.invalidate(). for fr in range(self.nfragments()):; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]); else: # release orientation to be free; self.PYfix_orientation = False. # <<< Methods for Saving >>>. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; _; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. N = self.natom(); if not save_ghosts:; N = 0; for i in range(self.natom()):; if self.Z(i):; N += 1; text = ""%d\n\n"" % (N). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); if save_ghosts or self.Z(i):; text += '%2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""Gh""), \; x * factor, y * factor, z * factor); return text. [docs] def save_xyz(self, filename, save_ghosts=True):; """"",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:88921,Deployability,update,updated,88921," noise coming in from optking. """"""; #raise FeatureNotImplemented('Molecule::symmetrize') # FINAL SYMM; temp = zero(self.natom(), 3); ct = self.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(self). # Symmetrize the molecule to remove any noise; for at in range(self.natom()):; for g in range(ct.order()):; Gatom = atom_map[at][g]; so = ct.symm_operation(g). # Full so must be used if molecule is not in standard orientation; temp[at][0] += so[0][0] * self.x(Gatom) / ct.order(); temp[at][0] += so[0][1] * self.y(Gatom) / ct.order(); temp[at][0] += so[0][2] * self.z(Gatom) / ct.order(); temp[at][1] += so[1][0] * self.x(Gatom) / ct.order(); temp[at][1] += so[1][1] * self.y(Gatom) / ct.order(); temp[at][1] += so[1][2] * self.z(Gatom) / ct.order(); temp[at][2] += so[2][0] * self.x(Gatom) / ct.order(); temp[at][2] += so[2][1] * self.y(Gatom) / ct.order(); temp[at][2] += so[2][2] * self.z(Gatom) / ct.order(). # Set the geometry to ensure z-matrix variables get updated; self.set_geometry(temp). [docs] def schoenflies_symbol(self):; """"""Returns the Schoenflies symbol""""""; return self.point_group().symbol(). [docs] def valid_atom_map(self, tol=0.01):; """"""Check if current geometry fits current point group. """"""; np = [0.0, 0.0, 0.0]; ct = self.point_group().char_table(). # loop over all centers; for at in range(self.natom()):; ac = self.xyz(at). # For each operation in the pointgroup, transform the coordinates of; # center ""at"" and see which atom it maps into; for g in range(ct.order()):; so = ct.symm_operation(g). for ii in range(3):; np[ii] = 0; for jj in range(3):; np[ii] += so[ii][jj] * ac[jj]. if self.atom_at_position(np, tol) < 0:; return False; return True. [docs] def full_point_group_with_n(self):; """"""Return point group name such as Cnv or Sn.""""""; return self.full_pg. [docs] def full_pg_n(self):; """"""Return n in Cnv, etc.; If there is no n (e.g. Td); it's the highest-order rotation axis. """"""; return self.PYfull_pg_n. [docs",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:96742,Deployability,update,updated,96742,"lows rows to be in a different order.; @param rhs Matrix to compare to.; @returns true if equal, otherwise false. """"""; for m in range(len(mat)):; for m_rhs in range(len(mat)):. for n in range(len(mat[m])):; if abs(mat[m][n] - rhs[m_rhs][n]) > tol:; break # from n; else:; # whole row matched, goto next m row; break # from m_rhs; else:; # no matching row was found; return False; else:; return True. [docs]def compute_atom_map(mol):; """"""Computes atom mappings during symmetry operations. Useful in; generating SO information and Cartesian displacement SALCs.; param mol Molecule to form mapping matrix from.; returns Integer matrix of dimension natoms X nirreps. """"""; # create the character table for the point group; ct = mol.point_group().char_table(). natom = mol.natom(); ng = ct.order(); atom_map = [0] * natom; for i in range(natom):; atom_map[i] = [0] * ng. np = [0.0, 0.0, 0.0]; so = SymmetryOperation(). # loop over all centers; for i in range(natom):; ac = mol.xyz(i). # then for each symop in the pointgroup, transform the coordinates of; # center ""i"" and see which atom it maps into; for g in range(ng):; so = ct.symm_operation(g). for ii in range(3):; np[ii] = 0; for jj in range(3):; np[ii] += so[ii][jj] * ac[jj]. atom_map[i][g] = mol.atom_at_position(np, 0.05); if atom_map[i][g] < 0:; print("""""" Molecule:\n""""""); mol.print_out(); print("""""" attempted to find atom at\n""""""); print("""""" %lf %lf %lf\n"""""" % (np[0], np[1], np[2])); raise ValidationError(""ERROR: Symmetry operation %d did not map atom %d to another atom:\n"" % (g, i + 1)). return atom_map. # TODO outfile; # ignored =, +, 0, += assignment operators; # no pubchem; # TODO rename save_string_for_psi4; # TODO add no_com no_reorint in save string for psi4. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:1878,Energy Efficiency,charge,charge,1878," this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #; from __future__ import absolute_import; from __future__ import print_function; import os; import re; import copy; import math; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict; from .periodictable import *; from .physconst import *; from .vecutil import *; from .exceptions import *; #from libmintscoordentry import *; from .libmintscoordentry import NumberValue, VariableValue, CartesianEntry, ZMatrixEntry; from .libmintspointgrp import SymmOps, similar, SymmetryOperation, PointGroup. #from libmintspointgrp import PointGroups; #print PointGroups. LINEAR_A_TOL = 1.0E-2 # When sin(a) is below this, we consider the angle to be linear; DEFAULT_SYM_TOL = 1.0E-8; FULL_PG_TOL = 1.0e-8; ZERO = 1.0E-14; NOISY_ZERO = 1.0E-8. [docs]class LibmintsMolecule(object):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Mole",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:2994,Energy Efficiency,charge,charge,2994,"tin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False # TODO None?. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:3045,Energy Efficiency,charge,charge,3045,"ments by other psi4 developers. Major; differences from the C++ class are: no basisset handling, no symmetry,; no pubchem, no efp, no discarding dummies. This class translated so; that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False # TODO None?. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragmen",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:4064,Energy Efficiency,charge,charge,4064,"the user; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False # TODO None?. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule; self.pg = None; # Full point group; self.full_pg = 'C1'; # n of the highest rotational axis Cn; self.PYfull_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = None; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array (length 1st dim nunique); self.equiv = 0; # Atom to ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:5778,Energy Efficiency,charge,charge,5778,"self.PYfull_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = None; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array (length 1st dim nunique); self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(sel",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:5902,Energy Efficiency,charge,charge,5902,"# Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array (length 1st dim nunique); self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:5934,Energy Efficiency,charge,charge,5934,"# Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array (length 1st dim nunique); self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometr",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:6042,Energy Efficiency,charge,charge,6042,"ue); self.equiv = 0; # Atom to unique atom mapping array (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise Validat",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:6101,Energy Efficiency,charge,charge,6101,"ay (length natom); self.PYatom_to_unique = 0. if psi4molstr:; self.create_molecule_from_string(psi4molstr). # <<< Simple Methods for Basic Molecule Information >>>. [docs] def name(self):; """"""Get molecule name. >>> print H2OH2O.name(); water_dimer. """"""; return self.PYname. [docs] def set_name(self, name):; """"""Set molecule name. >>> H2OH2O.set_name('water_dimer'). """"""; self.PYname = name. [docs] def natom(self):; """"""Number of atoms. >>> print H2OH2O.natom(); 6. """"""; return len(self.atoms). [docs] def nallatom(self):; """"""Number of all atoms (includes dummies). >>> print H2OH2O.nallatom(); 7. """"""; return len(self.full_atoms). [docs] def molecular_charge(self):; """"""Gets the molecular charge. >>> print H2OH2O.molecular_charge(); -2. """"""; return self.PYmolecular_charge. [docs] def set_molecular_charge(self, charge):; """"""Sets the molecular charge. >>> H2OH2O.set_molecular_charge(-2). """"""; self.PYcharge_specified = True; self.PYmolecular_charge = charge. [docs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Molecule::set_units: argument must be 'Angs",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:7465,Energy Efficiency,charge,charge,7465,"multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Molecule::set_units: argument must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn is None:; return temp; else:; return temp[posn]. [docs] def mass(self, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:8750,Energy Efficiency,charge,charge,8750,"e()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn is None:; return temp; else:; return temp[posn]. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:9236,Energy Efficiency,charge,charge,9236,"48769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn is None:; return temp; else:; return temp[posn]. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:9268,Energy Efficiency,charge,charge,9268,"48769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = scale(self.atoms[atom].compute(), self.input_units_to_au); if posn is None:; return temp; else:; return temp[posn]. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dum",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:9356,Energy Efficiency,charge,charge,9356,"put_units_to_au); if posn is None:; return temp; else:; return temp[posn]. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:9401,Energy Efficiency,charge,charge,9401,"temp; else:; return temp[posn]. [docs] def mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_uni",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:9450,Energy Efficiency,charge,charge,9450," mass(self, atom):; """"""Returns mass of atom (0-indexed). >>> print H2OH2O.mass(4); 1.00782503207. """"""; if self.atoms[atom].mass() != 0.0:; return self.atoms[atom].mass(). if math.fabs(self.atoms[atom].Z() - int(self.atoms[atom].Z())) > 0.0:; print(""""""WARNING: Obtaining masses from atom with fractional charge...may be incorrect!!!\n""""""); # TODO outfile; return z2mass[int(self.atoms[atom].Z())]. [docs] def symbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed). >>> print H2OH2O.symbol(4); H. """"""; return self.atoms[atom].symbol(). [docs] def label(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in the input file (C2, H4). (0-indexed). >>> print H2OH2O.label(4); H3. """"""; return self.atoms[atom].label(). [docs] def charge(self, atom):; """"""Returns charge of atom (0-indexed).; Related to SAD guess in libmints version. >>> print H2OH2O.charge(4); 1.0. """"""; return self.atoms[atom].charge(). [docs] def fZ(self, atom):; """"""Nuclear charge of atom (includes dummies). >>> print H2OH2O.fZ(4); 8. """"""; return self.full_atoms[atom].Z(). [docs] def fx(self, atom):; """"""x position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fx(4); 2.55231135823. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[0]. [docs] def fy(self, atom):; """"""y position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fy(4); 0.210645882307. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[1]. [docs] def fz(self, atom):; """"""z position of atom (0-indexed, includes dummies) in Bohr. >>> print H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):;",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:11052,Energy Efficiency,charge,charge,11052," H2OH2O.fz(4); 0.0. """"""; return self.input_units_to_au * self.full_atoms[atom].compute()[2]. [docs] def fxyz(self, atom):; """"""Returns a Vector3 with x, y, z position of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies) (0-indexed). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; for fr in range(self.nfragments()):; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:11209,Energy Efficiency,charge,charge,11209,"tion of atom; (0-indexed) in Bohr (includes dummies). >>> print H2OH2O.fxyz(4); [2.5523113582286716, 0.21064588230662976, 0.0]. """"""; return scale(self.full_atoms[atom].compute(), self.input_units_to_au). [docs] def fmass(self, atom):; """"""Returns mass of atom (0-indexed, includes dummies). >>> print H2OH2O.fmass(4); 15.9949146196. """"""; return self.full_atoms[atom].mass(). [docs] def fsymbol(self, atom):; """"""Returns the cleaned up label of the atom (C2 => C, H4 = H) (includes dummies) (0-indexed). >>> print H2OH2O.fsymbol(4); O. """"""; return self.full_atoms[atom].symbol(). [docs] def flabel(self, atom):; """"""Returns the original label of the atom (0-indexed) as given in; the input file (C2, H4) (includes dummies). >>> print H2OH2O.flabel(4); O2. """"""; return self.full_atoms[atom].label(). [docs] def fcharge(self, atom):; """"""Returns charge of atom (0-indexed, includes dummies).; Related to SAD guess in libmints version. >>> print H2OH2O.fcharge(4); 8.0. """"""; return self.full_atoms[atom].charge(). # <<< Simple Methods for Fragmentation >>>. [docs] def nfragments(self):; """"""The number of fragments in the molecule. >>> print H2OH2O.nfragments(); 2. """"""; return len(self.fragments). [docs] def nactive_fragments(self):; """"""The number of active fragments in the molecule. >>> print H2OH2O.nactive_fragments(); 2. """"""; n = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Real':; n += 1; return n. [docs] def activate_all_fragments(self):; """"""Sets all fragments in the molecule to be active.""""""; self.lock_frame = False; for fr in range(self.nfragments()):; self.fragment_types[fr] = 'Real'. [docs] def set_active_fragment(self, fr):; """"""Tags fragment index *fr* as composed of real atoms.""""""; self.lock_frame = False; self.fragment_types[fr - 1] = 'Real'. [docs] def set_active_fragments(self, reals):; """"""Tags the fragments in array *reals* as composed of real atoms.""""""; self.lock_frame = False; for fr in reals:; self.fragment_types[fr - 1] = 'Real'. [docs] def set_gho",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:16629,Energy Efficiency,charge,charge,16629,"(-?\d+\.\d+|-?\d+\.|-?\.\d+|-?\d+|tda)\s*$', re.IGNORECASE); ghost = re.compile(r'@(.*)|Gh\((.*)\)', re.IGNORECASE). lines = re.split('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; self.PYsymmetry_from_input = symmetry.match(line).group(1).lower(). # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line.split()[0].strip()):; glines.append(line); else:; raise ValidationError('Molecule::create_molecule_from_string: Unidentifiable line in geometry specification: %s' % (line)). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of t",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:18624,Energy Efficiency,charge,charge,18624,"lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:18671,Energy Efficiency,charge,charge,18671,"lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:18927,Energy Efficiency,charge,charge,18927,"ag = []. # handle atom markers; else:; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomm = atom.match(line.split()[0].strip().upper()); atomLabel = atomm.group('label'); atomSym = atomm.group('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Er",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:19134,Energy Efficiency,charge,charge,19134,"('symbol'). # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; ghostAtom = False if (atomm.group('gh1') is None and atomm.group('gh2') is None) else True. # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_mol",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:19645,Energy Efficiency,charge,charge,19645,"tAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomM",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:20637,Energy Efficiency,charge,charge,20637,"charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple t",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:22037,Energy Efficiency,charge,charge,22037,"ries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Molecule::create_molecule_from_string: Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or ",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:25688,Energy Efficiency,charge,charge,25688,"Z, fileAtom, el2mass[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); f",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:26330,Energy Efficiency,charge,charge,26330,"u = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; # TODO if (Process::environment.options.get_int(""PRINT"") > 2) {; text += ""\n""; for i in range(self.natom()):; text += """""" %8s\n"""""" % (self.label(i)); for bas in self.atoms[i].basissets().keys():; text += """""" %-15s %-20s %s\n"""""" % (bas,; self.atoms[i].basissets()[bas], self.atoms[i].shells()[bas]); text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_i",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:27577,Energy Efficiency,charge,charge,27577,"--------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; # TODO if (Process::environment.options.get_int(""PRINT"") > 2) {; text += ""\n""; for i in range(self.natom()):; text += """""" %8s\n"""""" % (self.label(i)); for bas in self.atoms[i].basissets().keys():; text += """""" %-15s %-20s %s\n"""""" % (bas,; self.atoms[i].basissets()[bas], self.atoms[i].shells()[bas]); text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity(",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:28479,Energy Efficiency,charge,charge,28479,""""""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """,MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:29336,Energy Efficiency,charge,charge,29336,""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j) * psi_bohr2angstroms); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_full(self):; """"""Print full atom list. Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:30037,Energy Efficiency,charge,charge,30037,"Same as :py:func:`print_out` only displays dummy atoms. """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); if self.full_pg:; text += """""" Full point group: %s\n\n"""""" % (self.get_full_point_group()); text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; (self.units(), self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.nallatom()):; geom = self.full_atoms[i].compute(); text += """""" %8s%4s """""" % (self.fsymbol(i), """" if self.fZ(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print(text); # TODO outfile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; """"""; text = """"; if self.nallatom():; text += "" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr"",; self.molecular_charge(), self.multiplicity()); for i in range(self.nallatom()):; if self.fZ(i) or self.fsymbol(i) == ""X"":; text += "" %-8s"" % (self.fsymbol(i)); else:; text += "" %-8s"" % (""Gh("" + self.fsymbol(i) + "")""); text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """""" %-10s=%16.10f\n"""""" % (vb, val); text += ""\n"". print(text); # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units()",MatchSource.WIKI,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html
