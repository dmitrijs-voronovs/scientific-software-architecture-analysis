id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:9637,Security,access,accessSpecDecl,9637,")). Return typeNameParameters. Matcher<Attr>attrMatcher<Attr>...; Matches attributes.; Attributes may be attached with a variety of different syntaxes (including; keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,; and ``#pragma``s). They may also be implicit. Given; struct [[nodiscard]] Foo{};; void bar(int * __attribute__((nonnull)) );; __declspec(noinline) void baz();. #pragma omp declare simd; int min();; attr(); matches ""nodiscard"", ""nonnull"", ""noinline"", and the whole ""#pragma"" line. Matcher<CXXBaseSpecifier>cxxBaseSpecifierMatcher<CXXBaseSpecifier>...; Matches class bases. Examples matches public virtual B.; class B {};; class C : public virtual B {};. Matcher<CXXCtorInitializer>cxxCtorInitializerMatcher<CXXCtorInitializer>...; Matches constructor initializers. Examples matches i(42).; class C {; C() : i(42) {}; int i;; };. Matcher<Decl>accessSpecDeclMatcher<AccessSpecDecl>...; Matches C++ access specifier declarations. Given; class C {; public:; int a;; };; accessSpecDecl(); matches 'public:'. Matcher<Decl>bindingDeclMatcher<BindingDecl>...; Matches binding declarations; Example matches foo and bar; (matcher = bindingDecl(). auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>blockDeclMatcher<BlockDecl>...; Matches block declarations. Example matches the declaration of the nameless block printing an input; integer. myFunc(^(int p) {; printf(""%d"", p);; }). Matcher<Decl>classTemplateDeclMatcher<ClassTemplateDecl>...; Matches C++ class template declarations. Example matches Z; template<class T> class Z {};. Matcher<Decl>classTemplatePartialSpecializationDeclMatcher<ClassTemplatePartialSpecializationDecl>...; Matches C++ class template partial specializations. Given; template<class T1, class T2, int I>; class A {};. template<class T, int I>; class A<T, T*, I> {};. template<>; class A<int, int, 1> {};; classTemplatePartialSpecializationDecl(); matches the specialization A<T,T*,I> but not A<int,int,1>. Matcher<Decl>classTemplateSpecializa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48729,Security,inject,injectedClassNameTypeMatcher,48729,"elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48793,Security,inject,injected,48793,"larations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48889,Security,inject,injectedClassNameType,48889,"um class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:132835,Security,inject,injected,132835,"Matcher; Matches if the node or any descendant matches. Generates results for each match. For example, in:; class A { class B {}; class C {}; };; The matcher:; cxxRecordDecl(hasName(""::A""),; findAll(cxxRecordDecl(isDefinition()).bind(""m""))); will generate results for A, B and C. Usable as: Any Matcher. Matcher<*>forEachDescendantMatcher<*>; Matches AST nodes that have descendant AST nodes that match the; provided matcher. Example matches X, A, A::X, B, B::C, B::C::X; (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(""X""))))); class X {};; class A { class X {}; }; // Matches A, because A::X is a class of name; // X inside A.; class B { class C { class X {}; }; };. DescendantT must be an AST base type. As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for; each result that matches instead of only on the first one. Note: Recursively combined ForEachDescendant can cause many matches:; cxxRecordDecl(forEachDescendant(cxxRecordDecl(; forEachDescendant(cxxRecordDecl()); ))); will match 10 times (plus injected class name matches) on:; class A { class B { class C { class D { class E {}; }; }; }; };. Usable as: Any Matcher. Matcher<*>forEachMatcher<*>; Matches AST nodes that have child AST nodes that match the; provided matcher. Example matches X, Y, Y::X, Z::Y, Z::Y::X; (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(""X""))); class X {};; class Y { class X {}; }; // Matches Y, because Y::X is a class of name X; // inside Y.; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. As opposed to 'has', 'forEach' will cause a match for each result that; matches instead of only on the first one. Usable as: Any Matcher. Matcher<*>hasAncestorMatcher<*>; Matches AST nodes that have an ancestor that matches the provided; matcher. Given; void f() { if (true) { int x = 42; } }; void g() { for (;;) { int x = 43; } }; expr(integerLiteral(hasAncestor(ifStmt()))) matches 42, but not 43. Usable as: Any Matcher. Ma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:135264,Security,access,accessing,135264,"hat match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Because CallExpr and CXXConstructExpr do not share a common; base class with API accessing arguments etc, AST Matchers for code; which should match both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invocation(hasArgument(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:147903,Security,access,access,147903,"iendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<CXXConstructExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CXXConstructExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a construct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:174226,Security,access,access,174226,": Callee cannot take the more general internal::Matcher<Expr>; because this introduces ambiguous overloads with calls to Callee taking a; internal::Matcher<Decl>, as the matcher hierarchy is purely; implemented in terms of implicit casts. Matcher<CallExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CallExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CallExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CallExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call express",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:1751,Testability,test,testing,1751,"u can; find all matchers that can be used to match on Stmt nodes.; The exception to that rule are matchers that can match on any node. Those; are marked with a * and are listed in the beginning of each category.; Note that the categorization of matchers is a great help when you combine; them into matcher expressions. You will usually want to form matcher expressions; that read like english sentences by alternating between node matchers and; narrowing or traversal matchers, like this:. recordDecl(hasDescendant(; ifStmt(hasTrueExpression(; expr(hasDescendant(; ifStmt())))))). Traverse Mode. The default mode of operation of AST Matchers visits all nodes in the AST,; even if they are not spelled in the source. This is; AsIs mode. This mode requires writing AST matchers; that explicitly traverse or ignore implicit nodes, such as parentheses; surrounding an expression or expressions with cleanups. These implicit; nodes are not always obvious from the syntax of the source code, and so this; mode requires careful consideration and testing to get the desired behavior; from an AST matcher. In addition, because template instantiations are matched in the default mode,; transformations can be accidentally made to template declarations. Finally,; because implicit nodes are matched by default, transformations can be made on; entirely incorrect places in the code.; For these reasons, it is possible to ignore AST nodes which are not spelled; in the source using the IgnoreUnlessSpelledInSource; mode. This is likely to be far less error-prone for users who are not already; very familiar with where implicit nodes appear in the AST. It is also likely; to be less error-prone for experienced AST users, as difficult cases do not; need to be encountered and matcher expressions adjusted for these cases.; In clang-query, the mode can be changed with. set traversal IgnoreUnlessSpelledInSource. This affects both matchers and AST dump output in results. When using the C++ API such as in clang-ti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14424,Testability,test,test,14424,"Matcher<FunctionTemplateDecl>...; Matches C++ function template declarations. Example matches f; template<class T> void f(T t) {}. Matcher<Decl>indirectFieldDeclMatcher<IndirectFieldDecl>...; Matches indirect field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14453,Testability,test,test,14453,"Matcher<FunctionTemplateDecl>...; Matches C++ function template declarations. Example matches f; template<class T> void f(T t) {}. Matcher<Decl>indirectFieldDeclMatcher<IndirectFieldDecl>...; Matches indirect field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14527,Testability,test,test,14527,"Matcher<FunctionTemplateDecl>...; Matches C++ function template declarations. Example matches f; template<class T> void f(T t) {}. Matcher<Decl>indirectFieldDeclMatcher<IndirectFieldDecl>...; Matches indirect field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14656,Testability,test,test,14656,"t field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:14720,Testability,test,test,14720,"t field declarations. Given; struct X { struct { int a; }; };; indirectFieldDecl(); matches 'a'. Matcher<Decl>labelDeclMatcher<LabelDecl>...; Matches a declaration of label. Given; goto FOO;; FOO: bar();; labelDecl(); matches 'FOO:'. Matcher<Decl>linkageSpecDeclMatcher<LinkageSpecDecl>...; Matches a declaration of a linkage specification. Given; extern ""C"" {}; linkageSpecDecl(); matches ""extern ""C"" {}"". Matcher<Decl>namedDeclMatcher<NamedDecl>...; Matches a declaration of anything that could have a name. Example matches X, S, the anonymous union type, i, and U;; typedef int X;; struct S {; union {; int i;; } U;; };. Matcher<Decl>namespaceAliasDeclMatcher<NamespaceAliasDecl>...; Matches a declaration of a namespace alias. Given; namespace test {}; namespace alias = ::test;; namespaceAliasDecl(); matches ""namespace alias"" but not ""namespace test"". Matcher<Decl>namespaceDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:21836,Testability,test,testStructBinding,21836,"efault(private); #pragma omp parallel default(firstprivate); #pragma omp parallel. ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``,; `` default(private)`` and ``default(firstprivate)``. Matcher<QualType>qualTypeMatcher<QualType>...; Matches QualTypes in the clang AST. Matcher<Stmt>addrLabelExprMatcher<AddrLabelExpr>...; Matches address of label statements (GNU extension). Given; FOO: bar();; void *ptr = &&FOO;; goto *bar;; addrLabelExpr(); matches '&&FOO'. Matcher<Stmt>arrayInitIndexExprMatcher<ArrayInitIndexExpr>...; The arrayInitIndexExpr consists of two subexpressions: a common expression; (the source array) that is evaluated once up-front, and a per-element initializer; that runs once for each array element. Within the per-element initializer,; the current index may be obtained via an ArrayInitIndexExpr. Given; void testStructBinding() {; int a[2] = {1, 2};; auto [x, y] = a;; }; arrayInitIndexExpr() matches the array index that implicitly iterates; over the array `a` to copy each element to the anonymous array; that backs the structured binding `[x, y]` elements of which are; referred to by their aliases `x` and `y`. Matcher<Stmt>arrayInitLoopExprMatcher<ArrayInitLoopExpr>...; Matches a loop initializing the elements of an array in a number of contexts:; * in the implicit copy/move constructor for a class with an array member; * when a lambda-expression captures an array by value; * when a decomposition declaration decomposes an array. Given; void testLambdaCapture() {; int a[10];; auto Lam1 = [a]() {; return;; };; }; arrayInitLoopExpr() matches the implicit loop that initializes each element of; the implicit array field inside the lambda object, that represents the array `a`; captured by value. Matcher<Stmt>arraySubscriptExprMatcher<ArraySubscriptExpr>...; Matches array subscript expressions. Given; int i = a[1];; arraySubscriptExpr(); matches ""a[1]"". Matcher<Stmt>asmStmtMatcher<AsmStmt>...; Matches asm statements. int i = 100;; __asm(""mov ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:22480,Testability,test,testLambdaCapture,22480,"ion; (the source array) that is evaluated once up-front, and a per-element initializer; that runs once for each array element. Within the per-element initializer,; the current index may be obtained via an ArrayInitIndexExpr. Given; void testStructBinding() {; int a[2] = {1, 2};; auto [x, y] = a;; }; arrayInitIndexExpr() matches the array index that implicitly iterates; over the array `a` to copy each element to the anonymous array; that backs the structured binding `[x, y]` elements of which are; referred to by their aliases `x` and `y`. Matcher<Stmt>arrayInitLoopExprMatcher<ArrayInitLoopExpr>...; Matches a loop initializing the elements of an array in a number of contexts:; * in the implicit copy/move constructor for a class with an array member; * when a lambda-expression captures an array by value; * when a decomposition declaration decomposes an array. Given; void testLambdaCapture() {; int a[10];; auto Lam1 = [a]() {; return;; };; }; arrayInitLoopExpr() matches the implicit loop that initializes each element of; the implicit array field inside the lambda object, that represents the array `a`; captured by value. Matcher<Stmt>arraySubscriptExprMatcher<ArraySubscriptExpr>...; Matches array subscript expressions. Given; int i = a[1];; arraySubscriptExpr(); matches ""a[1]"". Matcher<Stmt>asmStmtMatcher<AsmStmt>...; Matches asm statements. int i = 100;; __asm(""mov al, 2"");; asmStmt(); matches '__asm(""mov al, 2"")'. Matcher<Stmt>atomicExprMatcher<AtomicExpr>...; Matches atomic builtins.; Example matches __atomic_load_n(ptr, 1); void foo() { int *ptr; __atomic_load_n(ptr, 1); }. Matcher<Stmt>autoreleasePoolStmtMatcher<ObjCAutoreleasePoolStmt>...; Matches an Objective-C autorelease pool statement. Given; @autoreleasepool {; int x = 0;; }; autoreleasePoolStmt(stmt()) matches the declaration of ""x""; inside the autorelease pool. Matcher<Stmt>binaryConditionalOperatorMatcher<BinaryConditionalOperator>...; Matches binary conditional operator expressions (GNU extension). Example ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53525,Testability,log,logical,53525,"ypedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is eq",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:78055,Testability,test,test,78055,"0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<CallExpr>argumentCountAtLeastunsigned N; Checks that a call expression or a constructor call expression has at least; the specified number of arguments (including absent default arguments). Example matches f(0, 0) and g(0, 0, 0); (matcher = callExpr(argumentCountAtLeast(2))); void f(int x, int y);; void g(int x, int y, int z);; f(0, 0);; g(0, 0, 0);. Matcher<CallExpr>argumentCountIsunsigned N; Checks that a call expression or a constructor call expression has; a specific number of arguments (including absent default arguments). Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2))); void f(int x, int y);; f(0, 0);. Matcher<CallExpr>usesADL; Matches call expressions which were resolved using ADL. Example matches y(x) but not y(42) or NS::y(x).; namespace NS {; struct X {};; void y(X);; }. void y(...);. void test() {; NS::X x;; y(x); // Matches; NS::y(x); // Doesn't match; y(42); // Doesn't match; using NS::y;; y(x); // Found by both unqualified lookup and ADL, doesn't match; }. Matcher<CastExpr>hasCastKindCastKind Kind; Matches casts that has a given cast kind. Example: matches the implicit cast around 0; (matcher = castExpr(hasCastKind(CK_NullToPointer))); int *p = 0;. If the matcher is use from clang-query, CastKind parameter; should be passed as a quoted string. e.g., hasCastKind(""CK_NullToPointer""). Matcher<CharacterLiteral>equalsbool Value. Matcher<CharacterLiteral>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the pos",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11578,Usability,guid,guide,11578,"specialization A<T,T*,I> but not A<int,int,1>. Matcher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11615,Usability,guid,guide,11615,"cher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher<DecompositionDecl>...; Matches decomposition-decla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:61238,Usability,guid,guide,61238,"nstructExpr(requiresZeroInitialization())); will match the implicit array filler for pt[1]. Matcher<CXXConstructorDecl>isCopyConstructor; Matches constructor declarations that are copy constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3. Matcher<CXXConstructorDecl>isDefaultConstructor; Matches constructor declarations that are default constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3. Matcher<CXXConstructorDecl>isDelegatingConstructor; Matches constructors that delegate to another constructor. Given; struct S {; S(); // #1; S(int) {} // #2; S(S &&) : S() {} // #3; };; S::S() : S(0) {} // #4; cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not; #1 or #2. Matcher<CXXConstructorDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:62228,Usability,guid,guide,62228,"duction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXCtorInitializer>isBaseInitializer; Matches a constructor initializer if it is initializing a base, as; opposed to a member. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:63950,Usability,guid,guide,63950,"ber. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constructor initializer if it is initializing a member, as; opposed to a base. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer())); will match D(int), but not match E(). Matcher<CXXCtorInitializer>isWritten; Matches a constructor initializer if it is explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:183,Availability,avail,available,183,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:557,Availability,error,error,557,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:1313,Availability,down,downcasts,1313," than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:2170,Availability,error,error,2170,"res user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versions of GCC) is the; C89 standard plus a lot of extensions. C89 doesn't have an inline; keyword, but GCC recognizes it as an extension and just treats it as a hint to; the optimizer.; There are several ways to fix this problem:. Change add to a static inline; function. This is usually the right solution if only one; translation unit needs to use the function. static; inline functions are always resolved within the translation; unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add som",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4380,Availability,error,errors,4380,"o relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5120,Availability,error,error,5120,"ions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undete",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5164,Availability,error,error,5164,". These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5789,Availability,error,error,5789,"; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; retu",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5883,Availability,error,error,5883,"tory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program whi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5908,Availability,error,error,5908,"tory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program whi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6249,Availability,error,error,6249,"orted; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely br",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6266,Availability,error,error,6266,"move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6305,Availability,error,error,6305,"move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8509,Availability,error,error,8509,"r (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Obje",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8543,Availability,error,error,8543,"assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArra",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9075,Availability,error,error,9075,"l register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Cla",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9535,Availability,error,error,9535," suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10253,Availability,error,error,10253,"ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werro",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12012,Availability,error,error,12012,"ted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a clas",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14084,Availability,error,error,14084,"the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was decla",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16272,Availability,error,errors,16272,"x this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16341,Availability,error,error,16341,"call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16548,Availability,error,error,16548,"ration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:18227,Availability,error,error,18227,"at we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19737,Availability,down,downside,19737,"essor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:20976,Availability,error,error,20976,"lass type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows imp",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21702,Availability,error,error,21702,"member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; alre",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21877,Availability,avail,available,21877,"ion parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21931,Availability,down,downcasts,21931," void f(int a, int a);. Clang diagnoses this error (where the parameter name has been redeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, meth",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:21998,Availability,down,downcasts,21998,"edeclared). To fix this problem, rename one of the parameters. C++11 compatibility. Deleted special member functions. In C++11, the explicit declaration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22394,Availability,error,error,22394,"ion process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22402,Availability,down,downcast,22402,"mplementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22419,Availability,error,error,22419,"before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22474,Availability,down,downcast,22474,"before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22642,Availability,down,downcast,22642,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7464,Deployability,integrat,integrated,7464,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7549,Deployability,integrat,integrated,7549,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7665,Deployability,integrat,integrated,7665," __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instructio",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11652,Energy Efficiency,allocate,allocate,11652,"e or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where th",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:563,Integrability,message,message,563,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:811,Integrability,interface,interfaces,811,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:877,Integrability,protocol,protocol,877,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:987,Integrability,depend,dependent,987,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4030,Integrability,interface,interfaces,4030,"Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue cas",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6924,Integrability,depend,depends,6924," return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. as",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7464,Integrability,integrat,integrated,7464,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7549,Integrability,integrat,integrated,7549,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7665,Integrability,integrat,integrated,7665," __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instructio",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8515,Integrability,message,message,8515,"r (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Obje",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9235,Integrability,interface,interfaces,9235,"; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9577,Integrability,interface,interface,9577," suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10558,Integrability,interface,interface,10558," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10572,Integrability,protocol,protocol,10572," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10632,Integrability,interface,interface,10632,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10646,Integrability,protocol,protocol,10646,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10837,Integrability,interface,interface,10837,"tanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12120,Integrability,depend,dependent,12120,"ted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a clas",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12868,Integrability,depend,dependent,12868,"ate <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a class type, it looks up the; name in that class's namespace; the result is all the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& valu",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:13376,Integrability,depend,dependent,13376,"{; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a class type, it looks up the; name in that class's namespace; the result is all the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14194,Integrability,depend,dependent,14194,"the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& value) {; std::cout << value << ""\n"";; }. namespace ns {; struct Data {};; }. std::ostream& operator<<(std::ostream& out, ns::Data data) {; return out << ""Some data"";; }. void Use() {; Dump(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was decla",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:14952,Integrability,depend,dependent,14952,"(ns::Data());; }; Again, Clang complains:. my_file2.cpp:5:13: error: call to function 'operator<<' that is neither visible in the template definition nor found by argument-dependent lookup; std::cout << value << ""\n"";; ^; my_file2.cpp:17:3: note: in instantiation of function template specialization 'Dump<ns::Data>' requested here; Dump(ns::Data());; ^; my_file2.cpp:12:15: note: 'operator<<' should be declared prior to the call site or in namespace 'ns'; std::ostream& operator<<(std::ostream& out, ns::Data data) {; ^. Just like before, unqualified lookup didn't find any declarations; with the name operator<<. Unlike before, the argument; types both contain class types: one of them is an instance of the; class template type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typena",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:15752,Integrability,depend,dependent,15752," type std::basic_ostream, and the other is the; type ns::Data that we declared above. Therefore, ADL will; look in the namespaces std and ns for; an operator<<. Since one of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:15913,Integrability,depend,dependent,15913," of the argument types was; still dependent during the template definition, ADL isn't done until; the template is instantiated during Use, which means that; the operator<< we want it to find has already been; declared. Unfortunately, it was declared in the global namespace, not; in either of the namespaces that ADL will look in!. There are two ways to fix this problem:; Make sure the function you want to call is declared before the; template that might call it. This is the only option if none of its; argument types contain classes. You can do this either by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16485,Integrability,depend,dependent,16485," by moving the; template definition, or by moving the function definition, or by; adding a forward declaration of the function before the template.; Move the function into the same namespace as one of its arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the me",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16693,Integrability,depend,dependent,16693,"arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed t",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:17036,Integrability,depend,depends,17036," void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they a",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:17958,Integrability,depend,depend,17958," the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed to accept it:. class IOOptions;; template <class T> bool read(T &value) {; IOOptions opts;; return read(opts, value);; }. class IOOptions { bool ForceReads; };; bool read(const IOOptions &opts, int &x);; template bool read<>(int &);. The standard says that types which don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:18995,Integrability,depend,dependent,18995,"ich don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Defa",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22262,Integrability,interface,interface,22262,"nstructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code wi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22284,Integrability,interface,interface,22284,"nstructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code wi",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23307,Integrability,interface,interface,23307,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23428,Integrability,message,message-send,23428,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:450,Modifiability,portab,portability,450,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:687,Modifiability,variab,variable,687,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:733,Modifiability,variab,variables,733,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:853,Modifiability,variab,variables,853,". Language Compatibility. Language Compatibility. Clang strives to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlin",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:1127,Modifiability,variab,variable,1127,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4296,Modifiability,portab,portable,4296," set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem,",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4721,Modifiability,rewrite,rewrite,4721,"vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4866,Modifiability,rewrite,rewrite,4866,"ve leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; ret",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5406,Modifiability,variab,variable,5406,"ese, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5473,Modifiability,variab,variable,5473,"functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping i",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5590,Modifiability,variab,variable,5590,".h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initial",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5641,Modifiability,variab,variable,5641,".h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initial",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6363,Modifiability,variab,variable,6363,":. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allo",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6411,Modifiability,rewrite,rewrite,6411,"ps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6467,Modifiability,variab,variable,6467,"ps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6638,Modifiability,variab,variables,6638,", leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6686,Modifiability,variab,variable,6686,"ider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler i",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6886,Modifiability,variab,variables,6886,"^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific exam",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7048,Modifiability,variab,variables,7048,"f scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7101,Modifiability,variab,variables,7101,"f scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7156,Modifiability,variab,variables,7156,".e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The s",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9367,Modifiability,variab,variables,9367,"en though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p)",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10544,Modifiability,variab,variables,10544," of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10614,Modifiability,variab,variables,10614,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10690,Modifiability,variab,variable,10690,"o; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11138,Modifiability,variab,variable,11138," Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11349,Modifiability,variab,variable,11349," to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says tha",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19976,Modifiability,variab,variable,19976," ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function prototype in C++ code, e.g. void f(int a, int a);. Clang diagnoses this error (where the ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:23112,Modifiability,extend,extend,23112,",; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In particular, it is impossible to use property dot; syntax in Objective-C++ with the property name class, so; the following code will fail to parse:. @interface I {; int cls;; }; + (int)class;; @end. @implementation I; - (int) Meth { return I.class; }; @end. Use explicit message-send syntax instead, i.e. [I class]. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:2041,Performance,optimiz,optimization,2041,"mplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versions of GCC) is the; C89 standard plus a lot of extensions. C89 doesn't have an inline; keyword, but GCC recognizes it as an extension and just treats it as a hint to; the optimizer.; There are several ways to fix this problem:. Change add to a static inline; function. This is usually the right solution if only one; translation unit needs to use the function. static; inline functions are always resolved within the translation; unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore i",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:2484,Performance,optimiz,optimizer,2484,"U C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; main will have an unresolved reference to that other; definition. Therefore we'll get a (correct) link-time error like this:. Undefined symbols:; ""_add"", referenced from:; _main in cc-y1jXIr.o. By contrast, GNU C89 mode (used by default in older versions of GCC) is the; C89 standard plus a lot of extensions. C89 doesn't have an inline; keyword, but GCC recognizes it as an extension and just treats it as a hint to; the optimizer.; There are several ways to fix this problem:. Change add to a static inline; function. This is usually the right solution if only one; translation unit needs to use the function. static; inline functions are always resolved within the translation; unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-s",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:22121,Safety,unsafe,unsafe,22121,"laration of a move constructor or a move; assignment operator within a class deletes the implicit declaration; of the copy constructor and copy assignment operator. This change came; fairly late in the C++11 standardization process, so early; implementations of C++11 (including Clang before 3.0, GCC before 4.7,; and Visual Studio 2010) do not implement this rule, leading them to; accept this ill-formed code:. struct X {; X(X&&); // deletes implicit copy constructor:; // X(const X&) = delete;; };. void f(X x);; void g(X x) {; f(x); // error: X has a deleted copy constructor; }. This affects some early C++11 code, including Boost's popular shared_ptr; up to version 1.47.0. The fix for Boost's shared_ptr is; available here. Objective-C++ compatibility. Implicit downcasts. Due to a bug in its implementation, GCC allows implicit downcasts; of Objective-C pointers (from a base class to a derived class) when; calling functions. Such code is inherently unsafe, since the object; might not actually be an instance of the derived class, and is; rejected by Clang. For example, given this code:. @interface Base @end; @interface Derived : Base @end. void f(Derived *p);; void g(Base *p) {; f(p);; }. Clang produces the following error:. downcast.mm:6:3: error: no matching function for call to 'f'; f(p);; ^; downcast.mm:4:6: note: candidate function not viable: cannot convert from; superclass 'Base *' to subclass 'Derived *' for 1st argument; void f(Derived *p);; ^. If the downcast is actually correct (e.g., because the code has; already checked that the object has the appropriate type), add an; explicit cast:. f((Derived *)base);. Using class as a property name. In C and Objective-C, class is a normal identifier and; can be used to name fields, ivars, methods, and so on. In; C++, class is a keyword. For compatibility with existing; code, Clang permits class to be used as part of a method; selector in Objective-C++, but this does not extend to any other part; of the language. In parti",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:3749,Security,access,accessing,3749," unit, so you won't have to add a non-inline definition; of the function elsewhere in your program.; Remove the inline keyword from this definition of; add. The inline keyword is not required; for a function to be inlined, nor does it guarantee that it will be.; Some compilers ignore it completely. Clang treats it as a mild; suggestion from the programmer.; Provide an external (non-inline) definition; of add somewhere else in your program. The two; definitions must be equivalent!; Compile in the GNU C89 dialect by adding; -std=gnu89 to the set of Clang options. This option is; only recommended if the program source cannot be changed or if the; program also relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source f",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:4417,Usability,simpl,simple,4417,"o relies on additional C89-specific behavior that cannot; be changed. All of this only applies to C code; the meaning of inline; in C++ is very different from its meaning in either GNU89 or C99. ""missing"" vector __builtin functions. The Intel and AMD manuals document a number ""<*mmintrin.h>""; header files, which define a standardized API for accessing vector operations; on X86 CPUs. These functions have names like _mm_xor_ps and; _mm256_addsub_pd. Compilers have leeway to implement these functions; however they want. Since Clang supports an excellent set of native vector operations,; the Clang headers implement these interfaces in terms of the native vector; operations. In contrast, GCC implements these functions mostly as a 1-to-1 mapping to; builtin function calls, like __builtin_ia32_paddw128. These builtin; functions are an internal implementation detail of GCC, and are not portable to; the Intel compiler, the Microsoft compiler, or Clang. If you get build errors; mentioning these, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block ",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8146,Usability,clear,clear,8146,"ocal variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'su",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:8768,Usability,clear,clear,8768,"le of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyw",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11481,Usability,simpl,simple,11481," to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says tha",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19629,Usability,clear,clearer,19629,"typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:19894,Usability,simpl,simple,19894,"s soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Default initialization of const variable of a class type requires user-defined default constructor. If a class or struct has no user-defined default; constructor, C++ doesn't allow you to default construct a const; instance of it like this ([dcl.init], p9):. class Foo {; public:; // The compiler-supplied default constructor works fine, so we; // don't bother with defining one.; ...; };. void Bar() {; const Foo foo; // Error!; ...; }. To fix this, you can define a default constructor for the class:. class Foo {; public:; Foo() {}; ...; };. void Bar() {; const Foo foo; // Now the compiler is happy.; ...; }. An upcoming change to the C++ standard is expected to weaken this rule to only; apply when the compiler-supplied default constructor would leave a member; uninitialized. Clang implements the more relaxed rule in version 3.8 onwards. Parameter name lookup. Some versions of GCC allow the redeclaration of function parameter names within a function protot",MatchSource.DOCS,interpreter/llvm-project/clang/www/compatibility.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9972,Availability,error,errors,9972,25; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected neste,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:23465,Availability,error,error,23465,"type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator all",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24876,Availability,avail,available,24876,"ignature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:28153,Availability,error,error,28153,"on with non-trivial constructor; N/A. 405; CD6; Unqualified function name lookup; Yes. 406; CD1; Static data member in class with name for linkage purposes; Clang 2.9. 407; C++11; Named class with associated typedef: two names or one?; Clang 3.8. 408; CD2; sizeof applied to unknown-bound array static data member of template; Clang 3.4. 409; CD1; Obsolete paragraph missed by changes for issue 224; Yes. 410; CD1; Paragraph missed in changes for issue 166; No. 411; CD6; Use of universal-character-name in character versus string literals; Unknown. 412; NAD; Can a replacement allocation function be inline?; Clang 3.4. 413; CD1; Definition of ""empty class""; Yes. 414; CD1; Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instantiation; Yes. 416; CD1; Class must be complete to allow operator lookup?; Yes. 417; CD1; Using derived-class qualified name in out-of-class nested class definition; No. 418; CD6; Imperfect wording on error on multiple default arguments on a called function; No. 419; open; Can cast to virtual base class be done on partially-constructed object?; Not resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression eval",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38340,Availability,error,error,38340, overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:39405,Availability,failure,failure,39405,the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5. 577; CD3; void in an empty parameter list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference init,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:47713,Availability,error,errors,47713, Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/definitions in type-specifier-seqs and type-ids; Clang 3.0. 687; NAD; template keyword with unqualified-ids; Unknown. 688; CD1; Constexpr constructors and static initialization; Unknown. 689; CD5; Maximum values of signed and unsigned integers; Unknown. 690; CD2; The dynamic type of an rvalue reference; Unknown. 691; C++11; Template parameter packs in class template partial specializations; Unknown. 692; C++11; Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resol,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:48789,Availability,failure,failure,48789,"1; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic o",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:51124,Availability,error,error,51124,alification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751; CD2; Deriving from closure classes; Unknown. 752; CD2; Name lookup in nested lambda-expressions; Unknown. 753; CD2; Array names in lambda capture sets; Unknown. 754; CD2; Lambda expressions in default arguments of block-scope function declarations; Unknown. 755; CD3; Generalized lambda-captures; Unknown. 756; CD2; Dropping cv-qualification on members of closure objects; Unknown. 757; CD2; Types without linkage in declarations; Unknown. 758; C++11; Missing cases of declarations that are not definitions; Unknown. 759; CD2; Destruction of closure objects; Unknown. 760; CD2; this inside a nested class of a non-static member function; Unknown. 761; CD2; Inferred return type of closure ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74328,Availability,error,error,74328,d resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; Unknown. 1134; C++11; When is an explicitly-defaulted function defined?; Unknown. 1135; C++11; Explicitly-defaulted non-public specia,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78382,Availability,failure,failure,78382, inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:81720,Availability,failure,failure,81720,tion-call xvalues and decltype; Unknown. 1213; CD3; Array subscripting and xvalues; Clang 7. 1214; C++11; Kinds of initializers; Unknown. 1215; C++11; Definition of POD struct; Unknown. 1216; C++11; Exceptions “allowed” by a noexcept-specification; Unknown. 1217; NAD; Are deleted functions implicitly noexcept?; Unknown. 1218; C++11; What is the “currently-handled exception” in a multi-threaded program?; Unknown. 1219; C++11; Non-static data member initializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknown. 1226; CD3; Converting a braced-init-list default argument; Unknown. 1227; CD3; Mixing immediate and non-immediate contexts in deduction failure; Clang 3.0. 1228; NAD; Copy-list-initialization and explicit constructors; Unknown. 1229; C++11; Overload resolution with empty braced-init-list argument; Unknown. 1230; dup; Confusing description of ambiguity of destructor name; Unknown. 1231; C++11; Variadic templates requiring an empty pack expansion; Unknown. 1232; C++11; Creation of array temporaries using a braced-init-list; Unknown. 1233; C++11; Pack expansions and dependent calls; Unknown. 1234; C++11; abstract-declarator does not permit ... after ptr-operator; Unknown. 1235; C++11; “Unused” ellipsis and default arguments in partial ordering; Unknown. 1236; C++11; Inconsistently-interrelated examples; Unknown. 1237; C++11; Deprecated implicit copy assignment in example; Unknown. 1238; C++11; Overloading ambiguity binding reference to function; Unknown. 1239; C++11; Hexadecimal floating-point literals vs user-defined literals; Unknown. 1240; C++11; constexpr defaulted constructors; Unknown. 1241,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:84270,Availability,failure,failure,84270,d lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98247,Availability,failure,failure,98247,"; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98536,Availability,redundant,redundant,98536,"o linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:101777,Availability,failure,failure,101777,afting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignm,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106747,Availability,failure,failure,106747,rvening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as ar,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:107598,Availability,error,errors,107598,ments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as array[1]; Unknown. 1597; CD3; Misleading constexpr example; Unknown. 1598; C++14; Criterion for equality of pointers to members; Unknown. 1599; CD4; Lifetime of initializer_list underlying array; Unknown. 1600; CD4; Erroneous reference initialization in example; Unknown. 1601; C++14; Promotion of enumeration with fixed underlying type; Clang 10. 1602; review; Linkage of specialization vs linkage of template arguments; Not resolved. 1603; CD4; Errors resulting from giving unnamed namespaces internal linkage; Unknown. 1604; C++14; Double temporaries in reference initialization; Unknown. 1605; CD3; Misleading parenthetical comment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Def,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:111258,Availability,failure,failure,111258,"33; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member initializer; Unknown. 1642; DRWP; Missing requirements for prvalue operands; Unknown. 1643; NAD; Default arguments for template parameter packs; Unknown. 1644; NAD; Equivalent exception-specifications in function template declarations; Unknown. 1645; CD4; Identical inheriting constructors via default arguments; Clang 3.9. 1646; CD5; decltype-specifiers, abstract classes, and deduction failure; Unknown. 1647; drafting; Type agreement of non-type template arguments in partial specializations; Not resolved. 1648; C++14; thread_local vs block extern declarations; Unknown. 1649; C++14; Error in the syntax of mem-initializer-list; Unknown. 1650; NAD; Class prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not reso",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116806,Availability,failure,failure,116806,7; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:139894,Availability,error,errors,139894,and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory fo,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142293,Availability,failure,failure,142293,e lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156640,Availability,failure,failures,156640,allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:158489,Availability,failure,failure,158489,bda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:171279,Availability,failure,failure,171279,"wn. 2485; DRWP; Bit-fields in integral promotions; Unknown. 2486; CD6; Call to noexcept function via noexcept(false) pointer/lvalue; Unknown. 2487; drafting; Type dependence of function-style cast to incomplete array type; Not resolved. 2488; open; Overloading virtual functions and functions with trailing requires-clauses; Not resolved. 2489; C++23; Storage provided by array of char; Unknown. 2490; CD6; Restrictions on destruction in constant expressions; Unknown. 2491; CD6; Export of typedef after its first declaration; Unknown. 2492; drafting; Comparing user-defined conversion sequences in list-initialization; Not resolved. 2493; dup; auto as a conversion-type-id; Unknown. 2494; CD6; Multiple definitions of non-odr-used entities; Unknown. 2495; open; Glvalue result of a function call; Not resolved. 2496; CD6; ref-qualifiers and virtual overriding; Unknown. 2497; drafting; Points of instantiation for constexpr function templates; Not resolved. 2498; open; Partial specialization failure and the immediate context; Not resolved. 2499; CD6; Inconsistency in definition of pointer-interconvertibility; Unknown. 2500; extension; noexcept(false) functions and noexcept expressions; Extension. 2501; drafting; Explicit instantiation and trailing requires-clauses; Not resolved. 2502; CD6; Unintended declaration conflicts in nested statement scopes; Unknown. 2503; drafting; Unclear relationship among name, qualified name, and unqualified name; Not resolved. 2504; DR; Inheriting constructors from virtual base classes; Unknown. 2505; drafting; Nested unnamed namespace of inline unnamed namespace; Not resolved. 2506; CD6; Structured bindings and array cv-qualifiers; Unknown. 2507; CD6; Default arguments for operator[]; Unknown. 2508; C++23; Restrictions on uses of template parameter names; Unknown. 2509; CD6; decl-specifier-seq in lambda-specifiers; Unknown. 2510; NAD; noexcept-specifier of friend function vs class completeness; Unknown. 2511; CD6; cv-qualified bit-fields; Unknown.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:172738,Availability,error,error,172738,ified name; Not resolved. 2504; DR; Inheriting constructors from virtual base classes; Unknown. 2505; drafting; Nested unnamed namespace of inline unnamed namespace; Not resolved. 2506; CD6; Structured bindings and array cv-qualifiers; Unknown. 2507; CD6; Default arguments for operator[]; Unknown. 2508; C++23; Restrictions on uses of template parameter names; Unknown. 2509; CD6; decl-specifier-seq in lambda-specifiers; Unknown. 2510; NAD; noexcept-specifier of friend function vs class completeness; Unknown. 2511; CD6; cv-qualified bit-fields; Unknown. 2512; NAD; typeid and incomplete class types; Unknown. 2513; open; Ambiguity with requires-clause and operator-function-id; Not resolved. 2514; open; Modifying const subobjects; Not resolved. 2515; open; Result of a function call; Not resolved. 2516; C++23; Locus of enum-specifier or opaque-enum-declaration; Clang 3.0. 2517; C++23; Useless restriction on use of parameter in constraint-expression; Unknown. 2518; C++23; Conformance requirements and #error/#warning; Clang 17. 2519; DRWP; Object representation of a bit-field; Unknown. 2520; C++23; Template signature and default template arguments; Unknown. 2521; C++23; User-defined literals and reserved identifiers; Clang 17. 2522; open; Removing placemarker tokens and retention of whitespace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180801,Availability,failure,failure,180801,C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Inject,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:183802,Availability,failure,failure,183802,"on of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions; Unknown. 2656; drafting; Converting consteval lambda to function pointer in non-immediate context; Not resolved. 2657; tentatively ready; Cv-qualification adjustment when binding reference to temporary; Unknown. 2658; C++23; Trivial copying of unions in core constant expressions; Unknown. 2659; C++23; Missing feature-test macro for lifetime extension in range-for loop; Unknown. 2660; open; Confusing term ""this parameter""; Not resolved. 2661; open; Missing disambiguation rule for pure-specifier vs. brace-or-equal-initializer; Not resolved. 2662; C++23; Example for member access control vs. overload resolution; Unknown. 2663; DRWP; Example for member redeclarations with using-declarations; Unknown. 2664; C++23; Deduction failure in CTAD for alias templates; Unknown. 2665; NAD; Replacing a subobject with a complete object; Unknown. 2666; open; Lifetime extension through static_cast; Not resolved. 2667; C++23; Named module imports do not import macros; Unknown. 2668; tentatively ready; co_await in a lambda-expression; Unknown. 2669; open; Lifetime extension for aggregate initialization; Not resolved. 2670; open; Programs and translation units; Not resolved. 2671; open; friend named by a template-id; Not resolved. 2672; DR; Lambda body SFINAE is still required, contrary to intent and note; Clang 18. 2673; C++23; User-declared spaceship vs. built-in operators; Unknown. 2674; C++23; Prohibit explicit object parameters for constructors; Unknown. 2675; open; start_lifetime_as, placement-new, and active union members; Not resolved. 2676; open; Replacing a complete object having base subobjects; Not resolved. 2677; review; Replacing union subobjects; Not resolved. 2678; C++23; std::source_location::current is unimplementa",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186440,Availability,error,error,186440,"Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187787,Availability,redundant,redundant,187787,"types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumer",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192407,Availability,failure,failure,192407,s between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functio,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78270,Deployability,release,release,78270,wn. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:143999,Deployability,release,release,143999, Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and con,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24035,Energy Efficiency,reduce,reduces,24035," 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit sp",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125862,Energy Efficiency,allocate,allocated,125862,lock-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer arithmetic and multi-level qualification conversions; Unknown. 1866; CD4; Initializing variant members with non-trivial destructors; Unknown. 1867; NAD; Function/expression ambiguity with qualified parameter name; Unknown. 1868; drafting; Meaning of “plac,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175231,Energy Efficiency,allocate,allocated,175231,"ay comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafti",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:387,Integrability,depend,dependent,387,". Clang - C++ Defect Report Status. C++ Defect Report Support in Clang. C++ defect report implementation status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3017,Integrability,depend,dependent,3017,"Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete t",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3087,Integrability,depend,dependent,3087,"1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7960,Integrability,depend,dependent,7960,"essions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class ar",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:8755,Integrability,depend,dependent,8755,"unction""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11726,Integrability,inject,injection,11726,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,Integrability,inject,injection,11784,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13043,Integrability,depend,dependent,13043,"1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lo",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13579,Integrability,depend,dependent,13579,"d punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:14040,Integrability,depend,dependent,14040,"dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:14793,Integrability,depend,dependent,14793,1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templates; Yes. 229; NAD; Partial specialization of function templates; Clang 2.9. 230; NAD; Calls to pure virtual functions; Clang 3.0. 231; NAD; Visibility of names after using-directives; Yes. 232; NAD; Is indirection through a null pointer undefined behavior?; Unknown. 233; drafting; References vs pointers in UDC overload resolution; Not resolved. 234; NAD; Reuse of base class subobjects; N/A. 235; TC1; Assignment vs initialization; N/A. 236; NAD; Explicit temporaries and integral constant expressions; Clang 3.2. 237; CD1; Explicit instantiation and base class members; Duplicate of 470. 238; CD4; Precision and accuracy constraints on floating point; Unknown. 239; CD1; Footnote 116 and Koenig lookup; Yes. 240; CD3; Uninitialized values and un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18892,Integrability,depend,dependencies,18892,"nt deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. 290; NAD; Should memcpy be allowed into a POD with a const member?; N/A. 291; CD1; Overload resolution needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,Integrability,inject,injection,20182,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:21404,Integrability,depend,dependent,21404,"ot simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization ex",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:22242,Integrability,depend,dependent,22242," in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for argument-dependent lookup; Duplicate of 557. 322; CD1; Deduction of reference conversions; Clang 2.8. 323; CD1; Where must export appear?; No. 324; CD1; Can ""&"" be applied to assignment to bit-field?; Clang 3.6. 325; drafting; When are default arguments parsed?; Not resolved. 326; CD1; Wording for definition of trivial constructor; Clang 3.1. 327; CD1; Use of ""structure"" without definition; Duplicate of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization examples are still incorrect; Yes. 337; CD1; Attempt to create array of abtract type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocat",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:23572,Integrability,rout,routine,23572," unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:25729,Integrability,depend,dependent,25729,"rd C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386; CD6; Friend declaration of name brought in by using-declaration; Unknown. 387; CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29274,Integrability,inject,injected,29274,"ot resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29397,Integrability,inject,inject,29397,"; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording is",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:30557,Integrability,depend,dependent,30557,"435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:30625,Integrability,depend,dependent,30625,"/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to co",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:35291,Integrability,depend,dependent,35291,502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma following enumerator-list; Yes (C++11 onwards). 519; CD1; Null pointer preservation in void* conversions; Yes. 520; CD1; Old-style casts between incomplete class types; N/A. 521; CD1; Requirements for exceptions thrown by allocation functions; No. 522; CD1; Array-to-pointer decay in template argument deduction; Yes. 523; open; Can a one-past-the-end pointer be invalidated by deleting an adjacent object?; Not resolved. 524; CD1; Can function-notation calls to operator functions be dependent?; Yes. 525; CD1; Missing * in example; Yes. 526; CD1; Confusing aspects in the specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” clas,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:35992,Integrability,depend,dependent,35992,"n of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma following enumerator-list; Yes (C++11 onwards). 519; CD1; Null pointer preservation in void* conversions; Yes. 520; CD1; Old-style casts between incomplete class types; N/A. 521; CD1; Requirements for exceptions thrown by allocation functions; No. 522; CD1; Array-to-pointer decay in template argument deduction; Yes. 523; open; Can a one-past-the-end pointer be invalidated by deleting an adjacent object?; Not resolved. 524; CD1; Can function-notation calls to operator functions be dependent?; Yes. 525; CD1; Missing * in example; Yes. 526; CD1; Confusing aspects in the specification of non-deduced contexts; Yes. 527; CD2; Problems with linkage of types; N/A. 528; NAD; Why are incomplete class types not allowed with typeid?; Unknown. 529; drafting; Use of template<> with “explicitly-specialized” class templates; Not resolved. 530; CD1; Nontype template arguments in constant expressions; Yes. 531; C++11; Defining members of explicit specializations; Partial. 532; C++11; Member/nonmember operator template partial ordering; Clang 3.5. 533; NAD; Special treatment for C-style header names; N/A. 534; CD1; template-names and operator-function-ids; Clang 2.9. 535; CD3; Copy construction without a copy constructor; Yes. 536; CD6; Problems in the description of id-expressions; N/A. 537; CD1; Definition of “signature”; N/A. 538; CD1; Definition and usage; of structure, POD-struct, POD-union,; and POD class; N/A. 539; CD3; Constraints on type-specifier",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38192,Integrability,depend,dependent,38192,nstructors; Clang 3.0. 544; NAD; Base class lookup in explicit specialization; Yes. 545; open; User-defined conversions and built-in operator overload resolution; Not resolved. 546; C++11; Explicit instantiation of class template members; Yes. 547; C++11; Partial specialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard convers,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38480,Integrability,depend,dependent,38480,ecialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:40264,Integrability,depend,dependent,40264,pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5. 577; CD3; void in an empty parameter list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:40493,Integrability,depend,dependent,40493,list; Clang 3.5. 578; CD6; Phase 1 replacement of characters with universal-character-names; Unknown. 579; open; What is a “nested” > or >>?; Not resolved. 580; C++11; Access in template-parameters of member and friend definitions; Partial. 581; CD5; Can a templated constructor be explicitly instantiated or specialized?; Unknown. 582; CD1; Template conversion functions; N/A. 583; CD3; Relational pointer comparisons against the null pointer constant; Clang 4. 584; NAD; Unions and aliasing; N/A. 585; NAD; Friend template template parameters; Clang 3.0. 586; NAD; Default template-arguments and template argument deduction; N/A. 587; CD2; Lvalue operands of a conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of e,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41297,Integrability,inject,injected-class-name,41297,lates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditiona,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:48463,Integrability,depend,dependent,48463,"Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved. 698; open; The definition of “sequenced before” is too narrow; Not resolved. 699; CD2; Must constexpr member functions be defined in the class member-specification?; Unknown. 700; C++11; Constexpr member functions of class templates; Unknown. 701; CD2; When is the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:53357,Integrability,depend,dependent,53357,"765; CD2; Local types in inline functions with external linkage; Unknown. 766; CD2; Where may lambda expressions appear?; Unknown. 767; CD2; void and other unnamed lambda-parameters; Unknown. 768; CD2; Ellipsis in a lambda parameter list; Unknown. 769; CD2; Initialization of closure objects; Unknown. 770; CD2; Ambiguity in late-specified return type; Unknown. 771; CD2; Move-construction of reference members of closure objects; Unknown. 772; CD2; capture-default in lambdas in local default arguments; Unknown. 773; C++11; Parentheses in address non-type template arguments; Unknown. 774; CD2; Can a closure class be a POD?; Unknown. 775; CD2; Capturing references to functions; Unknown. 776; CD2; Delegating constructors, destructors, and std::exit; Unknown. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknown. 782; CD2; Lambda expressions and argument-dependent lookup; Unknown. 783; open; Definition of “argument”; Not resolved. 784; C++11; List of incompatibilities with the previous Standard; Unknown. 785; CD2; “Execution sequence” is inappropriate phraseology; Unknown. 786; CD2; Definition of “thread”; Unknown. 787; CD2; Unnecessary lexical undefined behavior; Unknown. 788; CD2; Relationship between locale and values of the execution character set; Unknown. 789; CD2; Deprecating trigraphs; Unknown. 790; CD2; Concatenation of raw and non-raw string literals; Unknown. 792; CD2; Effects of std::quick_exit; Unknown. 793; CD2; Use of class members during destruction; Unknown. 794; NAD; Base-derived conversion in member type of pointer-to-member conversion; Unknown. 795; NAD; Dependency of lambdas on <functional>; Unknown. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in c",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55350,Integrability,depend,dependent,55350,scribed in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating exception specifications; Unknown. 831; CD2; Limit on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enum,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57184,Integrability,depend,dependent,57184, on recursively nested template instantiations; Unknown. 832; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:59543,Integrability,depend,dependent,59543,alized static data member; Unknown. 885; NAD; Partial ordering of function templates with unordered parameter pairs; Unknown. 886; CD2; Member initializers and aggregates; Unknown. 887; CD2; Move construction of thrown object; Unknown. 888; CD2; Union member initializers; Unknown. 891; CD2; const_cast to rvalue reference from objectless rvalue; Unknown. 892; C++11; Missing requirements for constexpr constructors; Unknown. 893; NAD; Brace syntax for enumerator-definitions; Unknown. 896; CD2; Rvalue references and rvalue-reference conversion functions; Unknown. 897; open; _Pragma and extended string-literals; Not resolved. 898; C++11; Declarations in constexpr functions; Unknown. 899; CD2; Explicit conversion functions in direct class initialization; Unknown. 900; C++23; Lifetime of temporaries in range-based for; Unknown. 901; drafting; Deleted operator delete; Not resolved. 902; NAD; In-class initialization of non-constant static data members; Unknown. 903; CD3; Value-dependent integral null pointer constants; Unknown. 904; CD2; Parameter packs in lambda-captures; Unknown. 905; CD2; Explicit defaulted copy constructors and trivial copyability; Unknown. 906; CD2; Which special member functions can be defaulted?; Unknown. 908; CD2; Deleted global allocation and deallocation functions; Unknown. 909; NAD; Old-style casts with conversion functions; Unknown. 910; CD2; Move constructors and implicitly-declared copy constructors; Unknown. 912; CD3; Character literals and universal-character-names; Unknown. 913; CD2; Deduction rules for array- and function-type conversion functions; Unknown. 914; open; Value-initialization of array types; Not resolved. 915; CD2; Deleted specializations of member function templates; Unknown. 919; CD2; Contradictions regarding inline namespaces; Unknown. 920; CD2; Interaction of inline namespaces and using-declarations; Unknown. 921; CD2; Unclear specification of inline namespaces; Unknown. 922; CD2; Implicit default constructor definitions an,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65598,Integrability,depend,dependent,65598,ant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65619,Integrability,depend,dependent,65619,ant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65931,Integrability,depend,dependent,65931, Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent loo,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:66915,Integrability,depend,dependent,66915,"ameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defin",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:69128,Integrability,depend,dependent,69128," Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete-expressions and deallocation functions; Unknown. 1038; DR; Overload resolution of &x.static_func; Unknown. 1039; dup; Coordinating C and C++ alignment specifications; Unknown. 1040; NAD; Memory model issues; Unknown. 1041; dup; alias-declarations as class members; Unknown. 1042; C++11; Attributes in alias-declarations; Clang 3.5. 1043; C++11; Qualified name lookup in the current instantiation; Unknown. 1044; C++11; Point of declaration for an alias-declaration; Unknown. 1045; NAD; Requiring explicit instantiation declarations; Unknown. 1046; open; What is a “use” of a class specialization?; Not resolved. 1047; C++11; When is typeid value-dependent?; Unknown. 1048; CD3; auto deduction and lambda return type deduction.; Clang 3.6. 1049; open; Copy elision through reference parameters of inline functions; Not resolved. 1050; NAD; Effects of thread support on object lifetime; Unknown. 1051; C++11; Reference members and generated copy constructors; Unknown. 1052; dup; const non-static data member and PODness; Unknown. 1053; NAD; Terminate vs undefined behavior for noexcept violation; Unknown. 1054; C++11; Lvalue-to-rvalue conversions in expression statements; No. 1055; C++11; Permissible uses of void; Unknown. 1056; C++11; Template aliases, member definitions, and the current instantiation; Unknown. 1057; C++11; decltype and the current instantiation; Unknown. 1058; NAD; Reference binding of incompatible array types; Unknown. 1059; CD3; Cv-qualified array types (with rvalues); Unknown. 1060; C++11; Scoped enumerators in integral constant expressions; Unknown. 1061; C++11; Negative array bounds in a new-expression; Un",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:71051,Integrability,depend,dependent,71051,". 1061; C++11; Negative array bounds in a new-expression; Unknown. 1062; C++11; Syntax of attribute-specifiers in lambdas; Unknown. 1063; C++11; [[hiding]] with non-attribute declarations; Unknown. 1064; C++11; Defaulted move constructor for a union; Unknown. 1065; C++11; [[hiding]] with [[override]]; Unknown. 1066; C++11; When is a copy/move assignment operator implicitly defined?; Unknown. 1067; NAD; [[hiding]], using-declarations, and multiple inheritance; Unknown. 1068; C++11; Template aliases with default arguments and template parameter packs; Unknown. 1069; C++11; Incorrect function type with trailing-return-type; Unknown. 1070; C++11; Missing initializer clauses in aggregate initialization; Clang 3.5. 1071; C++11; Literal class types and trivial default constructors; Unknown. 1072; C++11; Scoped enumerator with the same name as its containing class; Unknown. 1073; C++11; Merging dynamic-exception-specifications and noexcept-specifications; Unknown. 1074; C++11; Value-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between templates and copy constructors; Unknown. 1081; C++11; Defaulted destructor and unusable operator delete; Unknown. 1082; C++11; Implicit copy function if subobject has none?; Unknown. 1083; C++11; Passing an object to ellipsis with non-trivial move constructor; Unknown. 1084; NAD; Conditions for a deleted move function; Unknown. 1085; NAD; Move assignment operators and virtual bases; Unknown. 1086; C++11; const_cast to rvalue reference to function type; Unknown. 1087; C++11; Additional applications of issue 899; Unknown. 1088; C++11; Dependent non-type template a",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78008,Integrability,depend,dependent,78008,e; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initializat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78323,Integrability,depend,dependency-ordered-before,78323,-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Ina,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78911,Integrability,depend,dependent,78911,unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use of address-constant pointers in constant expressions; Unknown. 1194; C++11; Constexpr references; Unknown. 1195; C++11; References to non-literal types in constexpr functions; Unknown. 1196; C++11; Definition required for explicit instantiation after explicit specialization?; Unknown. 1197; C++11; Constexpr arrays; Unknown. 1198; C++11; Literal types and copy constructors; Unknown. 1199; C++11; Deleted constexpr functions; Unknown. 1200; CD6; Lookup rules for template parameters; N/A. 1201; C++11; Are deleted and defaulted functions def,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:82154,Integrability,depend,dependent,82154,tializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknown. 1226; CD3; Converting a braced-init-list default argument; Unknown. 1227; CD3; Mixing immediate and non-immediate contexts in deduction failure; Clang 3.0. 1228; NAD; Copy-list-initialization and explicit constructors; Unknown. 1229; C++11; Overload resolution with empty braced-init-list argument; Unknown. 1230; dup; Confusing description of ambiguity of destructor name; Unknown. 1231; C++11; Variadic templates requiring an empty pack expansion; Unknown. 1232; C++11; Creation of array temporaries using a braced-init-list; Unknown. 1233; C++11; Pack expansions and dependent calls; Unknown. 1234; C++11; abstract-declarator does not permit ... after ptr-operator; Unknown. 1235; C++11; “Unused” ellipsis and default arguments in partial ordering; Unknown. 1236; C++11; Inconsistently-interrelated examples; Unknown. 1237; C++11; Deprecated implicit copy assignment in example; Unknown. 1238; C++11; Overloading ambiguity binding reference to function; Unknown. 1239; C++11; Hexadecimal floating-point literals vs user-defined literals; Unknown. 1240; C++11; constexpr defaulted constructors; Unknown. 1241; C++11; Which members does a destructor destroy?; Unknown. 1242; C++11; Initializing variant class members; Unknown. 1243; C++11; Misleading footnote regarding multiple-declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in typ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83488,Integrability,depend,dependent,83488, 1238; C++11; Overloading ambiguity binding reference to function; Unknown. 1239; C++11; Hexadecimal floating-point literals vs user-defined literals; Unknown. 1240; C++11; constexpr defaulted constructors; Unknown. 1241; C++11; Which members does a destructor destroy?; Unknown. 1242; C++11; Initializing variant class members; Unknown. 1243; C++11; Misleading footnote regarding multiple-declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifie,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83850,Integrability,depend,dependent,83850,declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83962,Integrability,depend,dependent,83962,emplates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:84845,Integrability,depend,dependent,84845,tion via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of intmax_t and uintmax_t; Unknown. 1278; drafting; Incorrect treatment of contrived object; Not resolved. 1279; drafting; Additional differences between C++ 2003 and C++ 2011; Not resolved. 1280; NAD; Object reallocation and reference members; Unknown. 1281; NAD; Virtual and dependent base classes; Unknown. 1282; CD3; Underspecified destructor exception-specification; Unknown. 1283; drafting; Static data members of classes with typedef name for linkage purposes; Not resolved. 1284; CD4; Should the lifetime of an array be independent of that of its elements?; Unknown. 1285; NAD; Tri,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:85526,Integrability,depend,dependent,85526,rflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown. 1273; NAD; Accessibility and function signatures; Unknown. 1274; CD4; Common nonterminal for expression and braced-init-list; Unknown. 1275; CD3; Incorrect comment in example of template parameter pack restriction; Unknown. 1276; NAD; Reference to stdint.h; Unknown. 1277; NAD; Lax definition of intmax_t and uintmax_t; Unknown. 1278; drafting; Incorrect treatment of contrived object; Not resolved. 1279; drafting; Additional differences between C++ 2003 and C++ 2011; Not resolved. 1280; NAD; Object reallocation and reference members; Unknown. 1281; NAD; Virtual and dependent base classes; Unknown. 1282; CD3; Underspecified destructor exception-specification; Unknown. 1283; drafting; Static data members of classes with typedef name for linkage purposes; Not resolved. 1284; CD4; Should the lifetime of an array be independent of that of its elements?; Unknown. 1285; NAD; Trivial destructors and object lifetime; Unknown. 1286; drafting; Equivalence of alias templates; Not resolved. 1287; C++14; Direct initialization vs “implicit” conversion in reference binding; Unknown. 1288; CD3; Reference list initialization; Unknown. 1289; NAD; Can an alias template name the current instantiation?; Unknown. 1290; CD3; Lifetime of the underlying array of an initializer_list member; Unknown. 1291; CD6; Looking up a conversion-type-id; N/A. 1292; CD4; Dependent calls with braced-init-lists containing a pack expansion; Unknown. 1293; CD3; String literals in constant expressions; Unknown. 1294; open; Side effects in dynamic/static initialization; Not resolved. 1295; CD3; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:88309,Integrability,depend,dependent,88309," Overload resolution based on size of array initializer-list; Clang 14. 1308; CD3; Completeness of class type within an exception-specification; Superseded by 1330. 1309; CD4; Incorrect note regarding lookup of a member of the current instantiation; Unknown. 1310; CD3; What is an “acceptable lookup result?”; Clang 5. 1311; CD3; Volatile lvalues in constant expressions; Unknown. 1312; CD3; Simulated reinterpret_cast in constant expressions; Unknown. 1313; CD3; Undefined pointer arithmetic in constant expressions; Unknown. 1314; NAD; Pointer arithmetic within standard-layout objects; Unknown. 1315; CD4; Restrictions on non-type template arguments in partial specializations; Partial. 1316; NAD; constexpr function requirements and class scope; Unknown. 1317; NAD; Unnamed scoped enumerations; Unknown. 1318; CD3; Syntactic ambiguities with final; Unknown. 1319; NAD; Error in pack expansion example; Unknown. 1320; CD3; Converting scoped enumerations to bool; Unknown. 1321; CD3; Equivalency of dependent calls; Unknown. 1322; drafting; Function parameter type decay in templates; Not resolved. 1323; NAD; Nonexistent nonterminal in alignment-specifier grammar; Unknown. 1324; CD3; Value initialization and defaulted constructors; Unknown. 1325; NAD; Omitted declarator in friend declarations; Unknown. 1326; dup; Deducing an array bound from an initializer-list; Unknown. 1327; CD3; virt-specifier in a defaulted definition; Unknown. 1328; CD3; Conflict in reference binding vs overload resolution; Unknown. 1329; CD3; Recursive deduction substitutions; Unknown. 1330; CD3; Delayed instantiation of noexcept specifiers; Clang 4 (C++11 onwards). 1331; CD5; const mismatch with defaulted copy constructor; Unknown. 1332; CD5; Handling of invalid universal-character-names; Unknown. 1333; CD3; Omission of const in a defaulted copy constructor; Unknown. 1334; NAD; Layout compatibility and cv-qualification; Unknown. 1335; CD6; Stringizing, extended characters, and universal-character-names; Unk",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:94882,Integrability,depend,dependency,94882,tiple function parameter packs; Duplicate of 1388. 1400; NAD; Function pointer equality; Unknown. 1401; CD3; Similar types and reference compatibility; Unknown. 1402; CD3; Move functions too often deleted; Unknown. 1403; CD6; Universal-character-names in comments; Unknown. 1404; drafting; Object reallocation in unions; Not resolved. 1405; CD3; constexpr and mutable members of literal types; Unknown. 1406; CD3; ref-qualifiers and added parameters of non-static member function templates; Unknown. 1407; NAD; Integral to bool conversion in converted constant expressions; Unknown. 1408; CD3; What is “the same aggregate initialization?”; Unknown. 1409; CD3; What is the second standard conversion sequence of a list-initialization sequence?; Unknown. 1410; CD3; Reference overload tiebreakers should apply to rvalue references; Unknown. 1411; CD3; More on global scope :: in nested-name-specifier; Unknown. 1412; CD3; Problems in specifying pointer conversions; Unknown. 1413; CD3; Missing cases of value-dependency; Clang 12. 1414; drafting; Binding an rvalue reference to a reference-unrelated lvalue; Not resolved. 1415; CD3; Missing prohibition of block-scope definition of extern object; Unknown. 1416; CD3; Function cv-qualifiers and typeid; Unknown. 1417; C++14; Pointers/references to functions with cv-qualifiers or ref-qualifier; Unknown. 1418; CD3; Type of initializer_list backing array; Unknown. 1419; NAD; Evaluation order in aggregate initialization; Unknown. 1420; NAD; Abstract final classes; Unknown. 1421; NAD; Full expressions and aggregate initialization; Unknown. 1422; dup; Type of character literals containing universal-character-names; Unknown. 1423; CD3; Convertibility of nullptr to bool; Clang 11. 1424; C++14; When must sub-object destructors be accessible?; Unknown. 1425; CD3; Base-class subobjects of standard-layout structs; N/A (ABI constraint). 1426; CD5; Allowing additional parameter types in defaulted functions; Unknown. 1427; NAD; Default constructor and de,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:96898,Integrability,depend,dependent,96898,known. 1428; CD3; Dynamic const objects; Unknown. 1429; NAD; Scope of a member template's template parameter; Unknown. 1430; open; Pack expansion into fixed alias template parameter list; Not resolved. 1431; CD3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of invalid pointers; Unknown. 1439; CD3; Lookup and friend template declarations; Unknown. 1440; CD3; Acceptable decltype-specifiers used as nested-name-specifiers; Unknown. 1441; C++14; Unclear wording for signal handler restrictions; Unknown. 1442; CD3; Argument-dependent lookup in the range-based for; Unknown. 1443; NAD; Default arguments and non-static data members; Yes. 1444; drafting; Type adjustments of non-type template parameters; Not resolved. 1445; dup; Argument-dependent lookup of begin and end; Unknown. 1446; CD4; Member function with no ref-qualifier and non-member function with rvalue reference; Unknown. 1447; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:97111,Integrability,depend,dependent,97111,3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of invalid pointers; Unknown. 1439; CD3; Lookup and friend template declarations; Unknown. 1440; CD3; Acceptable decltype-specifiers used as nested-name-specifiers; Unknown. 1441; C++14; Unclear wording for signal handler restrictions; Unknown. 1442; CD3; Argument-dependent lookup in the range-based for; Unknown. 1443; NAD; Default arguments and non-static data members; Yes. 1444; drafting; Type adjustments of non-type template parameters; Not resolved. 1445; dup; Argument-dependent lookup of begin and end; Unknown. 1446; CD4; Member function with no ref-qualifier and non-member function with rvalue reference; Unknown. 1447; CD3; static_cast of bit-field lvalue to rvalue reference; Unknown. 1448; NAD; Integral values of type bool; Unknown. 1449; CD3; Narrowing conversion of negative value to unsigned type; Unknown. 1450; CD3; INT_MIN % -1; Unknown. 1451; CD4; Objects with no linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 14,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98855,Integrability,depend,dependent,98855," constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in m",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99270,Integrability,depend,dependent,99270,"gnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception s",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99604,Integrability,depend,dependent,99604,"ct; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:100865,Integrability,depend,dependent,100865,tion; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497; NAD; Aggregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length b,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106201,Integrability,wrap,wrapper,106201,mpty base classes; Unknown. 1562; C++14; Non-static data member initializers and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109864,Integrability,depend,dependent,109864,"; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1630; CD4; Multiple default constructor templates; Unknown. 1631; CD4; Incorrect overload resolution for single-element initializer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member i",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:112505,Integrability,depend,dependent,112505,ass prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unknown. 1664; C++14; Argument-dependent lookup of lambdas used in default arguments; Unknown. 1665; drafting; Declaration matching in explicit instantiations; Not resolved. 1666; C++14; Address constant expressions; Unknown. 1667; NAD; Function exiting via exception called by destructor during unwinding; Unknown. 1668; drafting; Parameter type determination still not clear enough; Not resolved. 1669; C++14; auto return type for main; Unknown. 1670; drafting; auto as conversion-type-id; Not resolved. 1671; NAD; Unclear rules for deduction with cv-qualification; Unknown. 1672; CD4; Layout compatibility with multiple empty bases; Clang 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Nami,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114417,Integrability,depend,dependent,114417,ed. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specifica,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117727,Integrability,depend,dependence,117727, Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:120675,Integrability,depend,dependency,120675,umeration used as enumerator value; Unknown. 1766; CD4; Values outside the range of the values of an enumeration; Unknown. 1767; C++14; Scoped enumeration in a switch statement; Unknown. 1768; NAD; Zero-element array of runtime bound; Unknown. 1769; C++14; Catching a base class of the exception object; Unknown. 1770; C++14; Type matching of non-type template parameters and arguments; Unknown. 1771; CD6; Restricted lookup in nested-name-specifier; Unknown. 1772; C++14; __func__ in a lambda body; Clang 14. 1773; C++14; Out-of-lifetime lvalue-to-rvalue conversion; Unknown. 1774; CD4; Discrepancy between subobject destruction and stack unwinding; Unknown. 1775; C++14; Undefined behavior of line splice in raw string literal; Unknown. 1776; CD4; Replacement of class objects containing reference members; Unknown. 1777; CD4; Empty pack expansion in dynamic-exception-specification; Unknown. 1778; C++14; exception-specification in explicitly-defaulted functions; Clang 9. 1779; CD4; Type dependency of __func__; Clang 14. 1780; CD4; Explicit instantiation/specialization of generic lambda operator(); Unknown. 1781; CD5; Converting from nullptr_t to bool in overload resolution; Unknown. 1782; CD4; Form of initialization for nullptr_t to bool conversion; Unknown. 1783; NAD; Why are virtual destructors non-trivial?; Unknown. 1784; C++17; Concurrent execution during static local initialization; Unknown. 1785; NAD; Conflicting diagnostic requirements for template definitions; Unknown. 1786; C++14; Effect of merging allocations on memory leakage; Unknown. 1787; C++14; Uninitialized unsigned char values; Unknown. 1788; CD4; Sized deallocation of array of non-class type; Unknown. 1789; open; Array reference vs array decay in overload resolution; Not resolved. 1790; open; Ellipsis following function parameter pack; Not resolved. 1791; CD4; Incorrect restrictions on cv-qualifier-seq and ref-qualifier; Unknown. 1792; NAD; Incorrect example of explicit specialization of member enumeration; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125034,Integrability,inject,injected-class-name,125034,stant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; U,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125112,Integrability,depend,dependency,125112,mbiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not r,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:128370,Integrability,depend,depending,128370,eordering declarations in class scope; Unknown. 1876; NAD; Preventing explicit specialization; Unknown. 1877; CD4; Return type deduction from return with no operand; Unknown. 1878; CD4; operator auto template; Clang 18. 1879; NAD; Inadequate definition of alignment requirement; Unknown. 1880; CD4; When are parameter objects destroyed?; Unknown. 1881; CD4; Standard-layout classes and unnamed bit-fields; Clang 7. 1882; CD4; Reserved names without library use; Unknown. 1883; drafting; Protected access to constructors in mem-initializers; Not resolved. 1884; CD6; Unclear requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:128941,Integrability,depend,dependent,128941, requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unkno,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:129399,Integrability,inject,injected-class-names,129399,ember function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130243,Integrability,depend,dependent,130243,ed by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NA,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135051,Integrability,depend,dependent,135051,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135069,Integrability,depend,dependent,135069,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:136448,Integrability,depend,dependent,136448,explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspecified; Unknown. 2002; open; White space within preprocessing directives; Not resolved. 2003; drafting; Zero-argument macros incorrectly specified; Not resolved. 2004; CD4; Unions with mutable members in constant expressions; Unknown. 2005; NAD; Incorrect constexpr reference initialization requirements; Unknown. 2006; CD4; Cv-qualified void types; Unknown. 2007; CD6; Argument-dependent lookup for operator=; Clang 3.4. 2008; CD4; Default template-arguments underspecified; Unknown. 2009; CD6; Unclear specification of class scope; N/A. 2010; CD4; exception-specifications and conversion operators; Unknown. 2011; C++17; Unclear effect of reference capture of reference; Unknown. 2012; CD4; Lifetime of references; Unknown. 2013; drafting; Pointer subtraction in large array; Not resolved. 2014; NAD; Unneeded deallocation signatures; Unknown. 2015; CD4; odr-use of deleted virtual functions; Unknown. 2016; CD4; Confusing wording in description of conversion function; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy eli,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138023,Integrability,inject,injected-class-name,138023,n; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140284,Integrability,depend,dependent,140284,itializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not reso,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140416,Integrability,depend,dependent,140416,s rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with em,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140438,Integrability,depend,dependent,140438,s rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with em,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140696,Integrability,depend,dependent,140696,ved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140966,Integrability,depend,dependence,140966,es; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unkno,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142168,Integrability,depend,dependent,142168,tor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142844,Integrability,depend,dependent,142844,ting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:142965,Integrability,depend,dependence,142965, of negative value by zero bits; Unknown. 2088; CD5; Late tiebreakers in partial ordering; Unknown. 2089; drafting; Restricting selection of builtin overloaded operators; Not resolved. 2090; drafting; Dependency via non-dependent base class; Not resolved. 2091; CD4; Deducing reference non-type template arguments; Unknown. 2092; CD5; Deduction failure and overload resolution; Unknown. 2093; CD4; Qualification conversion for pointer-to-member handler matching; Unknown. 2094; C++17; Trivial copy/move constructor for class with volatile member; Clang 5. 2095; CD4; Capturing rvalue references to functions by copy; Unknown. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:143564,Integrability,depend,dependence,143564,. 2096; CD4; Constraints on literal unions; Duplicate of 2598. 2097; extension; Lambdas and noreturn attribute; Extension. 2098; CD4; Is uncaught_exceptions() per-thread?; Unknown. 2099; CD4; Inferring the bound of an array static data member; Unknown. 2100; C++17; Value-dependent address of static data member of class template; Clang 12. 2101; CD4; Incorrect description of type- and value-dependence; Unknown. 2102; DR; Constructor checking in new-expression; Unknown. 2103; CD5; Lvalue-to-rvalue conversion is irrelevant in odr-use of a reference; Yes. 2104; CD4; Internal-linkage constexpr references and ODR requirements; Unknown. 2105; open; When do the arguments for a parameter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant in,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144268,Integrability,inject,injection,144268,eter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145446,Integrability,depend,dependent,145446,; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145959,Integrability,depend,dependency,145959,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145974,Integrability,inject,injected-class-name,145974,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:148418,Integrability,depend,dependent,148418,"eclarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolved. 2173; open; Partial specialization with non-deduced contexts; Not resolved. 2174; C++17; Unclear rules for friend definitions in templates; Unknown. 2175; CD4; Ambiguity with attribute in conversion operator declaration; Unknown. 2176; CD4; Destroying the returned object when a destructor throws; Unknown. 2177; CD5; Placement operator delete and parameter copies; Unknown. 2178; NAD; Substitution of dependent template arguments in default template arguments; Unknown. 2179; drafting; Required diagnostic for partial specialization after first use; Not resolved. 2180; CD4; Virtual bases in destructors and defaulted assignment operators; Yes. 2181; drafting; Normative requirements in an informative Annex; Not resolved. 2182; drafting; Pointer arithmetic in array-like containers; Not resolved. 2183; NAD; Problems in description of potential exceptions; Unknown. 2184; CD4; Missing C compatibility entry for decrement of bool; Unknown. 2185; CD6; Cv-qualified numeric types; Unknown. 2186; drafting; Unclear point that “preceding initialization” must precede; Not resolved. 2187; drafting; Protected members and access via qualified-id; Not resolved. 2188; open; empty-declaration grammar ambiguity; Not resolved. 2189; open; Surrogate call template; Not resolved. 2190; open; Insufficient specification of __has_include; Not resolved. 2191; C++17; Incorrect result for noexcept(typeid(v)); Unknown. 2192; open; Const",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152286,Integrability,depend,dependent,152286,"x variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and i",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152369,Integrability,depend,dependent,152369,"cts; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154423,Integrability,depend,dependent,154423,nown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a us,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:154449,Integrability,depend,dependent,154449,nown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a us,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155072,Integrability,depend,dependence,155072,of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniq,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155169,Integrability,depend,dependence,155169, asm-definition; Unknown. 2263; drafting; Default argument instantiation for friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specif,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159231,Integrability,inject,injected-class-name,159231, a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163193,Integrability,contract,contract-attribute-specifiers,163193,D; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402;,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:164467,Integrability,depend,dependent,164467, 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402; CD6; When is the restriction to a single c-char in a Unicode literal enforced?; Unknown. 2403; drafting; Temporary materialization and base/member initialization; Not resolved. 2404; CD5; [[no_unique_address]] and allocation order; Unknown. 2405; CD6; Additional type-dependent expressions; Unknown. 2406; CD5; [[fallthrough]] attribute and iteration statements; Clang 5. 2407; C++23; Missing entry in Annex C for defaulted comparison operators; Unknown. 2408; NAD; Temporaries and previously-initialized elements in aggregate initialization; Unknown. 2409; drafting; Explicit specializations of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “u,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:167433,Integrability,depend,dependency,167433,ries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine lambdas; Unknown. 2454; NAD; Tail recursion and coroutine symmetric transfer; Unknown. 2455; CD6; Concatenation of string literals vs translation phases 5 and 6; Unknown. 2456; open; Viable user-defined conversions in converted constant expressions; Not resolved. 2457; CD6; Unexpanded parameter packs don't make a function type dependent; Unknown. 2458; CD6; Value category of expressions denoting non-static member functions; Unknown. 2459; drafting; Te,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:168309,Integrability,depend,dependent,168309,pressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine lambdas; Unknown. 2454; NAD; Tail recursion and coroutine symmetric transfer; Unknown. 2455; CD6; Concatenation of string literals vs translation phases 5 and 6; Unknown. 2456; open; Viable user-defined conversions in converted constant expressions; Not resolved. 2457; CD6; Unexpanded parameter packs don't make a function type dependent; Unknown. 2458; CD6; Value category of expressions denoting non-static member functions; Unknown. 2459; drafting; Template parameter initialization; Clang 18. 2460; CD6; C language linkage and constrained non-template friends; Unknown. 2461; CD6; Diagnosing non-bool type constraints; Unknown. 2462; drafting; Problems with the omission of the typename keyword; Not resolved. 2463; open; Trivial copyability and unions with non-trivial members; Not resolved. 2464; CD6; Constexpr launder and unions; Unknown. 2465; CD6; Coroutine parameters passed to a promise constructor; Unknown. 2466; CD6; co_await should be a single evaluation; Unknown. 2467; drafting; CTAD for alias templates and the deducible check; Not resolved. 2468; drafting; Omission of the typename keyword in a member template parameter list; Not resolved. 2469; drafting; Implicit object creation vs constant expressions; Not resolved. 2470; CD6; Multiple array objects providing storage for one obje,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:170448,Integrability,depend,dependence,170448,uctor calls; Not resolved. 2474; CD6; Cv-qualification and deletion; Unknown. 2475; C++23; Object declarations of type cv void; Unknown. 2476; tentatively ready; placeholder-type-specifiers and function declarators; Unknown. 2477; CD6; Defaulted vs deleted copy constructors/assignment operators; Unknown. 2478; C++23; Properties of explicit specializations of implicitly-instantiated class templates; Unknown. 2479; CD6; Missing specifications for consteval and constinit; Unknown. 2480; drafting; Lookup for enumerators in modules; Not resolved. 2481; CD6; Cv-qualification of temporary to which a reference is bound; Unknown. 2482; CD6; bit_cast and indeterminate values; Unknown. 2483; C++23; Language linkage of static member functions; Unknown. 2484; CD6; char8_t and char16_t in integral promotions; Unknown. 2485; DRWP; Bit-fields in integral promotions; Unknown. 2486; CD6; Call to noexcept function via noexcept(false) pointer/lvalue; Unknown. 2487; drafting; Type dependence of function-style cast to incomplete array type; Not resolved. 2488; open; Overloading virtual functions and functions with trailing requires-clauses; Not resolved. 2489; C++23; Storage provided by array of char; Unknown. 2490; CD6; Restrictions on destruction in constant expressions; Unknown. 2491; CD6; Export of typedef after its first declaration; Unknown. 2492; drafting; Comparing user-defined conversion sequences in list-initialization; Not resolved. 2493; dup; auto as a conversion-type-id; Unknown. 2494; CD6; Multiple definitions of non-odr-used entities; Unknown. 2495; open; Glvalue result of a function call; Not resolved. 2496; CD6; ref-qualifiers and virtual overriding; Unknown. 2497; drafting; Points of instantiation for constexpr function templates; Not resolved. 2498; open; Partial specialization failure and the immediate context; Not resolved. 2499; CD6; Inconsistency in definition of pointer-interconvertibility; Unknown. 2500; extension; noexcept(false) functions and noexcept expression,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:179153,Integrability,depend,dependency,179153,"dule linkage; Not resolved. 2589; review; Context of access checks during constraint satisfaction checking; Not resolved. 2590; C++23; Underlying type should determine size and alignment requirements of an enum; Unknown. 2591; DR; Implicit change of active union member for anonymous union in union; Unknown. 2592; open; Missing definition for placement allocation/deallocation function; Not resolved. 2593; review; Insufficient base class restriction for pointer-to-member expression; Not resolved. 2594; CD6; Disallowing a global function template main; Unknown. 2595; DR; ""More constrained"" for eligible special member functions; Unknown. 2596; drafting; Instantiation of constrained non-template friends; Not resolved. 2597; CD6; Replaceable allocation and deallocation functions in the global module; Unknown. 2598; C++23; Unions should not require a non-static data member of literal type; Clang 18. 2599; C++23; What does initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribut",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:190079,Integrability,depend,depend,190079,"t resolved. 2735; open; List-initialization and conversions in overload resolution; Not resolved. 2736; open; Standard layout class with empty base class also in first member; Not resolved. 2737; open; Temporary lifetime extension for reference init-captures; Not resolved. 2738; review; ""denotes a destructor"" is missing specification; Not resolved. 2739; open; Nested requirement not a constant expression; Not resolved. 2740; open; Too many objects have constexpr-unknown type; Not resolved. 2741; open; Implicit conversion sequence from empty list to array of unknown bound; Not resolved. 2742; open; Guaranteed copy elision for brace-initialization from prvalue; Not resolved. 2743; open; Copying non-trivial objects nested within a union; Not resolved. 2744; open; Multiple objects of the same type at the same address; Not resolved. 2745; open; Dependent odr-use in generic lambdas; Not resolved. 2746; open; Checking of default template arguments; Not resolved. 2747; DR; Cannot depend on an already-deleted splice; Unknown. 2748; tentatively ready; Accessing static data members via null pointer; Unknown. 2749; DR; Treatment of ""pointer to void"" for relational comparisons; Unknown. 2750; DRWP; construct_at without constructor call; Unknown. 2751; NAD; Order of destruction for parameters for operator functions; Unknown. 2752; open; Excess-precision floating-point literals; Not resolved. 2753; DR; Storage reuse for string literal objects and backing arrays; Unknown. 2754; DR; Using *this in explicit object member functions that are coroutines; Unknown. 2755; DR; Incorrect wording applied by P2738R1; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192246,Integrability,depend,dependence,192246,orability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment functi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:193088,Integrability,depend,dependence,193088," linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert m",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194101,Integrability,message,message,194101," DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; C",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:5664,Modifiability,variab,variables,5664,"; Yes. 61; NAD; Address of static member function ""&p->f""; Clang 3.4. 62; CD1; Unnamed members of classes used as type parameters; Clang 2.9. 63; CD1; Class instantiation from pointer conversion to void*, null and self; Yes. 64; TC1; Partial ordering to disambiguate explicit specialization; Yes. 65; TC1; Typo in default argument example; N/A. 66; NAD; Visibility of default args vs overloads added after using-declaration; No. 67; TC1; Evaluation of left side of object-expression; N/A. 68; TC1; Grammar does not allow ""friend class A<int>;""; Clang 2.8. 69; TC1; Storage class specifiers on template declarations; Clang 9. 70; CD1; Is an array bound a nondeduced context?; Yes. 71; NAD; Incorrect cross reference; N/A. 72; dup; Linkage and storage class specifiers for templates; Duplicate of 69. 73; TC1; Pointer equality; Superseded by 1652. 74; TC1; Enumeration value in direct-new-declarator; Yes. 75; TC1; In-class initialized members must be const; Yes. 76; TC1; Are const volatile variables considered ""constant expressions""?; Yes. 77; CD1; The definition of friend does not allow nested classes to be friends; Yes. 78; CD1; Section 8.5 paragraph 9 should state it only applies to non-static objects; Superseded by ????. 79; dup; Alignment and placement new; N/A. 80; TC1; Class members with same name as class; Clang 2.9. 81; NAD; Null pointers and C compatibility; N/A. 82; dup; Definition of ""using"" a constant expression; Duplicate of 48. 83; TC1; Overloading and deprecated conversion of string literal; Yes. 84; TC1; Overloading and conversion loophole used by auto_ptr; Yes. 85; TC1; Redeclaration of member class; Clang 3.4. 86; CD1; Lifetime of temporaries in query expressions; Duplicate of 446. 87; CD1; Exception specifications on function parameters; No. 88; NAD; Specialization of member constant templates; Clang 2.8. 89; TC1; Object lifetime does not account for reference rebinding; N/A. 90; TC1; Should the enclosing class be an ""associated class"" too?; Yes. 91; NAD; A unio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7565,Modifiability,extend,extended-namespace-definition,7565,"TC1; Should the enclosing class be an ""associated class"" too?; Yes. 91; NAD; A union's associated types should include the union itself; Yes. 92; CD4; Should exception-specifications be part of the type system?; Clang 4 (C++17 onwards). 93; TC1; Missing word in 3.8 basic.life paragraph 2; N/A. 94; TC1; Inconsistencies in the descriptions of constant expressions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9249,Modifiability,variab,variables,9249,; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:22814,Modifiability,variab,variable,22814,"te of 538. 328; CD1; Missing requirement that class member types be complete; Yes. 329; CD1; Evaluation of friends of templates; Clang 3.5. 330; CD4; Qualification conversions and pointers to arrays of pointers; Clang 7. 331; CD1; Allowed copy constructor signatures; Clang 11. 332; CD3; cv-qualified void parameter types; Duplicate of 577. 333; NAD; Ambiguous use of ""declaration"" in disambiguation section; Yes. 334; NAD; Is a comma-expression dependent if its first operand is?; Yes. 335; CD1; Allowing export on template members of nontemplate classes; No. 336; CD1; Explicit specialization examples are still incorrect; Yes. 337; CD1; Attempt to create array of abtract type should cause deduction to fail; Yes. 338; CD6; Enumerator name with linkage used as class name in other translation unit; Unknown. 339; CD1; Overload resolution in operand of sizeof in constant expression; Clang 2.8. 340; NAD; Unclear wording in disambiguation section; Yes. 341; C++11; extern ""C"" namespace member function versus global variable; Superseded by 1708. 342; CD3; Terminology: ""indirection"" versus ""dereference""; N/A. 343; C++17; Make template optional in contexts that require a type; No. 344; CD3; Naming destructors; Duplicate of 1435. 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:28822,Modifiability,variab,variables,28822,"Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instantiation; Yes. 416; CD1; Class must be complete to allow operator lookup?; Yes. 417; CD1; Using derived-class qualified name in out-of-class nested class definition; No. 418; CD6; Imperfect wording on error on multiple default arguments on a called function; No. 419; open; Can cast to virtual base class be done on partially-constructed object?; Not resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31199,Modifiability,variab,variable,31199,"of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conf",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31277,Modifiability,variab,variables,31277,"ime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across p",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31939,Modifiability,variab,variable,31939,of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Quali,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32202,Modifiability,inherit,inherited,32202,ull pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Oper,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32286,Modifiability,inherit,inheritance,32286,ariables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Operator overloading in constant expressions; Yes. 488; CD1; Local types,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:34494,Modifiability,variab,variable,34494,; Initializers for empty-class aggregrate members; Duplicate of 413. 492; CD1; typeid constness inconsistent with example; Unknown. 493; CD2; Type deduction from a bool context; Duplicate of 976. 494; CD1; Problems with the resolution of issue 45; Duplicate of 372. 495; CD2; Overload resolution with template and non-template conversion functions; Clang 3.5. 496; CD3; Is a volatile-qualified type really a POD?; Superseded by 2094. 497; CD1; Missing required initialization in example; Superseded by 253. 498; open; Storage class specifiers in definitions of class members; Not resolved. 499; CD2; Throwing an array of unknown size; Yes. 500; CD1; Access in base-specifiers of friend and nested classes; Duplicate of 372. 501; NAD; Visibility of friend declarations within the befriending class; Yes. 502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; CD1; Is the initializer for a namespace member in the scope of the namespace?; Yes. 515; CD1; Non-dependent references to base class members; Superseded by 1017. 516; CD1; Use of signed in bit-field declarations; N/A. 517; CD1; Partial specialization following explicit instantiation; No. 518; CD1; Trailing comma follo,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:42096,Modifiability,variab,variables,42096,Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditional expressions; Yes. 619; C++11; Completeness of array types; Yes. 620; CD1; Declaration order in layout-compatible POD structs; Duplicate of 568. 621; C++11; Template argument deduction from function return types; Yes. 622; NAD; Relational comparisons of arbitrary pointers; Unknown. 623; CD3; Use of pointers to deallocated storage; N/A. 624; CD1; Overflow in calculating size of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:43197,Modifiability,variab,variables,43197,-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditional expressions; Yes. 619; C++11; Completeness of array types; Yes. 620; CD1; Declaration order in layout-compatible POD structs; Duplicate of 568. 621; C++11; Template argument deduction from function return types; Yes. 622; NAD; Relational comparisons of arbitrary pointers; Unknown. 623; CD3; Use of pointers to deallocated storage; N/A. 624; CD1; Overflow in calculating size of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632; CD1; Brace-enclosed initializer for scalar member of aggregate; Yes. 633; CD2; Specifications for variables that should also apply to references; N/A. 634; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis redux; Yes. 635; NAD; Names of constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:44360,Modifiability,extend,extended,44360, constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr instances of constexpr constructor templates; Clang 3.1. 648; CD1; Constant expressions in constexpr initializers; Yes. 649; CD1; Optionally ill-formed extended alignment requests; Clang 3.5. 650; CD2; Order of destruction for temporaries bound to the returned value of a function; Unknown. 651; CD1; Problems in decltype specification and examples; Yes. 652; CD2; Compile-time evaluation of floating-point expressions; Yes. 653; CD2; Copy assignment of unions; Unknown. 654; CD1; Conversions to and from nullptr_t; Superseded by 1423. 655; C++11; Initialization not specified for forwarding constructors; Yes. 656; CD2; Direct binding to the result of a conversion operator; Yes. 657; CD2; Abstract class parameter in synthesized declaration; Partial. 658; CD2; Defining reinterpret_cast for pointer types; Unknown. 659; CD1; Alignment of function types; Clang 3.0. 660; CD1; Unnamed scoped enumerations; Clang 3.0. 661; CD1; Semantics of arithmetic comparisons; Unknown. 662; NAD; Forming a pointer to a reference type; Yes. 663; CD1; Valid Cyrillic identifier characters; Superseded by P1949. 664; CD2; Direct binding of references to non-class rvalue,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:46913,Modifiability,variab,variable,46913,coped enumeration type to integral type; Clang 2.9. 672; CD2; Sequencing of initialization in new-expressions; Unknown. 673; NAD; Injection of names from elaborated-type-specifiers in friend declarations; Yes. 674; C++11; “matching specialization” for a friend declaration; Clang 8. 675; CD3; Signedness of bit-field with typedef or template parameter type; Duplicate of 739. 676; C++11; static_assert-declarations and general requirements for declarations; N/A. 677; CD1; Deleted operator delete and virtual destructors; No. 678; C++11; Language linkage of member function parameter types and the ODR; Unknown. 679; CD1; Equivalence of template-ids and operator function templates; Yes. 680; CD2; What is a move constructor?; N/A. 681; CD1; Restrictions on declarators with late-specified return types; Partial. 682; CD5; Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/definitions in type-specifier-seqs and type-ids; Clang 3.0. 687; NAD; template keyword with unqualified-ids; Unknown. 688; CD1; Constexpr constructors and static initialization; Unknown. 689; CD5; Maximum values of signed and unsigned integers; Unknown. 690; CD2; The dynamic type of an rvalue reference; Unknown. 691; C++11; Template parameter packs in class template partial specializations; Unknown. 692; C++11; Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:49601,Modifiability,variab,variable,49601,"nknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by th",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50355,Modifiability,variab,variables,50355,"d_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:52305,Modifiability,variab,variables,52305,"alifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751; CD2; Deriving from closure classes; Unknown. 752; CD2; Name lookup in nested lambda-expressions; Unknown. 753; CD2; Array names in lambda capture sets; Unknown. 754; CD2; Lambda expressions in default arguments of block-scope function declarations; Unknown. 755; CD3; Generalized lambda-captures; Unknown. 756; CD2; Dropping cv-qualification on members of closure objects; Unknown. 757; CD2; Types without linkage in declarations; Unknown. 758; C++11; Missing cases of declarations that are not definitions; Unknown. 759; CD2; Destruction of closure objects; Unknown. 760; CD2; this inside a nested class of a non-static member function; Unknown. 761; CD2; Inferred return type of closure object call operator; Unknown. 762; CD2; Name lookup in the compound-statement of a lambda expression; Unknown. 763; CD2; Is a closure object's operator() inline?; Unknown. 764; CD2; Capturing unused variables in a lambda expression; Unknown. 765; CD2; Local types in inline functions with external linkage; Unknown. 766; CD2; Where may lambda expressions appear?; Unknown. 767; CD2; void and other unnamed lambda-parameters; Unknown. 768; CD2; Ellipsis in a lambda parameter list; Unknown. 769; CD2; Initialization of closure objects; Unknown. 770; CD2; Ambiguity in late-specified return type; Unknown. 771; CD2; Move-construction of reference members of closure objects; Unknown. 772; CD2; capture-default in lambdas in local default arguments; Unknown. 773; C++11; Parentheses in address non-type template arguments; Unknown. 774; CD2; Can a closure class be a POD?; Unknown. 775; CD2; Capturing references to functions; Unknown. 776; CD2; Delegating constructors, destructors, and std::exit; Unknown. 777; CD2; Default arguments and parameter packs; Clang 3.7. 778; C++11; Template parameter packs in non-type template parameters; Unknown. 779; CD2; Rvalue reference members of closure objects?; Unknow",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55127,Modifiability,variab,variables,55127,known. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57306,Modifiability,extend,extended,57306, Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and binding references to rvalues; Unknown. 879; CD2; Missing buil,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:59149,Modifiability,extend,extended,59149, rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and binding references to rvalues; Unknown. 879; CD2; Missing built-in comparison operators for pointer types; Unknown. 880; CD2; Built-in conditional operator for scoped enumerations; Unknown. 882; CD2; Defining main as deleted; Unknown. 883; CD2; std::memcpy vs std::memmove; Unknown. 884; CD2; Defining an explicitly-specialized static data member; Unknown. 885; NAD; Partial ordering of function templates with unordered parameter pairs; Unknown. 886; CD2; Member initializers and aggregates; Unknown. 887; CD2; Move construction of thrown object; Unknown. 888; CD2; Union member initializers; Unknown. 891; CD2; const_cast to rvalue reference from objectless rvalue; Unknown. 892; C++11; Missing requirements for constexpr constructors; Unknown. 893; NAD; Brace syntax for enumerator-definitions; Unknown. 896; CD2; Rvalue references and rvalue-reference conversion functions; Unknown. 897; open; _Pragma and extended string-literals; Not resolved. 898; C++11; Declarations in constexpr functions; Unknown. 899; CD2; Explicit conversion functions in direct class initialization; Unknown. 900; C++23; Lifetime of temporaries in range-based for; Unknown. 901; drafting; Deleted operator delete; Not resolved. 902; NAD; In-class initialization of non-constant static data members; Unknown. 903; CD3; Value-dependent integral null pointer constants; Unknown. 904; CD2; Parameter packs in lambda-captures; Unknown. 905; CD2; Explicit defaulted copy constructors and trivial copyability; Unknown. 906; CD2; Which special member functions can be defaulted?; Unknown. 908; CD2; Deleted global allocation and deallocation functions; Unknown. 909; NAD; Old-style casts with conversion functions; Unknown. 910; CD2; Move constructors and implicitly-declared copy constructors; Unknown. 912; CD3; Character literals and universal-character-names; Unknown. 913; CD2; Deduction rules for array- and function-type conversion functio,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67463,Modifiability,variab,variable,67463,"e declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:70512,Modifiability,inherit,inheritance,70512,"ODness; Unknown. 1053; NAD; Terminate vs undefined behavior for noexcept violation; Unknown. 1054; C++11; Lvalue-to-rvalue conversions in expression statements; No. 1055; C++11; Permissible uses of void; Unknown. 1056; C++11; Template aliases, member definitions, and the current instantiation; Unknown. 1057; C++11; decltype and the current instantiation; Unknown. 1058; NAD; Reference binding of incompatible array types; Unknown. 1059; CD3; Cv-qualified array types (with rvalues); Unknown. 1060; C++11; Scoped enumerators in integral constant expressions; Unknown. 1061; C++11; Negative array bounds in a new-expression; Unknown. 1062; C++11; Syntax of attribute-specifiers in lambdas; Unknown. 1063; C++11; [[hiding]] with non-attribute declarations; Unknown. 1064; C++11; Defaulted move constructor for a union; Unknown. 1065; C++11; [[hiding]] with [[override]]; Unknown. 1066; C++11; When is a copy/move assignment operator implicitly defined?; Unknown. 1067; NAD; [[hiding]], using-declarations, and multiple inheritance; Unknown. 1068; C++11; Template aliases with default arguments and template parameter packs; Unknown. 1069; C++11; Incorrect function type with trailing-return-type; Unknown. 1070; C++11; Missing initializer clauses in aggregate initialization; Clang 3.5. 1071; C++11; Literal class types and trivial default constructors; Unknown. 1072; C++11; Scoped enumerator with the same name as its containing class; Unknown. 1073; C++11; Merging dynamic-exception-specifications and noexcept-specifications; Unknown. 1074; C++11; Value-dependent noexcept-expressions; Unknown. 1075; C++11; Grammar does not allow template alias in type-name; Unknown. 1076; CD5; Value categories and lvalue temporaries; Unknown. 1077; NAD; Explicit specializations in non-containing namespaces; Unknown. 1078; NAD; Narrowing and the usual arithmetic conversions; Unknown. 1079; C++11; Overload resolution involving aggregate initialization; Unknown. 1080; C++11; Confusing relationship between te",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:73709,Modifiability,variab,variables,73709,pressions; Unknown. 1099; C++11; Infinite recursion in constexpr functions; Unknown. 1100; C++11; constexpr conversion functions and non-type template arguments; Unknown. 1101; C++11; Non-integral initialized static data members; Unknown. 1102; C++11; Better example of undefined behavior; Unknown. 1103; C++11; Reversion of phase 1 and 2 transformations in raw string literals; Unknown. 1104; C++11; Global-scope template arguments vs the <: digraph; Unknown. 1105; C++11; Issues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; U,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:76687,Modifiability,variab,variable,76687,OD class; Unknown. 1141; NAD; Non-static data member initializers have not been implemented; Unknown. 1142; C++11; friend declaration of member function of containing class; Unknown. 1143; NAD; Move semantics for *this have not been implemented; Unknown. 1144; C++11; Remove access declarations; Unknown. 1145; C++11; Defaulting and triviality; Unknown. 1146; C++11; exception-specifications of defaulted functions; Unknown. 1147; C++11; Destructors should be default nothrow; Unknown. 1148; C++11; Copy elision and move construction of function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unkno,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:89253,Modifiability,extend,extended,89253,"ol; Unknown. 1321; CD3; Equivalency of dependent calls; Unknown. 1322; drafting; Function parameter type decay in templates; Not resolved. 1323; NAD; Nonexistent nonterminal in alignment-specifier grammar; Unknown. 1324; CD3; Value initialization and defaulted constructors; Unknown. 1325; NAD; Omitted declarator in friend declarations; Unknown. 1326; dup; Deducing an array bound from an initializer-list; Unknown. 1327; CD3; virt-specifier in a defaulted definition; Unknown. 1328; CD3; Conflict in reference binding vs overload resolution; Unknown. 1329; CD3; Recursive deduction substitutions; Unknown. 1330; CD3; Delayed instantiation of noexcept specifiers; Clang 4 (C++11 onwards). 1331; CD5; const mismatch with defaulted copy constructor; Unknown. 1332; CD5; Handling of invalid universal-character-names; Unknown. 1333; CD3; Omission of const in a defaulted copy constructor; Unknown. 1334; NAD; Layout compatibility and cv-qualification; Unknown. 1335; CD6; Stringizing, extended characters, and universal-character-names; Unknown. 1336; CD3; Definition of “converting constructor”; Unknown. 1337; dup; Partial ordering and non-deduced parameters; Unknown. 1338; CD4; Aliasing and allocation functions; Unknown. 1339; NAD; Parenthesized braced-init-list and arrays; Unknown. 1340; CD3; Complete type in member pointer expressions; Unknown. 1341; NAD; Bit-field initializers; Superseded by P0683R1. 1342; CD6; Order of initialization with multiple declarators; Unknown. 1343; C++17; Sequencing of non-class initialization; Unknown. 1344; C++14; Adding new special member functions to a class via default arguments; Unknown. 1345; CD3; Initialization of anonymous union class members; Unknown. 1346; CD3; expression-list initializers and the auto specifier; Clang 3.5. 1347; CD3; Consistency of auto in multiple-declarator declarations; Clang 3.1. 1348; drafting; Use of auto in a trailing-return-type; Not resolved. 1349; dup; Consistency of alias template redeclarations; Unknown. 1350; CD",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:90312,Modifiability,inherit,inherited,90312,; Unknown. 1336; CD3; Definition of “converting constructor”; Unknown. 1337; dup; Partial ordering and non-deduced parameters; Unknown. 1338; CD4; Aliasing and allocation functions; Unknown. 1339; NAD; Parenthesized braced-init-list and arrays; Unknown. 1340; CD3; Complete type in member pointer expressions; Unknown. 1341; NAD; Bit-field initializers; Superseded by P0683R1. 1342; CD6; Order of initialization with multiple declarators; Unknown. 1343; C++17; Sequencing of non-class initialization; Unknown. 1344; C++14; Adding new special member functions to a class via default arguments; Unknown. 1345; CD3; Initialization of anonymous union class members; Unknown. 1346; CD3; expression-list initializers and the auto specifier; Clang 3.5. 1347; CD3; Consistency of auto in multiple-declarator declarations; Clang 3.1. 1348; drafting; Use of auto in a trailing-return-type; Not resolved. 1349; dup; Consistency of alias template redeclarations; Unknown. 1350; CD3; Incorrect exception specification for inherited constructors; Clang 3.5. 1351; CD4; Problems with implicitly-declared exception-specifications; Unknown. 1352; CD3; Inconsistent class scope and completeness rules; Unknown. 1353; DRWP; Array and variant members and deleted special member functions; Unknown. 1354; CD3; Destructor exceptions for temporaries in noexcept expressions; Unknown. 1355; CD3; Aggregates and “user-provided” constructors; Unknown. 1356; CD4; Exception specifications of copy assignment operators with virtual bases; Unknown. 1357; CD3; brace-or-equal-initializers for function and typedef members; Unknown. 1358; CD3; Unintentionally ill-formed constexpr function template instances; Clang 3.1. 1359; CD3; constexpr union constructors; Clang 3.5. 1360; CD6; constexpr defaulted default constructors; Unknown. 1361; CD3; Requirement on brace-or-equal-initializers of literal types; Unknown. 1362; CD3; Complete type required for implicit conversion to T&; Unknown. 1363; CD3; Triviality vs multiple default,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98912,Modifiability,variab,variables,98912,"address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; Whe",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99911,Modifiability,inherit,inheriting,99911, Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497; NAD; Aggregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:101617,Modifiability,variab,variables,101617,gregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Arr,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102894,Modifiability,variab,variable,102894,lo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage o,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109025,Modifiability,variab,variables,109025,"enumeration with fixed underlying type; Clang 10. 1602; review; Linkage of specialization vs linkage of template arguments; Not resolved. 1603; CD4; Errors resulting from giving unnamed namespaces internal linkage; Unknown. 1604; C++14; Double temporaries in reference initialization; Unknown. 1605; CD3; Misleading parenthetical comment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109358,Modifiability,extend,extended,109358,"mment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1630; CD4; Multiple default constructor templates; Unknown. 1631; CD4; Incorrect overload resolution for single-element initializer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:111136,Modifiability,inherit,inheriting,111136,"zer-list; Clang 3.7. 1632; CD5; Lambda capture in member initializers; Unknown. 1633; CD4; Copy-initialization in member initialization; Unknown. 1634; drafting; Temporary storage duration; Not resolved. 1635; drafting; How similar are template default arguments to function default arguments?; Not resolved. 1636; CD5; Bits required for negative enumerator values; Unknown. 1637; NAD; Recursion in constexpr template default constructor; Unknown. 1638; CD4; Declaring an explicit specialization of a scoped enumeration; Clang 3.1. 1639; CD4; exception-specifications and pointer/pointer-to-member expressions; Unknown. 1640; CD5; Array of abstract instance of class template; Unknown. 1641; NAD; Assignment in member initializer; Unknown. 1642; DRWP; Missing requirements for prvalue operands; Unknown. 1643; NAD; Default arguments for template parameter packs; Unknown. 1644; NAD; Equivalent exception-specifications in function template declarations; Unknown. 1645; CD4; Identical inheriting constructors via default arguments; Clang 3.9. 1646; CD5; decltype-specifiers, abstract classes, and deduction failure; Unknown. 1647; drafting; Type agreement of non-type template arguments in partial specializations; Not resolved. 1648; C++14; thread_local vs block extern declarations; Unknown. 1649; C++14; Error in the syntax of mem-initializer-list; Unknown. 1650; NAD; Class prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114096,Modifiability,variab,variables,114096,ng 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs se,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114248,Modifiability,variab,variables,114248,eduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115374,Modifiability,variab,variable,115374,namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning e,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115884,Modifiability,variab,variable,115884,; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:115957,Modifiability,variab,variable,115957, its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 17,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116020,Modifiability,variab,variable,116020,reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknow,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116142,Modifiability,inherit,inherited,116142,esolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and def,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117005,Modifiability,variab,variable,117005, 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexce,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117083,Modifiability,variab,variable,117083,AD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue con,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117163,Modifiability,variab,variable,117163,d constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown.,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117214,Modifiability,variab,variable,117214,luated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered init,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117851,Modifiability,inherit,inheriting,117851,return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier o,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:118245,Modifiability,variab,variable,118245,d type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier of destructor; Clang 11. 1754; NAD; Declaration of partial specialization of static data member template; Unknown. 1755; drafting; Out-of-class partial specializations of member templates; Not resolved. 1756; CD4; Direct-list-initialization of a non-class object; Clang 3.7. 1757; CD4; Const integral subobjects; Unknown. 1758; CD4; Explicit conversion in copy/move list initialization; Clang 3.7. 1759,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:118323,Modifiability,variab,variable,118323,special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier of destructor; Clang 11. 1754; NAD; Declaration of partial specialization of static data member template; Unknown. 1755; drafting; Out-of-class partial specializations of member templates; Not resolved. 1756; CD4; Direct-list-initialization of a non-class object; Clang 3.7. 1757; CD4; Const integral subobjects; Unknown. 1758; CD4; Explicit conversion in copy/move list initialization; Clang 3.7. 1759; C++14; UTF-8 code units in plain char; Unknown. 1760; C++14; Access,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:123452,Modifiability,inherit,inherited,123452, as member-declaration; Clang 2.9. 1804; CD4; Partial specialization and friendship; Clang 2.7. 1805; CD4; Conversions of array operands in conditional-expressions; Unknown. 1806; CD4; Virtual bases and move-assignment; Unknown. 1807; CD4; Order of destruction of array elements after an exception; Clang 3.0. 1808; drafting; Constructor templates vs default constructors; Not resolved. 1809; CD4; Narrowing and template argument deduction; Unknown. 1810; CD4; Invalid ud-suffixes; Unknown. 1811; CD4; Lookup of deallocation function in a virtual destructor definition; Unknown. 1812; C++17; Omission of template in a typename-specifier; No. 1813; CD4; Direct vs indirect bases in standard-layout classes; Clang 7. 1814; CD4; Default arguments in lambda-expressions; Yes. 1815; CD4; Lifetime extension in aggregate initialization; No. 1816; CD4; Unclear specification of bit-field values; Unknown. 1817; drafting; Linkage specifications and nested scopes; Not resolved. 1818; CD6; Visibility and inherited language linkage; Unknown. 1819; CD4; Acceptable scopes for definition of partial specialization; Unknown. 1820; CD6; Qualified typedef names; Unknown. 1821; CD6; Qualified redeclarations in a class member-specification; Clang 2.9. 1822; CD6; Lookup of parameter names in lambda-expressions; Yes. 1823; CD4; String literal uniqueness in inline functions; Unknown. 1824; CD4; Completeness of return type vs point of instantiation; Unknown. 1825; C++17; Partial ordering between variadic and non-variadic function templates; Unknown. 1826; NAD; const floating-point in constant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declar,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125313,Modifiability,variab,variable,125313,eted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130503,Modifiability,variab,variables,130503,ation; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qual,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:131817,Modifiability,inherit,inherited,131817,ime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from lambda; Unknown. 1938; CD5; Should hosted/freestanding be implementation-defined?; Unknown. 1939; open; Argument conversions to nondeduced parameter types revisited; Not resolved. 1940; CD4; static_assert in anonymous unions; Clang 3.5. 1941; CD4; SFINAE and inherited constructor default arguments; Clang 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:132873,Modifiability,variab,variables,132873,ng 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and ope,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:133053,Modifiability,inherit,inherited,133053,arations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant spe,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134656,Modifiability,extend,extending,134656,expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138170,Modifiability,variab,variable,138170,n vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter lists; Unknown. 2046; C++17; Incomplete thread specifications; Unknown. 2047; CD4; Coordinating “throws anything” specificat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144466,Modifiability,flexible,flexible,144466,versions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initial,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144602,Modifiability,variab,variables,144602,cified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit mem,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144757,Modifiability,extend,extended,144757,5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:146029,Modifiability,variab,variable,146029,r-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clang 11. 2158; drafting; Polymorphic behavior during destruction; Not r,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:147097,Modifiability,variab,variables,147097,"CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clang 11. 2158; drafting; Polymorphic behavior during destruction; Not resolved. 2159; NAD; Lambda capture and local thread_local variables; Unknown. 2160; open; Issues with partial ordering; Not resolved. 2161; NAD; Explicit instantiation declaration and “preceding initialization”; Unknown. 2162; CD3; Capturing this by reference; Unknown. 2163; CD4; Labels in constexpr functions; Unknown. 2164; CD5; Name hiding and using-directives; Unknown. 2165; CD6; Namespaces, declarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolved. 2173; open; Partial specialization with non-deduced contexts; Not ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:151282,Modifiability,variab,variable,151282,"ictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-d",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:153169,Modifiability,variab,variable,153169,"Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, and TUs; Not resolved. 2251; C++17; Unreachable enumeration list-initialization; Unknown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class friend definition; Extension. 2262; C++17; Attributes for asm-definition;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:155211,Modifiability,inherit,inheriting,155211,r friends; Not resolved. 2264; drafting; Memberwise copying with indeterminate value; Not resolved. 2265; drafting; Delayed pack expansion and member redeclarations; Not resolved. 2266; CD5; Has dependent type vs is type-dependent; Unknown. 2267; CD5; Copy-initialization of temporary in reference direct-initialization; No. 2268; C++17; Unions with mutable members in constant expressions revisited; Unknown. 2269; dup; Additional recursive references in aggregate DMIs; Unknown. 2270; NAD; Non-inline functions and explicit instantiation declarations; Unknown. 2271; C++17; Aliasing this; Unknown. 2272; C++17; Implicit initialization of aggregate members of reference type; Unknown. 2273; CD5; Inheriting constructors vs implicit default constructor; Unknown. 2274; NAD; Generic lambda capture vs constexpr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unkn,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157136,Modifiability,inherit,inheritance,157136,nknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Sel,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157276,Modifiability,variab,variable,157276,ion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; draf,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157854,Modifiability,variab,variables,157854,constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initializat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159096,Modifiability,variab,variable,159096,Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160245,Modifiability,variab,variables,160245,own. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ s,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160887,Modifiability,inherit,inherited,160887,"resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ should be constexpr; Not resolved. 2363; NAD; Opaque enumeration friend declarations; Unknown. 2364; NAD; Constant expressions, aggregate initialization, and modifications; Unknown. 2365; CD5; Confusing specification for dynamic_cast; Unknown. 2366; CD5; Can default initialization be constant initialization?; Unknown. 2367; NAD; Lambdas in default arguments vs the ODR; Unknown. 2368; CD5; Differences in relational and three-way constant comparisons; Unknown. 2369; CD6; Ordering between constraints and substitution; Unknown. 2370; CD6; friend declarations of namespace-scope functions; No. 2371; CD5; Use",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163137,Modifiability,variab,variable,163137,specification of enum direct-list-initialization; Unknown. 2375; NAD; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:163290,Modifiability,variab,variable,163290, CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD5; Const-default-constructible for members; Clang 15. 2395; drafting; Parameters following a pack expansion; Not resolved. 2396; CD6; Lookup of names in complex conversion-type-ids; No. 2397; CD6; auto specifier for pointers and references to arrays; Clang 17. 2398; drafting; Template template parameter matching and deduction; Not resolved. 2399; CD5; Unclear referent of “expression” in assignment-expression; Unknown. 2400; CD5; Constexpr virtual functions and temporary objects; Unknown. 2401; drafting; Array decay vs prohibition of subobject non-type arguments; Not resolved. 2402; CD6; When is the restriction to a single c-char in a Unicode literal enfor,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166265,Modifiability,variab,variables,166265,"nknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:174018,Modifiability,variab,variables,174018,"espace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175328,Modifiability,variab,variable,175328,"40; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafting; Conversion to function pointer with an explicit object parameter; Not res",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186308,Modifiability,extend,extended,186308,"egate CTAD, string, and brace elision; Unknown. 2686; open; Pack expansion into a non-pack parameter of a concept; Not resolved. 2687; C++23; Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186555,Modifiability,inherit,inheritance,186555," Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:191705,Modifiability,variab,variable,191705,"; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; Unknown. 2761; DR; Implicitly invoking the deleted destructor of an anonymous union member; Unknown. 2762; DR; Type of implicit object parameter; Unknown. 2763; DR; Ignorability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function parameters before they are substituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; r",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194221,Modifiability,variab,variables,194221,"ect copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolv",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194566,Modifiability,rewrite,rewrite,194566,"g to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolved. 2814; review; Alignment requirement of incomplete class type; Not resolved. 2815; open; Overload resolution for references/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196668,Modifiability,variab,variables,196668,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:196945,Modifiability,extend,extended,196945,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:197020,Modifiability,inherit,inheriting,197020,"rences/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary expression""; Unknown. 2827; review; Representation of unsigned integral types; Not resolved. 2828; review; Ambiguous interpretation of C-style cast; Not resolved. 2829; open; Redundant case in restricting user-defined conversion sequences; Not resolved. 2830; open; Top-level cv-qualification should be ignored for list-initialization; Not resolved. 2831; open; Non-templated function definitions and requires-clauses; Not resolved. 2832; open; Invented temporary variables and temporary objects; Not resolved. 2833; review; Evaluation of odr-use; Not resolved. 2834; open; Partial ordering and explicit object parameters; Not resolved. 2835; open; Name-independent declarations; Not resolved. 2836; open; Conversion rank of long double and extended floating-point types; Not resolved. 2837; open; Instantiating and inheriting by-value copy constructors; Not resolved. 2838; open; Declaration conflicts in lambda-expressions; Not resolved. 2839; open; Explicit destruction of base classes; Not resolved. 2840; open; Missing requirements for fundamental alignments; Not resolved. 2841; open; When do const objects start being const?; Not resolved. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:806,Performance,optimiz,optimization,806,". Clang - C++ Defect Report Status. C++ Defect Report Support in Clang. C++ defect report implementation status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65280,Performance,perform,perform,65280,D2; Position of attribute-specifier in declarator syntax; Unknown. 980; CD2; Explicit instantiation of a member of a class template; Unknown. 981; C++11; Constexpr constructor templates and literal types; Unknown. 982; NAD; Initialization with an empty initializer list; Unknown. 983; CD2; Ambiguous pointer-to-member constant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:81076,Performance,multi-thread,multi-threaded,81076,ialized static data members; Unknown. 1204; C++11; Specifiers in a for-range-declaration; Unknown. 1205; dup; Lvalue reference binding and function viability; Unknown. 1206; C++11; Defining opaque enumeration members of class templates; Unknown. 1207; C++11; Type of class member in trailing-return-type; Unknown. 1208; C++11; Explicit noexcept in defaulted definition; Unknown. 1209; open; Is a potentially-evaluated expression in a template definition a “use?”; Not resolved. 1210; C++11; Injection of elaborated-type-specifier in enumeration scope; Unknown. 1211; drafting; Misaligned lvalues; Not resolved. 1212; C++11; Non-function-call xvalues and decltype; Unknown. 1213; CD3; Array subscripting and xvalues; Clang 7. 1214; C++11; Kinds of initializers; Unknown. 1215; C++11; Definition of POD struct; Unknown. 1216; C++11; Exceptions “allowed” by a noexcept-specification; Unknown. 1217; NAD; Are deleted functions implicitly noexcept?; Unknown. 1218; C++11; What is the “currently-handled exception” in a multi-threaded program?; Unknown. 1219; C++11; Non-static data member initializers in constant expressions; Unknown. 1220; C++11; Looking up conversion-type-ids; Unknown. 1221; open; Partial ordering and reference collapsing; Not resolved. 1222; NAD; Unnecessary restriction on auto array types; Unknown. 1223; drafting; Syntactic disambiguation and trailing-return-types; Clang 17. 1224; C++11; constexpr defaulted copy constructors; Unknown. 1225; C++11; constexpr constructors and virtual bases; Unknown. 1226; CD3; Converting a braced-init-list default argument; Unknown. 1227; CD3; Mixing immediate and non-immediate contexts in deduction failure; Clang 3.0. 1228; NAD; Copy-list-initialization and explicit constructors; Unknown. 1229; C++11; Overload resolution with empty braced-init-list argument; Unknown. 1230; dup; Confusing description of ambiguity of destructor name; Unknown. 1231; C++11; Variadic templates requiring an empty pack expansion; Unknown. 1232; C++11; Creati,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:133193,Performance,concurren,concurrent,133193,; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown. 1956; CD4; Reuse of storage of automatic variables; Unknown. 1957; NAD; decltype(auto) with direct-list-initialization; Unknown. 1958; CD4; decltype(auto) with parenthesized initializer; Unknown. 1959; CD4; Inadvertently inherited copy constructor; Clang 3.9. 1960; NAD; Visibility of entity named in class-scope using-declaration; No. 1961; C++17; Potentially-concurrent actions within a signal handler; Unknown. 1962; open; Type of __func__; Not resolved. 1963; CD4; Implementation-defined identifier characters; Unknown. 1964; NAD; opaque-enum-declaration in alias-declaration?; Unknown. 1965; drafting; Explicit casts to reference types; Not resolved. 1966; CD4; Colon following enumeration elaborated-type-specifier; Clang 11. 1967; CD4; Temporary lifetime and move-elision; Unknown. 1968; NAD; Address of typeid in constant expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:174567,Performance,optimiz,optimized,174567,"ences; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration preven",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50419,Safety,safe,safely-derived,50419,n. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:57255,Safety,safe,safety,57255,; CD2; Value of preprocessing numbers; Unknown. 833; CD2; Explicit conversion of a scoped enumeration value to a floating type; Unknown. 834; CD2; What is an “ordinary string literal”?; Unknown. 835; CD2; Scoped enumerations and the “usual arithmetic conversions”; Unknown. 836; NAD; [[noreturn]] applied to function types; Unknown. 837; C++11; Constexpr functions and return braced-init-list; Unknown. 838; C++11; Use of this in a brace-or-equal-initializer; Unknown. 839; dup; sizeof with opaque enumerations; Unknown. 840; CD2; Rvalue references as nontype template parameters; Unknown. 842; CD2; Casting to rvalue reference type; Unknown. 845; CD2; What is the “first declaration” of an explicit specialization?; Unknown. 846; CD2; Rvalue references to functions; Unknown. 847; CD2; Error in rvalue reference deduction example; Unknown. 850; CD2; Restrictions on use of non-static data members; Unknown. 852; CD6; using-declarations and dependent base classes; Unknown. 853; CD2; Support for relaxed pointer safety; Unknown. 854; CD2; Left shift and unsigned extended types; Unknown. 855; CD2; Incorrect comments in braced-init-list assignment example; Unknown. 858; CD2; Example binding an rvalue reference to an lvalue; Unknown. 860; C++11; Explicit qualification of constexpr member functions; Unknown. 861; CD2; Unintended ambiguity in inline namespace lookup; Unknown. 862; CD2; Undefined behavior with enumerator value overflow; Unknown. 863; CD2; Rvalue reference cast to incomplete type; Unknown. 864; C++11; braced-init-list in the range-based for statement; Unknown. 865; CD2; Initializing a std::initializer_list; Unknown. 869; CD2; Uninitialized thread_local objects; Unknown. 872; CD2; Lexical issues with raw strings; Unknown. 873; C++11; Deducing rvalue references in declarative contexts; Clang 3.0. 874; CD2; Class-scope definitions of enumeration types; Unknown. 876; CD2; Type references in rvalue reference deduction specification; Unknown. 877; CD2; Viable functions and bindi,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:77815,Safety,safe,safety,77815,Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Recursive instantiation via alias template; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unk,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:79188,Safety,safe,safely-derived,79188, C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initialization example; Unknown. 1188; C++11; Type punning in constant expressions; Unknown. 1189; C++11; Address of distinct base class subobjects; Unknown. 1190; C++11; Operations on non-safely-derived pointers; Unknown. 1191; C++11; Deleted subobject destructors and implicitly-defined constructors; Unknown. 1192; C++11; Inadvertent change to ODR and templates; Unknown. 1193; C++11; Use of address-constant pointers in constant expressions; Unknown. 1194; C++11; Constexpr references; Unknown. 1195; C++11; References to non-literal types in constexpr functions; Unknown. 1196; C++11; Definition required for explicit instantiation after explicit specialization?; Unknown. 1197; C++11; Constexpr arrays; Unknown. 1198; C++11; Literal types and copy constructors; Unknown. 1199; C++11; Deleted constexpr functions; Unknown. 1200; CD6; Lookup rules for template parameters; N/A. 1201; C++11; Are deleted and defaulted functions definitions?; Unknown. 1202; C++11; Calling virtual functions during destruction; Unknown. 1203; dup; Misleading note regarding initialized static data members; Unknown. 1204; C++11; Specifiers in a for-range-declaration; Unknown. 1205; dup; Lvalue reference ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:98536,Safety,redund,redundant,98536,"o linkage in non-type template arguments; Unknown. 1452; NAD; Value-initialized objects may be constants; Unknown. 1453; CD3; Volatile members in literal classes?; Unknown. 1454; CD3; Passing constants through constexpr functions via references; Unknown. 1455; CD3; Lvalue converted constant expressions; Unknown. 1456; CD3; Address constant expression designating the one-past-the-end address; Unknown. 1457; CD3; Undefined behavior in left-shift; Unknown. 1458; CD3; Address of incomplete type vs operator&(); Unknown. 1459; open; Reference-binding tiebreakers in overload resolution; Not resolved. 1460; C++14; What is an empty union?; Clang 3.5. 1461; NAD; Narrowing conversions to bit-fields; Unknown. 1462; CD3; Deduction failure vs “ill-formed, no diagnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106282,Safety,safe,safety,106282,and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inheriting constructors and copy/move constructors; Unknown. 1568; dup; Temporary lifetime extension with intervening cast; Unknown. 1569; C++14; Deducing a function parameter pack before ellipsis; Unknown. 1570; C++14; Address of subobject as non-type template argument; Unknown. 1571; CD4; cv-qualification for indirect reference binding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 15,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187787,Safety,redund,redundant,187787,"types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumer",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1187,Security,access,access,1187,"Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1256,Security,access,access,1256,"on but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1950,Security,access,accessed,1950,"function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 3",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:2086,Security,access,access,2086,"nts used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:4168,Security,access,access,4168,"on of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversions; Clang 2.8. 52; TC1; Non-static members, member selection and access checking; Clang 2.8. 53; TC1; Lvalue-to-rvalue conversion before certain static_casts; Yes. 54; CD1; Static_cast from private base to derived class; Clang 2.8. 55; NAD; Adding/subtracting pointer and enumeration value; Yes. 56; TC1; Redeclaring typedefs within classes; Yes. 57; open; Empty unions; Not resolved. 58; CD1; Signedness of bit fields of enum type; Clang 3.1. 59; TC1; Clarification of overloading and UDC to reference type; Yes. 60; CD1; Reference binding and valid conversion sequences; Yes. 61; NAD; Address of static member function ""&p->f""; Clang 3.4. 62; CD1; Unnamed members of classes used as type parameters; Clang 2.9. 63; CD1; Class instantiation from pointer conversion to void*, null and self; Yes. 64; TC1; Partial ordering to disambiguate explicit specialization; Yes. 65; TC1; Typo in default argument example; N/A. 66; NAD; Visibility of default args vs overloads added after using-declaration; No. 67; TC1; Evaluation of left side of object-expressio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9913,Security,access,access,9913,emporaries in default initialization of class arrays; Duplicate of 201. 125; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; C,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:9982,Security,access,access,9982,25; CD1; Ambiguity in friend declaration syntax; Yes. 126; TC1; Exception specifications and const; Partial. 127; TC1; Ambiguity in description of matching deallocation function; Clang 2.9. 128; TC1; Casting between enum types; Yes. 129; CD3; Stability of uninitialized auto variables; Duplicate of 616. 130; NAD; Sequence points and new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected neste,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11726,Security,inject,injection,11726,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11750,Security,access,access,11750,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,Security,inject,injection,11784,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13644,Security,access,access,13644,"D-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member f",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13762,Security,access,accessible,13762,"Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18081,Security,access,access,18081,"on; Clang 4. 260; open; User-defined conversions and built-in operator=; Not resolved. 261; CD1; When is a deallocation function ""used?""; No. 262; CD1; Default arguments and ellipsis; Yes. 263; CD1; Can a constructor be declared a friend?; Clang 3.3. 264; open; Unusable template constructors and conversion functions; Not resolved. 265; dup; Destructors, exceptions, and deallocation; Duplicate of 353. 266; NAD; No grammar sentence symbol; N/A. 267; open; Alignment requirement for new-expressions; Not resolved. 268; open; Macro name suppression in rescanned replacement text; Not resolved. 269; NAD; Order of initialization of multiply-defined static data members; of class templates; N/A. 270; CD1; Order of initialization of static data members of class templates; N/A. 271; CD6; Explicit instantiation and template argument deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,Security,inject,injection,20182,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24043,Security,access,access,24043," 345; CD1; Misleading comment on example in templates chapter; Yes. 346; NAD; Typo in 15.4; N/A. 347; NAD; Use of derived class name in defining base class nested class; Yes. 348; CD1; delete and user-written deallocation functions; N/A. 349; CD1; Template argument deduction for conversion functions and qualification conversions; No. 350; open; signed char underlying representation for objects; Not resolved. 351; CD1; Sequence point error: unspecified or undefined?; N/A. 352; CD1; Nondeduced contexts; Clang 2.8. 353; CD1; Is deallocation routine called if destructor throws exception in delete?; Unknown. 354; CD1; Null as nontype template argument; Yes (C++11 onwards). 355; C++11; Global-scope :: in nested-name-specifier; Yes. 356; NAD; Wording of behavior of generated copy constructor for scalar members; N/A. 357; CD1; Definition of signature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit sp",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24836,Security,access,access,24836,"ignature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:26931,Security,access,access,26931," CD1; Errors in example in 14.6.5; Clang 2.8. 388; CD3; Catching base*& from a throw of derived*; Unknown. 389; CD1; Unnamed types in entities with linkage; No. 390; CD1; Pure virtual must be defined when implicitly called; Clang 3.3. 391; CD1; Require direct binding of short-lived references to rvalues; Clang 2.8 (C++11 onwards). 392; CD1; Use of full expression lvalue before temporary destruction; Unknown. 393; CD4; Pointer to array of unknown bound in template argument list in parameter; Unknown. 394; CD1; identifier-list is never defined; N/A. 395; NAD; Conversion operator template syntax; Clang 3.0. 396; CD1; Misleading note regarding use of auto for disambiguation; Yes. 397; CD1; Same address for string literals from default arguments in inline functions?; Superseded by 1823. 398; CD1; Ambiguous wording on naming a type in deduction; Yes. 399; CD6; Destructor lookup redux; Clang 11. 400; CD1; Using-declarations and the ""struct hack""; Yes. 401; CD1; When is access for template parameter default arguments checked?; Clang 2.8. 402; open; More on partial ordering of function templates; Not resolved. 403; CD1; Reference to a type as a template-id; Yes. 404; CD1; Unclear reference to construction with non-trivial constructor; N/A. 405; CD6; Unqualified function name lookup; Yes. 406; CD1; Static data member in class with name for linkage purposes; Clang 2.9. 407; C++11; Named class with associated typedef: two names or one?; Clang 3.8. 408; CD2; sizeof applied to unknown-bound array static data member of template; Clang 3.4. 409; CD1; Obsolete paragraph missed by changes for issue 224; Yes. 410; CD1; Paragraph missed in changes for issue 166; No. 411; CD6; Use of universal-character-name in character versus string literals; Unknown. 412; NAD; Can a replacement allocation function be inline?; Clang 3.4. 413; CD1; Definition of ""empty class""; Yes. 414; CD1; Multiple types found on destructor lookup; Duplicate of 305. 415; CD1; Template deduction does not cause instanti",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29274,Security,inject,injected,29274,"ot resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29397,Security,inject,inject,29397,"; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording is",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29823,Security,access,accesses,29823,"riables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32212,Security,access,access,32212,ull pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Oper,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41154,Security,access,access,41154, conditional expression differing only in cv-qualification; Clang 3.2. 588; CD2; Searching dependent bases of classes local to function templates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminat,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41297,Security,inject,injected-class-name,41297,lates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditiona,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:49149,Security,access,access,49149,"the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; C",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:66351,Security,access,access,66351,"raced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constr",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67047,Security,access,access,67047," of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74061,Security,access,access,74061, phase 1 and 2 transformations in raw string literals; Unknown. 1104; C++11; Global-scope template arguments vs the <: digraph; Unknown. 1105; C++11; Issues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74216,Security,access,access,74216,ues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; U,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:75967,Security,access,access,75967,ustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; Unknown. 1134; C++11; When is an explicitly-defaulted function defined?; Unknown. 1135; C++11; Explicitly-defaulted non-public special member functions; Unknown. 1136; C++11; Explicitly-defaulted explicit constructors; Unknown. 1137; C++11; Explicitly-defaulted virtual special member functions; Unknown. 1138; C++11; Rvalue-ness check for rvalue reference binding is wrong; Unknown. 1139; C++11; Rvalue reference binding to scalar xvalues; Unknown. 1140; C++11; Incorrect redefinition of POD class; Unknown. 1141; NAD; Non-static data member initializers have not been implemented; Unknown. 1142; C++11; friend declaration of member function of containing class; Unknown. 1143; NAD; Move semantics for *this have not been implemented; Unknown. 1144; C++11; Remove access declarations; Unknown. 1145; C++11; Defaulting and triviality; Unknown. 1146; C++11; exception-specifications of defaulted functions; Unknown. 1147; C++11; Destructors should be default nothrow; Unknown. 1148; C++11; Copy elision and move construction of function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Re,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:95653,Security,access,accessible,95653, Reference overload tiebreakers should apply to rvalue references; Unknown. 1411; CD3; More on global scope :: in nested-name-specifier; Unknown. 1412; CD3; Problems in specifying pointer conversions; Unknown. 1413; CD3; Missing cases of value-dependency; Clang 12. 1414; drafting; Binding an rvalue reference to a reference-unrelated lvalue; Not resolved. 1415; CD3; Missing prohibition of block-scope definition of extern object; Unknown. 1416; CD3; Function cv-qualifiers and typeid; Unknown. 1417; C++14; Pointers/references to functions with cv-qualifiers or ref-qualifier; Unknown. 1418; CD3; Type of initializer_list backing array; Unknown. 1419; NAD; Evaluation order in aggregate initialization; Unknown. 1420; NAD; Abstract final classes; Unknown. 1421; NAD; Full expressions and aggregate initialization; Unknown. 1422; dup; Type of character literals containing universal-character-names; Unknown. 1423; CD3; Convertibility of nullptr to bool; Clang 11. 1424; C++14; When must sub-object destructors be accessible?; Unknown. 1425; CD3; Base-class subobjects of standard-layout structs; N/A (ABI constraint). 1426; CD5; Allowing additional parameter types in defaulted functions; Unknown. 1427; NAD; Default constructor and deleted or inaccessible destructors; Unknown. 1428; CD3; Dynamic const objects; Unknown. 1429; NAD; Scope of a member template's template parameter; Unknown. 1430; open; Pack expansion into fixed alias template parameter list; Not resolved. 1431; CD3; Exceptions from other than throw-expressions; Unknown. 1432; C++17; Newly-ambiguous variadic template expansions; Clang 16. 1433; NAD; trailing-return-type and point of declaration; Unknown. 1434; NAD; Parenthesized braced-init-list; Unknown. 1435; CD3; template-id as the declarator for a class template constructor; Unknown. 1436; open; Interaction of constant expression changes with preprocessor expressions; Not resolved. 1437; CD3; alignas in alias-declaration; Unknown. 1438; CD3; Non-dereference use of inv,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102977,Security,access,access,102977,virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage of member of unnamed namespace; Unknown. 1545; NAD; friend function templates defin,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:103052,Security,access,access,103052,ing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage of member of unnamed namespace; Unknown. 1545; NAD; friend function templates defined in class templates; Unknown. 1546; NAD; Errors in function ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106950,Security,access,access,106950,nding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as array[1]; Unknown. 1597; CD3; Misleading constexpr example; Unknown. 1598; C++14; Criterion for equality of pointers to members; Unknown. 1599; CD4; Lifetime of initializer_list underlying array; Unknown. 1600; CD4; Erroneous ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125034,Security,inject,injected-class-name,125034,stant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; U,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125997,Security,access,access,125997,41; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer arithmetic and multi-level qualification conversions; Unknown. 1866; CD4; Initializing variant members with non-trivial destructors; Unknown. 1867; NAD; Function/expression ambiguity with qualified parameter name; Unknown. 1868; drafting; Meaning of “placeholder type”; Not resolved. 1869; NAD; thread_local vs linkage-specifications; Unknown. 1870; CD4; Contradictory wording about definitions,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:127246,Security,access,access,127246,ing literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer arithmetic and multi-level qualification conversions; Unknown. 1866; CD4; Initializing variant members with non-trivial destructors; Unknown. 1867; NAD; Function/expression ambiguity with qualified parameter name; Unknown. 1868; drafting; Meaning of “placeholder type”; Not resolved. 1869; NAD; thread_local vs linkage-specifications; Unknown. 1870; CD4; Contradictory wording about definitions vs explicit specialization/instantiation; Unknown. 1871; NAD; Non-identifier characters in ud-suffix; Unknown. 1872; CD4; Instantiations of constexpr templates that cannot appear in constant expressions; Clang 9. 1873; CD4; Protected member access from derived class friends; Unknown. 1874; CD4; Type vs non-type template parameters with class keyword; Unknown. 1875; CD4; Reordering declarations in class scope; Unknown. 1876; NAD; Preventing explicit specialization; Unknown. 1877; CD4; Return type deduction from return with no operand; Unknown. 1878; CD4; operator auto template; Clang 18. 1879; NAD; Inadequate definition of alignment requirement; Unknown. 1880; CD4; When are parameter objects destroyed?; Unknown. 1881; CD4; Standard-layout classes and unnamed bit-fields; Clang 7. 1882; CD4; Reserved names without library use; Unknown. 1883; drafting; Protected access to constructors in mem-initializers; Not resolved. 1884; CD6; Unclear requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and ex,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:127876,Security,access,access,127876,d. 1869; NAD; thread_local vs linkage-specifications; Unknown. 1870; CD4; Contradictory wording about definitions vs explicit specialization/instantiation; Unknown. 1871; NAD; Non-identifier characters in ud-suffix; Unknown. 1872; CD4; Instantiations of constexpr templates that cannot appear in constant expressions; Clang 9. 1873; CD4; Protected member access from derived class friends; Unknown. 1874; CD4; Type vs non-type template parameters with class keyword; Unknown. 1875; CD4; Reordering declarations in class scope; Unknown. 1876; NAD; Preventing explicit specialization; Unknown. 1877; CD4; Return type deduction from return with no operand; Unknown. 1878; CD4; operator auto template; Clang 18. 1879; NAD; Inadequate definition of alignment requirement; Unknown. 1880; CD4; When are parameter objects destroyed?; Unknown. 1881; CD4; Standard-layout classes and unnamed bit-fields; Clang 7. 1882; CD4; Reserved names without library use; Unknown. 1883; drafting; Protected access to constructors in mem-initializers; Not resolved. 1884; CD6; Unclear requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:129399,Security,inject,injected-class-names,129399,ember function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135104,Security,access,access,135104,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138023,Security,inject,injected-class-name,138023,n; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter ,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144268,Security,inject,injection,144268,eter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145974,Security,inject,injected-class-name,145974,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:149133,Security,access,access,149133,finitions in templates; Unknown. 2175; CD4; Ambiguity with attribute in conversion operator declaration; Unknown. 2176; CD4; Destroying the returned object when a destructor throws; Unknown. 2177; CD5; Placement operator delete and parameter copies; Unknown. 2178; NAD; Substitution of dependent template arguments in default template arguments; Unknown. 2179; drafting; Required diagnostic for partial specialization after first use; Not resolved. 2180; CD4; Virtual bases in destructors and defaulted assignment operators; Yes. 2181; drafting; Normative requirements in an informative Annex; Not resolved. 2182; drafting; Pointer arithmetic in array-like containers; Not resolved. 2183; NAD; Problems in description of potential exceptions; Unknown. 2184; CD4; Missing C compatibility entry for decrement of bool; Unknown. 2185; CD6; Cv-qualified numeric types; Unknown. 2186; drafting; Unclear point that “preceding initialization” must precede; Not resolved. 2187; drafting; Protected members and access via qualified-id; Not resolved. 2188; open; empty-declaration grammar ambiguity; Not resolved. 2189; open; Surrogate call template; Not resolved. 2190; open; Insufficient specification of __has_include; Not resolved. 2191; C++17; Incorrect result for noexcept(typeid(v)); Unknown. 2192; open; Constant expressions and order-of-eval undefined behavior; Not resolved. 2193; NAD; numeric_limits<int>::radix and digits; Unknown. 2194; drafting; Impossible case in list initialization; Not resolved. 2195; open; Unsolicited reading of trailing volatile members; Not resolved. 2196; C++17; Zero-initialization with virtual base classes; Unknown. 2197; C++17; Overload resolution and deleted special member functions; Unknown. 2198; C++17; Linkage of enumerators; Unknown. 2199; CD6; Typedefs and tags; Clang 3.8. 2200; NAD; Conversions in template argument deduction; Unknown. 2201; C++17; Cv-qualification of array types; Unknown. 2202; drafting; When does default argument instantiation occur?; No,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:151729,Security,access,access,151729,"anging linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 224",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:151998,Security,access,access,151998,"D; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152922,Security,access,access,152922,"function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, and TUs; Not resolved. 2251; C++17; Unreachable enumeration list-initialization; Unknown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear cont",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159231,Security,inject,injected-class-name,159231, a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160654,Security,access,access,160654,"converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ should be constexpr; Not resolved. 2363; NAD; Opaque enumeration friend declarations; Unknown. 2364; NAD; Constant expressions, aggregate initialization, and modifications; Unknown. 2365; CD5; Confusing specification for dynamic_cast; Unknown. 2366; CD5; Can default initialization be constant initialization?; Unknown. 2367; NAD; Lambdas in default arguments vs the ODR; Unknown. 2368; CD5; Differences",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:173967,Security,access,access,173967,"s; Clang 17. 2522; open; Removing placemarker tokens and retention of whitespace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-class",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175695,Security,access,access,175695,"open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafting; Conversion to function pointer with an explicit object parameter; Not resolved. 2565; open; Invalid types in the parameter-declaration-clause of a requires-expression; Clang 16. 2566; review; Matching deallocation for uncaught exception; Not resolved. 2567; NAD; Operator lookup ambiguity; Unknown. 2568; tentatively ready; Access checking during synthesis of defaulted comparison operator; Unknown. 2569; CD6; Use of decltype(capture) in a lambda's parameter-d",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:178218,Security,access,access,178218,"ectives; Not resolved. 2577; open; Undefined behavior for preprocessing directives in macro arguments; Not resolved. 2578; open; Undefined behavior when creating an invalid string literal via stringizing; Not resolved. 2579; open; Undefined behavior when token pasting does not create a preprocessing token; Not resolved. 2580; open; Undefined behavior with #line; Not resolved. 2581; open; Undefined behavior for predefined macros; Not resolved. 2582; CD6; Differing member lookup from nested classes; Unknown. 2583; C++23; Common initial sequence should consider over-alignment; Unknown. 2584; open; Equivalent types in function template declarations; Not resolved. 2585; CD6; Name lookup for coroutine allocation; Unknown. 2586; CD6; Explicit object parameter for assignment and comparison; Unknown. 2587; review; Visible side effects and initial value of an object; Not resolved. 2588; drafting; friend declarations and module linkage; Not resolved. 2589; review; Context of access checks during constraint satisfaction checking; Not resolved. 2590; C++23; Underlying type should determine size and alignment requirements of an enum; Unknown. 2591; DR; Implicit change of active union member for anonymous union in union; Unknown. 2592; open; Missing definition for placement allocation/deallocation function; Not resolved. 2593; review; Insufficient base class restriction for pointer-to-member expression; Not resolved. 2594; CD6; Disallowing a global function template main; Unknown. 2595; DR; ""More constrained"" for eligible special member functions; Unknown. 2596; drafting; Instantiation of constrained non-template friends; Not resolved. 2597; CD6; Replaceable allocation and deallocation functions in the global module; Unknown. 2598; C++23; Unions should not require a non-static data member of literal type; Clang 18. 2599; C++23; What does initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroy",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180110,Security,access,access,180110,"s initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unkn",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:183650,Security,access,access,183650,"ncorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions; Unknown. 2656; drafting; Converting consteval lambda to function pointer in non-immediate context; Not resolved. 2657; tentatively ready; Cv-qualification adjustment when binding reference to temporary; Unknown. 2658; C++23; Trivial copying of unions in core constant expressions; Unknown. 2659; C++23; Missing feature-test macro for lifetime extension in range-for loop; Unknown. 2660; open; Confusing term ""this parameter""; Not resolved. 2661; open; Missing disambiguation rule for pure-specifier vs. brace-or-equal-initializer; Not resolved. 2662; C++23; Example for member access control vs. overload resolution; Unknown. 2663; DRWP; Example for member redeclarations with using-declarations; Unknown. 2664; C++23; Deduction failure in CTAD for alias templates; Unknown. 2665; NAD; Replacing a subobject with a complete object; Unknown. 2666; open; Lifetime extension through static_cast; Not resolved. 2667; C++23; Named module imports do not import macros; Unknown. 2668; tentatively ready; co_await in a lambda-expression; Unknown. 2669; open; Lifetime extension for aggregate initialization; Not resolved. 2670; open; Programs and translation units; Not resolved. 2671; open; friend named by a template-id; Not resolved. 2672; DR; Lambda body SFINAE is still required, contrary to intent and note; Clang 18. 2673; C++23; User-declared spaceship vs. built-in operators; Unknown. 2674; C++23; Prohibit explicit object parameters for constructors; Unknown. 2675; open; start_lifetime_as, placement-new, and active union members; Not resolved. 2676; open; Replacing ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:188427,Security,access,access,188427,"dates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from source files; Not resolved. 2728; open; Evaluation of conversions in a delete-expression; Not resolved. 2729; DRWP; Meaning of new-type-id; Unknown. 2730; open; Comparison templates on enumeration types; Not resolved. 2731; open; List-initialization sequence with a user-defined conversion; Not resolved. 2732; DRWP; Can importable headers react to preprocessor state from point of import?; Unknown. 2733; DR; Applying [[maybe_unused]] to a label; Unknown. 2734; open; Immediate forward-declared function templates; Not resolved. 2735; open; List-initialization and conversions in overload resolution; Not resolved. 2736; open; Standard layout class with empty base class also in first member; Not resolved. 2737; open; Temporary lifetime extension for reference init-captures; Not resolved. 2738; review; ""denotes a destructor"" is",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:190920,Security,access,access,190920,". 2745; open; Dependent odr-use in generic lambdas; Not resolved. 2746; open; Checking of default template arguments; Not resolved. 2747; DR; Cannot depend on an already-deleted splice; Unknown. 2748; tentatively ready; Accessing static data members via null pointer; Unknown. 2749; DR; Treatment of ""pointer to void"" for relational comparisons; Unknown. 2750; DRWP; construct_at without constructor call; Unknown. 2751; NAD; Order of destruction for parameters for operator functions; Unknown. 2752; open; Excess-precision floating-point literals; Not resolved. 2753; DR; Storage reuse for string literal objects and backing arrays; Unknown. 2754; DR; Using *this in explicit object member functions that are coroutines; Unknown. 2755; DR; Incorrect wording applied by P2738R1; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; Unknown. 2761; DR; Implicitly invoking the deleted destructor of an anonymous union member; Unknown. 2762; DR; Type of implicit object parameter; Unknown. 2763; DR; Ignorability of [[noreturn]] during constant evaluation; Unknown. 2764; DR; Use of placeholders affecting name mangling; Unknown. 2765; open; Address comparisons between potentially non-unique objects during constant evaluation; Not resolved. 2766; open; Repeated evaluation of a string-literal may yield different objects; Not resolved. 2767; open; Non-defining declarations of anonymous unions; Not resolved. 2768; DR; Assignment to enumeration variable with a braced-init-list; Unknown. 2769; open; Substitution into template parameters and default template arguments should be interleaved; Not resolved. 2770; open; Trailing requires-clause can refer to function param",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:195199,Security,access,access,195199,"ntiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolved. 2814; review; Alignment requirement of incomplete class type; Not resolved. 2815; open; Overload resolution for references/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159565,Testability,log,logic,159565,ize of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar type,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:183392,Testability,test,test,183392," C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions; Unknown. 2656; drafting; Converting consteval lambda to function pointer in non-immediate context; Not resolved. 2657; tentatively ready; Cv-qualification adjustment when binding reference to temporary; Unknown. 2658; C++23; Trivial copying of unions in core constant expressions; Unknown. 2659; C++23; Missing feature-test macro for lifetime extension in range-for loop; Unknown. 2660; open; Confusing term ""this parameter""; Not resolved. 2661; open; Missing disambiguation rule for pure-specifier vs. brace-or-equal-initializer; Not resolved. 2662; C++23; Example for member access control vs. overload resolution; Unknown. 2663; DRWP; Example for member redeclarations with using-declarations; Unknown. 2664; C++23; Deduction failure in CTAD for alias templates; Unknown. 2665; NAD; Replacing a subobject with a complete object; Unknown. 2666; open; Lifetime extension through static_cast; Not resolved. 2667; C++23; Named module imports do not import macros; Unknown. 2668; tentatively ready; co_await in a lambda-expression; Unknown. 2669; open; Lifetime extension for aggregate initialization; Not resolved. 2670; open; Programs and translation units; Not resolved. 2671; open; friend named by a template-id; Not resolved. 2672; DR; Lambda body SFINAE is still required, contrary to intent and note; Clang 18. 2673; C++23; User-d",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13995,Usability,clear,clearly,13995,"ions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20395,Usability,simpl,simply,20395,"sive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the constructor of A; Superseded by 1310. 319; CD1; Use of names without linkage in declaring entities with linkage; No. 320; CD1; Question on copy constructor elision example; Yes. 321; dup; Associated classes and namespaces for ar",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67134,Usability,simpl,simple-declaration,67134,"mplate parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Em",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67210,Usability,simpl,simple-template-ids,67210,"class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown.",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:112845,Usability,clear,clear,112845,expr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unknown. 1664; C++14; Argument-dependent lookup of lambdas used in default arguments; Unknown. 1665; drafting; Declaration matching in explicit instantiations; Not resolved. 1666; C++14; Address constant expressions; Unknown. 1667; NAD; Function exiting via exception called by destructor during unwinding; Unknown. 1668; drafting; Parameter type determination still not clear enough; Not resolved. 1669; C++14; auto return type for main; Unknown. 1670; drafting; auto as conversion-type-id; Not resolved. 1671; NAD; Unclear rules for deduction with cv-qualification; Unknown. 1672; CD4; Layout compatibility with multiple empty bases; Clang 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templa,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140101,Usability,simpl,simplifications,140101,ations; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference para,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152207,Usability,simpl,simple-template-id,152207,"ically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156040,Usability,simpl,simple-declaration,156040,expr if; Unknown. 2275; drafting; Type-dependence of function template; Not resolved. 2276; C++17; Dependent noexcept and function type-dependence; Unknown. 2277; CD5; Ambiguity inheriting constructors with default arguments; Unknown. 2278; CD5; Copy elision in constant expressions reconsidered; Unknown. 2279; NAD; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address compar,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156316,Usability,simpl,simple-template-id,156316,D; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156419,Usability,simpl,simple-template-id,156419,hing a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype tem,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159211,Usability,simpl,simple-type-name,159211, a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Un,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160510,Usability,guid,guides,160510,"-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ should be constexpr; Not resolved. 2363; NAD; Opaque enumeration friend declarations; Unknown. 2364; NAD; Constant expressions, aggregate initialization, and modifications; Unknown. 2365; CD5; Confusing specification for dynamic_cast; Unk",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:162631,Usability,usab,usable,162631,ments vs the ODR; Unknown. 2368; CD5; Differences in relational and three-way constant comparisons; Unknown. 2369; CD6; Ordering between constraints and substitution; Unknown. 2370; CD6; friend declarations of namespace-scope functions; No. 2371; CD5; Use of the English term “attributes” is confusing; Unknown. 2372; CD5; Incorrect matching rules for block-scope extern declarations; Unknown. 2373; CD5; Incorrect handling of static member function templates in partial ordering; Unknown. 2374; C++20; Overly permissive specification of enum direct-list-initialization; Unknown. 2375; NAD; Multiple redeclarations of constexpr static data members; Unknown. 2376; CD5; Class template argument deduction with array declarator; Unknown. 2377; NAD; Explicit copy constructor vs function viability; Unknown. 2378; C++20; Inconsistent grammar for reference init-capture of pack; Unknown. 2379; CD5; Missing prohibition against constexpr in friend declaration; Unknown. 2380; CD5; capture-default makes too many references odr-usable; Unknown. 2381; CD5; Composite pointer type of pointers to plain and noexcept member functions; Unknown. 2382; CD5; Array allocation overhead for non-allocating placement new; Unknown. 2383; NAD; Variadic member functions of variadic class templates; Unknown. 2384; CD5; Conversion function templates and qualification conversions; Unknown. 2385; CD5; Lookup for conversion-function-ids; N/A. 2386; CD5; tuple_size requirements for structured binding; Clang 9. 2387; CD5; Linkage of const-qualified variable template; Clang 9. 2388; NAD; Applicability of contract-attribute-specifiers; Unknown. 2389; CD6; Agreement of deduced and explicitly-specified variable types; Unknown. 2390; CD5; Is the argument of __has_cpp_attribute macro-expanded?; Clang 14. 2391; dup; Additional template parameters following pack expansion; Unknown. 2392; C++23; new-expression size check and constant evaluation; Unknown. 2393; NAD; Pseudo-destructors and object lifetime; Unknown. 2394; CD,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:165468,Usability,usab,usable,165468,"-dependent expressions; Unknown. 2406; CD5; [[fallthrough]] attribute and iteration statements; Clang 5. 2407; C++23; Missing entry in Annex C for defaulted comparison operators; Unknown. 2408; NAD; Temporaries and previously-initialized elements in aggregate initialization; Unknown. 2409; drafting; Explicit specializations of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:165806,Usability,guid,guide,165806,"s of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:166984,Usability,usab,usable,166984,ng for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown. 2432; C++20; Return types for defaulted <=>; Unknown. 2433; C++20; Variable templates in the ODR; Unknown. 2434; open; Mandatory copy elision vs non-class objects; Not resolved. 2435; open; Alias template specializations; Not resolved. 2436; C++20; Copy semantics of coroutine parameters; Unknown. 2437; C++20; Conversion of std::strong_ordering in a defaulted operator<=>; Unknown. 2438; open; Problems in the specification of qualification conversions; Not resolved. 2439; C++20; Undefined term in definition of “usable in constant expressions”; Unknown. 2440; C++23; Allocation in core constant expressions; Unknown. 2441; C++20; Inline function parameters; Unknown. 2442; C++20; Incorrect requirement for default arguments; Unknown. 2443; C++23; Meaningless template exports; Unknown. 2444; drafting; Constant expressions in initialization odr-use; Not resolved. 2445; C++20; Partial ordering with rewritten candidates; Unknown. 2446; C++20; Questionable type-dependency of concept-ids; Unknown. 2447; C++20; Unintended description of abbreviated function templates; Unknown. 2448; CD6; Cv-qualification of arithmetic types and deprecation of volatile; Unknown. 2449; extension; Thunks as an implementation technique for pointers to virtual functions; Extension. 2450; review; braced-init-list as a template-argument; Clang 18. 2451; C++23; promise.unhandled_exception() and final suspend point; Unknown. 2452; CD6; Flowing off the end of a coroutine; Unknown. 2453; NAD; Deduced return types and coroutine l,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180042,Usability,resume,resumer,180042," data member of literal type; Clang 18. 2599; C++23; What does initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Un",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181127,Usability,guid,guides,181127, C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsist,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181797,Usability,simpl,simple-template-id,181797,"for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652;",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186239,Usability,guid,guides,186239," thread_local dynamic initialization; Not resolved. 2685; C++23; Aggregate CTAD, string, and brace elision; Unknown. 2686; open; Pack expansion into a non-pack parameter of a concept; Not resolved. 2687; C++23; Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187017,Usability,guid,guides,187017," 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template valid",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187548,Usability,guid,guides,187548,"unds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template validity rules for templated entities and alias templates; Unknown. 2721; DRWP; When exactly is storage reused?; Unknown. 2722; DRWP; Temporary materialization conversion for noexcept operator; Unknown. 2723; DRWP; Range of representable values for floating-point types; Unknown. 2724; DRWP; Clarify rounding for arithmetic right shift; Unknown. 2725; DR; Overload resolution for non-call of class member access; Unknown. 2726; review; Alternative tokens appearing as attribute-tokens; Not resolved. 2727; open; Importing header units synthesized from sour",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192950,Usability,guid,guides,192950,"bstituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 27",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:598,Availability,avail,available,598,". Clang - C++ Programming Language Status. C++ Support in Clang. Clang implements the following published and upcoming ISO C++ standards:. Language Standard; Flag; Available in Clang?. C++2c; -std=c++2c; Partial. C++23; -std=c++23; Partial. C++20; -std=c++20; Partial. C++17; -std=c++17; Clang 5. C++14; -std=c++14; Clang 3.4. C++11; -std=c++11; Clang 3.3. C++98 / C++03; -std=c++98; Yes (other than export). The Clang community is continually striving to improve C++ standards; compliance between releases by submitting and tracking C++ Defect Reports and implementing resolutions; as they become available.; Experimental work is also under way to implement C++ Technical; Specifications that will help drive the future of the C++ programming; language.; The LLVM bug tracker uses; the ""c++"" label, as well as mode-specific labels such as ""c++11"", ""c++14"",; and so on, to track known bugs with Clang's language conformance.; C++2c implementation status. Clang has support for some of the features of the C++ standard following; C++23, informally referred to as C++26.; You can use Clang in C++2c mode with the -std=c++2c option. List of features and minimum Clang version with support. Language Feature; C++26 Proposal; Available in Clang?. Remove undefined behavior from lexing; P2621R2 (DR); Clang 3.3. Making non-encodable string literals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:13205,Availability,error,errors,13205,"ons in using-declarations; P0195R2; Clang 4. (8): This is a backwards-incompatible change that is applied to; all language versions that allow type deduction from auto; (per the request of the C++ committee).; In Clang 3.7, a warning is emitted for all cases that would change meaning. (9): Under the MS ABI, function parameters are destroyed from; left to right in the callee. As a result, function parameters in calls to; operator<<, operator>>, operator->*,; operator&&, operator||, and operator,; functions using expression syntax are no longer guaranteed to be destroyed in; reverse construction order in that ABI.; This is not fully supported during constant expression evaluation until Clang 12. (10): Despite being the resolution to a Defect Report, this; feature is disabled by default in all language versions, and can be enabled; explicitly with the flag -frelaxed-template-template-args in Clang 4; onwards.; The change to the standard lacks a corresponding change for template partial; ordering, resulting in ambiguity errors for reasonable and previously-valid; code. This issue is expected to be rectified soon. C++14 implementation status; Clang 3.4 and later implement all of the ISO; C++ 2014 standard.; You can use Clang in C++14 mode with the -std=c++14 option; (use -std=c++1y in Clang 3.4 and earlier). List of features and minimum Clang version with support. Language Feature; C++14 Proposal; Available in Clang?. Tweak to certain C++ contextual conversions; N3323; Clang 3.4. Binary literals; N3472; Clang 2.9. decltype(auto); N3638; Clang 3.3. Return type deduction for normal functions; Clang 3.4. Initialized lambda captures; N3648; Clang 3.4. Generic lambdas; N3649; Clang 3.4. Variable templates; N3651; Clang 3.4. Relaxing requirements on constexpr functions; N3652; Clang 3.4. Member initializers and aggregates; N3653; Clang 3.3. Clarifying memory allocation; N3664; Clang 3.4. [[deprecated]] attribute; N3760; Clang 3.4. Single quotation mark as digit separator; N378",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:16393,Availability,error,errors,16393,Clang 2.9. auto-typed variables; N1984; Clang 2.9.     Multi-declarator auto; N1737; Clang 2.9.     Removal of auto as a storage-class specifier; N2546; Clang 2.9.     New function declarator syntax; N2541; Clang 2.9. Lambda expressions; N2927; Clang 3.1. P0588R1 (DR); No. Declared type of an expression; N2343; Clang 2.9.     Incomplete return types; N3276; Clang 3.1. Right angle brackets; N1757; Clang 2.9. Default template arguments for function templates; DR226; Clang 2.9. Solving the SFINAE problem for expressions; DR339; Clang 2.9. Alias templates; N2258; Clang 3.0. Extern templates; N1987; Clang 2.9. Null pointer constant; N2431; Clang 3.0. Strongly-typed enums; N2347; Clang 2.9. Forward declarations for enums; N2764; DR1206; Clang 3.1. Standardized attribute syntax; N2761; Clang 3.3 (1). Generalized constant expressions; N2235; Clang 3.1. P0859R0 (DR); Clang 8. Alignment support; N2341; Clang 3.3. Conditionally-support behavior; N1627; Clang 2.9. Changing undefined behavior into diagnosable errors; N1727; Clang 2.9. Delegating constructors; N1986; Clang 3.0. Inheriting constructors; N2540; Clang 3.3. P0136R1 (DR); Clang 3.9. Explicit conversion operators; N2437; Clang 3.0. New character types; N2249; Clang 2.9. Unicode string literals; N2442; Clang 3.0. Raw string literals; N2442; Clang 3.0. Universal character names in literals; N2170; Clang 3.1. User-defined literals; N2765; Clang 3.1. Standard Layout Types; N2342; Clang 3.0. Defaulted functions; N2346; Clang 3.0. ; P1286R2 (DR); Clang 9. Deleted functions; N2346; Clang 2.9. Extended friend declarations; N1791; Clang 2.9. Extending sizeof; N2253; DR850; Clang 3.1. Inline namespaces; N2535; Clang 2.9. Unrestricted unions; N2544; Clang 3.1. Local and unnamed types as template arguments; N2657; Clang 2.9. Range-based for; N2930; Clang 3.0. P0962R1 (DR); Clang 8. Explicit virtual overrides; N2928; N3206; N3272; Clang 3.0. Minimal support for garbage collection and reachability-based leak detection; N2670; N/A (2),MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:498,Deployability,release,releases,498,". Clang - C++ Programming Language Status. C++ Support in Clang. Clang implements the following published and upcoming ISO C++ standards:. Language Standard; Flag; Available in Clang?. C++2c; -std=c++2c; Partial. C++23; -std=c++23; Partial. C++20; -std=c++20; Partial. C++17; -std=c++17; Clang 5. C++14; -std=c++14; Clang 3.4. C++11; -std=c++11; Clang 3.3. C++98 / C++03; -std=c++98; Yes (other than export). The Clang community is continually striving to improve C++ standards; compliance between releases by submitting and tracking C++ Defect Reports and implementing resolutions; as they become available.; Experimental work is also under way to implement C++ Technical; Specifications that will help drive the future of the C++ programming; language.; The LLVM bug tracker uses; the ""c++"" label, as well as mode-specific labels such as ""c++11"", ""c++14"",; and so on, to track known bugs with Clang's language conformance.; C++2c implementation status. Clang has support for some of the features of the C++ standard following; C++23, informally referred to as C++26.; You can use Clang in C++2c mode with the -std=c++2c option. List of features and minimum Clang version with support. Language Feature; C++26 Proposal; Available in Clang?. Remove undefined behavior from lexing; P2621R2 (DR); Clang 3.3. Making non-encodable string literals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:1672,Integrability,message,messages,1672,"l; Specifications that will help drive the future of the C++ programming; language.; The LLVM bug tracker uses; the ""c++"" label, as well as mode-specific labels such as ""c++11"", ""c++14"",; and so on, to track known bugs with Clang's language conformance.; C++2c implementation status. Clang has support for some of the features of the C++ standard following; C++23, informally referred to as C++26.; You can use Clang in C++2c mode with the -std=c++2c option. List of features and minimum Clang version with support. Language Feature; C++26 Proposal; Available in Clang?. Remove undefined behavior from lexing; P2621R2 (DR); Clang 3.3. Making non-encodable string literals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:7679,Integrability,depend,dependent,7679,R0. P2092R0; Clang 16. P2113R0; Clang 16. Range-based for statements with initializer; P0614R1; Clang 8. ADL and function templates that are not visible; P0846R0; Clang 9. const mismatch with defaulted copy constructor; P0641R2; Clang 8. Consistent comparison (operator<=>); P0515R3; Clang 10. ; P0905R1. ; P1120R0. ; P1185R2. ; P1186R3. P1630R1. ; P1946R0. P1959R0. ; P2002R1; Clang 17. P2085R0; Clang 14. Access checking on specializations; P0692R1; Clang 14. Default constructible and assignable stateless lambdas; P0624R2; Clang 8. Lambdas in unevaluated contexts; P0315R4; Clang 17. [[no_unique_address]] attribute; P0840R2; Clang 9. [[likely]] and [[unlikely]] attributes; P0479R5; Clang 12. typename optional in more contexts; P0634R3; Clang 16. Pack expansion in lambda init-capture; P0780R2; Clang 9. Class types as non-type template parameters; P0732R2; Clang 12. ; Generalized non-type template parameters of scalar type; P1907R1. Clang 18 (Partial); Reference type template arguments referring to instantiation-dependent objects and subobjects; (i.e. declared inside a template but neither type- nor value-dependent) aren't fully supported.; . Destroying operator delete; P0722R3; Clang 6. Relaxations of constexpr restrictions; P1064R0; Clang 9. ; P1002R1; Clang 8. P1327R1; Clang 9. P1330R0. ; P1331R2; Clang 10. P1668R1. P0784R7. Prohibit aggregates with user-declared constructors; P1008R1; Clang 8. Feature test macros; P0941R2; (see below). explicit(bool); P0892R2; Clang 9. Signed integers are two's complement; P1236R1; Clang 9. char8_t; P0482R6; Clang 7 (11). Immediate functions (consteval); P1073R3; Clang 17. ; P1937R2; Clang 14. std::is_constant_evaluated; P0595R2; Clang 9. Nested inline namespaces; P1094R2; Clang 8. Structured binding extensions; P1091R3; Clang 16. P1381R1. Stronger Unicode requirements; P1041R4; Yes. P1139R2. Parenthesized initialization of aggregates; P0960R3; Clang 16. ; P1975R0. Modules; P1103R3; Clang 15. ; P1766R1 (DR); Clang 11. P1811R0; No. P17,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:7774,Integrability,depend,dependent,7774,L and function templates that are not visible; P0846R0; Clang 9. const mismatch with defaulted copy constructor; P0641R2; Clang 8. Consistent comparison (operator<=>); P0515R3; Clang 10. ; P0905R1. ; P1120R0. ; P1185R2. ; P1186R3. P1630R1. ; P1946R0. P1959R0. ; P2002R1; Clang 17. P2085R0; Clang 14. Access checking on specializations; P0692R1; Clang 14. Default constructible and assignable stateless lambdas; P0624R2; Clang 8. Lambdas in unevaluated contexts; P0315R4; Clang 17. [[no_unique_address]] attribute; P0840R2; Clang 9. [[likely]] and [[unlikely]] attributes; P0479R5; Clang 12. typename optional in more contexts; P0634R3; Clang 16. Pack expansion in lambda init-capture; P0780R2; Clang 9. Class types as non-type template parameters; P0732R2; Clang 12. ; Generalized non-type template parameters of scalar type; P1907R1. Clang 18 (Partial); Reference type template arguments referring to instantiation-dependent objects and subobjects; (i.e. declared inside a template but neither type- nor value-dependent) aren't fully supported.; . Destroying operator delete; P0722R3; Clang 6. Relaxations of constexpr restrictions; P1064R0; Clang 9. ; P1002R1; Clang 8. P1327R1; Clang 9. P1330R0. ; P1331R2; Clang 10. P1668R1. P0784R7. Prohibit aggregates with user-declared constructors; P1008R1; Clang 8. Feature test macros; P0941R2; (see below). explicit(bool); P0892R2; Clang 9. Signed integers are two's complement; P1236R1; Clang 9. char8_t; P0482R6; Clang 7 (11). Immediate functions (consteval); P1073R3; Clang 17. ; P1937R2; Clang 14. std::is_constant_evaluated; P0595R2; Clang 9. Nested inline namespaces; P1094R2; Clang 8. Structured binding extensions; P1091R3; Clang 16. P1381R1. Stronger Unicode requirements; P1041R4; Yes. P1139R2. Parenthesized initialization of aggregates; P0960R3; Clang 16. ; P1975R0. Modules; P1103R3; Clang 15. ; P1766R1 (DR); Clang 11. P1811R0; No. P1703R1; Subsumed by P1857. ; P1874R1; Clang 15. ; P1979R0; No. ; P1779R3; Clang 15. P1857R3; No. P2115R0; Pa,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:10013,Integrability,message,message,10013,"matic uses of volatile; P1152R4; Clang 10. [[nodiscard(""with reason"")]]; P1301R4; Clang 9. using enum; P1099R5; Clang 13. Class template argument deduction for aggregates; P1816R0; Clang 17. ; P2082R1. Class template argument deduction for alias templates; P1814R0; No. Permit conversions to arrays of unknown bound; P0388R4; Clang 14. constinit; P1143R2; Clang 10. Pseudo-destructors end object lifetimes; P0593R6 (DR); Clang 11. More implicit moves; P1825R0 (DR); Clang 13. (11): Prior to Clang 8, this feature is not enabled by; -std=c++20, but can be enabled with -fchar8_t. C++17 implementation status; Clang 5 and later implement all the features of the; ISO C++ 2017 standard.; By default, Clang 16 or later builds C++ code according to the C++17 standard.; You can use Clang in C++17 mode with the -std=c++17 option; (use -std=c++1z in Clang 4 and earlier). List of features and minimum Clang version with support. Language Feature; C++17 Proposal; Available in Clang?. static_assert with no message; N3928; Clang 3.5. Disabling trigraph expansion by default; N4086; Clang 3.5. typename in a template template parameter; N4051; Clang 3.5. New auto rules for direct-list-initialization; N3922; Clang 3.8 (8). Fold expressions; N4295; Clang 3.6. ; P0036R0; Clang 3.9. u8 character literals; N4267; Clang 3.6. Nested namespace definition; N4230; Clang 3.6. Attributes for namespaces and enumerators; N4266; Clang 3.6. Allow constant evaluation for all non-type template arguments; N4268; Clang 3.6. Remove deprecated register storage class; P0001R1; Clang 3.8. Remove deprecated bool increment; P0002R1; Clang 3.8. Make exception specifications part of the type system; P0012R1; Clang 4. __has_include in preprocessor conditionals; P0061R1; Yes. [[fallthrough]] attribute; P0188R1; Clang 3.9. [[nodiscard]] attribute; P0189R1; Clang 3.9. ; P1771R1 (DR); Clang 9. [[maybe_unused]] attribute; P0212R1; Clang 3.9. Aggregate initialization of classes with base classes; P0017R1; Clang 3.9. constexpr ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:17721,Integrability,depend,dependency,17721,"ng 3.1. User-defined literals; N2765; Clang 3.1. Standard Layout Types; N2342; Clang 3.0. Defaulted functions; N2346; Clang 3.0. ; P1286R2 (DR); Clang 9. Deleted functions; N2346; Clang 2.9. Extended friend declarations; N1791; Clang 2.9. Extending sizeof; N2253; DR850; Clang 3.1. Inline namespaces; N2535; Clang 2.9. Unrestricted unions; N2544; Clang 3.1. Local and unnamed types as template arguments; N2657; Clang 2.9. Range-based for; N2930; Clang 3.0. P0962R1 (DR); Clang 8. Explicit virtual overrides; N2928; N3206; N3272; Clang 3.0. Minimal support for garbage collection and reachability-based leak detection; N2670; N/A (2). Allowing move constructors to throw [noexcept]; N3050; Clang 3.0. Defining move special member functions; N3053; Clang 3.0. Concurrency. Sequence points; N2239; Clang 3.3. Atomic operations; N2427; Clang 3.1. Strong Compare and Exchange; N2748; Clang 3.1 (3). Bidirectional Fences; N2752; Clang 3.1. Memory model; N2429; Clang 3.2. Data-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not pr",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:1713,Modifiability,variab,variables,1713," C++ programming; language.; The LLVM bug tracker uses; the ""c++"" label, as well as mode-specific labels such as ""c++11"", ""c++14"",; and so on, to track known bugs with Clang's language conformance.; C++2c implementation status. Clang has support for some of the features of the C++ standard following; C++23, informally referred to as C++26.; You can use Clang in C++2c mode with the -std=c++2c option. List of features and minimum Clang version with support. Language Feature; C++26 Proposal; Available in Clang?. Remove undefined behavior from lexing; P2621R2 (DR); Clang 3.3. Making non-encodable string literals ill-formed; P1854R4 (DR); Clang 14. Unevaluated strings; P2361R6; Clang 18. Add @, $, and ` to the basic character set; P2558R2; Yes. constexpr cast from void*; P2738R1; Clang 17. On the ignorability of standard attributes; P2552R3 (DR); No. Static storage for braced initializers; P2752R3 (DR); No. User-generated static_assert messages; P2741R3; Clang 17. Placeholder variables with no name; P2169R4; Clang 18. Template parameter initialization; P2308R1 (DR); Clang 18. Pack Indexing; P2662R3; No. Remove Deprecated Arithmetic Conversion on Enumerations; P2864R2; Clang 18. C++23 implementation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed string literal concatenation; P2201R1; Yes. Deducing this",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:2903,Modifiability,variab,variables,2903,"ation status. Clang has support for some of the features of the ISO C++ 2023 standard.; You can use Clang in C++23 mode with the -std=c++23 option. List of features and minimum Clang version with support. Language Feature; C++23 Proposal; Available in Clang?. Literal suffix uz, z for size_t, ssize_t; P0330R8; Clang 13. Make () in lambdas optional in all cases; P1102R2; Clang 13. Simpler implicit move; P2266R1; Clang 13. if consteval; P1938R3; Clang 14. Allow duplicate attributes; P2156R1; Clang 13. Narrowing contextual conversions to bool; P1401R5; Clang 14. Trimming whitespaces before line splicing; P2223R2; Yes. Make declaration order layout mandated; P1874R4; Yes. C++ identifier syntax using UAX 31; P1949R7; Clang 14. Mixed string literal concatenation; P2201R1; Yes. Deducing this; P0847R7; Clang 18. P2797R0; No. Change scope of lambda trailing-return-type; P2036R3; Clang 17. P2579R0. Multidimensional subscript operator; P2128R6; Clang 15. Non-literal variables (and labels and gotos) in constexpr functions; P2242R3; Clang 15. Character encoding of diagnostic text; P2246R1; Yes. Character sets and encodings; P2314R4; Yes. Consistent character literal encoding; P2316R2; Yes. Add support for preprocessing directives elifdef and elifndef; P2334R1; Clang 13. Extend init-statement to allow alias-declaration; P2360R0; Clang 14. auto(x): decay-copy in the language; P0849R8; Clang 15. Attributes on Lambda-Expressions; P2173R1; Clang 13. constexpr for <cmath> and <cstdlib>; P0533R9; No. Type trait to determine if a reference binds to a temporary; P2255R2. Partial; Clang provides __reference_constructs_from_temporary type; trait builtin, with which std::reference_constructs_from_temporary; is implemented. __reference_converts_from_temporary needs to be; provided, following the normal cross-vendor convention to implement; traits requiring compiler support directly.; . The Equality Operator You Are Looking For; P2468R2; Clang 16. De-deprecating volatile compound operations; P",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:4905,Modifiability,inherit,inherited,4905,"volatile compound operations; P2327R1; Clang 15. Support for #warning; P2437R1; Yes. Remove non-encodable wide character literals and multicharacter wide character literals; P2362R3; Clang 14. Labels at the end of compound statements; P2324R2; Clang 16. Delimited escape sequences; P2290R3; Clang 15. Named universal character escapes; P2071R2; Clang 15. Relaxing some constexpr restrictions; P2448R2. Clang 17 (Partial); 	 We do not support outside of defaulted special memeber functions the change that constexpr functions no; longer have to be constexpr compatible but rather support a less restricted requirements for constexpr; functions. Which include allowing non-literal types as return values and parameters, allow calling of; non-constexpr functions and constructors.; . Using unknown pointers and references in constant expressions; P2280R4 (DR); No. static operator(); P1169R4; Clang 16. Extended floating-point types and standard names; P1467R9; No. Class template argument deduction from inherited constructors; P2582R1; No. Portable assumptions; P1774R8; No. Support for UTF-8 as a portable source file encoding; P2295R6; Clang 15. char8_t Compatibility and Portability Fix; P2513R3; Clang 16. Relax requirements on wchar_t to match existing practices; P2460R2; Yes. Explicit lifetime management; P2590R2; No. static operator[]; P2589R1; Clang 16. Permitting static constexpr variables in constexpr functions; P2647R1; Clang 16. consteval needs to propagate up; P2564R3 (DR); Clang 17. Lifetime extension in range-based for loops; P2718R0; No. Referencing The Unicode Standard; P2736R2; Yes. C++20 implementation status; Clang has support for some of the features of the; ISO C++ 2020 standard.; You can use Clang in C++20 mode with the -std=c++20 option; (use -std=c++2a in Clang 9 and earlier). List of features and minimum Clang version with support. Language Feature; C++20 Proposal; Available in Clang?. Default member initializers for bit-fields; P0683R1; Clang 6. const&-qualifi",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:5000,Modifiability,portab,portable,5000,"e character literals and multicharacter wide character literals; P2362R3; Clang 14. Labels at the end of compound statements; P2324R2; Clang 16. Delimited escape sequences; P2290R3; Clang 15. Named universal character escapes; P2071R2; Clang 15. Relaxing some constexpr restrictions; P2448R2. Clang 17 (Partial); 	 We do not support outside of defaulted special memeber functions the change that constexpr functions no; longer have to be constexpr compatible but rather support a less restricted requirements for constexpr; functions. Which include allowing non-literal types as return values and parameters, allow calling of; non-constexpr functions and constructors.; . Using unknown pointers and references in constant expressions; P2280R4 (DR); No. static operator(); P1169R4; Clang 16. Extended floating-point types and standard names; P1467R9; No. Class template argument deduction from inherited constructors; P2582R1; No. Portable assumptions; P1774R8; No. Support for UTF-8 as a portable source file encoding; P2295R6; Clang 15. char8_t Compatibility and Portability Fix; P2513R3; Clang 16. Relax requirements on wchar_t to match existing practices; P2460R2; Yes. Explicit lifetime management; P2590R2; No. static operator[]; P2589R1; Clang 16. Permitting static constexpr variables in constexpr functions; P2647R1; Clang 16. consteval needs to propagate up; P2564R3 (DR); Clang 17. Lifetime extension in range-based for loops; P2718R0; No. Referencing The Unicode Standard; P2736R2; Yes. C++20 implementation status; Clang has support for some of the features of the; ISO C++ 2020 standard.; You can use Clang in C++20 mode with the -std=c++20 option; (use -std=c++2a in Clang 9 and earlier). List of features and minimum Clang version with support. Language Feature; C++20 Proposal; Available in Clang?. Default member initializers for bit-fields; P0683R1; Clang 6. const&-qualified pointers to members; P0704R1; Clang 6. Allow lambda-capture [=, this]; P0409R2; Clang 6. __VA_OPT__ for pre",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:5294,Modifiability,variab,variables,5294,"Clang 17 (Partial); 	 We do not support outside of defaulted special memeber functions the change that constexpr functions no; longer have to be constexpr compatible but rather support a less restricted requirements for constexpr; functions. Which include allowing non-literal types as return values and parameters, allow calling of; non-constexpr functions and constructors.; . Using unknown pointers and references in constant expressions; P2280R4 (DR); No. static operator(); P1169R4; Clang 16. Extended floating-point types and standard names; P1467R9; No. Class template argument deduction from inherited constructors; P2582R1; No. Portable assumptions; P1774R8; No. Support for UTF-8 as a portable source file encoding; P2295R6; Clang 15. char8_t Compatibility and Portability Fix; P2513R3; Clang 16. Relax requirements on wchar_t to match existing practices; P2460R2; Yes. Explicit lifetime management; P2590R2; No. static operator[]; P2589R1; Clang 16. Permitting static constexpr variables in constexpr functions; P2647R1; Clang 16. consteval needs to propagate up; P2564R3 (DR); Clang 17. Lifetime extension in range-based for loops; P2718R0; No. Referencing The Unicode Standard; P2736R2; Yes. C++20 implementation status; Clang has support for some of the features of the; ISO C++ 2020 standard.; You can use Clang in C++20 mode with the -std=c++20 option; (use -std=c++2a in Clang 9 and earlier). List of features and minimum Clang version with support. Language Feature; C++20 Proposal; Available in Clang?. Default member initializers for bit-fields; P0683R1; Clang 6. const&-qualified pointers to members; P0704R1; Clang 6. Allow lambda-capture [=, this]; P0409R2; Clang 6. __VA_OPT__ for preprocessor comma elision; P0306R4; Clang 6. ; P1042R1; Clang 9. Designated initializers; P0329R4; Clang 10. template-parameter-list for generic lambdas; P0428R2; Clang 9. Concepts; P0734R0; Clang 10. ; P0857R0; Clang 16. ; P1084R2; Clang 10. P1141R2. ; P0848R3. Clang 16 (Partial); Because of o",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:11816,Modifiability,variab,variables,11816,"ttribute; P0189R1; Clang 3.9. ; P1771R1 (DR); Clang 9. [[maybe_unused]] attribute; P0212R1; Clang 3.9. Aggregate initialization of classes with base classes; P0017R1; Clang 3.9. constexpr lambda expressions; P0170R1; Clang 5. Differing begin and end types in range-based for; P0184R0; Clang 3.9. Lambda capture of *this; P0018R3; Clang 3.9. Direct-list-initialization of enums; P0138R2; Clang 3.9. Hexadecimal floating-point literals; P0245R1; Yes. Using attribute namespaces without repetition; P0028R4; Clang 3.9. Dynamic memory allocation for over-aligned data; P0035R4; Clang 4. Template argument deduction for class templates; P0091R3; Clang 5. ; P0512R0. P0620R0 (DR); Clang 7. P0702R1 (DR); Clang 6. Non-type template parameters with auto type; P0127R2; Clang 4. Guaranteed copy elision; P0135R1; Clang 4. Stricter expression evaluation order; P0145R3; Clang 4 (9). P0400R0. Requirement to ignore unknown attributes; P0283R2; Yes. constexpr if-statements; P0292R2; Clang 3.9. Inline variables; P0386R2; Clang 3.9. Structured bindings; P0217R3; Clang 4. P0961R1 (DR); Clang 8. P0969R0 (DR); Clang 8. Separate variable and condition for if and switch; P0305R1; Clang 3.9. Matching template template parameters to compatible arguments; P0522R0; Partial (10). Removing deprecated dynamic exception specifications; P0003R5; Clang 4. Pack expansions in using-declarations; P0195R2; Clang 4. (8): This is a backwards-incompatible change that is applied to; all language versions that allow type deduction from auto; (per the request of the C++ committee).; In Clang 3.7, a warning is emitted for all cases that would change meaning. (9): Under the MS ABI, function parameters are destroyed from; left to right in the callee. As a result, function parameters in calls to; operator<<, operator>>, operator->*,; operator&&, operator||, and operator,; functions using expression syntax are no longer guaranteed to be destroyed in; reverse construction order in that ABI.; This is not fully supported duri",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:11941,Modifiability,variab,variable,11941,"with base classes; P0017R1; Clang 3.9. constexpr lambda expressions; P0170R1; Clang 5. Differing begin and end types in range-based for; P0184R0; Clang 3.9. Lambda capture of *this; P0018R3; Clang 3.9. Direct-list-initialization of enums; P0138R2; Clang 3.9. Hexadecimal floating-point literals; P0245R1; Yes. Using attribute namespaces without repetition; P0028R4; Clang 3.9. Dynamic memory allocation for over-aligned data; P0035R4; Clang 4. Template argument deduction for class templates; P0091R3; Clang 5. ; P0512R0. P0620R0 (DR); Clang 7. P0702R1 (DR); Clang 6. Non-type template parameters with auto type; P0127R2; Clang 4. Guaranteed copy elision; P0135R1; Clang 4. Stricter expression evaluation order; P0145R3; Clang 4 (9). P0400R0. Requirement to ignore unknown attributes; P0283R2; Yes. constexpr if-statements; P0292R2; Clang 3.9. Inline variables; P0386R2; Clang 3.9. Structured bindings; P0217R3; Clang 4. P0961R1 (DR); Clang 8. P0969R0 (DR); Clang 8. Separate variable and condition for if and switch; P0305R1; Clang 3.9. Matching template template parameters to compatible arguments; P0522R0; Partial (10). Removing deprecated dynamic exception specifications; P0003R5; Clang 4. Pack expansions in using-declarations; P0195R2; Clang 4. (8): This is a backwards-incompatible change that is applied to; all language versions that allow type deduction from auto; (per the request of the C++ committee).; In Clang 3.7, a warning is emitted for all cases that would change meaning. (9): Under the MS ABI, function parameters are destroyed from; left to right in the callee. As a result, function parameters in calls to; operator<<, operator>>, operator->*,; operator&&, operator||, and operator,; functions using expression syntax are no longer guaranteed to be destroyed in; reverse construction order in that ABI.; This is not fully supported during constant expression evaluation until Clang 12. (10): Despite being the resolution to a Defect Report, this; feature is disabled by defaul",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:15403,Modifiability,variab,variables,15403,"nctions, either by providing them; explicitly or by using a C++ standard library that does. libstdc++; added these functions in version 5.0, and libc++ added them in; version 3.7. C++11 implementation status; Clang 3.3 and later implement all of the ISO; C++ 2011 standard.; You can use Clang in C++11 mode with the -std=c++11; option. Clang's C++11 mode can be used with; libc++ or with gcc's libstdc++. List of features and minimum Clang version with support. Language Feature; C++11 Proposal; Available in Clang?. Rvalue references; N2118; Clang 2.9; ; P1825R0 (DR); Clang 13.     Rvalue references for *this; N2439; Clang 2.9. Initialization of class objects by rvalues; N1610; Clang 2.9. Non-static data member initializers; N2756; Clang 3.0. Variadic templates; N2242; Clang 2.9.     Extending variadic template template parameters; N2555; Clang 2.9. Initializer lists; N2672; Clang 3.1. ; P1009R2 (DR); Clang 9. ; P1957R2 (DR); Clang 11. Static assertions; N1720; Clang 2.9. auto-typed variables; N1984; Clang 2.9.     Multi-declarator auto; N1737; Clang 2.9.     Removal of auto as a storage-class specifier; N2546; Clang 2.9.     New function declarator syntax; N2541; Clang 2.9. Lambda expressions; N2927; Clang 3.1. P0588R1 (DR); No. Declared type of an expression; N2343; Clang 2.9.     Incomplete return types; N3276; Clang 3.1. Right angle brackets; N1757; Clang 2.9. Default template arguments for function templates; DR226; Clang 2.9. Solving the SFINAE problem for expressions; DR339; Clang 2.9. Alias templates; N2258; Clang 3.0. Extern templates; N1987; Clang 2.9. Null pointer constant; N2431; Clang 3.0. Strongly-typed enums; N2347; Clang 2.9. Forward declarations for enums; N2764; DR1206; Clang 3.1. Standardized attribute syntax; N2761; Clang 3.3 (1). Generalized constant expressions; N2235; Clang 3.1. P0859R0 (DR); Clang 8. Alignment support; N2341; Clang 3.3. Conditionally-support behavior; N1627; Clang 2.9. Changing undefined behavior into diagnosable errors; N1727; Cl",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:18759,Modifiability,extend,extended,18759,"a-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing docume",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:18814,Modifiability,extend,extended,18814,"mics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing documents; ISO C++ also publishes a number of documents describing additional language; and library features that are not part of",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:17976,Performance,concurren,concurrency,17976,"s; N1791; Clang 2.9. Extending sizeof; N2253; DR850; Clang 3.1. Inline namespaces; N2535; Clang 2.9. Unrestricted unions; N2544; Clang 3.1. Local and unnamed types as template arguments; N2657; Clang 2.9. Range-based for; N2930; Clang 3.0. P0962R1 (DR); Clang 8. Explicit virtual overrides; N2928; N3206; N3272; Clang 3.0. Minimal support for garbage collection and reachability-based leak detection; N2670; N/A (2). Allowing move constructors to throw [noexcept]; N3050; Clang 3.0. Defining move special member functions; N3053; Clang 3.0. Concurrency. Sequence points; N2239; Clang 3.3. Atomic operations; N2427; Clang 3.1. Strong Compare and Exchange; N2748; Clang 3.1 (3). Bidirectional Fences; N2752; Clang 3.1. Memory model; N2429; Clang 3.2. Data-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not provide garbage collection.; (3): All compare-exchange operations are emitted as; strong compare-exchanges.; (4): memory_order_consume is lowered to; memory_order_acquire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:17357,Safety,detect,detection,17357, Clang 2.9. Changing undefined behavior into diagnosable errors; N1727; Clang 2.9. Delegating constructors; N1986; Clang 3.0. Inheriting constructors; N2540; Clang 3.3. P0136R1 (DR); Clang 3.9. Explicit conversion operators; N2437; Clang 3.0. New character types; N2249; Clang 2.9. Unicode string literals; N2442; Clang 3.0. Raw string literals; N2442; Clang 3.0. Universal character names in literals; N2170; Clang 3.1. User-defined literals; N2765; Clang 3.1. Standard Layout Types; N2342; Clang 3.0. Defaulted functions; N2346; Clang 3.0. ; P1286R2 (DR); Clang 9. Deleted functions; N2346; Clang 2.9. Extended friend declarations; N1791; Clang 2.9. Extending sizeof; N2253; DR850; Clang 3.1. Inline namespaces; N2535; Clang 2.9. Unrestricted unions; N2544; Clang 3.1. Local and unnamed types as template arguments; N2657; Clang 2.9. Range-based for; N2930; Clang 3.0. P0962R1 (DR); Clang 8. Explicit virtual overrides; N2928; N3206; N3272; Clang 3.0. Minimal support for garbage collection and reachability-based leak detection; N2670; N/A (2). Allowing move constructors to throw [noexcept]; N3050; Clang 3.0. Defining move special member functions; N3053; Clang 3.0. Concurrency. Sequence points; N2239; Clang 3.3. Atomic operations; N2427; Clang 3.1. Strong Compare and Exchange; N2748; Clang 3.1 (3). Bidirectional Fences; N2752; Clang 3.1. Memory model; N2429; Clang 3.2. Data-dependency ordering: atomics and memory model; N2664; Clang 3.2 (4). Propagating exceptions; N2179; Clang 2.9. Allow atomics use in signal handlers; N2547; Clang 3.1. Thread-local storage; N2659; Clang 3.3 (5). Dynamic initialization and destruction with concurrency; N2660; Clang 2.9. C99 Features in C++11. __func__ predefined identifier; N2340; Clang 2.9. C99 preprocessor; N1653; Clang 2.9. long long; N1811; Clang 2.9. Extended integral types; N1988; N/A (6). (1): The [[carries_dependency]] attribute; has no effect.; (2): No compiler changes are required for an implementation; such as Clang that does not pr,MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:8080,Testability,test,test,8080,"tions; P0692R1; Clang 14. Default constructible and assignable stateless lambdas; P0624R2; Clang 8. Lambdas in unevaluated contexts; P0315R4; Clang 17. [[no_unique_address]] attribute; P0840R2; Clang 9. [[likely]] and [[unlikely]] attributes; P0479R5; Clang 12. typename optional in more contexts; P0634R3; Clang 16. Pack expansion in lambda init-capture; P0780R2; Clang 9. Class types as non-type template parameters; P0732R2; Clang 12. ; Generalized non-type template parameters of scalar type; P1907R1. Clang 18 (Partial); Reference type template arguments referring to instantiation-dependent objects and subobjects; (i.e. declared inside a template but neither type- nor value-dependent) aren't fully supported.; . Destroying operator delete; P0722R3; Clang 6. Relaxations of constexpr restrictions; P1064R0; Clang 9. ; P1002R1; Clang 8. P1327R1; Clang 9. P1330R0. ; P1331R2; Clang 10. P1668R1. P0784R7. Prohibit aggregates with user-declared constructors; P1008R1; Clang 8. Feature test macros; P0941R2; (see below). explicit(bool); P0892R2; Clang 9. Signed integers are two's complement; P1236R1; Clang 9. char8_t; P0482R6; Clang 7 (11). Immediate functions (consteval); P1073R3; Clang 17. ; P1937R2; Clang 14. std::is_constant_evaluated; P0595R2; Clang 9. Nested inline namespaces; P1094R2; Clang 8. Structured binding extensions; P1091R3; Clang 16. P1381R1. Stronger Unicode requirements; P1041R4; Yes. P1139R2. Parenthesized initialization of aggregates; P0960R3; Clang 16. ; P1975R0. Modules; P1103R3; Clang 15. ; P1766R1 (DR); Clang 11. P1811R0; No. P1703R1; Subsumed by P1857. ; P1874R1; Clang 15. ; P1979R0; No. ; P1779R3; Clang 15. P1857R3; No. P2115R0; Partial. P1815R2; Partial. ; P2615R1 (DR); No. ; P2788R0 (DR); No. Coroutines; P0912R5. Partial; Fully supported on all targets except Windows, which; still has some stability and ABI issues.; . Deprecate a[b,c]; P1161R3; Clang 9. Deprecate some problematic uses of volatile; P1152R4; Clang 10. [[nodiscard(""with reason"")]]; P1301R4",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:15362,Testability,assert,assertions,15362,"efinitions of the sized deallocation functions, either by providing them; explicitly or by using a C++ standard library that does. libstdc++; added these functions in version 5.0, and libc++ added them in; version 3.7. C++11 implementation status; Clang 3.3 and later implement all of the ISO; C++ 2011 standard.; You can use Clang in C++11 mode with the -std=c++11; option. Clang's C++11 mode can be used with; libc++ or with gcc's libstdc++. List of features and minimum Clang version with support. Language Feature; C++11 Proposal; Available in Clang?. Rvalue references; N2118; Clang 2.9; ; P1825R0 (DR); Clang 13.     Rvalue references for *this; N2439; Clang 2.9. Initialization of class objects by rvalues; N1610; Clang 2.9. Non-static data member initializers; N2756; Clang 3.0. Variadic templates; N2242; Clang 2.9.     Extending variadic template template parameters; N2555; Clang 2.9. Initializer lists; N2672; Clang 3.1. ; P1009R2 (DR); Clang 9. ; P1957R2 (DR); Clang 11. Static assertions; N1720; Clang 2.9. auto-typed variables; N1984; Clang 2.9.     Multi-declarator auto; N1737; Clang 2.9.     Removal of auto as a storage-class specifier; N2546; Clang 2.9.     New function declarator syntax; N2541; Clang 2.9. Lambda expressions; N2927; Clang 3.1. P0588R1 (DR); No. Declared type of an expression; N2343; Clang 2.9.     Incomplete return types; N3276; Clang 3.1. Right angle brackets; N1757; Clang 2.9. Default template arguments for function templates; DR226; Clang 2.9. Solving the SFINAE problem for expressions; DR339; Clang 2.9. Alias templates; N2258; Clang 3.0. Extern templates; N1987; Clang 2.9. Null pointer constant; N2431; Clang 3.0. Strongly-typed enums; N2347; Clang 2.9. Forward declarations for enums; N2764; DR1206; Clang 3.1. Standardized attribute syntax; N2761; Clang 3.3 (1). Generalized constant expressions; N2235; Clang 3.1. P0859R0 (DR); Clang 8. Alignment support; N2341; Clang 3.3. Conditionally-support behavior; N1627; Clang 2.9. Changing undefined behav",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:19445,Testability,test,test,19445,"quire.; (5): thread_local support; requires a C++ runtime library providing __cxa_thread_atexit, such; as libc++abi 3.6 or later,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing documents; ISO C++ also publishes a number of documents describing additional language; and library features that are not part of standard C++. List of features and minimum Clang version with support. Document; Latest draft; Compiler flag; Available in Clang?. SD-6: SG10 feature test recommendations; SD-6; N/A. Clang 3.4 (N3745); . Clang 3.6 (N4200). Clang 4 (P0096R3). Clang 5 (P0096R4). Clang 7 (P0096R5). Clang 9 (P1353R0); . Clang 10 (P1902R1). [TS] Concepts; P0121R0. Superseded by P0734R0. [TS] Coroutines; N4663; -fcoroutines-ts-stdlib=libc++; Clang 5. -std=c++20-stdlib=libc++; Superseded by P0912R5. [TS] Library Fundamentals, Version 1 (invocation type traits); N4480; N/A; No. [TS] Library Fundamentals, Version 2 (source_location); N4617; N/A; Clang 9 (documentation). [TS]",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:19632,Testability,test,test,19632,"ater,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing documents; ISO C++ also publishes a number of documents describing additional language; and library features that are not part of standard C++. List of features and minimum Clang version with support. Document; Latest draft; Compiler flag; Available in Clang?. SD-6: SG10 feature test recommendations; SD-6; N/A. Clang 3.4 (N3745); . Clang 3.6 (N4200). Clang 4 (P0096R3). Clang 5 (P0096R4). Clang 7 (P0096R5). Clang 9 (P1353R0); . Clang 10 (P1902R1). [TS] Concepts; P0121R0. Superseded by P0734R0. [TS] Coroutines; N4663; -fcoroutines-ts-stdlib=libc++; Clang 5. -std=c++20-stdlib=libc++; Superseded by P0912R5. [TS] Library Fundamentals, Version 1 (invocation type traits); N4480; N/A; No. [TS] Library Fundamentals, Version 2 (source_location); N4617; N/A; Clang 9 (documentation). [TS] Modules; N4720; -fmodules-ts; Superseded by P1103R3. [DRAFT TS] Reflection; N4818. No. [TS] Transactional Memory; N4514. N",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:19993,Testability,test,test,19993,"r,; or libsupc++ 4.8 or later.; (6): No compiler changes are required for an implementation; such as Clang that does not provide any extended integer types.; __int128 is not treated as an extended integer type,; because changing intmax_t would be an ABI-incompatible; change. C++98 implementation status; Clang implements all of the ISO C++ 1998 standard; (including the defects addressed in the ISO C++ 2003 standard); except for export (which was removed in C++11). Defect reports; Clang generally aims to implement resolutions to Defect Reports (bug fixes; against prior standards) retroactively, in all prior standard versions where; the fix is meaningful. Significant Defect Report changes to language features; after the publication of the relevant standard are marked (DR) in the above; table.; Clang also has a test suite for conformance to resolutions for issues on the; C++ core issues list,; most of which are considered Defect Reports.; Implementation status for C++ core issues based on; that test suite is tracked on a separate page.; Technical specifications and standing documents; ISO C++ also publishes a number of documents describing additional language; and library features that are not part of standard C++. List of features and minimum Clang version with support. Document; Latest draft; Compiler flag; Available in Clang?. SD-6: SG10 feature test recommendations; SD-6; N/A. Clang 3.4 (N3745); . Clang 3.6 (N4200). Clang 4 (P0096R3). Clang 5 (P0096R4). Clang 7 (P0096R5). Clang 9 (P1353R0); . Clang 10 (P1902R1). [TS] Concepts; P0121R0. Superseded by P0734R0. [TS] Coroutines; N4663; -fcoroutines-ts-stdlib=libc++; Clang 5. -std=c++20-stdlib=libc++; Superseded by P0912R5. [TS] Library Fundamentals, Version 1 (invocation type traits); N4480; N/A; No. [TS] Library Fundamentals, Version 2 (source_location); N4617; N/A; Clang 9 (documentation). [TS] Modules; N4720; -fmodules-ts; Superseded by P1103R3. [DRAFT TS] Reflection; N4818. No. [TS] Transactional Memory; N4514. No. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/cxx_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:9366,Availability,error,error,9366,"objects; Yes. 120; NAD; Semantics of assignment to (and initialization of) bit-fields; Yes. 121; NAD; Conversions of pointer values to integral types; Yes. 122; Dup; Conversion/widening of bit-fields; Duplicate of 15. 123; NAD; 'Type categories' and qualified types; Yes. 124; C89; Casts to 'a void type' versus casts to 'the void type'; Yes. 125; NAD; Using things declared as 'extern (qualified) void'; Yes. 126; NAD; What does 'synonym' mean with respect to typedef names?; Yes. 127; Dup; Composite type of an enumerated type and an integral type; Duplicate of 13. 128; NAD; Editorial issue relating to tag declarations in type specifiers; Yes. 129; NAD; Tags and name spaces; Yes. 130; NAD; Guarantees when writing text to a stream; N/A. 131; C89; const member qualification and assignment; Yes. 132; Dup; Can undefined behavior occur at translation time, or only at run time?; Duplicate of 109. 133; NAD; Undefined behavior not previously listed in subclause G2; Yes. 134; NAD; What is an 'error number' for strerror?; N/A. 135; NAD; Can the size argument to 'fwrite' be zero?; N/A. 136; NAD; 'mktime' and time gaps; N/A. 137; NAD; 'printf' and negative floating point values; N/A. 138; C89; Is there an allocated storage duration?; Yes. 139; C89; Compatibility of complete and incomplete types; Yes. 140; NAD; Behavior of 'setvbuf'; N/A. 141; NAD; What is the meaning of EOF?; N/A. 142; C89; Reservation of macro names; Yes. 143; C89; 'fopen' modes; N/A. 144; C89; Preprocessing of preprocessing directives; Yes. 145; C89; Constant expressions; Unknown. 146; C89; Nugatory constraint; Yes. 147; C89; Sequence points in library functions; Yes. 148; NAD; Defining library functions; Yes. 149; C89; The term ""variable""; Yes. 150; C89; Initialization of a char array from a string literal; Yes. 151; C89; Behavior of 'printf' and flags; N/A. 152; NAD; Can you 'longjmp' out of a signal handler?; N/A. 153; Dup; Can 'f()' be considered a call to a function-like macro with one empty argument?; Dupli",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:11528,Availability,error,error,11528,"Legitimacy of type synonyms; Yes. 158; C89; Null pointer conversions; Yes. 159; C89; Consistency of the C Standard Defects exist in the way the Standard refers to itself; Yes. 160; Open; Reservation of identifiers; Not resolved. 161; NAD; Details of reserved symbols; Yes. 162; C89; 'gmtime' and 'localtime'; N/A. 163; C89; Undeclared identifiers; Yes. 164; NAD; Bad declarations; Yes. 165; C89; Tags and incomplete types; Not resolved. 166; Open; Meaning of lvalue; Not resolved. 167; Open; Consistency of the C Standard (Defect Report UK 015); Not resolved. 168; Open; Consistency of the C Standard (Defect Report UK 016); Not resolved. 169; NAD; Trigraphs; Yes. 170; C89; Operators and punctuators; Not resolved. 171; Open; Ranges of integral types; Not resolved. 172; Open; Relational and equality operators; Not resolved. 173; Open; Line numbers; Not resolved. 174; Open; Implicit conversions; Not resolved. 175; Open; Correction to Technical Corrigendum 1; Not resolved. 176; Open; Diagnostics for #error; Not resolved. 177; Open; Preprocessing directives; Not resolved. 178; Open; Conformance with array members and allocations; Not resolved. 201; NAD; Integer types longer than long; Yes. 202; C99; Change return type of certain <fenv.h> functions; N/A. 203; C99; C locale conflict with ISO/IEC 9945-2; N/A. 204; C99; size_t and ptrdiff_t as a long long type; Yes. 205; NAD; New keyword __at_least; Yes. 206; NAD; Default argument conversion of float _Complex; Yes. 207; C99; Handling of imaginary types. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 208; C99; Ambiguity in initialization; Yes. 209; C99; Problem implementing INTN_C macros. Partial; Clang provides these definitions in a freestanding compilation, but the; type of the value produced by UINT8_C and UINT16_C; is not the type after integer promotion per C99 7.18.4p3.; . 210; C99; 'fprintf' %a and %A conversions recommended practice; N/A. 211; C99; Accuracy of decimal st",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:13981,Availability,error,errors,13981,"decimal integer""; N/A. 221; NAD; Lacuna in pointer arithmetic; Yes. 222; C99; Partially initialized structures; Yes. 223; C99; 'FP_FAST_FMAF' and 'FP_FAST_FMAL' should be integer constant; N/A. 224; C99; fpclassify return is not defined; N/A. 225; C99; strtod, strtof and strtold expected form of the subject sequence; N/A. 226; NAD; strftime references; N/A. 227; NAD; strftime %U, %V, and %W conversion specifiers; N/A. 228; C99; wmemcmp declaration in Annex B; N/A. 229; C99; localeconv() *_sep_by_space table entries issues; N/A. 230; C99; Enumerated type rank; Yes. 231; NAD; Semantics of text-line and non-directive; No. 232; C99; Typo in Annex I; N/A. 233; C99; %g, %G precision specification; N/A. 234; C99; Miscellaneous Typos; Yes. 235; C99; ""C"" locale collating behaviour not defined; N/A. 236; NAD; The interpretation of type based aliasing rule when applied to union objects or allocated objects; Unknown. 237; NAD; Declarations using [static]; No. 238; C99; Decriptions of fma() overflow and underflow errors are missing; N/A. 239; C99; Annex F nexttoward description is inconsistent with 7.12.11.4 and F.9.8.3; N/A. 240; C99; lrint, llrint, lround, llround, and ilogb descriptions are not consistent for unrepresentable results; N/A. 241; C99; Make the base standard and Annex F consistent for pow(0, <0); N/A. 242; C99; Make the base standard and Annex F consistent for logb(0); N/A. 243; C99; Make the base standard and Annex F consistent for fmod(), remainder(), and remquo() for a zero divisor; N/A. 244; C99; tgamma(zero or negative integer) should be considered a pole error; N/A. 245; C99; Missing paragraph numbers; Yes. 246; NAD; Completion of declarators; Yes. 247; C99; Are values a form of behaviour?; Yes. 248; C99; Limits are required for optional types; Yes. 249; Dup; Lacuna applying C89:TC1 to C99; Duplicate of 9. 250; C99; Non-directives within macro arguments; Yes. 251; C99; Are struct fred and union fred the same type?; Yes. 252; NAD; Incomplete argument types wh",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:14555,Availability,error,error,14555," rank; Yes. 231; NAD; Semantics of text-line and non-directive; No. 232; C99; Typo in Annex I; N/A. 233; C99; %g, %G precision specification; N/A. 234; C99; Miscellaneous Typos; Yes. 235; C99; ""C"" locale collating behaviour not defined; N/A. 236; NAD; The interpretation of type based aliasing rule when applied to union objects or allocated objects; Unknown. 237; NAD; Declarations using [static]; No. 238; C99; Decriptions of fma() overflow and underflow errors are missing; N/A. 239; C99; Annex F nexttoward description is inconsistent with 7.12.11.4 and F.9.8.3; N/A. 240; C99; lrint, llrint, lround, llround, and ilogb descriptions are not consistent for unrepresentable results; N/A. 241; C99; Make the base standard and Annex F consistent for pow(0, <0); N/A. 242; C99; Make the base standard and Annex F consistent for logb(0); N/A. 243; C99; Make the base standard and Annex F consistent for fmod(), remainder(), and remquo() for a zero divisor; N/A. 244; C99; tgamma(zero or negative integer) should be considered a pole error; N/A. 245; C99; Missing paragraph numbers; Yes. 246; NAD; Completion of declarators; Yes. 247; C99; Are values a form of behaviour?; Yes. 248; C99; Limits are required for optional types; Yes. 249; Dup; Lacuna applying C89:TC1 to C99; Duplicate of 9. 250; C99; Non-directives within macro arguments; Yes. 251; C99; Are struct fred and union fred the same type?; Yes. 252; NAD; Incomplete argument types when calling non-prototyped functions; Yes. 253; NAD; ""overriding"" in designated initializers; Yes. 254; NAD; mbtowc and partial characters; N/A. 255; NAD; Non-prototyped function calls and argument mismatches; Yes. 256; NAD; Multiple inclusion of headers; N/A. 257; NAD; Common initial sequences and related issues with unions; Unknown. 258; NAD; Ordering of ""defined"" and macro replacement; Yes. 259; NAD; Macro invocations with no arguments; Yes. 260; NAD; Indeterminate values and identical representations; Unknown. 261; NAD; Constant expressions; Yes. 262",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:17768,Availability,error,error,17768,"ruct padding; Yes. 283; C99; Accessing a non-current union member (""type punning""); Unknown. 284; NAD; Does <math.h> define INT_MIN and INT_MAX?; N/A. 285; C99; Conversion of an imaginary type to _Bool. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 286; C99; Correctly rounded and rounding direction/mode; N/A. 287; Dup; Floating-point status flags and sequence points; Duplicate of 87. 288; NAD; Deficiency on multibyte conversions; N/A. 289; C99; Function prototype with [restrict]; Yes. 290; C99; FLT_EVAL_METHOD and extra precision and/or range; Unknown. 291; C99; Corrections to requirements on inexact floating-point exceptions; Unknown. 292; C99; Use of the word variable; Yes. 293; C99; Typo in Standard - double complex instead of complex in an example; Yes. 294; NAD; Technical question on C99 restrict keyword; Unknown. 295; C99; Incomplete types for function parameters; Yes. 296; C99; Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?; N/A. 297; C99; May FE_* floating-point exception flags have bits in common?; N/A. 298; C99; Validity of constant in unsigned long long range. Partial; Clang defines the behavior in this situation by automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long sentence describing preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:17824,Availability,error,errors,17824,"ruct padding; Yes. 283; C99; Accessing a non-current union member (""type punning""); Unknown. 284; NAD; Does <math.h> define INT_MIN and INT_MAX?; N/A. 285; C99; Conversion of an imaginary type to _Bool. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 286; C99; Correctly rounded and rounding direction/mode; N/A. 287; Dup; Floating-point status flags and sequence points; Duplicate of 87. 288; NAD; Deficiency on multibyte conversions; N/A. 289; C99; Function prototype with [restrict]; Yes. 290; C99; FLT_EVAL_METHOD and extra precision and/or range; Unknown. 291; C99; Corrections to requirements on inexact floating-point exceptions; Unknown. 292; C99; Use of the word variable; Yes. 293; C99; Typo in Standard - double complex instead of complex in an example; Yes. 294; NAD; Technical question on C99 restrict keyword; Unknown. 295; C99; Incomplete types for function parameters; Yes. 296; C99; Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?; N/A. 297; C99; May FE_* floating-point exception flags have bits in common?; N/A. 298; C99; Validity of constant in unsigned long long range. Partial; Clang defines the behavior in this situation by automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long sentence describing preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21592,Availability,redundant,redundant,21592,"rison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; doe",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21759,Availability,error,error,21759,"99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22269,Availability,error,error,22269,"; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a re",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:25989,Availability,error,error,25989,"; C11; The ctime_s function in Annex K defined incorrectly; N/A. 458; C11; ATOMIC_XXX_LOCK_FREE macros not constant expressions; N/A. 459; C11; atomic_load missing const qualifier; Yes. 460; C11; aligned_alloc underspecified; N/A. 461; NAD; Problems with references to objects in signal handlers; N/A. 462; C11; Clarifying objects accessed in signal handlers; N/A. 463; NAD; Left-shifting into the sign bit; Yes. 464; C11; Clarifying the Behavior of the #line Directive; Yes. 465; C11; Fixing an inconsistency in atomic_is_lock_free; Unknown. 466; NAD; Scope of a for loop control declaration; Yes. 467; C11; Maximum representable finite description vs math; Unknown. 468; C11; strncpy_s clobbers buffer past null; N/A. 469; NAD; Lock ownership vs. thread termination; N/A. 470; C11; mtx_trylock should be allowed to fail spuriously; N/A. 471; C11; Complex math functions cacosh and ctanh; N/A. 472; C11; Introduction to complex arithmetic in 7.3.1p3 wrong due to CMPLX; N/A. 473; C11; ""A range error occurs if x is too large."" is misleading; N/A. 474; NAD; NOTE 1 Clarification for atomic_compare_exchange; N/A. 475; C11; Misleading Atomic library references to atomic types; Yes. 476; C11; volatile semantics for lvalues; Unknown. 477; C11; nan should take a string argument; N/A. 478; NAD; Valid uses of the main function; Yes. 479; Dup; Unclear specification of mtx_trylock on non-recursive muteness; Duplicate of 269. 480; C11; cnd_wait and cnd_timewait should allow spurious wake-ups; N/A. 481; C11; Controlling expression of _Generic primary expression; Clang 3.8. 482; NAD; Macro invocation split over many files; Unknown. 483; NAD; __LINE__ and __FILE__ in macro replacement list; Yes. 484; NAD; invalid characters in strcoll(); N/A. 485; C11; Problem with the specification of ATOMIC_VAR_INIT; Yes. 486; NAD; Inconsistent specification for arithmetic on atomic objects; Unknown. 487; C11; timespec vs. tm; N/A. 488; C11; c16rtomb() on wide characters encoded as multiple char16_t; N/A. 489; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22092,Deployability,update,updated,22092,"rays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allow",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:2734,Energy Efficiency,allocate,allocated,2734,"hat does static storage duration do when zero for the type is not all zero bits?; Unknown. 17; C89; 39 unrelated questions about C89; Unknown. 18; NAD; How does fscanf behave in the presence of multibyte characters?; N/A. 19; NAD; Definition of the term ""printing character"" and isgraph(); N/A. 20; NAD; Is a compiler which allows the Relaxed Ref/Def linkage model to be considered a conforming compiler?; Yes. 21; C89; What is the result of: printf(""%#.4o"", 345);?; N/A. 22; C89; What is the result of: strtod(""100ergs"", &ptr);?; N/A. 23; NAD; what is the result of strtod(""0.0e99999"", &ptr);?; N/A. 24; NAD; In subclause 7.10.1.4 The strtod function: What does '""C"" locale' mean?; N/A. 25; NAD; What is meant by 'representable floating-point value?'; Yes. 26; NAD; Can a strictly conforming program contain a string literal with '$' or '@'?; Yes. 27; C89; Can there be characters in the character set that are not in the required source character set?; Yes. 28; NAD; Do object access rules apply to dynamically allocated objects?; Unknown. 29; NAD; Do two types have to have the same tag to be compatible?; No. 30; NAD; Can 'sin(DBL_MAX)' result in 'errno' being set to 'EDOM'?; N/A. 31; NAD; Can constant expressions overflow?; Yes. 32; NAD; Must implementations diagnose extensions to the constant evaluation rules?; No. 33; NAD; Conformance questions around 'shall' violations outside of constraints sections; Yes. 34; C89; External declarations in different scopes; Yes. 35; NAD; Questions about definition of functions without a prototype. Partial; Tags declared directly within an identifier list are incorrectly scoped; to the prototype rather than to the function body.; . 36; NAD; May floating-point constants be represented with more precision than implied by its type?; Yes. 37; NAD; Questions about multibyte characters and Unicode; Yes. 38; NAD; Questions about argument substitution during macro expansion; Yes. 39; NAD; Questions about the ""C"" locale; Yes. 40; NAD; 9 unrelated quest",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:5877,Energy Efficiency,allocate,allocated,5877,here an integral type for every pointer?; Yes. 58; NAD; Is there a limit on the number of digits processed by scanf and strtdo?; N/A. 59; NAD; Do types have to be completed?; Yes. 60; C89; Array initialization from a string literal; Yes. 61; NAD; Whitespace in scanf format string; N/A. 62; NAD; Can the rename function be defined to fail?; N/A. 63; Dup; Floating-point representation precision requirements; Duplicate of 56. 64; NAD; Null pointer constants; Yes. 65; C89; Questions on locales; N/A. 66; NAD; Another question on locales; N/A. 67; NAD; Integer and integral type confusion; Yes. 68; NAD; 'char' and signed vs unsigned integer types; Yes. 69; NAD; Questions about the representation of integer types; Yes. 70; NAD; Interchangeability of function arguments; Yes. 71; C89; Enumerated types; Yes. 72; NAD; Definition of object and pointer arithmetic; Unknown. 73; NAD; Definition of object and array access; Unknown. 74; NAD; Alignment and structure padding; Unknown. 75; NAD; Alignment of allocated memory; N/A. 76; Open; Pointers to the end of arrays; Not resolved. 77; NAD; Stability of addresses; Yes. 78; NAD; Uniqueness of addresses; Unknown. 79; NAD; Constancy of system library function addresses; N/A. 80; C89; Merging of string constants; Yes. 81; NAD; Left shift operator; Yes. 82; C89; Multiple varargs; Unknown. 83; C89; Use of library functions; N/A. 84; NAD; Incomplete type in function declaration; Yes. 85; C89; Returning from main; Yes. 86; NAD; Object-like macros in system headers; Yes. 87; NAD; Order of evaluation; Unknown. 88; NAD; Compatibility of incomplete types; Yes. 89; C89; Multiple definitions of macros; Yes. 90; NAD; Multibyte characters in formats; N/A. 91; NAD; Multibyte encodings; Yes. 92; Dup; Partial initialization of strings; Duplicate of 60. 93; C89; Reservation of identifiers; Yes. 94; NAD; Are constraints on function return the same as assignment?; Yes. 95; NAD; Is initialization as constrained as assignment?; Yes. 96; NAD; Arrays of incomple,MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:9580,Energy Efficiency,allocate,allocated,9580,"15. 123; NAD; 'Type categories' and qualified types; Yes. 124; C89; Casts to 'a void type' versus casts to 'the void type'; Yes. 125; NAD; Using things declared as 'extern (qualified) void'; Yes. 126; NAD; What does 'synonym' mean with respect to typedef names?; Yes. 127; Dup; Composite type of an enumerated type and an integral type; Duplicate of 13. 128; NAD; Editorial issue relating to tag declarations in type specifiers; Yes. 129; NAD; Tags and name spaces; Yes. 130; NAD; Guarantees when writing text to a stream; N/A. 131; C89; const member qualification and assignment; Yes. 132; Dup; Can undefined behavior occur at translation time, or only at run time?; Duplicate of 109. 133; NAD; Undefined behavior not previously listed in subclause G2; Yes. 134; NAD; What is an 'error number' for strerror?; N/A. 135; NAD; Can the size argument to 'fwrite' be zero?; N/A. 136; NAD; 'mktime' and time gaps; N/A. 137; NAD; 'printf' and negative floating point values; N/A. 138; C89; Is there an allocated storage duration?; Yes. 139; C89; Compatibility of complete and incomplete types; Yes. 140; NAD; Behavior of 'setvbuf'; N/A. 141; NAD; What is the meaning of EOF?; N/A. 142; C89; Reservation of macro names; Yes. 143; C89; 'fopen' modes; N/A. 144; C89; Preprocessing of preprocessing directives; Yes. 145; C89; Constant expressions; Unknown. 146; C89; Nugatory constraint; Yes. 147; C89; Sequence points in library functions; Yes. 148; NAD; Defining library functions; Yes. 149; C89; The term ""variable""; Yes. 150; C89; Initialization of a char array from a string literal; Yes. 151; C89; Behavior of 'printf' and flags; N/A. 152; NAD; Can you 'longjmp' out of a signal handler?; N/A. 153; Dup; Can 'f()' be considered a call to a function-like macro with one empty argument?; Duplicate of 3. 154; NAD; Consistency of implementation-defined values; Yes. 155; C89; Zero-sized allocations; N/A. 156; C89; Closed streams; N/A. 157; C89; Legitimacy of type synonyms; Yes. 158; C89; Null pointer conve",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:13856,Energy Efficiency,allocate,allocated,13856,"; 'asctime' limits; N/A. 218; C99; Signs of non-numeric floating point values; Yes. 219; NAD; Effective types; Yes. 220; C99; Definition of ""decimal integer""; N/A. 221; NAD; Lacuna in pointer arithmetic; Yes. 222; C99; Partially initialized structures; Yes. 223; C99; 'FP_FAST_FMAF' and 'FP_FAST_FMAL' should be integer constant; N/A. 224; C99; fpclassify return is not defined; N/A. 225; C99; strtod, strtof and strtold expected form of the subject sequence; N/A. 226; NAD; strftime references; N/A. 227; NAD; strftime %U, %V, and %W conversion specifiers; N/A. 228; C99; wmemcmp declaration in Annex B; N/A. 229; C99; localeconv() *_sep_by_space table entries issues; N/A. 230; C99; Enumerated type rank; Yes. 231; NAD; Semantics of text-line and non-directive; No. 232; C99; Typo in Annex I; N/A. 233; C99; %g, %G precision specification; N/A. 234; C99; Miscellaneous Typos; Yes. 235; C99; ""C"" locale collating behaviour not defined; N/A. 236; NAD; The interpretation of type based aliasing rule when applied to union objects or allocated objects; Unknown. 237; NAD; Declarations using [static]; No. 238; C99; Decriptions of fma() overflow and underflow errors are missing; N/A. 239; C99; Annex F nexttoward description is inconsistent with 7.12.11.4 and F.9.8.3; N/A. 240; C99; lrint, llrint, lround, llround, and ilogb descriptions are not consistent for unrepresentable results; N/A. 241; C99; Make the base standard and Annex F consistent for pow(0, <0); N/A. 242; C99; Make the base standard and Annex F consistent for logb(0); N/A. 243; C99; Make the base standard and Annex F consistent for fmod(), remainder(), and remquo() for a zero divisor; N/A. 244; C99; tgamma(zero or negative integer) should be considered a pole error; N/A. 245; C99; Missing paragraph numbers; Yes. 246; NAD; Completion of declarators; Yes. 247; C99; Are values a form of behaviour?; Yes. 248; C99; Limits are required for optional types; Yes. 249; Dup; Lacuna applying C89:TC1 to C99; Duplicate of 9. 250; C99; No",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21699,Integrability,synchroniz,synchronization,21699,". 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Du",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22964,Integrability,rout,routines,22964,"ds <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a representable value?; Yes. 433; C11; Issue with constraints for wide character function arguments involving RSIZE_MAX; N/A. 434; C11; Possible defect report: Missing constraint w.r.t. Atomic; Yes. 435; NAD; Possible defect report: Missing constraint w.r.t. Imaginary; Yes. 436; C11; Request for interpretation of C11 6.8.5#6; Yes. 437; C11; clock overflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C11; Issues with the definition of ""full expression""; Unknown. 440; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1; Unknown. 441; C11; Floating-point issues in C11 from PDTS 18661",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:10083,Modifiability,variab,variable,10083,"n writing text to a stream; N/A. 131; C89; const member qualification and assignment; Yes. 132; Dup; Can undefined behavior occur at translation time, or only at run time?; Duplicate of 109. 133; NAD; Undefined behavior not previously listed in subclause G2; Yes. 134; NAD; What is an 'error number' for strerror?; N/A. 135; NAD; Can the size argument to 'fwrite' be zero?; N/A. 136; NAD; 'mktime' and time gaps; N/A. 137; NAD; 'printf' and negative floating point values; N/A. 138; C89; Is there an allocated storage duration?; Yes. 139; C89; Compatibility of complete and incomplete types; Yes. 140; NAD; Behavior of 'setvbuf'; N/A. 141; NAD; What is the meaning of EOF?; N/A. 142; C89; Reservation of macro names; Yes. 143; C89; 'fopen' modes; N/A. 144; C89; Preprocessing of preprocessing directives; Yes. 145; C89; Constant expressions; Unknown. 146; C89; Nugatory constraint; Yes. 147; C89; Sequence points in library functions; Yes. 148; NAD; Defining library functions; Yes. 149; C89; The term ""variable""; Yes. 150; C89; Initialization of a char array from a string literal; Yes. 151; C89; Behavior of 'printf' and flags; N/A. 152; NAD; Can you 'longjmp' out of a signal handler?; N/A. 153; Dup; Can 'f()' be considered a call to a function-like macro with one empty argument?; Duplicate of 3. 154; NAD; Consistency of implementation-defined values; Yes. 155; C89; Zero-sized allocations; N/A. 156; C89; Closed streams; N/A. 157; C89; Legitimacy of type synonyms; Yes. 158; C89; Null pointer conversions; Yes. 159; C89; Consistency of the C Standard Defects exist in the way the Standard refers to itself; Yes. 160; Open; Reservation of identifiers; Not resolved. 161; NAD; Details of reserved symbols; Yes. 162; C89; 'gmtime' and 'localtime'; N/A. 163; C89; Undeclared identifiers; Yes. 164; NAD; Bad declarations; Yes. 165; C89; Tags and incomplete types; Not resolved. 166; Open; Meaning of lvalue; Not resolved. 167; Open; Consistency of the C Standard (Defect Report UK 015); Not resolve",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:17505,Modifiability,variab,variable,17505,"character encodings; Yes. 279; C99; Wide character code values for members of the basic character set; Yes. 280; NAD; struct tm, member tm_isdst, and mktime() in <time.h>; N/A. 281; C99; CLOCKS_PER_SEC should not be a constant expression; N/A. 282; C99; Flexible array members & struct padding; Yes. 283; C99; Accessing a non-current union member (""type punning""); Unknown. 284; NAD; Does <math.h> define INT_MIN and INT_MAX?; N/A. 285; C99; Conversion of an imaginary type to _Bool. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 286; C99; Correctly rounded and rounding direction/mode; N/A. 287; Dup; Floating-point status flags and sequence points; Duplicate of 87. 288; NAD; Deficiency on multibyte conversions; N/A. 289; C99; Function prototype with [restrict]; Yes. 290; C99; FLT_EVAL_METHOD and extra precision and/or range; Unknown. 291; C99; Corrections to requirements on inexact floating-point exceptions; Unknown. 292; C99; Use of the word variable; Yes. 293; C99; Typo in Standard - double complex instead of complex in an example; Yes. 294; NAD; Technical question on C99 restrict keyword; Unknown. 295; C99; Incomplete types for function parameters; Yes. 296; C99; Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?; N/A. 297; C99; May FE_* floating-point exception flags have bits in common?; N/A. 298; C99; Validity of constant in unsigned long long range. Partial; Clang defines the behavior in this situation by automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long se",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:18406,Modifiability,portab,portable,18406,"to requirements on inexact floating-point exceptions; Unknown. 292; C99; Use of the word variable; Yes. 293; C99; Typo in Standard - double complex instead of complex in an example; Yes. 294; NAD; Technical question on C99 restrict keyword; Unknown. 295; C99; Incomplete types for function parameters; Yes. 296; C99; Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?; N/A. 297; C99; May FE_* floating-point exception flags have bits in common?; N/A. 298; C99; Validity of constant in unsigned long long range. Partial; Clang defines the behavior in this situation by automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long sentence describing preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10.3p10: Clarifiying arguments vs. parameters; Yes. 308; C99; Clarify that source files et al. need not be ""files""; Yes. 309; C99; Clarifying trigraph substitution; Yes. 310; C99; Add non-corner case example of trigraphs; Yes. 311; C99; Definition of variably modified types; Yes. 312; C99; Meaning of ""known constant size""; Yes. 313; NAD; Incomplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_M",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:19029,Modifiability,variab,variably,19029," automatically using; long long or unsigned long long as the; underlying type of the constant; however, Clang fails to diagnose the; extension in C89 mode with such constants.; . 299; C99; Is cabs() a type-generic macro?; N/A. 300; NAD; Translation-time expresssion evaluation; Yes. 301; NAD; Meaning of FE_* macros in <fenv.h>; Yes. 302; C99; 6.10.2p5: Adding underscore to portable include file name character set; Yes. 303; C99; 6.10p2: Breaking up the very long sentence describing preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10.3p10: Clarifiying arguments vs. parameters; Yes. 308; C99; Clarify that source files et al. need not be ""files""; Yes. 309; C99; Clarifying trigraph substitution; Yes. 310; C99; Add non-corner case example of trigraphs; Yes. 311; C99; Definition of variably modified types; Yes. 312; C99; Meaning of ""known constant size""; Yes. 313; NAD; Incomplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initializ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:19512,Modifiability,variab,variably,19512," preprocessing directive; Yes. 304; C99; Clarifying illegal tokens in #if directives; Yes. 305; C99; 6.10.1p3: Clarifying handling of keywords in #if directives; Yes. 306; C99; 6.10.3p9: Clarifying that rescanning applies to object-like macros; Yes. 307; C99; 6.10.3p10: Clarifiying arguments vs. parameters; Yes. 308; C99; Clarify that source files et al. need not be ""files""; Yes. 309; C99; Clarifying trigraph substitution; Yes. 310; C99; Add non-corner case example of trigraphs; Yes. 311; C99; Definition of variably modified types; Yes. 312; C99; Meaning of ""known constant size""; Yes. 313; NAD; Incomplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predef",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:19919,Modifiability,variab,variable,19919,"substitution; Yes. 310; C99; Add non-corner case example of trigraphs; Yes. 311; C99; Definition of variably modified types; Yes. 312; C99; Meaning of ""known constant size""; Yes. 313; NAD; Incomplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for var",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20167,Modifiability,variab,variably-modified,20167,"omplete arrays of VLAs; Yes. 314; NAD; Cross-translation-unit tagged type compatibility; Unknown. 315; C99; Implementation-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20219,Modifiability,variab,variably-modified,20219,"n-defined bit-field types; Yes. 316; NAD; Unprototyped function types; Yes. 317; NAD; Function definitions with empty parentheses; Yes. 318; C99; (double)0.1f with FLT_EVAL_METHOD being 2; Unknown. 319; NAD; printf(""%a"", 1.0) and trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; real",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20927,Modifiability,variab,variable-length,20927,"le length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22748,Modifiability,variab,variables,22748," being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a representable value?; Yes. 433; C11; Issue with constraints for wide character function arguments involving RSIZE_MAX; N/A. 434; C11; Possible defect report: Missing constraint w.r.t. Atomic; Yes. 435; NAD; Possible defect report: Missing constraint w.r.t. Imaginary; Yes. 436; C11; Request for interpretation of C11 6.8.5#6; Yes. 437; C11; clock overflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:24710,Modifiability,variab,variables,24710,"on after discarding push back problems; N/A. 439; C11; Issues with the definition of ""full expression""; Unknown. 440; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1; Unknown. 441; C11; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 2; N/A. 442; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 3; Unknown. 443; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 4; Unknown. 444; C11; Issues with alignment in C11, part 1. Partial; Clang rejects use of an alignment specifier in a compound literal expression.; . 445; C11; Issues with alignment in C11, part 2; Unknown. 446; NAD; Use byte instead of character for memcmp, memcpy; N/A. 447; C11; Boolean from complex; Yes. 448; C11; What are the semantics of a # non-directive?; Yes. 449; NAD; What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?; N/A. 450; C11; tmpnam_s clears s[0] when maxsize > RSIZE_MAX; N/A. 451; NAD; Instability of uninitialized automatic variables; Unknown. 452; C11; Effective Type in Loop Invariant; Unknown. 453; C11; Atomic flag type and operations; N/A. 454; NAD; ATOMIC_VAR_INIT (issues 3 and 4); Yes. 455; NAD; ATOMIC_VAR_INIT issue 5; Yes. 456; Dup; Compile time definition of UINTN_C(value); Duplicate of 209. 457; C11; The ctime_s function in Annex K defined incorrectly; N/A. 458; C11; ATOMIC_XXX_LOCK_FREE macros not constant expressions; N/A. 459; C11; atomic_load missing const qualifier; Yes. 460; C11; aligned_alloc underspecified; N/A. 461; NAD; Problems with references to objects in signal handlers; N/A. 462; C11; Clarifying objects accessed in signal handlers; N/A. 463; NAD; Left-shifting into the sign bit; Yes. 464; C11; Clarifying the Behavior of the #line Directive; Yes. 465; C11; Fixing an inconsistency in atomic_is_lock_free; Unknown. 466; NAD; Scope of a for loop control declaration; Yes. 467; C11; Maximum representable finite description vs math; Unknown. 468; C11; strncpy_s clobbers buff",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:1236,Performance,perform,perform,1236," C Standard are; currently under investigation. Any defect report whose status in Clang is; currently unknown will be marked in purple.; The LLVM bug tracker uses; the ""c"", ""c99"", ""c11"", ""c17"", and ""c23"" labels to track known bugs with Clang's language; conformance. Number; Status; Issue title; Available in Clang?. 1; C89; Do functions return values by copying?; Yes. 2; NAD; Subclause 6.8.3.2: Semantics of #; Unknown. 3; NAD; Subclause 6.1.8: Preprocessing numbers; Unknown. 4; NAD; Are multiple definitions of unused identifiers with external linkage permitted?; Yes. 5; NAD; May a conforming implementation define and recognize a pragma which would change the semantics of the language?; Yes. 6; C89; It is unclear how the strtoul function behaves when presented with a subject sequence that begins with a minus sign; N/A. 7; NAD; Are declarations of the form struct-or-union identifier ; permitted after the identifier tag has already been declared?; Yes. 8; NAD; Can a conforming C compiler to perform dead-store elimination?; Yes. 9; C89; Use of typedef names in parameter declarations; No. 10; NAD; Is a typedef to an incomplete type legal?; Yes. 11; C89; Merging of declarations for linked identifier; Yes. 12; NAD; Is it valid to take the address of a dereferenced void pointer?; Yes. 13; C89; Compatible and composite function types; Yes. 14; C89; Issues with setjmp and fscanf descriptions; N/A. 15; NAD; What is the promoted type of a plain int bit-field?; Yes. 16; C89; What does static storage duration do when zero for the type is not all zero bits?; Unknown. 17; C89; 39 unrelated questions about C89; Unknown. 18; NAD; How does fscanf behave in the presence of multibyte characters?; N/A. 19; NAD; Definition of the term ""printing character"" and isgraph(); N/A. 20; NAD; Is a compiler which allows the Relaxed Ref/Def linkage model to be considered a conforming compiler?; Yes. 21; C89; What is the result of: printf(""%#.4o"", 345);?; N/A. 22; C89; What is the result of: strtod(""10",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:4289,Safety,abort,abort,4289,"clared directly within an identifier list are incorrectly scoped; to the prototype rather than to the function body.; . 36; NAD; May floating-point constants be represented with more precision than implied by its type?; Yes. 37; NAD; Questions about multibyte characters and Unicode; Yes. 38; NAD; Questions about argument substitution during macro expansion; Yes. 39; NAD; Questions about the ""C"" locale; Yes. 40; NAD; 9 unrelated questions about C89. Partial; Question 6 has full support, the rest of the questions are currently unknown.; . 41; NAD; Do characters defined in 5.2.1 impact 7.3.1?; N/A. 42; NAD; On the behavior of library functions and overlapping objects; N/A. 43; C89; On the definition of the NULL macro; Yes. 44; NAD; On the result of the offsetof macro; Yes. 45; NAD; Is the behavior of freopen defined when the file is invalid?; N/A. 46; NAD; Use of typedef names in parameter declarations; Yes. 47; NAD; Questions about declaration conformance; Yes. 48; NAD; Clarifications on the abort() function; N/A. 49; C89; Can strxfrm() output more characters than were input?; N/A. 50; NAD; Do wide string literals implicitly include <stddef.h>?; Yes. 51; NAD; Question on pointer arithmetic; Yes. 52; C89; Editorial corrections; Yes. 53; C89; Accessing a pointer to a function with a prototype through a pointer to pointer to function without a prototype; Yes. 54; C89; Can the string handling functions have a length of 0?; N/A. 55; C89; Signal handler macros should have distinct values; N/A. 56; NAD; Floating-point representation precision requirements; Yes. 57; NAD; Is there an integral type for every pointer?; Yes. 58; NAD; Is there a limit on the number of digits processed by scanf and strtdo?; N/A. 59; NAD; Do types have to be completed?; Yes. 60; C89; Array initialization from a string literal; Yes. 61; NAD; Whitespace in scanf format string; N/A. 62; NAD; Can the rename function be defined to fail?; N/A. 63; Dup; Floating-point representation precision requirements;",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:12051,Safety,detect,detects,12051,"68; Open; Consistency of the C Standard (Defect Report UK 016); Not resolved. 169; NAD; Trigraphs; Yes. 170; C89; Operators and punctuators; Not resolved. 171; Open; Ranges of integral types; Not resolved. 172; Open; Relational and equality operators; Not resolved. 173; Open; Line numbers; Not resolved. 174; Open; Implicit conversions; Not resolved. 175; Open; Correction to Technical Corrigendum 1; Not resolved. 176; Open; Diagnostics for #error; Not resolved. 177; Open; Preprocessing directives; Not resolved. 178; Open; Conformance with array members and allocations; Not resolved. 201; NAD; Integer types longer than long; Yes. 202; C99; Change return type of certain <fenv.h> functions; N/A. 203; C99; C locale conflict with ISO/IEC 9945-2; N/A. 204; C99; size_t and ptrdiff_t as a long long type; Yes. 205; NAD; New keyword __at_least; Yes. 206; NAD; Default argument conversion of float _Complex; Yes. 207; C99; Handling of imaginary types. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 208; C99; Ambiguity in initialization; Yes. 209; C99; Problem implementing INTN_C macros. Partial; Clang provides these definitions in a freestanding compilation, but the; type of the value produced by UINT8_C and UINT16_C; is not the type after integer promotion per C99 7.18.4p3.; . 210; C99; 'fprintf' %a and %A conversions recommended practice; N/A. 211; C99; Accuracy of decimal string to/from ""binary"" (non-decimal) floating-point conversions; Yes. 212; NAD; Binding of multibyte conversion state objects; N/A. 213; C99; Lacuna in 'mbrtowc'; N/A. 214; NAD; 'atexit' function registration; N/A. 215; C99; Equality operators; Yes. 216; C99; Source character encodings; Yes. 217; NAD; 'asctime' limits; N/A. 218; C99; Signs of non-numeric floating point values; Yes. 219; NAD; Effective types; Yes. 220; C99; Definition of ""decimal integer""; N/A. 221; NAD; Lacuna in pointer arithmetic; Yes. 222; C99; Partially initialized structures; Yes. 223",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:16997,Safety,detect,detects,16997,"3; C99; Meaning of __STDC_ISO_10646__. Yes; The compiler portion of this DR is implemented in Clang, but the; __STDC_ISO_10646__ macro is not defined by Clang; the; standard library behavior factors into whether this macro can or cannot; be defined.; . 274; C99; Meaning of ""character"" in <string.h> functions; N/A. 275; C99; Bitwise-OR of nothing; N/A. 276; C99; Orientation of perror; N/A. 277; NAD; Declarations within iteration statements; No. 278; C99; Lacuna in character encodings; Yes. 279; C99; Wide character code values for members of the basic character set; Yes. 280; NAD; struct tm, member tm_isdst, and mktime() in <time.h>; N/A. 281; C99; CLOCKS_PER_SEC should not be a constant expression; N/A. 282; C99; Flexible array members & struct padding; Yes. 283; C99; Accessing a non-current union member (""type punning""); Unknown. 284; NAD; Does <math.h> define INT_MIN and INT_MAX?; N/A. 285; C99; Conversion of an imaginary type to _Bool. Partial; Clang detects use of the _Imaginary keyword but does not otherwise; support the type yet.; . 286; C99; Correctly rounded and rounding direction/mode; N/A. 287; Dup; Floating-point status flags and sequence points; Duplicate of 87. 288; NAD; Deficiency on multibyte conversions; N/A. 289; C99; Function prototype with [restrict]; Yes. 290; C99; FLT_EVAL_METHOD and extra precision and/or range; Unknown. 291; C99; Corrections to requirements on inexact floating-point exceptions; Unknown. 292; C99; Use of the word variable; Yes. 293; C99; Typo in Standard - double complex instead of complex in an example; Yes. 294; NAD; Technical question on C99 restrict keyword; Unknown. 295; C99; Incomplete types for function parameters; Yes. 296; C99; Is exp(INFINITY) overflow? A range error? A divide-by-zero exception? INFINITY without any errors?; N/A. 297; C99; May FE_* floating-point exception flags have bits in common?; N/A. 298; C99; Validity of constant in unsigned long long range. Partial; Clang defines the behavior in this situation by",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:20479,Safety,unsafe,unsafe,20479,"d trailing zeros; N/A. 320; C99; Scope of variably modified type; Yes. 321; C99; Wide character code values for members of the basic character set; Yes. 322; C99; Problem with TC2 Change #67 (Add perror to the list defining byte input/output functions); N/A. 323; C99; Potential problems with TC2 #34, #35, and #36; N/A. 324; C99; Tokenization obscurities; Yes. 325; NAD; strerror(); N/A. 326; C99; asctime(); N/A. 327; C99; Italicize definition of variable length array type, add forward references; Yes. 328; C99; String literals in compound literal initialization. Partial; Clang properly implements the use of string literals in a compound; literal initializer, but fails to diagnose use of a variably-modified; type at file scope. DR339 (about variably-modified types) is marked as; a duplicate of DR328.; . 329; C99; Math functions and directed rounding; N/A. 330; C99; Externally visible exceptional conditions; N/A. 331; NAD; permit FE_DIVBYZERO when errno says EDOM; N/A. 332; C99; gets is generally unsafe; N/A. 333; C99; Missing Predefined Macro Name; Yes. 334; Open; Missing semantics of comparison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke frag",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:21592,Safety,redund,redundant,21592,"rison macros; Not resolved. 335; NAD; _Bool bit-fields; Yes. 336; C99; What does TMP_MAX actually indicate?; N/A. 337; C99; stdio.h macro definition problems; N/A. 338; C99; C99 seems to exclude indeterminate value from being an uninitialized register; Yes. 339; Dup; Variably modified compound literal; Duplicate of 328. 340; C99; Composite types for variable-length arrays; Yes. 341; C99; [*] in abstract declarators; Yes. 342; Dup; VLAs and conditional expressions; Duplicate of 340. 343; C99; Initializing qualified wchar_t arrays; Yes. 344; C99; Casts in preprocessor conditional expressions; Yes. 345; C99; Where does parameter scope start?; Yes. 400; C11; realloc with size zero problems; Unknown. 401; C11; ""happens before"" can not be cyclic; Yes. 402; C11; Memory model coherence is not aligned with C++11; Yes. 403; C11; malloc() and free() in the memory model; N/A. 404; C11; Joke fragment remains in a footnote; Yes. 405; C11; The mutex specification; N/A. 406; C11; Visible sequences of side effects are redundant; Yes. 407; C11; Memory ordering of atomics; Unknown. 408; NAD; Should locks provide intra-thread synchronization; N/A. 409; C11; f(inf) is inf being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; doe",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:27865,Safety,safe,safety,27865,"; Yes. 476; C11; volatile semantics for lvalues; Unknown. 477; C11; nan should take a string argument; N/A. 478; NAD; Valid uses of the main function; Yes. 479; Dup; Unclear specification of mtx_trylock on non-recursive muteness; Duplicate of 269. 480; C11; cnd_wait and cnd_timewait should allow spurious wake-ups; N/A. 481; C11; Controlling expression of _Generic primary expression; Clang 3.8. 482; NAD; Macro invocation split over many files; Unknown. 483; NAD; __LINE__ and __FILE__ in macro replacement list; Yes. 484; NAD; invalid characters in strcoll(); N/A. 485; C11; Problem with the specification of ATOMIC_VAR_INIT; Yes. 486; NAD; Inconsistent specification for arithmetic on atomic objects; Unknown. 487; C11; timespec vs. tm; N/A. 488; C11; c16rtomb() on wide characters encoded as multiple char16_t; N/A. 489; NAD; Integer Constant Expression. Partial; Clang inconsistently diagnoses folding a constan expression into an ICE; as an extension.; . 490; NAD; Unwritten Assumptions About if-then; Yes. 491; C11; Concern with Keywords that Match Reserved Identifiers. Partial; Clang issues a reserved identifier diagnostic when the identifier leads; with an underscore followed by a capital letter or double underscores,; even if the identifier is used for a macro definition.; . 492; NAD; Named Child struct-union with no Member; Clang 3.6. 493; Dup; Mutex Initialization Underspecified; Duplicate of 469. 494; C11; Part 1: Alignment specifier expression evaluation; Yes. 495; C11; Part 2: Atomic specifier expression evaluation; Not resolved. 496; NAD; offsetof questions; Yes. 497; C11; ""white-space character"" defined in two places; N/A. 498; C11; mblen, mbtowc, and wctomb thread-safety; N/A. 499; C17; Anonymous structure in union behavior; Yes. 500; C17; Ambiguous specification for FLT_EVAL_METHOD; Unknown. 501; C17; Can DECIMAL_DIG be larger than necessary?; N/A. 502; NAD; Flexible array member in an anonymous struct; Yes. 503; NAD; Hexadecimal floating-point and strtod; N/A. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:2700,Security,access,access,2700,"hat does static storage duration do when zero for the type is not all zero bits?; Unknown. 17; C89; 39 unrelated questions about C89; Unknown. 18; NAD; How does fscanf behave in the presence of multibyte characters?; N/A. 19; NAD; Definition of the term ""printing character"" and isgraph(); N/A. 20; NAD; Is a compiler which allows the Relaxed Ref/Def linkage model to be considered a conforming compiler?; Yes. 21; C89; What is the result of: printf(""%#.4o"", 345);?; N/A. 22; C89; What is the result of: strtod(""100ergs"", &ptr);?; N/A. 23; NAD; what is the result of strtod(""0.0e99999"", &ptr);?; N/A. 24; NAD; In subclause 7.10.1.4 The strtod function: What does '""C"" locale' mean?; N/A. 25; NAD; What is meant by 'representable floating-point value?'; Yes. 26; NAD; Can a strictly conforming program contain a string literal with '$' or '@'?; Yes. 27; C89; Can there be characters in the character set that are not in the required source character set?; Yes. 28; NAD; Do object access rules apply to dynamically allocated objects?; Unknown. 29; NAD; Do two types have to have the same tag to be compatible?; No. 30; NAD; Can 'sin(DBL_MAX)' result in 'errno' being set to 'EDOM'?; N/A. 31; NAD; Can constant expressions overflow?; Yes. 32; NAD; Must implementations diagnose extensions to the constant evaluation rules?; No. 33; NAD; Conformance questions around 'shall' violations outside of constraints sections; Yes. 34; C89; External declarations in different scopes; Yes. 35; NAD; Questions about definition of functions without a prototype. Partial; Tags declared directly within an identifier list are incorrectly scoped; to the prototype rather than to the function body.; . 36; NAD; May floating-point constants be represented with more precision than implied by its type?; Yes. 37; NAD; Questions about multibyte characters and Unicode; Yes. 38; NAD; Questions about argument substitution during macro expansion; Yes. 39; NAD; Questions about the ""C"" locale; Yes. 40; NAD; 9 unrelated quest",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:5787,Security,access,access,5787,istinct values; N/A. 56; NAD; Floating-point representation precision requirements; Yes. 57; NAD; Is there an integral type for every pointer?; Yes. 58; NAD; Is there a limit on the number of digits processed by scanf and strtdo?; N/A. 59; NAD; Do types have to be completed?; Yes. 60; C89; Array initialization from a string literal; Yes. 61; NAD; Whitespace in scanf format string; N/A. 62; NAD; Can the rename function be defined to fail?; N/A. 63; Dup; Floating-point representation precision requirements; Duplicate of 56. 64; NAD; Null pointer constants; Yes. 65; C89; Questions on locales; N/A. 66; NAD; Another question on locales; N/A. 67; NAD; Integer and integral type confusion; Yes. 68; NAD; 'char' and signed vs unsigned integer types; Yes. 69; NAD; Questions about the representation of integer types; Yes. 70; NAD; Interchangeability of function arguments; Yes. 71; C89; Enumerated types; Yes. 72; NAD; Definition of object and pointer arithmetic; Unknown. 73; NAD; Definition of object and array access; Unknown. 74; NAD; Alignment and structure padding; Unknown. 75; NAD; Alignment of allocated memory; N/A. 76; Open; Pointers to the end of arrays; Not resolved. 77; NAD; Stability of addresses; Yes. 78; NAD; Uniqueness of addresses; Unknown. 79; NAD; Constancy of system library function addresses; N/A. 80; C89; Merging of string constants; Yes. 81; NAD; Left shift operator; Yes. 82; C89; Multiple varargs; Unknown. 83; C89; Use of library functions; N/A. 84; NAD; Incomplete type in function declaration; Yes. 85; C89; Returning from main; Yes. 86; NAD; Object-like macros in system headers; Yes. 87; NAD; Order of evaluation; Unknown. 88; NAD; Compatibility of incomplete types; Yes. 89; C89; Multiple definitions of macros; Yes. 90; NAD; Multibyte characters in formats; N/A. 91; NAD; Multibyte encodings; Yes. 92; Dup; Partial initialization of strings; Duplicate of 60. 93; C89; Reservation of identifiers; Yes. 94; NAD; Are constraints on function return the same as assign,MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22738,Security,access,access,22738," being a range error; N/A. 410; C11; ilogb inconsistent with lrint, lround; N/A. 411; C11; Predefined macro values; Yes. 412; C11; #elif; Yes. 413; NAD; Initialization; Yes. 414; C11; Typos in 6.27 Threads <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a representable value?; Yes. 433; C11; Issue with constraints for wide character function arguments involving RSIZE_MAX; N/A. 434; C11; Possible defect report: Missing constraint w.r.t. Atomic; Yes. 435; NAD; Possible defect report: Missing constraint w.r.t. Imaginary; Yes. 436; C11; Request for interpretation of C11 6.8.5#6; Yes. 437; C11; clock overflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:25325,Security,access,accessed,25325,"art 2; Unknown. 446; NAD; Use byte instead of character for memcmp, memcpy; N/A. 447; C11; Boolean from complex; Yes. 448; C11; What are the semantics of a # non-directive?; Yes. 449; NAD; What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?; N/A. 450; C11; tmpnam_s clears s[0] when maxsize > RSIZE_MAX; N/A. 451; NAD; Instability of uninitialized automatic variables; Unknown. 452; C11; Effective Type in Loop Invariant; Unknown. 453; C11; Atomic flag type and operations; N/A. 454; NAD; ATOMIC_VAR_INIT (issues 3 and 4); Yes. 455; NAD; ATOMIC_VAR_INIT issue 5; Yes. 456; Dup; Compile time definition of UINTN_C(value); Duplicate of 209. 457; C11; The ctime_s function in Annex K defined incorrectly; N/A. 458; C11; ATOMIC_XXX_LOCK_FREE macros not constant expressions; N/A. 459; C11; atomic_load missing const qualifier; Yes. 460; C11; aligned_alloc underspecified; N/A. 461; NAD; Problems with references to objects in signal handlers; N/A. 462; C11; Clarifying objects accessed in signal handlers; N/A. 463; NAD; Left-shifting into the sign bit; Yes. 464; C11; Clarifying the Behavior of the #line Directive; Yes. 465; C11; Fixing an inconsistency in atomic_is_lock_free; Unknown. 466; NAD; Scope of a for loop control declaration; Yes. 467; C11; Maximum representable finite description vs math; Unknown. 468; C11; strncpy_s clobbers buffer past null; N/A. 469; NAD; Lock ownership vs. thread termination; N/A. 470; C11; mtx_trylock should be allowed to fail spuriously; N/A. 471; C11; Complex math functions cacosh and ctanh; N/A. 472; C11; Introduction to complex arithmetic in 7.3.1p3 wrong due to CMPLX; N/A. 473; C11; ""A range error occurs if x is too large."" is misleading; N/A. 474; NAD; NOTE 1 Clarification for atomic_compare_exchange; N/A. 475; C11; Misleading Atomic library references to atomic types; Yes. 476; C11; volatile semantics for lvalues; Unknown. 477; C11; nan should take a string argument; N/A. 478; NAD; Valid uses of the main function; Yes. 47",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:7538,Testability,assert,assert,7538,"D; Multibyte characters in formats; N/A. 91; NAD; Multibyte encodings; Yes. 92; Dup; Partial initialization of strings; Duplicate of 60. 93; C89; Reservation of identifiers; Yes. 94; NAD; Are constraints on function return the same as assignment?; Yes. 95; NAD; Is initialization as constrained as assignment?; Yes. 96; NAD; Arrays of incomplete types; Yes. 97; Dup; Use of offsetof with an incomplete type; Duplicate of 40. 98; NAD; Pre/post increment/decrement of function or incomplete types; Yes. 99; NAD; ANSI/ISO C Defect report #rfg6; Unknown. 100; Dup; Defect with the return statement; Duplicate of 1. 101; C89; Type qualifiers and ""as if by assignment""; Yes. 102; NAD; Tag redeclaration constraints; Yes. 103; NAD; Formal parameters of incomplete type; Yes. 104; Dup; Incomplete tag types in a parameter list; Duplicate of 84. 105; Dup; Precedence of requirements on compatible types; Duplicate of 17. 106; NAD; When can you dereference a void pointer?; Yes. 107; NAD; Type requirements of the assert macro parameter; N/A. 108; NAD; Can a macro identifier hide a keyword?; Yes. 109; NAD; Are undefined values and undefined behavior the same?; Yes. 110; Dup; Formal parameters having array-of-non-object types; Duplicate of 47. 111; NAD; Conversion of pointer-to-qualified type values to type (void*) values; Yes. 112; NAD; Null pointer constants and relational comparisons; Yes. 113; NAD; Return expressions in functions declared to return qualified void; Yes. 114; NAD; Initialization of multi-dimensional char array objects; Yes. 115; NAD; Member declarators as declarators; Yes. 116; NAD; Implicit unary & applied to register arrays; Yes. 117; NAD; Abstract semantics, sequence points, and expression evaluation; Yes. 118; C89; Completion point for enumerated types; Yes. 119; NAD; Initialization of multi-dimensional array objects; Yes. 120; NAD; Semantics of assignment to (and initialization of) bit-fields; Yes. 121; NAD; Conversions of pointer values to integral types; Yes. 122; Du",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:14351,Testability,log,logb,14351,"7; NAD; strftime %U, %V, and %W conversion specifiers; N/A. 228; C99; wmemcmp declaration in Annex B; N/A. 229; C99; localeconv() *_sep_by_space table entries issues; N/A. 230; C99; Enumerated type rank; Yes. 231; NAD; Semantics of text-line and non-directive; No. 232; C99; Typo in Annex I; N/A. 233; C99; %g, %G precision specification; N/A. 234; C99; Miscellaneous Typos; Yes. 235; C99; ""C"" locale collating behaviour not defined; N/A. 236; NAD; The interpretation of type based aliasing rule when applied to union objects or allocated objects; Unknown. 237; NAD; Declarations using [static]; No. 238; C99; Decriptions of fma() overflow and underflow errors are missing; N/A. 239; C99; Annex F nexttoward description is inconsistent with 7.12.11.4 and F.9.8.3; N/A. 240; C99; lrint, llrint, lround, llround, and ilogb descriptions are not consistent for unrepresentable results; N/A. 241; C99; Make the base standard and Annex F consistent for pow(0, <0); N/A. 242; C99; Make the base standard and Annex F consistent for logb(0); N/A. 243; C99; Make the base standard and Annex F consistent for fmod(), remainder(), and remquo() for a zero divisor; N/A. 244; C99; tgamma(zero or negative integer) should be considered a pole error; N/A. 245; C99; Missing paragraph numbers; Yes. 246; NAD; Completion of declarators; Yes. 247; C99; Are values a form of behaviour?; Yes. 248; C99; Limits are required for optional types; Yes. 249; Dup; Lacuna applying C89:TC1 to C99; Duplicate of 9. 250; C99; Non-directives within macro arguments; Yes. 251; C99; Are struct fred and union fred the same type?; Yes. 252; NAD; Incomplete argument types when calling non-prototyped functions; Yes. 253; NAD; ""overriding"" in designated initializers; Yes. 254; NAD; mbtowc and partial characters; N/A. 255; NAD; Non-prototyped function calls and argument mismatches; Yes. 256; NAD; Multiple inclusion of headers; N/A. 257; NAD; Common initial sequences and related issues with unions; Unknown. 258; NAD; Ordering of ""de",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:24618,Usability,clear,clears,24618,"verflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C11; Issues with the definition of ""full expression""; Unknown. 440; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1; Unknown. 441; C11; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 2; N/A. 442; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 3; Unknown. 443; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 4; Unknown. 444; C11; Issues with alignment in C11, part 1. Partial; Clang rejects use of an alignment specifier in a compound literal expression.; . 445; C11; Issues with alignment in C11, part 2; Unknown. 446; NAD; Use byte instead of character for memcmp, memcpy; N/A. 447; C11; Boolean from complex; Yes. 448; C11; What are the semantics of a # non-directive?; Yes. 449; NAD; What is the value of TSS_DTOR_ITERATIONS for implementations with no maximum?; N/A. 450; C11; tmpnam_s clears s[0] when maxsize > RSIZE_MAX; N/A. 451; NAD; Instability of uninitialized automatic variables; Unknown. 452; C11; Effective Type in Loop Invariant; Unknown. 453; C11; Atomic flag type and operations; N/A. 454; NAD; ATOMIC_VAR_INIT (issues 3 and 4); Yes. 455; NAD; ATOMIC_VAR_INIT issue 5; Yes. 456; Dup; Compile time definition of UINTN_C(value); Duplicate of 209. 457; C11; The ctime_s function in Annex K defined incorrectly; N/A. 458; C11; ATOMIC_XXX_LOCK_FREE macros not constant expressions; N/A. 459; C11; atomic_load missing const qualifier; Yes. 460; C11; aligned_alloc underspecified; N/A. 461; NAD; Problems with references to objects in signal handlers; N/A. 462; C11; Clarifying objects accessed in signal handlers; N/A. 463; NAD; Left-shifting into the sign bit; Yes. 464; C11; Clarifying the Behavior of the #line Directive; Yes. 465; C11; Fixing an inconsistency in atomic_is_lock_free; Unknown. 466; NAD; Scope of a for loop control declaration; Yes. 467; C11; Maximum representable fini",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_dr_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:664,Availability,avail,available,664,". Clang - C Programming Language Status. C Support in Clang. Clang implements the following published and upcoming ISO C standards:. Language Standard; Flag; Available in Clang?. C89; -std=c89; Yes. C99; -std=c99; Almost certainly. C11; -std=c11; Probably. C17; -std=c17; Maybe?. C23; -std=c23; Partial. The implementation status for C99, C11, C17, and C23 are currently under; investigation. Any proposal whose status in Clang is currently unknown; will be marked in magenta.; The Clang community is continually striving to improve C standards; compliance between releases by submitting and tracking; C Defect Reports and implementing resolutions as; they become available.; The LLVM bug tracker uses; the ""c"", ""c99"", ""c11"", ""c17"", and ""c23"" labels to track known bugs with Clang's language; conformance.; C89 implementation status; Clang implements all of the ISO 9899:1990 (C89) standard.; You can use Clang in C89 mode with the -std=c89 or -std=c90 options.; C99 implementation status; Clang implements a significant portion of the ISO 9899:1999 (C99) standard, but the status of individual proposals is still under investigation.; Note, the list of C99 features comes from the C99 committee draft. Not all C99 documents are publicly available, so the documents referenced in this section may be inaccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown.",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:1238,Availability,avail,available,1238,"17; Maybe?. C23; -std=c23; Partial. The implementation status for C99, C11, C17, and C23 are currently under; investigation. Any proposal whose status in Clang is currently unknown; will be marked in magenta.; The Clang community is continually striving to improve C standards; compliance between releases by submitting and tracking; C Defect Reports and implementing resolutions as; they become available.; The LLVM bug tracker uses; the ""c"", ""c99"", ""c11"", ""c17"", and ""c23"" labels to track known bugs with Clang's language; conformance.; C89 implementation status; Clang implements all of the ISO 9899:1990 (C89) standard.; You can use Clang in C89 mode with the -std=c89 or -std=c90 options.; C99 implementation status; Clang implements a significant portion of the ISO 9899:1999 (C99) standard, but the status of individual proposals is still under investigation.; Note, the list of C99 features comes from the C99 committee draft. Not all C99 documents are publicly available, so the documents referenced in this section may be inaccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Ye",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:2283,Availability,reliab,reliable,2283,"naccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintmax_t; N736; Yes. mixed declarations and code; N740; Yes. new block scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; U",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:6766,Availability,avail,available,6766," Supporting the 'noreturn' property in C1x; N1478; Clang 3.3. Updates to C++ memory model based on formalization; N1480; Unknown. Explicit initializers for atomics; N1482; Unknown. Atomics proposal (minus ternary op); N1485; Yes. UTF-8 string literals; N1488; Clang 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for extended identifier characters for C and C++; N1518; Unknown. Atomic C1x/C++0x compatibility refinements (1st part only); N1526; Yes. Atomic bitfields implementation defined; N1530; Yes. Small fix for the effect of alignment on struct/union type compatibility; N1532; Yes. Synthesis re _Atomic; N1537; Unknown. Clarification for wide evaluation; N1531; Unknown. C17 implementation status; There are no major changes in this edition, only technical corrections and clarifications that are tracked by Defect Report.; You can use Clang in C17 mode with the -std=c17 or -std=c18 options (available in Clang 6 and later).; C23 implementation status; Clang has support for some of the features of the C standard following C17, informally referred to as C23.; You can use Clang in C23 mode with the -std=c23 option (available in Clang 18 and later) or with the; -std=c2x option (available in Clang 9 and later). List of features and minimum Clang version with support. Language Feature; C23 Proposal; Available in Clang?. Evaluation formats; N2186; Unknown. Clarifying the restrict Keyword v2; N2660; Unknown. Harmonizing static_assert with C++; N2665; Clang 9. nodiscard attribute; N2267; Clang 9. maybe_unused attribute; N2270; Clang 9. TS 18661 Integration. ; N2314; Unknown. ; N2341; Unknown. ; N2401; Unknown. ; N2359; No. ; N2546; Unknown. N2580; Unknown. ; N2640; Unknown. ; N2755; Unknown. Preprocessor line numbers unspecified; N2322. Partial; The line number associated with a macro invocation is not the line; number of the first character of the macro name in ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:6991,Availability,avail,available,6991,"ng 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for extended identifier characters for C and C++; N1518; Unknown. Atomic C1x/C++0x compatibility refinements (1st part only); N1526; Yes. Atomic bitfields implementation defined; N1530; Yes. Small fix for the effect of alignment on struct/union type compatibility; N1532; Yes. Synthesis re _Atomic; N1537; Unknown. Clarification for wide evaluation; N1531; Unknown. C17 implementation status; There are no major changes in this edition, only technical corrections and clarifications that are tracked by Defect Report.; You can use Clang in C17 mode with the -std=c17 or -std=c18 options (available in Clang 6 and later).; C23 implementation status; Clang has support for some of the features of the C standard following C17, informally referred to as C23.; You can use Clang in C23 mode with the -std=c23 option (available in Clang 18 and later) or with the; -std=c2x option (available in Clang 9 and later). List of features and minimum Clang version with support. Language Feature; C23 Proposal; Available in Clang?. Evaluation formats; N2186; Unknown. Clarifying the restrict Keyword v2; N2660; Unknown. Harmonizing static_assert with C++; N2665; Clang 9. nodiscard attribute; N2267; Clang 9. maybe_unused attribute; N2270; Clang 9. TS 18661 Integration. ; N2314; Unknown. ; N2341; Unknown. ; N2401; Unknown. ; N2359; No. ; N2546; Unknown. N2580; Unknown. ; N2640; Unknown. ; N2755; Unknown. Preprocessor line numbers unspecified; N2322. Partial; The line number associated with a macro invocation is not the line; number of the first character of the macro name in the invocation.; Additionally, Clang may not associate the line number of a pp-directive; with the first # token. As these are recommended practices; and not normative requirements, Clang's behavior is still conforming.; . deprecated attribute; N2334; Clang 9. At",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:7054,Availability,avail,available,7054,"ng 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for extended identifier characters for C and C++; N1518; Unknown. Atomic C1x/C++0x compatibility refinements (1st part only); N1526; Yes. Atomic bitfields implementation defined; N1530; Yes. Small fix for the effect of alignment on struct/union type compatibility; N1532; Yes. Synthesis re _Atomic; N1537; Unknown. Clarification for wide evaluation; N1531; Unknown. C17 implementation status; There are no major changes in this edition, only technical corrections and clarifications that are tracked by Defect Report.; You can use Clang in C17 mode with the -std=c17 or -std=c18 options (available in Clang 6 and later).; C23 implementation status; Clang has support for some of the features of the C standard following C17, informally referred to as C23.; You can use Clang in C23 mode with the -std=c23 option (available in Clang 18 and later) or with the; -std=c2x option (available in Clang 9 and later). List of features and minimum Clang version with support. Language Feature; C23 Proposal; Available in Clang?. Evaluation formats; N2186; Unknown. Clarifying the restrict Keyword v2; N2660; Unknown. Harmonizing static_assert with C++; N2665; Clang 9. nodiscard attribute; N2267; Clang 9. maybe_unused attribute; N2270; Clang 9. TS 18661 Integration. ; N2314; Unknown. ; N2341; Unknown. ; N2401; Unknown. ; N2359; No. ; N2546; Unknown. N2580; Unknown. ; N2640; Unknown. ; N2755; Unknown. Preprocessor line numbers unspecified; N2322. Partial; The line number associated with a macro invocation is not the line; number of the first character of the macro name in the invocation.; Additionally, Clang may not associate the line number of a pp-directive; with the first # token. As these are recommended practices; and not normative requirements, Clang's behavior is still conforming.; . deprecated attribute; N2334; Clang 9. At",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:565,Deployability,release,releases,565,". Clang - C Programming Language Status. C Support in Clang. Clang implements the following published and upcoming ISO C standards:. Language Standard; Flag; Available in Clang?. C89; -std=c89; Yes. C99; -std=c99; Almost certainly. C11; -std=c11; Probably. C17; -std=c17; Maybe?. C23; -std=c23; Partial. The implementation status for C99, C11, C17, and C23 are currently under; investigation. Any proposal whose status in Clang is currently unknown; will be marked in magenta.; The Clang community is continually striving to improve C standards; compliance between releases by submitting and tracking; C Defect Reports and implementing resolutions as; they become available.; The LLVM bug tracker uses; the ""c"", ""c99"", ""c11"", ""c17"", and ""c23"" labels to track known bugs with Clang's language; conformance.; C89 implementation status; Clang implements all of the ISO 9899:1990 (C89) standard.; You can use Clang in C89 mode with the -std=c89 or -std=c90 options.; C99 implementation status; Clang implements a significant portion of the ISO 9899:1999 (C99) standard, but the status of individual proposals is still under investigation.; Note, the list of C99 features comes from the C99 committee draft. Not all C99 documents are publicly available, so the documents referenced in this section may be inaccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown.",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:8441,Deployability,update,update,8441," N2401; Unknown. ; N2359; No. ; N2546; Unknown. N2580; Unknown. ; N2640; Unknown. ; N2755; Unknown. Preprocessor line numbers unspecified; N2322. Partial; The line number associated with a macro invocation is not the line; number of the first character of the macro name in the invocation.; Additionally, Clang may not associate the line number of a pp-directive; with the first # token. As these are recommended practices; and not normative requirements, Clang's behavior is still conforming.; . deprecated attribute; N2334; Clang 9. Attributes. ; N2335; Clang 9. ; N2554; Clang 9. Defining new types in offsetof; N2350; Yes. fallthrough attribute; N2408; Clang 9. Two's complement sign representation; N2412; Clang 14. Adding the u8 character prefix; N2418; Clang 15. Remove support for function definitions with identifier lists; N2432; Clang 15. *_IS_IEC_60559 feature test macros; N2379; Unknown. Floating-point negation and conversion; N2416; Unknown. Annex F.8 update for implementation extensions and rounding; N2384; Unknown. _Bool definitions for true and false; N2393; Subsumed by N2935. [[nodiscard(""should have a reason"")]]; N2448; Clang 10. Allowing unnamed parameters in function definitions; N2480; Clang 11. Free positioning of labels inside compound statements; N2508; Clang 18. Clarification request for C17 example of undefined behavior; N2517; No. Querying attribute support; N2553; Clang 9. Binary literals; N2549; Clang 9. Allow duplicate attributes; N2557; Clang 13. Character encoding of diagnostic text; N2563; Yes. What we think we reserve; N2572; Partial. Remove mixed wide string literal concatenation; N2594; Clang 9. Update to IEC 60559:2020; N2600; Unknown. Compatibility of Pointers to Arrays with Qualifiers; N2607. Partial; Much of the proposal is implemented, but Clang lacks pedantic diagnostics; in C17 and earlier regarding use of incompatible pointer types as an; extension. Further, Clang does not properly compute the correct result; type for the ?: operator",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:10581,Deployability,update,update,10581,"ier and its argument; N2562; Clang 16. String functions for freestanding implementations; N2524; No. Digit separators; N2626; Clang 13. Missing +(x) in table; N2641; Yes. Add support for preprocessing directives elifdef and elifndef; N2645; Clang 13. [[maybe_unused]] for labels; N2662; Clang 16. Zeros compare equal; N2670; Yes. Negative values; N2671; Yes. 5.2.4.2.2	cleanup; N2672; Yes. Towards Integer Safety; N2683; Clang 18. Adding Fundamental Type for N-bit Integers. ; N2763; Clang 15. ; N2775; Clang 15. ; N2969; Clang 15. ; N3035; Clang 15. #warning directive; N2686; Yes. Sterile characters; N2686; Yes. Numerically equal; N2716; Yes. char16_t & char32_t string literals shall be UTF-16 & UTF-32; N2728; Yes. IEC 60559 binding; N2749; Unknown. __has_include for C; N2799; Yes. Annex F overflow and underflow; N2747; Yes. Remove UB from Incomplete Types in Function Parameters; N2770; Yes. Variably-modified types; N2778; Yes. Types do not have types; N2781; Yes. 5.2.4.2.2	cleanup (N2672 update); N2806; Yes. Allow 16-bit ptrdiff_t; N2808; Yes. Proposal to update CFP freestanding requirements; N2823; Unknown. Types and sizes; N2838; Yes. Clarifying integer terms; N2837; Yes. Clarification for max exponent macros; N2843; Unknown. Clarification about expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promo",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:10650,Deployability,update,update,10650,"; N2524; No. Digit separators; N2626; Clang 13. Missing +(x) in table; N2641; Yes. Add support for preprocessing directives elifdef and elifndef; N2645; Clang 13. [[maybe_unused]] for labels; N2662; Clang 16. Zeros compare equal; N2670; Yes. Negative values; N2671; Yes. 5.2.4.2.2	cleanup; N2672; Yes. Towards Integer Safety; N2683; Clang 18. Adding Fundamental Type for N-bit Integers. ; N2763; Clang 15. ; N2775; Clang 15. ; N2969; Clang 15. ; N3035; Clang 15. #warning directive; N2686; Yes. Sterile characters; N2686; Yes. Numerically equal; N2716; Yes. char16_t & char32_t string literals shall be UTF-16 & UTF-32; N2728; Yes. IEC 60559 binding; N2749; Unknown. __has_include for C; N2799; Yes. Annex F overflow and underflow; N2747; Yes. Remove UB from Incomplete Types in Function Parameters; N2770; Yes. Variably-modified types; N2778; Yes. Types do not have types; N2781; Yes. 5.2.4.2.2	cleanup (N2672 update); N2806; Yes. Allow 16-bit ptrdiff_t; N2808; Yes. Proposal to update CFP freestanding requirements; N2823; Unknown. Types and sizes; N2838; Yes. Clarifying integer terms; N2837; Yes. Clarification for max exponent macros; N2843; Unknown. Clarification about expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:11733,Deployability,update,update,11733,"Yes. Clarifying integer terms; N2837; Yes. Clarification for max exponent macros; N2843; Unknown. Clarification about expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal/Equivalent; N2847; Yes. 5.2.4.2.2 Cleanup, Again Again (N2806 update); N2879; Yes. char8_t: A type for UTF-8 characters and strings; N2653; No. Clarification for max exponent macros-update; N2882; Unknown. Consistent, Warningless, and Intuitive Initialization with {}. ; N2900; Clang 17. ; N3011; Clang 17. Not-so-magic: typeof. ; N2927; Clang 16. ; N2930; Clang 16. Type annex tgmath narrowing macros with integer args v2; N2931; Unknown. Revise spelling of keywords v7; N2934; Clang 17. Make false and true first-class language features v8; N2935; Clang 15. Properly define blocks as part of the grammar v3; N2937; Yes. Annex X (replacing Annex H) for IEC 60559 interchange; N2601; No. Indeterminate Values and Trap Representations; N2861; Yes. Remove ATOMIC_VAR_INIT v2; N2886; Clang 17. Require exact-width integer type interfaces v2; N2888; Yes. Wording Change for Variably-Modified Types; N2992; Yes. Identifier syntax fixes; N2939; Clang 15. Remove trigraphs??!; N2940; Clang 18. Improved normal enumerations; N3029; Unknown. Relax requirements for v",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:11853,Deployability,update,update,11853," expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal/Equivalent; N2847; Yes. 5.2.4.2.2 Cleanup, Again Again (N2806 update); N2879; Yes. char8_t: A type for UTF-8 characters and strings; N2653; No. Clarification for max exponent macros-update; N2882; Unknown. Consistent, Warningless, and Intuitive Initialization with {}. ; N2900; Clang 17. ; N3011; Clang 17. Not-so-magic: typeof. ; N2927; Clang 16. ; N2930; Clang 16. Type annex tgmath narrowing macros with integer args v2; N2931; Unknown. Revise spelling of keywords v7; N2934; Clang 17. Make false and true first-class language features v8; N2935; Clang 15. Properly define blocks as part of the grammar v3; N2937; Yes. Annex X (replacing Annex H) for IEC 60559 interchange; N2601; No. Indeterminate Values and Trap Representations; N2861; Yes. Remove ATOMIC_VAR_INIT v2; N2886; Clang 17. Require exact-width integer type interfaces v2; N2888; Yes. Wording Change for Variably-Modified Types; N2992; Yes. Identifier syntax fixes; N2939; Clang 15. Remove trigraphs??!; N2940; Clang 18. Improved normal enumerations; N3029; Unknown. Relax requirements for va_start; N2975; Clang 16. Enhanced enumerations; N3030; Unknown. Freestanding C and IEC 60559 conformance scope reduc",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:10975,Integrability,interface,interfaces,10975,"s. Towards Integer Safety; N2683; Clang 18. Adding Fundamental Type for N-bit Integers. ; N2763; Clang 15. ; N2775; Clang 15. ; N2969; Clang 15. ; N3035; Clang 15. #warning directive; N2686; Yes. Sterile characters; N2686; Yes. Numerically equal; N2716; Yes. char16_t & char32_t string literals shall be UTF-16 & UTF-32; N2728; Yes. IEC 60559 binding; N2749; Unknown. __has_include for C; N2799; Yes. Annex F overflow and underflow; N2747; Yes. Remove UB from Incomplete Types in Function Parameters; N2770; Yes. Variably-modified types; N2778; Yes. Types do not have types; N2781; Yes. 5.2.4.2.2	cleanup (N2672 update); N2806; Yes. Allow 16-bit ptrdiff_t; N2808; Yes. Proposal to update CFP freestanding requirements; N2823; Unknown. Types and sizes; N2838; Yes. Clarifying integer terms; N2837; Yes. Clarification for max exponent macros; N2843; Unknown. Clarification about expression transformations; N2846; Unknown. Contradiction about INFINITY macro; N2848; Unknown. Require exact-width integer type interfaces; N2872; Yes. @, $, and ‘ in the source/execution character set; N2701; Yes. Quantum exponent of NaN (version 2); N2754; Unknown. The noreturn attribute; N2764; Clang 15. *_HAS_SUBNORM==0 implies what?; N2797; Yes. Disambiguate the storage class of some compound literals; N2819; Unknown. Add annotations for unreachable control flow v2; N2826; Clang 17. Unicode Sequences More Than 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal/Equivalent; N2847; Yes. 5.2.4.2.2 Cleanup, Again Again (N2806 update); N2879; Yes. char8_t: A type for UTF-8 characters and strings; N2653; No. Clarification for max exponent macros-update; N2882; Unknown. Consistent, Warningless, and Intuitive Initialization with {}. ; N2900; Clang 17. ; N3011; Cl",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:12495,Integrability,interface,interfaces,12495,"an 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal/Equivalent; N2847; Yes. 5.2.4.2.2 Cleanup, Again Again (N2806 update); N2879; Yes. char8_t: A type for UTF-8 characters and strings; N2653; No. Clarification for max exponent macros-update; N2882; Unknown. Consistent, Warningless, and Intuitive Initialization with {}. ; N2900; Clang 17. ; N3011; Clang 17. Not-so-magic: typeof. ; N2927; Clang 16. ; N2930; Clang 16. Type annex tgmath narrowing macros with integer args v2; N2931; Unknown. Revise spelling of keywords v7; N2934; Clang 17. Make false and true first-class language features v8; N2935; Clang 15. Properly define blocks as part of the grammar v3; N2937; Yes. Annex X (replacing Annex H) for IEC 60559 interchange; N2601; No. Indeterminate Values and Trap Representations; N2861; Yes. Remove ATOMIC_VAR_INIT v2; N2886; Clang 17. Require exact-width integer type interfaces v2; N2888; Yes. Wording Change for Variably-Modified Types; N2992; Yes. Identifier syntax fixes; N2939; Clang 15. Remove trigraphs??!; N2940; Clang 18. Improved normal enumerations; N3029; Unknown. Relax requirements for va_start; N2975; Clang 16. Enhanced enumerations; N3030; Unknown. Freestanding C and IEC 60559 conformance scope reduction; N2951; Unknown. Unsequenced functions; N2956; No. Comma ommission and deletion (__VA_OPT__); N3033; Unknown. Underspecified object definitions; N3006; No. Type inference for object declarations; N3007; Clang 18. constexpr for object definitions; N3018; No. Introduce storage class specifiers for compound literals; N3038; No. Identifier primary expressions; N3034; Yes. Introduce the nullptr constant; N3042; Clang 17. Memory layout of unions; N2929; Yes. Improved tag compatibility; N3037; No. #embed; N3017; No. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:1684,Modifiability,variab,variable,1684,"s; the ""c"", ""c99"", ""c11"", ""c17"", and ""c23"" labels to track known bugs with Clang's language; conformance.; C89 implementation status; Clang implements all of the ISO 9899:1990 (C89) standard.; You can use Clang in C89 mode with the -std=c89 or -std=c90 options.; C99 implementation status; Clang implements a significant portion of the ISO 9899:1999 (C99) standard, but the status of individual proposals is still under investigation.; Note, the list of C99 features comes from the C99 committee draft. Not all C99 documents are publicly available, so the documents referenced in this section may be inaccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocesso",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:1719,Modifiability,flexible,flexible,1719,"""c23"" labels to track known bugs with Clang's language; conformance.; C89 implementation status; Clang implements all of the ISO 9899:1990 (C89) standard.; You can use Clang in C89 mode with the -std=c89 or -std=c90 options.; C99 implementation status; Clang implements a significant portion of the ISO 9899:1999 (C99) standard, but the status of individual proposals is still under investigation.; Note, the list of C99 features comes from the C99 committee draft. Not all C99 documents are publicly available, so the documents referenced in this section may be inaccurate, unknown, or not linked. You can use Clang in C99 mode with the -std=c99 option. List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintma",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:2374,Modifiability,extend,extended,2374, List of features and minimum Clang version with support. Language Feature; C99 Proposal; Available in Clang?. restricted character set support via digraphs and <iso646.h>; Unknown; Unknown. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintmax_t; N736; Yes. mixed declarations and code; N740; Yes. new block scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; Unknown. additional predefined macro names; Unknown; Unknown. _Pragma preprocessing operator,MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:2550,Modifiability,extend,extended,2550,wn. more precise aliasing rules via effective type; Unknown; Unknown. restricted pointers; N448; Unknown. variable length arrays; N683; Yes. flexible array members; Unknown; Yes. static and type qualifiers in parameter array declarators; Unknown; Yes. more precise aliasing rules via effective type; Unknown; Unknown. complex and imaginary support in <complex.h>. N620; Unknown. N638; Unknown. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintmax_t; N736; Yes. mixed declarations and code; N740; Yes. new block scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; Unknown. additional predefined macro names; Unknown; Unknown. _Pragma preprocessing operator; N634. Yes. standard pragmas. N631; Unknown. N696; Unknown. __func__ predefined identifier; N611; Yes. va_copy macro; N671; Yes. LIA compatibility annex; N792; No. remove deprecation of ,MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:2958,Modifiability,variab,variable,2958,. N657; Unknown. N694; Unknown. N809; Unknown. type-generic math macros in <tgmath.h>; N693; Yes. the long long int type; N601; Yes. increase minimum translation limits; N590; Unknown. additional floating-point characteristics in <float.h>; Unknown; Unknown. remove implicit int. N635; Yes. N692; Yes. N722; Yes. reliable integer division; N617; Yes. universal character names (\u and \U); Unknown; Yes. extended identifiers; N717; Unknown. hexadecimal floating-point constants; N308. Yes. compound literals; N716; Yes. designated initializers; N494; Yes. // comments; N644; Yes. extended integer types and library functions in <inttypes.h> and <stdint.h>; Unknown. Yes. remove implicit function declaration; N636; Yes. preprocessor arithmetic done in intmax_t/uintmax_t; N736; Yes. mixed declarations and code; N740; Yes. new block scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; Unknown. additional predefined macro names; Unknown; Unknown. _Pragma preprocessing operator; N634. Yes. standard pragmas. N631; Unknown. N696; Unknown. __func__ predefined identifier; N611; Yes. va_copy macro; N671; Yes. LIA compatibility annex; N792; No. remove deprecation of aliased array parameters; Unknown; Unknown. conversion of array to pointer not limited to lvalues; Unknown; Unknown. relaxed constraints on aggregate and union initialization; Unknown; Unknown. relaxed restrictions on portable header names; N772; Unknown. return without an expression not permitted in function that returns a value; Unknown; Yes. C11 implementation status; Clang implements a,MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:3797,Modifiability,portab,portable,3797,"scopes for selection and iteration statements; Unknown; Unknown. integer constant type rules; N629; Yes. integer promotion rules; N725; Yes. macros with a variable number of arguments; N707; Yes. IEC 60559 support; Unknown; Unknown. trailing comma allowed in enum declaration; Unknown; Yes. inline functions; N741; Yes. boolean type in <stdbool.h>; N815; Yes. idempotent type qualifiers; N505; Yes. empty macro arguments; N570; Unknown. new structure type compatibility (tag compatibility); N522; Unknown. additional predefined macro names; Unknown; Unknown. _Pragma preprocessing operator; N634. Yes. standard pragmas. N631; Unknown. N696; Unknown. __func__ predefined identifier; N611; Yes. va_copy macro; N671; Yes. LIA compatibility annex; N792; No. remove deprecation of aliased array parameters; Unknown; Unknown. conversion of array to pointer not limited to lvalues; Unknown; Unknown. relaxed constraints on aggregate and union initialization; Unknown; Unknown. relaxed restrictions on portable header names; N772; Unknown. return without an expression not permitted in function that returns a value; Unknown; Yes. C11 implementation status; Clang implements a significant portion of the ISO 9899:2011 (C11) standard, but the status of individual proposals is still under investigation.; You can use Clang in C11 mode with the -std=c11 option (use -std=c1x in Clang 3.0 and earlier). List of features and minimum Clang version with support. Language Feature; C11 Proposal; Available in Clang?. A finer-grained specification for sequencing; N1252; Unknown. Clarification of expressions; N1282; Unknown. Extending the lifetime of temporary objects (factored approach); N1285; Unknown. Requiring signed char to have no padding bits; N1310; Unknown. Initializing static or external variables; N1311; Yes. Conversion between pointers and floating types; N1316; Yes. Adding TR 19769 to the C Standard Library; N1326; Clang 3.3. Static assertions; N1330; Yes. Parallel memory sequencing model propos",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:4589,Modifiability,variab,variables,4589,"sed array parameters; Unknown; Unknown. conversion of array to pointer not limited to lvalues; Unknown; Unknown. relaxed constraints on aggregate and union initialization; Unknown; Unknown. relaxed restrictions on portable header names; N772; Unknown. return without an expression not permitted in function that returns a value; Unknown; Yes. C11 implementation status; Clang implements a significant portion of the ISO 9899:2011 (C11) standard, but the status of individual proposals is still under investigation.; You can use Clang in C11 mode with the -std=c11 option (use -std=c1x in Clang 3.0 and earlier). List of features and minimum Clang version with support. Language Feature; C11 Proposal; Available in Clang?. A finer-grained specification for sequencing; N1252; Unknown. Clarification of expressions; N1282; Unknown. Extending the lifetime of temporary objects (factored approach); N1285; Unknown. Requiring signed char to have no padding bits; N1310; Unknown. Initializing static or external variables; N1311; Yes. Conversion between pointers and floating types; N1316; Yes. Adding TR 19769 to the C Standard Library; N1326; Clang 3.3. Static assertions; N1330; Yes. Parallel memory sequencing model proposal; N1349; Unknown. Analyzability (#1, #4 - conditionally normative); N1350; Unknown. FLT_EVAL_METHOD issues (first change only); N1353; Unknown. _Bool bit-fields; N1356; Yes. Technical corrigendum for C1X; N1359; Unknown. Benign typedef redefinition; N1360; Clang 3.1. Thread-local storage; N1364; Clang 3.3. Constant expressions; N1365; Unknown. Contractions and expression evaluation methods; N1367; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generi",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:6182,Modifiability,extend,extended,6182,"67; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generic macro facility; N1441; Yes. Dependency ordering for C memory model; N1444; Unknown. Subsetting the standard; N1460; Yes. Assumed types in F.9.2; N1468; Unknown. Supporting the 'noreturn' property in C1x; N1478; Clang 3.3. Updates to C++ memory model based on formalization; N1480; Unknown. Explicit initializers for atomics; N1482; Unknown. Atomics proposal (minus ternary op); N1485; Yes. UTF-8 string literals; N1488; Clang 3.3. Optimizing away infinite loops; N1509; Yes. Conditional normative status for Annex G; N1514; Unknown. Creation of complex value; N1464; Unknown. Recommendations for extended identifier characters for C and C++; N1518; Unknown. Atomic C1x/C++0x compatibility refinements (1st part only); N1526; Yes. Atomic bitfields implementation defined; N1530; Yes. Small fix for the effect of alignment on struct/union type compatibility; N1532; Yes. Synthesis re _Atomic; N1537; Unknown. Clarification for wide evaluation; N1531; Unknown. C17 implementation status; There are no major changes in this edition, only technical corrections and clarifications that are tracked by Defect Report.; You can use Clang in C17 mode with the -std=c17 or -std=c18 options (available in Clang 6 and later).; C23 implementation status; Clang has support for some of the features of the C standard following C17, informally referred to as C23.; You can use Clang in C23 mode with the -std=c23 option (available in Clang 18 and later) or with the; -std=c2x option (available in Clang 9 and later). List of features and minimum Clang version with support. Language Feature; C23 Proposal; Available in Clang?. Evalu",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:4740,Testability,assert,assertions,4740,"zation; Unknown; Unknown. relaxed restrictions on portable header names; N772; Unknown. return without an expression not permitted in function that returns a value; Unknown; Yes. C11 implementation status; Clang implements a significant portion of the ISO 9899:2011 (C11) standard, but the status of individual proposals is still under investigation.; You can use Clang in C11 mode with the -std=c11 option (use -std=c1x in Clang 3.0 and earlier). List of features and minimum Clang version with support. Language Feature; C11 Proposal; Available in Clang?. A finer-grained specification for sequencing; N1252; Unknown. Clarification of expressions; N1282; Unknown. Extending the lifetime of temporary objects (factored approach); N1285; Unknown. Requiring signed char to have no padding bits; N1310; Unknown. Initializing static or external variables; N1311; Yes. Conversion between pointers and floating types; N1316; Yes. Adding TR 19769 to the C Standard Library; N1326; Clang 3.3. Static assertions; N1330; Yes. Parallel memory sequencing model proposal; N1349; Unknown. Analyzability (#1, #4 - conditionally normative); N1350; Unknown. FLT_EVAL_METHOD issues (first change only); N1353; Unknown. _Bool bit-fields; N1356; Yes. Technical corrigendum for C1X; N1359; Unknown. Benign typedef redefinition; N1360; Clang 3.1. Thread-local storage; N1364; Clang 3.3. Constant expressions; N1365; Unknown. Contractions and expression evaluation methods; N1367; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generic macro facility; N1441; Yes. Dependency ordering for C memory model; N1444; Unknown. Subsetting the standard; N1460; Yes. Assumed types in F.9.2; N1468; Unknown. S",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:8346,Testability,test,test,8346,"ttribute; N2267; Clang 9. maybe_unused attribute; N2270; Clang 9. TS 18661 Integration. ; N2314; Unknown. ; N2341; Unknown. ; N2401; Unknown. ; N2359; No. ; N2546; Unknown. N2580; Unknown. ; N2640; Unknown. ; N2755; Unknown. Preprocessor line numbers unspecified; N2322. Partial; The line number associated with a macro invocation is not the line; number of the first character of the macro name in the invocation.; Additionally, Clang may not associate the line number of a pp-directive; with the first # token. As these are recommended practices; and not normative requirements, Clang's behavior is still conforming.; . deprecated attribute; N2334; Clang 9. Attributes. ; N2335; Clang 9. ; N2554; Clang 9. Defining new types in offsetof; N2350; Yes. fallthrough attribute; N2408; Clang 9. Two's complement sign representation; N2412; Clang 14. Adding the u8 character prefix; N2418; Clang 15. Remove support for function definitions with identifier lists; N2432; Clang 15. *_IS_IEC_60559 feature test macros; N2379; Unknown. Floating-point negation and conversion; N2416; Unknown. Annex F.8 update for implementation extensions and rounding; N2384; Unknown. _Bool definitions for true and false; N2393; Subsumed by N2935. [[nodiscard(""should have a reason"")]]; N2448; Clang 10. Allowing unnamed parameters in function definitions; N2480; Clang 11. Free positioning of labels inside compound statements; N2508; Clang 18. Clarification request for C17 example of undefined behavior; N2517; No. Querying attribute support; N2553; Clang 9. Binary literals; N2549; Clang 9. Allow duplicate attributes; N2557; Clang 13. Character encoding of diagnostic text; N2563; Yes. What we think we reserve; N2572; Partial. Remove mixed wide string literal concatenation; N2594; Clang 9. Update to IEC 60559:2020; N2600; Unknown. Compatibility of Pointers to Arrays with Qualifiers; N2607. Partial; Much of the proposal is implemented, but Clang lacks pedantic diagnostics; in C17 and earlier regarding use of incom",MatchSource.DOCS,interpreter/llvm-project/clang/www/c_status.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:208,Availability,down,down,208,". Clang - Expressive Diagnostics. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this. This section; talks about the experience provided by the command line compiler, contrasting; Clang output to GCC 4.9's output in some cases. Column Numbers and Caret Diagnostics; First, all diagnostics produced by clang include full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related informatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:241,Availability,error,error,241,". Clang - Expressive Diagnostics. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this. This section; talks about the experience provided by the command line compiler, contrasting; Clang output to GCC 4.9's output in some cases. Column Numbers and Caret Diagnostics; First, all diagnostics produced by clang include full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related informatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:765,Availability,error,error,765,". Clang - Expressive Diagnostics. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this. This section; talks about the experience provided by the command line compiler, contrasting; Clang output to GCC 4.9's output in some cases. Column Numbers and Caret Diagnostics; First, all diagnostics produced by clang include full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related informatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:2168,Availability,error,error,2168,"haracter occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related information. In the following somewhat; nonsensical example you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error. Because clang prints a; point, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about.; Range information is very useful for; cases involving precedence issues and many other cases. $ gcc-4.9 -fsyntax-only t.c; t.c: In function 'int f(int, int)':; t.c:7:39: error: invalid operands to binary + (have 'int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ^; $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Precision in Wording; A detail is that we have tried really hard to make the diagnostics that come; out of clang contain exactly the pertinent information about what is wron",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:2572,Availability,error,error,2572,"character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related information. In the following somewhat; nonsensical example you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error. Because clang prints a; point, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about.; Range information is very useful for; cases involving precedence issues and many other cases. $ gcc-4.9 -fsyntax-only t.c; t.c: In function 'int f(int, int)':; t.c:7:39: error: invalid operands to binary + (have 'int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ^; $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Precision in Wording; A detail is that we have tried really hard to make the diagnostics that come; out of clang contain exactly the pertinent information about what is wrong and; why. In the example above, we tell you what the inferred types are for; the left and right hand sides, and we don't repeat what is obvious from the; point (e.g., that this is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to u",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:2750,Availability,error,error,2750,"ing for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related information. In the following somewhat; nonsensical example you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error. Because clang prints a; point, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about.; Range information is very useful for; cases involving precedence issues and many other cases. $ gcc-4.9 -fsyntax-only t.c; t.c: In function 'int f(int, int)':; t.c:7:39: error: invalid operands to binary + (have 'int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ^; $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Precision in Wording; A detail is that we have tried really hard to make the diagnostics that come; out of clang contain exactly the pertinent information about what is wrong and; why. In the example above, we tell you what the inferred types are for; the left and right hand sides, and we don't repeat what is obvious from the; point (e.g., that this is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:3691,Availability,error,error,3691,"fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Precision in Wording; A detail is that we have tried really hard to make the diagnostics that come; out of clang contain exactly the pertinent information about what is wrong and; why. In the example above, we tell you what the inferred types are for; the left and right hand sides, and we don't repeat what is obvious from the; point (e.g., that this is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If t",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:3805,Availability,error,error,3805,"((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Precision in Wording; A detail is that we have tried really hard to make the diagnostics that come; out of clang contain exactly the pertinent information about what is wrong and; why. In the example above, we tell you what the inferred types are for; the left and right hand sides, and we don't repeat what is obvious from the; point (e.g., that this is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka""",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4494,Availability,error,error,4494,"nction). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::service",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4878,Availability,error,error,4878,"lective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled wit",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:5606,Availability,error,error,5606,"er to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:5999,Availability,error,error,5999,"into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6337,Availability,redundant,redundant,6337,"p) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7065,Availability,error,errors,7065,">', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7202,Availability,error,error,7202,"ovide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7366,Availability,error,error,7366,"e; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != d",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7576,Availability,error,error,7576," that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no kno",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:8677,Availability,error,errors,8677,"ments and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig deep into the definition of the macro to; understand how you got into trouble. The following simple example shows how; Clang helps you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();;",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:9165,Availability,error,error,9165,"stics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig deep into the definition of the macro to; understand how you got into trouble. The following simple example shows how; Clang helps you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10211,Availability,recover,recover,10211,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10401,Availability,error,error,10401," __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type)",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10478,Availability,error,error,10478,"g that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they al",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10580,Availability,recover,recover,10580,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10806,Availability,error,error,10806,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10933,Availability,error,error,10933,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10999,Availability,error,error,10999,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:11090,Availability,error,error,11090,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:11225,Availability,error,error,11225,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:11344,Availability,failure,failure,11344,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:908,Energy Efficiency,green,green,908,". Clang - Expressive Diagnostics. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this. This section; talks about the experience provided by the command line compiler, contrasting; Clang output to GCC 4.9's output in some cases. Column Numbers and Caret Diagnostics; First, all diagnostics produced by clang include full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related informatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:259,Integrability,message,messages,259,". Clang - Expressive Diagnostics. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this. This section; talks about the experience provided by the command line compiler, contrasting; Clang output to GCC 4.9's output in some cases. Column Numbers and Caret Diagnostics; First, all diagnostics produced by clang include full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related informatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4240,Integrability,wrap,wrap,4240,"s is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace m",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7582,Integrability,message,message,7582," that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no kno",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:11125,Integrability,depend,dependent,11125,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:5776,Modifiability,extend,extends,5776,"lang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = {",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10813,Modifiability,variab,variable,10813,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:1668,Safety,detect,detected,1668,"lude full column number; information. The clang command-line compiler driver uses this information; to print ""point diagnostics"".; (IDEs can use the information to display in-line error markup.); This is nice because it makes it very easy to understand exactly; what is wrong in a particular piece of code.; The point (the green ""^"" character) exactly shows where the problem is, even; inside of a string. This makes it really easy to jump to the problem and; helps when multiple instances of the same character occur on a line. (We'll; revisit this more in following examples.). $ clang -fsyntax-only format-strings.c; format-strings.c:91:13: warning: '.*' specified field precision is missing a matching 'int' argument; printf(""%.*d"");; ^. Note that modern versions of GCC have followed Clang's lead, and are; now able to give a column for a diagnostic, and include a snippet of source; text in the result. However, Clang's column number is much more accurate,; pointing at the problematic format specifier, rather than the ); character the parser had reached when the problem was detected.; Also, Clang's diagnostic is colored by default, making it easier to; distinguish from nearby text.; Range Highlighting for Related Text; Clang captures and accurately tracks range information for expressions,; statements, and other constructs in your program and uses this to make; diagnostics highlight related information. In the following somewhat; nonsensical example you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error. Because clang prints a; point, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about.; Range information is very useful for; cases involving precedence issues and many other cases. $ gcc-4.9 -fsyntax-only t.c; t.c: In function 'int f(int, int)':; t.c:7:39: error: invali",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6337,Safety,redund,redundant,6337,"p) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10211,Safety,recover,recover,10211,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10580,Safety,recover,recover,10580,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4677,Security,expose,expose,4677,"fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::S",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4220,Usability,simpl,simple,4220,"s is a ""binary +"").; Many other examples abound. In the following example, not only do we tell you; that there is a problem with the *; and point to it, we say exactly why and tell you what the type is (in case it is; a complicated subexpression, such as a call to an overloaded function). This; sort of attention to detail makes it much easier to understand and fix problems; quickly. $ gcc-4.9 -fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace m",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:6428,Usability,guid,guidance,6428,"te information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::Server const' and '::services::WebService const *'); server += http;; ~~~~~~ ^ ~~~~. Naturally, type preservation extends to uses of templates, and Clang retains information about how a particular template specialization (like std::vector<Real>) was spelled within the source code. For example:. $ clang -fsyntax-only t.cpp; t.cpp:12:7: error: incompatible type assigning 'vector<Real>', expected 'std::string' (aka 'class std::basic_string<char>'); str = vec;; ^ ~~~. Fix-it Hints; ""Fix-it"" hints provide advice for fixing small, localized problems; in source code. When Clang produces a diagnostic about a particular; problem that it can work around (e.g., non-standard or redundant; syntax, missing keywords, common mistakes, etc.), it may also provide; specific guidance in the form of a code transformation to correct the; problem. In the following example, Clang warns about the use of a GCC; extension that has been considered obsolete since 1993. The underlined; code should be removed, then replaced with the code below the; point line ("".x ="" or "".y ="", respectively). $ clang t.c; t.c:5:28: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7763,Usability,clear,clearly,7763,"NU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig d",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:8873,Usability,simpl,simple,8873,"ap<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig deep into the definition of the macro to; understand how you got into trouble. The following simple example shows how; Clang helps you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implem",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:9962,Usability,simpl,simple,9962,"s you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10157,Usability,user experience,user experience,10157,"how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10228,Usability,simpl,simple,10228,"truct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no match",MatchSource.DOCS,interpreter/llvm-project/clang/www/diagnostics.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1784,Availability,down,down,1784,"architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1817,Availability,error,error,1817,"architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2258,Availability,error,error,2258," when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2546,Availability,error,error,2546,"f-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just wa",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3772,Availability,error,errors,3772,"h makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only need; to understand small pieces of the big picture). ""The world needs better compiler tools, tools which are built as libraries.; This design point allows reuse of the tools in new and novel ways. However,; building the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and keeping the libraries independent of; any specific client."". Currently, clang is ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:6611,Availability,avail,available,6611,"ibcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7454,Availability,down,down,7454,"esigned and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:13322,Availability,error,error,13322,"; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which must be bugfixed and maintained independently of each other. Conformance with C/C++/ObjC and their; variants. When you start work on implementing a language, you find out that there is a; huge gap between how the language works and how most people understand it to; work. This gap is the difference between a normal programmer and a (scary?; super-natural?) ""language lawyer"", who knows the ins and outs of the language; and can grok standardese with ease.; In practice, being conformant with the languages means that we aim to support; the full language, including the dark and dusty corners (like trigraphs,; preprocessor arcana, C99 VLAs, etc). Where we support extensions above and; beyo",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:13328,Availability,recover,recovery,13328,"; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which must be bugfixed and maintained independently of each other. Conformance with C/C++/ObjC and their; variants. When you start work on implementing a language, you find out that there is a; huge gap between how the language works and how most people understand it to; work. This gap is the difference between a normal programmer and a (scary?; super-natural?) ""language lawyer"", who knows the ins and outs of the language; and can grok standardese with ease.; In practice, being conformant with the languages means that we aim to support; the full language, including the dark and dusty corners (like trigraphs,; preprocessor arcana, C99 VLAs, etc). Where we support extensions above and; beyo",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:14411,Availability,error,errors,14411,"able; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which must be bugfixed and maintained independently of each other. Conformance with C/C++/ObjC and their; variants. When you start work on implementing a language, you find out that there is a; huge gap between how the language works and how most people understand it to; work. This gap is the difference between a normal programmer and a (scary?; super-natural?) ""language lawyer"", who knows the ins and outs of the language; and can grok standardese with ease.; In practice, being conformant with the languages means that we aim to support; the full language, including the dark and dusty corners (like trigraphs,; preprocessor arcana, C99 VLAs, etc). Where we support extensions above and; beyond what the standard officially allows, we make an effort to explicitly call; this out in the code and emit warnings about it (which are disabled by default,; but can optionally be mapped to either warnings or errors), allowing you to use; clang in ""strict"" mode if you desire. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1293,Energy Efficiency,efficient,efficient,1293,"ients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1439,Energy Efficiency,adapt,adapt,1439,"ients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:5875,Energy Efficiency,power,power,5875,"s, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8018,Energy Efficiency,efficient,efficient,8018,"rm to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:9844,Energy Efficiency,reduce,reduce,9844,"n; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation time.; A further difference between IDEs and batch compiler is that they often; impose very different requirements on the front-end: they depend on high; performance in order to provide a ""snappy"" experience, and thus really want; techniques like ""incremental compilation"", ""fuzzy parsing"", etc. Finally, IDEs; often have very different requirements than code generation, often requiring; information that a codegen-only frontend can throw away. Clang is; specifically designed and built to capture this information. Use the LLVM 'Apache 2' License. We actively intend for clang (and LLVM as a whole) to be used for; commercial projects, not only as a stand-alone compiler but also as a library; embedded inside a proprietary application. We feel that the license encourages; contributors to pick up the source and work with it, and believe that those; individu",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1835,Integrability,message,messages,1835,"architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3101,Integrability,rout,routinely,3101,"t a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3267,Integrability,depend,depend,3267,"ng -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:4138,Integrability,interface,interfaces,4138,"sions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only need; to understand small pieces of the big picture). ""The world needs better compiler tools, tools which are built as libraries.; This design point allows reuse of the tools in new and novel ways. However,; building the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and keeping the libraries independent of; any specific client."". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and pr",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:10010,Integrability,depend,depend,10010,"always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation time.; A further difference between IDEs and batch compiler is that they often; impose very different requirements on the front-end: they depend on high; performance in order to provide a ""snappy"" experience, and thus really want; techniques like ""incremental compilation"", ""fuzzy parsing"", etc. Finally, IDEs; often have very different requirements than code generation, often requiring; information that a codegen-only frontend can throw away. Clang is; specifically designed and built to capture this information. Use the LLVM 'Apache 2' License. We actively intend for clang (and LLVM as a whole) to be used for; commercial projects, not only as a stand-alone compiler but also as a library; embedded inside a proprietary application. We feel that the license encourages; contributors to pick up the source and work with it, and believe that those; individuals and organizations will contribute back their work if they do not; want to have to maintain a fork forever (which is time consuming and expensive; when merges are involved). Further, nobody makes money on compilers these days,; but many people need them to get bigger goals accomplished",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:11788,Integrability,depend,depended,11788,"e; individuals and organizations will contribute back their work if they do not; want to have to maintain a fork forever (which is time consuming and expensive; when merges are involved). Further, nobody makes money on compilers these days,; but many people need them to get bigger goals accomplished: it makes sense for; everyone to work together.; For more information about the LLVM/clang license, please see the LLVM License; Description for more information. Internal Design and Implementation. A real-world, production quality compiler. Clang is designed and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; a",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1439,Modifiability,adapt,adapt,1439,"ients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:4573,Modifiability,extend,extend,4573,"e most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only need; to understand small pieces of the big picture). ""The world needs better compiler tools, tools which are built as libraries.; This design point allows reuse of the tools in new and novel ways. However,; building the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and keeping the libraries independent of; any specific client."". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:5729,Modifiability,refactor,refactoring,5729,". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been signi",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:6130,Modifiability,refactor,refactoring,6130,", identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7598,Modifiability,refactor,refactoring,7598,"e believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after co",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7894,Modifiability,refactor,refactoring,7894,"ration, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the impleme",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12121,Modifiability,extend,extend,12121,"rk together.; For more information about the LLVM/clang license, please see the LLVM License; Description for more information. Internal Design and Implementation. A real-world, production quality compiler. Clang is designed and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; pa",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:13451,Modifiability,evolve,evolve,13451,"e the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which must be bugfixed and maintained independently of each other. Conformance with C/C++/ObjC and their; variants. When you start work on implementing a language, you find out that there is a; huge gap between how the language works and how most people understand it to; work. This gap is the difference between a normal programmer and a (scary?; super-natural?) ""language lawyer"", who knows the ins and outs of the language; and can grok standardese with ease.; In practice, being conformant with the languages means that we aim to support; the full language, including the dark and dusty corners (like trigraphs,; preprocessor arcana, C99 VLAs, etc). Where we support extensions above and; beyond what the standard officially allows, we make an effort to explicitly call; this out in the code and emit warnings about it (which are disabled by default,; but can optionally be mapped to either warnings or errors), allowing you to use; clang in ""str",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:780,Performance,scalab,scalable,780,". Clang - Features and Goals. Clang - Features and Goals. This page describes the features and goals of; Clang in more detail and gives a more broad explanation about what we mean.; These features are:. End-User Features:. Fast compiles and low memory use; Expressive diagnostics; GCC compatibility. Utility and Applications:. Library based architecture; Support diverse clients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong i",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:959,Performance,perform,performance,959,". Clang - Features and Goals. Clang - Features and Goals. This page describes the features and goals of; Clang in more detail and gives a more broad explanation about what we mean.; These features are:. End-User Features:. Fast compiles and low memory use; Expressive diagnostics; GCC compatibility. Utility and Applications:. Library based architecture; Support diverse clients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong i",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1041,Performance,perform,performance,1041," explanation about what we mean.; These features are:. End-User Features:. Fast compiles and low memory use; Expressive diagnostics; GCC compatibility. Utility and Applications:. Library based architecture; Support diverse clients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:5606,Performance,optimiz,optimization,5606,"n layering, decent design, and keeping the libraries independent of; any specific client."". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7110,Performance,optimiz,optimizer,7110," would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:10026,Performance,perform,performance,10026,"always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation time.; A further difference between IDEs and batch compiler is that they often; impose very different requirements on the front-end: they depend on high; performance in order to provide a ""snappy"" experience, and thus really want; techniques like ""incremental compilation"", ""fuzzy parsing"", etc. Finally, IDEs; often have very different requirements than code generation, often requiring; information that a codegen-only frontend can throw away. Clang is; specifically designed and built to capture this information. Use the LLVM 'Apache 2' License. We actively intend for clang (and LLVM as a whole) to be used for; commercial projects, not only as a stand-alone compiler but also as a library; embedded inside a proprietary application. We feel that the license encourages; contributors to pick up the source and work with it, and believe that those; individuals and organizations will contribute back their work if they do not; want to have to maintain a fork forever (which is time consuming and expensive; when merges are involved). Further, nobody makes money on compilers these days,; but many people need them to get bigger goals accomplished",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:11696,Performance,perform,performance,11696,"e; individuals and organizations will contribute back their work if they do not; want to have to maintain a fork forever (which is time consuming and expensive; when merges are involved). Further, nobody makes money on compilers these days,; but many people need them to get bigger goals accomplished: it makes sense for; everyone to work together.; For more information about the LLVM/clang license, please see the LLVM License; Description for more information. Internal Design and Implementation. A real-world, production quality compiler. Clang is designed and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; a",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8000,Safety,safe,safe,8000,"ration, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the impleme",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:13328,Safety,recover,recovery,13328,"; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which must be bugfixed and maintained independently of each other. Conformance with C/C++/ObjC and their; variants. When you start work on implementing a language, you find out that there is a; huge gap between how the language works and how most people understand it to; work. This gap is the difference between a normal programmer and a (scary?; super-natural?) ""language lawyer"", who knows the ins and outs of the language; and can grok standardese with ease.; In practice, being conformant with the languages means that we aim to support; the full language, including the dark and dusty corners (like trigraphs,; preprocessor arcana, C99 VLAs, etc). Where we support extensions above and; beyo",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:5203,Security,hash,hash,5203,"cause they only need; to understand small pieces of the big picture). ""The world needs better compiler tools, tools which are built as libraries.; This design point allows reuse of the tools in new and novel ways. However,; building the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and keeping the libraries independent of; any specific client."". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set of parser actions; to build a standardized AST for programs.; libcodegen - Lower the AST to LLVM IR for optimization & code; generation.; librewrite - Editing of text buffers (important for code rewriting; transformation, like refactoring).; libanalysis - Static analysis support.; clang - A driver program, client of the libraries at various; levels. As an example of the power of this library based design.... If you wanted to; build a preprocessor, you would take the Basic and Lexer libraries. If you want; an indexer, you would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would th",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:995,Testability,benchmark,benchmarks,995,"lang - Features and Goals. Clang - Features and Goals. This page describes the features and goals of; Clang in more detail and gives a more broad explanation about what we mean.; These features are:. End-User Features:. Fast compiles and low memory use; Expressive diagnostics; GCC compatibility. Utility and Applications:. Library based architecture; Support diverse clients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:513,Usability,simpl,simple,513,". Clang - Features and Goals. Clang - Features and Goals. This page describes the features and goals of; Clang in more detail and gives a more broad explanation about what we mean.; These features are:. End-User Features:. Fast compiles and low memory use; Expressive diagnostics; GCC compatibility. Utility and Applications:. Library based architecture; Support diverse clients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong i",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2123,Usability,clear,clear,2123,"online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compati",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:2155,Usability,simpl,simple,2155,"ou can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensi",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:3217,Usability,undo,undocumented,3217,"ng -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases involving precedence issues and many other situations.; Clang diagnostics are very polished and have many features. For more; information and examples, please see the Expressive; Diagnostics page. GCC Compatibility. GCC is currently the defacto-standard open source compiler today, and it; routinely compiles a huge volume of code. GCC supports a huge number of; extensions and features (many of which are undocumented) and a lot of; code and header files depend on these features in order to build.; While it would be nice to be able to ignore these extensions and focus on; implementing the language standards to the letter, pragmatics force us to; support the GCC extensions that see the most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:6967,Usability,simpl,simple,6967," would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7463,Usability,simpl,simplified,7463,"esigned and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8123,Usability,simpl,simply,8123,"rm to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8153,Usability,simpl,simple,8153,"rm to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we ",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:8810,Usability,simpl,simple,8810,"much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after code generation. Finally,; clang provides support for building and retaining fully-fledged ASTs, and even; supports writing them out to disk.; Designing the libraries with clean and simple APIs allows these high-level; policy decisions to be determined in the client, instead of forcing ""one true; way"" in the implementation of any of these libraries. Getting this right is; hard, and we don't always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation ti",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:11937,Usability,simpl,simple,11937," these days,; but many people need them to get bigger goals accomplished: it makes sense for; everyone to work together.; For more information about the LLVM/clang license, please see the LLVM License; Description for more information. Internal Design and Implementation. A real-world, production quality compiler. Clang is designed and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are co",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12381,Usability,simpl,simple,12381,"igned and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forw",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12424,Usability,simpl,simple,12424," whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12601,Usability,simpl,simplicity,12601," whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which",MatchSource.DOCS,interpreter/llvm-project/clang/www/features.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:1085,Availability,avail,available,1085," have checked out and built clang and; played around with it, you might be wondering what you can do to make it better; and contribute to its development. Alternatively, maybe you just want to follow; the development of the project to see it progress. Contribute. See the hacking document for information on how; to author patches. Follow what's going on; Clang is a subproject of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new la",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:2321,Availability,mainten,maintenance,2321,"-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang community. However, extensions; (particularly language extensions) have long-term maintenance costs; for Clang. The benefits of the extension need to be evaluated against; these costs. The Clang project uses the following criteria for this; evaluation:. Evidence of a significant user community: This is based on a number of; factors, including an existing user community, the perceived likelihood that; users would adopt such a feature if it were available, and any secondary; effects that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the f",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:2687,Availability,avail,available,2687," clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang community. However, extensions; (particularly language extensions) have long-term maintenance costs; for Clang. The benefits of the extension need to be evaluated against; these costs. The Clang project uses the following criteria for this; evaluation:. Evidence of a significant user community: This is based on a number of; factors, including an existing user community, the perceived likelihood that; users would adopt such a feature if it were available, and any secondary; effects that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard,",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4552,Availability,mainten,maintenance,4552,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:396,Deployability,patch,patches,396,". Clang - Get Involved. Getting Involved with the Clang Project; Once you have checked out and built clang and; played around with it, you might be wondering what you can do to make it better; and contribute to its development. Alternatively, maybe you just want to follow; the development of the project to see it progress. Contribute. See the hacking document for information on how; to author patches. Follow what's going on; Clang is a subproject of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; all",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:1005,Deployability,update,updates,1005,". Clang - Get Involved. Getting Involved with the Clang Project; Once you have checked out and built clang and; played around with it, you might be wondering what you can do to make it better; and contribute to its development. Alternatively, maybe you just want to follow; the development of the project to see it progress. Contribute. See the hacking document for information on how; to author patches. Follow what's going on; Clang is a subproject of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; all",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:1473,Deployability,patch,patch,1473,"project of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang community. However, extensions; (particularly language extensions) have long-term maintenance costs; for Clang. The benefits of the extension need to be evaluated against; these costs. The Clang project us",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:2029,Modifiability,extend,extend,2029,"dates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang community. However, extensions; (particularly language extensions) have long-term maintenance costs; for Clang. The benefits of the extension need to be evaluated against; these costs. The Clang project uses the following criteria for this; evaluation:. Evidence of a significant user community: This is based on a number of; factors, including an existing user community, the perceived likelihood that; users would adopt such a feature if it were available, and any secondary; effects that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:3967,Modifiability,evolve,evolves,3967,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4664,Security,validat,validate,4664,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4447,Testability,test,test,4447,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4469,Testability,test,testing,4469,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4578,Testability,test,test,4578,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:1329,Usability,learn,learning,1329,"ybe you just want to follow; the development of the project to see it progress. Contribute. See the hacking document for information on how; to author patches. Follow what's going on; Clang is a subproject of the LLVM Project; and has a Discourse forum and mailing list:. Clang Frontend Discourse forum -; This forum is for discussions related to Clang (questions and answers, design; discussions, RFCs, etc).; Discord chat - Real-time chat for; discussions related to Clang (primarily for questions and answers).; Regular meetings are held on the. first and third Wednesday of each month to discuss C and C++; standards-related activities happening within the Clang community. These; meetings are a way to coordinate efforts between implementers and provide; updates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang commun",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4373,Usability,learn,learn,4373,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_involved.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:469,Availability,down,download,469,". Clang - Getting Started. Getting Started: Building and Running Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:1044,Availability,down,downloads,1044,"Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:1123,Availability,down,download,1123,"Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PRO",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2658,Availability,avail,available,2658,"or, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3512,Availability,down,download,3512,"ou may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf settin",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3634,Availability,down,download,3634,"+ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building with",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3766,Availability,down,download,3766,"her of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:7346,Availability,error,errors,7346,"017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organization); cd build_ninja; set CC=cl (necessary to force CMake to choose MSVC over mingw GCC; if you have it installed); set CXX=cl; cmake -GNinja -DLLVM_ENABLE_PROJECTS=clang ..\llvm; ninja clang This will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsyntax-only ~/t.c. GCC options:. $ clang -fsyntax-only ~/t.c -pedantic; /Users/sabre/t.c:2:17: warning: extension used; typedef float V __attribute__((vector_size(16)));; ^; 1 diagnostic generated. Pretty printing from the AST:; Note, the -cc1 argument indicates the compiler front-end, and; not the driver, should be run. The compiler front-end has several additional; Clang specific features which are not exposed through the GCC compatible driver; interface. $ clang -cc1 ~/t.c -ast-print; typedef float V __attribute__(( vector_size(16) ));; V foo(V a, V b) {; return a + b * a;; }. Code generation with LLVM:. $ clang ~/t.c -S -emit-llvm -o -; defi",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:418,Deployability,release,released,418,". Clang - Getting Started. Getting Started: Building and Running Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:451,Deployability,release,releases,451,". Clang - Getting Started. Getting Started: Building and Running Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:482,Deployability,release,release,482,". Clang - Getting Started. Getting Started: Building and Running Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:521,Deployability,release,releases,521,". Clang - Getting Started. Getting Started: Building and Running Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:1962,Deployability,release,release,1962,"Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2713,Deployability,install,installations,2713,"or, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2751,Deployability,install,installations,2751,"or, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2800,Deployability,configurat,configuration,2800," (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and fin",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2963,Deployability,install,installed,2963," (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and fin",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:5005,Deployability,configurat,configuration,5005,"ties provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and sear",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:6578,Deployability,install,installed,6578,"ws. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and search for ""Command Prompt"", you should; see shortcuts created by Visual Studio to do this. To use native x64; tools, choose the one titled ""x64 Native Tools Command Prompt for VS; 2017"".; Alternatively, launch a regular cmd prompt and run the; appropriate vcvarsall.bat incantation. To get the 2017 x64 tools, this; would be:; ""C:\Program Files (x86)\Microsoft Visual; Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organization); cd build_ninja; set CC=cl (necessary to force CMake to choose MSVC over mingw GCC; if you have it installed); set CXX=cl; cmake -GNinja -DLLVM_ENABLE_PROJECTS=clang ..\llvm; ninja clang This will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:8165,Integrability,interface,interface,8165,"will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsyntax-only ~/t.c. GCC options:. $ clang -fsyntax-only ~/t.c -pedantic; /Users/sabre/t.c:2:17: warning: extension used; typedef float V __attribute__((vector_size(16)));; ^; 1 diagnostic generated. Pretty printing from the AST:; Note, the -cc1 argument indicates the compiler front-end, and; not the driver, should be run. The compiler front-end has several additional; Clang specific features which are not exposed through the GCC compatible driver; interface. $ clang -cc1 ~/t.c -ast-print; typedef float V __attribute__(( vector_size(16) ));; V foo(V a, V b) {; return a + b * a;; }. Code generation with LLVM:. $ clang ~/t.c -S -emit-llvm -o -; define <4 x float> @foo(<4 x float> %a, <4 x float> %b) {; entry:; %mul = mul <4 x float> %b, %a; %add = add <4 x float> %mul, %a; ret <4 x float> %add; }; $ clang -fomit-frame-pointer -O3 -S -o - t.c # On x86_64; ...; _foo:; Leh_func_begin1:; 	mulps	%xmm0, %xmm1; 	addps	%xmm1, %xmm0; 	ret; Leh_func_end1:. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2071,Modifiability,variab,variables,2071,"process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyn",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2800,Modifiability,config,configuration,2800," (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and fin",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:5005,Modifiability,config,configuration,5005,"ties provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and sear",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:7191,Modifiability,portab,portability,7191,"rompt for VS; 2017"".; Alternatively, launch a regular cmd prompt and run the; appropriate vcvarsall.bat incantation. To get the 2017 x64 tools, this; would be:; ""C:\Program Files (x86)\Microsoft Visual; Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organization); cd build_ninja; set CC=cl (necessary to force CMake to choose MSVC over mingw GCC; if you have it installed); set CXX=cl; cmake -GNinja -DLLVM_ENABLE_PROJECTS=clang ..\llvm; ninja clang This will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsyntax-only ~/t.c. GCC options:. $ clang -fsyntax-only ~/t.c -pedantic; /Users/sabre/t.c:2:17: warning: extension used; typedef float V __attribute__((vector_size(16)));; ^; 1 diagnostic generated. Pretty printing from the AST:; Note, the -cc1 argument indicates the compiler front-end, and; not the driver, should be run. The compiler front-end has several additional; Clang specific features which are not exposed through the GCC compatible",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:2612,Safety,detect,detect,2612,"or, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you need a debug build, switch Release to Debug. See; frequently used cmake variables; for more options.; ; cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G ""Unix Makefiles"" ../llvm; make; Note: For subsequent Clang development, you can just run; make clang.; CMake allows you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:8122,Security,expose,exposed,8122,"will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsyntax-only ~/t.c. GCC options:. $ clang -fsyntax-only ~/t.c -pedantic; /Users/sabre/t.c:2:17: warning: extension used; typedef float V __attribute__((vector_size(16)));; ^; 1 diagnostic generated. Pretty printing from the AST:; Note, the -cc1 argument indicates the compiler front-end, and; not the driver, should be run. The compiler front-end has several additional; Clang specific features which are not exposed through the GCC compatible driver; interface. $ clang -cc1 ~/t.c -ast-print; typedef float V __attribute__(( vector_size(16) ));; V foo(V a, V b) {; return a + b * a;; }. Code generation with LLVM:. $ clang ~/t.c -S -emit-llvm -o -; define <4 x float> @foo(<4 x float> %a, <4 x float> %b) {; entry:; %mul = mul <4 x float> %b, %a; %add = add <4 x float> %mul, %a; ret <4 x float> %add; }; $ clang -fomit-frame-pointer -O3 -S -o - t.c # On x86_64; ...; _foo:; Leh_func_begin1:; 	mulps	%xmm0, %xmm1; 	addps	%xmm1, %xmm0; 	ret; Leh_func_end1:. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:995,Testability,test,test,995,". Clang - Getting Started. Getting Started: Building and Running Clang; This page gives you the shortest path to checking out Clang and demos a few; options. This should get you up and running with the minimum of muss and fuss.; If you like what you see, please consider getting; involved with the Clang community. If you run into problems, please file; bugs on the LLVM bug tracker.; Release Clang Versions; Clang is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/.; Clang is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.; Building Clang and Working with the Code; On Unix-like Systems; If you would like to check out and build Clang, the current procedure is as; follows:. Get the required tools.; ; See; ; Getting Started with the LLVM System - Requirements.; Note also that Python is needed for running the test suite.; Get it at: ; https://www.python.org/downloads/; Standard build process uses CMake. Get it at:; ; https://cmake.org/download/. Check out the LLVM project:; ; Change directory to where you want the llvm directory placed.; git clone https://github.com/llvm/llvm-project.git; The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:; ; git clone --depth=1 https://github.com/llvm/llvm-project.git (using this only the latest version of llvm can be built); For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:; ; cd llvm-project; git fetch --unshallow. Build LLVM and Clang:; ; cd llvm-project; mkdir build (in-tree build is not supported); cd build; This builds both LLVM and Clang in release mode. Alternatively, if; you ne",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3272,Testability,test,testsuite,3272," you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://gith",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3715,Testability,test,test,3715,"system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3812,Testability,test,test,3812,"her of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3937,Testability,test,tested,3937,"c containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead o",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:4098,Testability,test,tested,4098,"ly (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have cr",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:4330,Testability,test,tests,4330,"tails setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you add",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:5518,Testability,test,tests,5518," Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and search for ""Command Prompt"", you should; see shortcuts created by Visual Studio to do this. To use native x64; tools, choose the one titled ""x64 Native Tools Command Prompt for VS; 2017"".; Alternatively, launch a regular cmd prompt and run the; appropriate vcvarsall.bat incantation. To get the 2017 x64 tools, this; would be:; ""C:\Program Files (x86)\Microsoft Visual; Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organizat",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:5818,Testability,test,tests,5818,"=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and search for ""Command Prompt"", you should; see shortcuts created by Visual Studio to do this. To use native x64; tools, choose the one titled ""x64 Native Tools Command Prompt for VS; 2017"".; Alternatively, launch a regular cmd prompt and run the; appropriate vcvarsall.bat incantation. To get the 2017 x64 tools, this; would be:; ""C:\Program Files (x86)\Microsoft Visual; Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organization); cd build_ninja; set CC=cl (necessary to force CMake to choose MSVC over mingw GCC; if you have it installed); set CXX=cl; cmake -GNinja -DLLVM_ENABLE_PROJECTS=clang ..\llvm; ninja clang This will build just clang.; ninja check-clang This will run the clang tests. Clang Compil",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:6737,Testability,test,tests,6737,"t files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and search for ""Command Prompt"", you should; see shortcuts created by Visual Studio to do this. To use native x64; tools, choose the one titled ""x64 Native Tools Command Prompt for VS; 2017"".; Alternatively, launch a regular cmd prompt and run the; appropriate vcvarsall.bat incantation. To get the 2017 x64 tools, this; would be:; ""C:\Program Files (x86)\Microsoft Visual; Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organization); cd build_ninja; set CC=cl (necessary to force CMake to choose MSVC over mingw GCC; if you have it installed); set CXX=cl; cmake -GNinja -DLLVM_ENABLE_PROJECTS=clang ..\llvm; ninja clang This will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsynt",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:4968,Usability,guid,guide,4968,"ties provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://github.com/llvm/llvm-project.git. Note: Some Clang tests are sensitive to the line endings. Ensure; that checking out the files does not convert LF line endings to CR+LF. If; you're using git on Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and sear",MatchSource.DOCS,interpreter/llvm-project/clang/www/get_started.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3225,Availability,error,error,3225,"ebugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages f",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4190,Availability,error,error,4190," do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; Th",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4835,Availability,down,downloads,4835," a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7368,Availability,failure,failure,7368,"lang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commi",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:492,Deployability,patch,patches,492,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:931,Deployability,integrat,integrating,931,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2356,Deployability,update,update,2356,"LVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expe",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4784,Deployability,install,installed,4784,"y. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6413,Deployability,configurat,configuration,6413,"ild"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6640,Deployability,configurat,configuration,6640,"ly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; T",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8283,Deployability,configurat,configurations,8283,"ailed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8387,Deployability,configurat,configurations,8387,"ress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8439,Deployability,patch,patch,8439,"ress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8604,Deployability,patch,patch,8604,"ng: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with -o -). You; can also use -emit-llvm-bc to write an LLVM bitcode file; which can be processed by the suite of LLVM tools; like llvm-dis, llvm-nm, etc. See the LLVM; Command",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8673,Deployability,patch,patch,8673,"\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with -o -). You; can also use -emit-llvm-bc to write an LLVM bitcode file; which can be processed by the suite of LLVM tools; like llvm-dis, llvm-nm, etc. See the LLVM; Command Guide; for more information. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:835,Integrability,rout,routines,835,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:931,Integrability,integrat,integrating,931,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clan",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1007,Integrability,interface,interfaces,1007,". Hacking on clang. Hacking on Clang. This document provides some hints for how to get started hacking; on Clang for developers who are new to the Clang and/or LLVM; codebases. Coding Standards; Developer Documentation; Debugging; Testing. Testing on Unix-like Systems; Testing using Visual Studio on Windows; Testing on the Command Line; Testing changes affecting libc++. Creating Patch Files; LLVM IR Generation. Coding Standards. Clang follows the; LLVM Coding; Standards. When submitting patches, please take care to follow these standards; and to match the style of the code to that present in Clang (for example, in; terms of indentation, bracing, and statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/cla",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1579,Integrability,wrap,wrapping,1579," statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERB",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1732,Integrability,wrap,wrapped,1732," statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERB",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3706,Integrability,message,message,3706,"il; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3811,Integrability,message,message,3811,"-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4196,Integrability,message,messages,4196," do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; Th",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2122,Modifiability,config,configure,2122,"LVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expe",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5020,Modifiability,variab,variable,5020,"emaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a c",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6413,Modifiability,config,configuration,6413,"ild"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6483,Modifiability,config,config,6483,"oft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indicatio",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6640,Modifiability,config,configuration,6640,"ly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; T",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8283,Modifiability,config,configurations,8283,"ailed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8387,Modifiability,config,configurations,8387,"ress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2565,Testability,test,test,2565,"ue class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current tes",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2627,Testability,test,test,2627,"ue class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current tes",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2767,Testability,test,test,2767,"ers there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2852,Testability,test,tests,2852,"tils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2881,Testability,test,test,2881,"tils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2928,Testability,test,test,2928,"tils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2947,Testability,test,test,2947,"tils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:2996,Testability,test,test,2996,"tils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3027,Testability,test,test,3027," types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/t",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3137,Testability,test,test,3137," types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/t",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3205,Testability,test,test,3205,"ebugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages f",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3298,Testability,test,test,3298,">\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; mak",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3377,Testability,test,test,3377,"g includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as i",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3469,Testability,test,tests,3469,"g includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as i",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3562,Testability,test,test,3562,"g includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as i",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3643,Testability,test,test,3643,"il; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3732,Testability,test,tests,3732,"il; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3767,Testability,test,tests,3767,"-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3854,Testability,test,test,3854,"-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3952,Testability,test,test,3952,"ual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4017,Testability,test,test,4017," individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4079,Testability,test,test,4079,"cating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4228,Testability,test,test,4228," do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; Th",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4310,Testability,test,test,4310,"e test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4652,Testability,test,test,4652,"; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Be",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4737,Testability,test,test,4737,"y. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4939,Testability,test,tests,4939,"sts (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started r",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5260,Testability,test,tests,5260,"unner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5320,Testability,test,test,5320,"tory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on W",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5588,Testability,test,tests,5588,"ng Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will nee",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5636,Testability,test,test,5636,"ng Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will nee",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5695,Testability,test,tests,5695,"ne.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5839,Testability,test,tests,5839,"/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5894,Testability,test,tests,5894," Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6003,Testability,test,tests,6003," Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6045,Testability,test,tests,6045,"or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\util",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6266,Testability,test,test,6266,"Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\ll",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6317,Testability,test,test,6317,"efore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the te",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6694,Testability,test,test,6694,"ly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; T",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6755,Testability,test,test,6755,"ly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; T",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6793,Testability,test,test,6793,"ated for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Fail",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6952,Testability,test,test,6952,"ave started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing chang",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7003,Testability,test,test,7003,"nning any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7015,Testability,test,test,7015,"nning any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7185,Testability,test,test,7185,"vm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions lik",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7230,Testability,test,test,7230,"m=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next re",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7299,Testability,test,test,7299,"lang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commi",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7319,Testability,test,tests,7319,"lang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commi",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7483,Testability,test,tests,7483,"ease, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7653,Testability,test,tests,7653," which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7853,Testability,test,tests,7853," --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. F",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8239,Testability,test,tested,8239,"\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historicall",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8546,Testability,test,test,8546,"ht look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with -o -). You; can also use -emit-llvm-bc to write an LLVM bitcode file; which can be processed by the suite ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:8759,Testability,test,tests,8759,"\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. For questions regarding; libc++, the best place to ask is the #libcxx channel on; LLVM's Discord server. Creating Patch Files. To contribute changes to Clang see; LLVM's Getting Started page. LLVM IR Generation. The LLVM IR generation part of clang handles conversion of the; AST nodes output by the Sema module to the LLVM Intermediate; Representation (IR). Historically, this was referred to as; ""codegen"", and the Clang code for this lives; in lib/CodeGen.; The output is most easily inspected using the -emit-llvm; option to clang (possibly in conjunction with -o -). You; can also use -emit-llvm-bc to write an LLVM bitcode file; which can be processed by the suite of LLVM tools; like llvm-dis, llvm-nm, etc. See the LLVM; Command Guide; for more information. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1555,Usability,simpl,simple,1555," statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERB",MatchSource.DOCS,interpreter/llvm-project/clang/www/hacking.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:1255,Availability,down,down,1255," C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, b",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:793,Deployability,integrat,integration,793,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:1414,Deployability,integrat,integration,1414,"the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, building it, and; playing with it. This will show you the sorts of things we can do; today and will let you have the ""Clang experience"" first hand: hopefully; it will ""resonate"" with you. :); Once you've",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:793,Integrability,integrat,integration,793,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:1414,Integrability,integrat,integration,1414,"the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, building it, and; playing with it. This will show you the sorts of things we can do; today and will let you have the ""Clang experience"" first hand: hopefully; it will ""resonate"" with you. :); Once you've",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:726,Modifiability,refactor,refactoring,726,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:1859,Performance,perform,performance-critical,1859,"ing, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, building it, and; playing with it. This will show you the sorts of things we can do; today and will let you have the ""Clang experience"" first hand: hopefully; it will ""resonate"" with you. :); Once you've done that, please consider getting; involved in the Clang community. The Clang developers include numerous; volunteer contributors with a variety of backgrounds. If you're; interested in; following the development of Clang, signing up for a mailing list is a good; way to learn about how the project works. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:933,Usability,simpl,simple,933,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:2699,Usability,learn,learn,2699,"ing, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang is probably a great solution for you. Please see; the C++ status page or the; C status page for more information about what; standard modes and features are supported. Get it and get involved!. Start by getting the code, building it, and; playing with it. This will show you the sorts of things we can do; today and will let you have the ""Clang experience"" first hand: hopefully; it will ""resonate"" with you. :); Once you've done that, please consider getting; involved in the Clang community. The Clang developers include numerous; volunteer contributors with a variety of backgrounds. If you're; interested in; following the development of Clang, signing up for a mailing list is a good; way to learn about how the project works. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/index.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:76,Availability,avail,available,76,". Clang - Open Projects. Open Clang Projects; Here are a few tasks that are available for anyone to work on, depending; on what your interests are. This list is provided to generate ideas, it is not; intended to be comprehensive. Please ask on; Discourse for more specifics; or to verify that one of these isn't already completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:2904,Availability,mainten,maintenance,2904,"akes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expre",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4383,Availability,reliab,reliability,4383,"alking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-comp",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4553,Availability,reliab,reliability,4553,"that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; option",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4569,Availability,error,error,4569,"that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; option",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4709,Availability,error,errors,4709,"that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; option",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:6754,Availability,down,down,6754,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5490,Deployability,configurat,configurations,5490,"eparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5755,Deployability,configurat,configuration,5755,"e interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:6420,Deployability,configurat,configuration,6420,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:2781,Energy Efficiency,reduce,reduced,2781,"ten to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long t",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5326,Energy Efficiency,efficient,efficient,5326,"s to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for C",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:6707,Energy Efficiency,reduce,reduce,6707,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:109,Integrability,depend,depending,109,". Clang - Open Projects. Open Clang Projects; Here are a few tasks that are available for anyone to work on, depending; on what your interests are. This list is provided to generate ideas, it is not; intended to be comprehensive. Please ask on; Discourse for more specifics; or to verify that one of these isn't already completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5260,Integrability,interface,interfaces,5260,"nt and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5981,Integrability,depend,dependency,5981,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5490,Modifiability,config,configurations,5490,"eparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5755,Modifiability,config,configuration,5755,"e interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:6420,Modifiability,config,configuration,6420,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:3140,Performance,perform,performance,3140,"des.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could us",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:3476,Performance,perform,performing,3476," Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:3537,Performance,perform,performance,3537,"ccordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or ran",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5821,Safety,avoid,avoid,5821,"e interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1296,Testability,test,test,1296,"y completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general con",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1436,Testability,test,test,1436,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1460,Testability,test,test,1460,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1500,Testability,test,tests,1500,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1626,Testability,test,tests,1626,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1641,Testability,test,test,1641,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1677,Testability,test,tests,1677,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1692,Testability,test,test,1692,"ete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for;",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1722,Testability,test,tests,1722,"or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducib",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1794,Testability,test,test,1794,"or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducib",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1814,Testability,test,test,1814,"or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducib",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1967,Testability,test,test,1967,"ntation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; b",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:2137,Testability,test,tests,2137,"ntation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; b",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:2328,Testability,test,testing,2328,"rage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:2530,Testability,test,test,2530,"t of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance pro",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:2789,Testability,test,test,2789,"ten to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long t",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4256,Testability,test,testing,4256,"t for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4346,Testability,test,testing,4346,"t for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:4833,Testability,test,test,4833,"ng byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason about source code.; clang-doc is one; great application of this functionality, which generates code documentation; from source code. The tool is in early stages of development and could use more; dedicated effort to complete the implementation.; Self-testing using clang: There are several neat ways to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:843,Usability,undo,undocumented,843,". Clang - Open Projects. Open Clang Projects; Here are a few tasks that are available for anyone to work on, depending; on what your interests are. This list is provided to generate ideas, it is not; intended to be comprehensive. Please ask on; Discourse for more specifics; or to verify that one of these isn't already completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model sui",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:3086,Usability,user experience,user experience,3086,"r open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general conformance testing is; determining which C defect reports and; C++ defect reports Clang implements. These; lists currently have a number of entries marked as Unknown.; Completing the investigation involves adding test coverage for; C; and; C++; defect reports and updating the documentation accordingly.; Bug triage: Clang's ; issue trackercurrently has over 20,000 open issues, many of which are not; appropriately tagged, are no longer reproducible, could use a reduced test case,; or otherwise needs some manual interaction. We can always use help with; bug triage and; issue tracker maintenance. Improve build times with Clang: the time it takes Clang to process a; translation unit is very important to our users; the lower the build time, the; better the overall user experience. It would be good to improve Clang's; performance as well as to find ways to proactively alert us when we've; introduced a change that has significant negative impact on build times.; Complete support for the experimental constant expression interpreter; : Clang's production constant expression interpreter computes a constant; expression result by walking over AST nodes, performing calculations as it; goes. This does not have good performance properties, and so we've begun work; on an ; experimental constant expression interpreter that works by converting the; AST into bytecode that is interpreted. This effort has a long tail of work left; to complete because it requires implementing byte code for every kind of; expression and type that can be used in a constant expression for C++ and C. Improve clang-doc: Clang's library-based design allows it to be used; by a variety of tools that reason abou",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5288,Usability,simpl,simplifies,5288,"s to; improve the quality of clang by self-testing. Some examples:. Improve the reliability of AST printing and serialization by; ensuring that the AST produced by clang on an input doesn't change; when it is reparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for C",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5950,Usability,simpl,simple,5950,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:6582,Usability,simpl,simple,6582,"rk on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on Discourse,; Discord,; or for advice. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/OpenProjects.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/related.html:1989,Integrability,interface,interface,1989," Clang related project you would like; added to this list. FreeBSD Clang Page. Site:. https://wiki.freebsd.org/BuildingFreeBSDWithClang. This is an effort to get FreeBSD to build with clang/llvm.; . Chromium Clang Page. Site:. https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/clang.md. Notes on using Clang to build the Chromium web browser.; . Debian Clang Page. Sites:; https://clang.debian.net/. https://wiki.debian.org/llvm-clang. Notes on using Clang to rebuild the whole Debian archive.; . Include what you use. Site:; https://github.com/include-what-you-use/include-what-you-use. Analyze #includes in C and C++ source files; . OCLint. Site:; http://oclint.org/. OCLint is a static code analysis tool for improving quality and reducing defects by inspecting C, C++ and Objective-C code.; . DXR. Site:; https://github.com/mozilla/dxr. DXR is a code search and navigation tool aimed at making sense of large projects like Firefox. It supports full-text and regex searches as well as structural queries like ""Find all the callers of this function.""; . CodeCompass. Site:; https://github.com/Ericsson/CodeCompass. CodeCompass is an open-source, extensible code comprehension framework which uses LLVM/Clang to analyze and visualize C and C++ projects. It also supports both regex-based text search, discovering complex C/C++ language elements, with advanced navigation and visualisation.; . CodeChecker. Site:; https://github.com/Ericsson/CodeChecker. CodeChecker is a static analysis infrastructure built on the LLVM/Clang Static Analyzer toolchain. It provides a user interface to execute analysis of C/C++ projects with Clang SA and Clang-Tidy, which outputs are then stored into a database navigable via a web application. This web application and a corresponding command-line tool supports a variety of report management and issue triaging options, such as difference view between analyses, automatic incremental analysis, marking and commenting on individual reports.; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/related.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/related.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:3990,Energy Efficiency,allocate,allocated,3990,"));; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // no",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:7058,Energy Efficiency,allocate,allocate,7058," v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidat",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1169,Integrability,message,message,1169,"sues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precisio",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:7307,Integrability,interface,interface,7307," note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interfa",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:7651,Integrability,interface,interface,7651,"t(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @pr",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8149,Integrability,protocol,protocol,8149,"e following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8277,Integrability,interface,interface,8277,"@interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8340,Integrability,interface,interface,8340,"ntation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all lang",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8742,Integrability,protocol,protocol,8742,")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Al",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8869,Integrability,interface,interface,8869,"/ warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer over",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8930,Integrability,interface,interface,8930,"oa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1000,Modifiability,variab,variables,1000,". Alpha Checks. Alpha Checkers; Experimental checkers in addition to the ; Default Checkers. These are checkers with known issues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4113,Modifiability,variab,variable,4113,"ha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.Inval",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4399,Modifiability,polymorphi,polymorphic,4399,"turn sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4764,Modifiability,polymorphi,polymorphic,4764,"t_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5031,Modifiability,polymorphi,polymorphic,5031,"/ returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:7564,Modifiability,variab,variables,7564,"ble code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be inval",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8055,Modifiability,variab,variables,8055,"ate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMet",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8730,Modifiability,variab,variables,8730,": NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5314,Security,access,accessed,5314," Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5504,Security,access,accessed,5504," // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.de",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5806,Security,access,accessed,5806,"their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, Descriptio",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:9850,Security,secur,security,9850,"r"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is taint",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10329,Security,secur,security,10329,"1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10730,Security,secur,security,10730,"s"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void te",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10868,Security,secur,security,10868,"C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11021,Security,secur,security,11021,") {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test()",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11389,Security,secur,security,11389,"hecker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCrit",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11639,Security,secur,security,11639,"void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; uniq",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11975,Security,secur,security,11975,"c(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLo",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15498,Security,access,access,15498,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:687,Testability,log,log,687,". Alpha Checks. Alpha Checkers; Experimental checkers in addition to the ; Default Checkers. These are checkers with known issues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:728,Testability,log,log,728,". Alpha Checks. Alpha Checkers; Experimental checkers in addition to the ; Default Checkers. These are checkers with known issues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:824,Testability,log,log,824,". Alpha Checks. Alpha Checkers; Experimental checkers in addition to the ; Default Checkers. These are checkers with known issues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1016,Testability,test,test,1016,"; Experimental checkers in addition to the ; Default Checkers. These are checkers with known issues or limitations that; keep them from being on by default. They are likely to have false positives.; Bug reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1195,Testability,test,test,1195," reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1281,Testability,test,test,1281,"ime.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1527,Testability,test,test,1527,"a Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (in",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1695,Testability,test,test,1695," warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // wa",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1780,Testability,test,test,1780," { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1920,Testability,test,test,1920,"} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Che",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2052,Testability,test,test,2052," (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2523,Testability,test,test,2523," (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stac",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2675,Testability,test,test,2675," struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disable",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2786,Testability,test,test,2786,"; Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:3052,Testability,test,test,3052,"= 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:3221,Testability,test,test,3221,"e unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:3379,Testability,test,test,3379,"bleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that a",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4225,Testability,test,test,4225,"&y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:6580,Testability,test,test,6580,"rators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; wi",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:6648,Testability,test,test,6648,"the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @i",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:6741,Testability,test,test,6741,"begin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, DescriptionExample. alpha.llvm.Conventions; (C); Check code for LLVM codebase conventions:. A StringRef should not be bound to a temporary std::string; whose lifetime is shorter than the StringRef's.; Clang AST nodes should not have fields that can allocate memory. OS X Alpha Checkers. Name, DescriptionExample. alpha.osx.cocoa.DirectIvarAssignment; (ObjC); Check that Objective C properties follow the following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; anno",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:9926,Testability,test,test,9926,"nvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). v",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10020,Testability,test,test,10020,"ethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mma",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10201,Testability,test,test,10201,"ings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10260,Testability,test,test,10260,"icates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10407,Testability,test,test,10407,"le instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for a",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10464,Testability,test,test,10464,"tes single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];.",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10648,Testability,test,test,10648," [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10768,Testability,test,test,10768,"ckers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: u",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10953,Testability,test,test,10953,"ruct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-securi",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11115,Testability,test,test,11115,".; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; s",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11504,Testability,test,test,11504,"; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; re",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11558,Testability,test,test,11558,"e -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_t",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11733,Testability,test,test,11733,"bc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:12020,Testability,test,test,12020," mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:12171,Testability,test,test,12171,"WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_tr",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:12658,Testability,test,test,12658,"on; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acqui",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:12866,Testability,test,test,12866," to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misu",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:13405,Testability,test,test,13405," critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; f",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:13546,Testability,test,test,13546,"lock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fs",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:13710,Testability,test,test,13710,"sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14089,Testability,test,test,14089,"lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer a",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14181,Testability,test,test,14181,"ck_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1,",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14484,Testability,test,test,14484,"k_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functi",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14569,Testability,test,test,14569,"// warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x,",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14691,Testability,test,test,14691,"id test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14838,Testability,test,test,14838,"impleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unord",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14934,Testability,test,test,14934,"e demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nonde",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15148,Testability,test,test,15148,"void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15384,Testability,test,test,15384,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15418,Testability,test,test,15418,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15564,Testability,test,test,15564,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15841,Testability,test,test,15841,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:16082,Testability,test,test,16082,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:14447,Usability,clear,clearerr,14447,"void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y =",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:5621,Availability,avail,availability,5621,"_RETAINED;; - (NSString*) alsoReturnsRetained;; @end. @implementation MyClass; - (NSString*) returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a retained Cocoa; object, this attribute can be used to indicate that the object reference; returned should not be considered as an ""owning"" reference being; returned to the caller. The Foundation framework defines a; macro NS_RETURNS_NOT_RETAINED that is functionally equivalent to; the one shown below.; Usage is identical to ns_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_NOT_RETAINED; #if __has_feature(attribute_ns_returns_not_retained); #define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained)); #else; #define NS_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'cf_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'cf_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Core; Foundation object that the caller is responsible for releasing. The; CoreFoundation framework defines a macro CF_RETURNS_RETAINED; that is functionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:5648,Availability,avail,available,5648,"_RETAINED;; - (NSString*) alsoReturnsRetained;; @end. @implementation MyClass; - (NSString*) returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a retained Cocoa; object, this attribute can be used to indicate that the object reference; returned should not be considered as an ""owning"" reference being; returned to the caller. The Foundation framework defines a; macro NS_RETURNS_NOT_RETAINED that is functionally equivalent to; the one shown below.; Usage is identical to ns_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_NOT_RETAINED; #if __has_feature(attribute_ns_returns_not_retained); #define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained)); #else; #define NS_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'cf_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'cf_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Core; Foundation object that the caller is responsible for releasing. The; CoreFoundation framework defines a macro CF_RETURNS_RETAINED; that is functionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:9270,Availability,avail,availability,9270,"CFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running scan-build on this example produces the following output:. Attribute 'cf_returns_not_retained'; (Clang-specific); The 'cf_returns_not_retained' attribute is the complement of 'cf_returns_retained'. Where a function or; method may appear to obey the Core Foundation or Cocoa conventions and return; a retained Core Foundation object, this attribute can be used to indicate that; the object reference returned should not be considered as an; ""owning"" reference being returned to the caller. The; CoreFoundation framework defines a macro CF_RETURNS_NOT_RETAINED; that is functionally equivalent to the one shown below.; Usage is identical to cf_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibili",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:9297,Availability,avail,available,9297,"CFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running scan-build on this example produces the following output:. Attribute 'cf_returns_not_retained'; (Clang-specific); The 'cf_returns_not_retained' attribute is the complement of 'cf_returns_retained'. Where a function or; method may appear to obey the Core Foundation or Cocoa conventions and return; a retained Core Foundation object, this attribute can be used to indicate that; the object reference returned should not be considered as an; ""owning"" reference being returned to the caller. The; CoreFoundation framework defines a macro CF_RETURNS_NOT_RETAINED; that is functionally equivalent to the one shown below.; Usage is identical to cf_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibili",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:14215,Availability,error,error-prone,14215,"RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the cal",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18542,Availability,failure,failure,18542,"ed out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20858,Availability,error,error,20858,"ent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Att",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:3521,Deployability,release,release,3521,"2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consider using proper naming; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'ns_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Cocoa; object that the caller is responsible for releasing (via sending a; release message to the object). The Foundation framework defines a; macro NS_RETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7338,Deployability,release,released,7338,"unctionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7383,Deployability,release,release,7383,"unctionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:9911,Deployability,release,release,9911,"red as an; ""owning"" reference being returned to the caller. The; CoreFoundation framework defines a macro CF_RETURNS_NOT_RETAINED; that is functionally equivalent to the one shown below.; Usage is identical to cf_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10606,Deployability,release,releaseArg,10606,"else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10647,Deployability,release,releaseSecondArg,10647,"else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10764,Deployability,release,releaseArg,10764,"ed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(at",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10889,Deployability,release,releaseSecondArg,10889,"ates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consum",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10948,Deployability,release,released,10948,"ates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consum",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:12200,Deployability,release,releaseArg,12200,"tes to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CON",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:12335,Deployability,release,releaseArg,12335,"completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13878,Deployability,release,release,13878,"ibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:14063,Deployability,release,release,14063,"_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That i",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:14266,Deployability,release,releases,14266,"RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the cal",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:14370,Deployability,release,release,14370,"ith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:15252,Deployability,release,release,15252," lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their parameters,; including the implicit this parameter.; . These summaries can be overriden with the following; attributes:; Attribute 'os_returns_retained'; The os_returns_retained attribute (accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:15742,Deployability,release,release,15742,"e; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their parameters,; including the implicit this parameter.; . These summaries can be overriden with the following; attributes:; Attribute 'os_returns_retained'; The os_returns_retained attribute (accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:16575,Deployability,release,release,16575,"(accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indicates that the method call; consumes the implicit this argument: the caller; should assume one was subtracted from the reference count of the object; after the call, and the callee has on obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with a",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:16602,Deployability,release,release,16602,"(accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indicates that the method call; consumes the implicit this argument: the caller; should assume one was subtracted from the reference count of the object; after the call, and the callee has on obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with a",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:17096,Deployability,release,release,17096," OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indicates that the method call; consumes the implicit this argument: the caller; should assume one was subtracted from the reference count of the object; after the call, and the callee has on obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:17145,Deployability,release,release,17145," OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indicates that the method call; consumes the implicit this argument: the caller; should assume one was subtracted from the reference count of the object; after the call, and the callee has on obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18104,Deployability,release,release,18104,"n obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *dat",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:19156,Deployability,release,release,19156," in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13735,Energy Efficiency,allocate,allocated,13735,"r own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13959,Energy Efficiency,allocate,allocated,13959,"_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That i",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:3529,Integrability,message,message,3529,"2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consider using proper naming; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'ns_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Cocoa; object that the caller is responsible for releasing (via sending a; release message to the object). The Foundation framework defines a; macro NS_RETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:4537,Integrability,interface,interface,4537,"ETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_returns_retained); #define NS_RETURNS_RETAINED __attribute__((ns_returns_retained)); #else; #define NS_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSString*) returnsRetained NS_RETURNS_RETAINED;; - (NSString*) alsoReturnsRetained;; @end. @implementation MyClass; - (NSString*) returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a retained Cocoa; object, this attribute can be used to indicate that the object reference; returned should not be considered as an ""owning"" reference being; returned to the caller. The Foundation framework defines a; macro NS_RETURNS_NOT_RETAINED that is functionally equivalent to; the one shown below.; Usage is identical to ns_returns_retained. When using the; attribute, be sure to declare it within the proper macro",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7391,Integrability,message,message,7391,"unctionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7414,Integrability,bridg,bridging,7414,"unctionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7878,Integrability,interface,interface,7878,"ven the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running scan-build on this example produces the following output:. Attribute 'cf_returns_not_retained'; (Clang-specific); The 'cf_returns_not_retained' attribute is the complement of 'cf_returns_retained'. Where a function or; method may appear to obey the Core Foundation or Cocoa conventions and return; a retained Core Foundation object, this attribute can be used to indicate that; the object reference returned should not be considered as an; ""owning"" ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:9919,Integrability,message,message,9919,"red as an; ""owning"" reference being returned to the caller. The; CoreFoundation framework defines a macro CF_RETURNS_NOT_RETAINED; that is functionally equivalent to the one shown below.; Usage is identical to cf_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10571,Integrability,interface,interface,10571,"else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:12165,Integrability,interface,interface,12165,"tes to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CON",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:12546,Integrability,message,message,12546,"xample. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:12618,Integrability,message,message,12618,"xample. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13107,Integrability,interface,interface,13107,"e Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually increment",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18330,Integrability,depend,depends,18330,"meters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21423,Integrability,depend,depends,21423,"hen the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; re",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:287,Modifiability,enhance,enhance,287,". Source Annotations. Source Annotations; The Clang frontend supports several source-level annotations in the form of; GCC-style; attributes and pragmas that can help make using the Clang Static Analyzer; more useful. These annotations can both help suppress false positives as well as; enhance the analyzer's ability to find bugs.; This page gives a practical overview of such annotations. For more technical; specifics regarding Clang-specific annotations please see the Clang's list of language; extensions. Details of ""standard"" GCC attributes (that Clang also; supports) can be found in the GCC; manual, with the majority of the relevant attributes being in the section on; function; attributes.; Note that attributes that are labeled Clang-specific are not; recognized by GCC. Their use can be conditioned using preprocessor macros; (examples included on this page).; Specific Topics. Annotations to Enhance Generic Checks. Null Pointer Checking. Attribute 'nonnull'. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management Annotations. Attribute 'ns_returns_retained'; Attribute 'ns_returns_not_retained'; Attribute 'cf_returns_retained'; Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function w",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:2064,Modifiability,extend,extends,2064,"Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consid",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13718,Modifiability,inherit,inherit,13718,"r own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:4141,Performance,perform,perform,4141,"attributes described here. However, you should consider using proper naming; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'ns_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Cocoa; object that the caller is responsible for releasing (via sending a; release message to the object). The Foundation framework defines a; macro NS_RETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_returns_retained); #define NS_RETURNS_RETAINED __attribute__((ns_returns_retained)); #else; #define NS_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSString*) returnsRetained NS_RETURNS_RETAINED;; - (NSString*) alsoReturnsRetained;; @end. @implementation MyClass; - (NSString*) returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13775,Performance,perform,perform,13775,"r own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually incrementing and decrementing reference counts is error-prone:; over-retains lead to leaks, and over-releases lead to uses-after-free.; The analyzer can help the programmer to check for unbalanced; retain/release calls.; The reference count checking is based on the principle of; locality: it should be possible to establish correctness; (lack of leaks/uses after free) by looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20352,Performance,perform,performing,20352,"f and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointe",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21394,Performance,perform,performing,21394,"hen the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; re",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:22344,Performance,optimiz,optimized,22344,"s, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; return.; Example; On Mac OS X, the function prototype for __assert_rtn (declared in; assert.h) is specifically annotated with the 'noreturn' attribute:. void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));. Attribute 'analyzer_noreturn' (Clang-specific); The Clang-specific 'analyzer_noreturn' attribute is almost identical to; 'noreturn' except that it is ignored by the compiler for the purposes of code; generation.; This attribute is useful for annotating assertion handlers that actually; can return, but for the purpose of using the analyzer we want to; pretend that such functions do not return.; Because this attribute is Clang-specific, its use should be conditioned with; the use of preprocessor macros.; Example. #ifndef CLANG_ANALYZER_NORETURN; #if __has_feature(attribute_analyzer_noreturn); #define CLANG_ANALYZER_NORETURN __att",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18124,Safety,avoid,avoid,18124,"n obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *dat",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21338,Safety,safe,safety,21338,"re; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate d",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:15531,Security,access,accessed,15531,"y looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their parameters,; including the implicit this parameter.; . These summaries can be overriden with the following; attributes:; Attribute 'os_returns_retained'; The os_returns_retained attribute (accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:15848,Security,access,accessed,15848,"unctions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their parameters,; including the implicit this parameter.; . These summaries can be overriden with the following; attributes:; Attribute 'os_returns_retained'; The os_returns_retained attribute (accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indic",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:16413,Security,access,accessed,16413,"(accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indicates that the method call; consumes the implicit this argument: the caller; should assume one was subtracted from the reference count of the object; after the call, and the callee has on obligation to either; release the argument, or store it and eventually release it in the; destructor. void addThisToList(OSArray *givenList) LIBKERN_CONSUMES_THIS;. Out Parameters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with a",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:2283,Testability,test,test,2283," Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consider using proper naming; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:4181,Testability,test,test,4181,"; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'ns_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Cocoa; object that the caller is responsible for releasing (via sending a; release message to the object). The Foundation framework defines a; macro NS_RETURNS_RETAINED that is functionally equivalent to the; one shown below.; Placing on Objective-C methods: For Objective-C methods, this; annotation essentially tells the analyzer to treat the method as if its name; begins with ""alloc"" or ""new"" or contains the word; ""copy"".; Placing on C functions: For C functions returning Cocoa objects, the; analyzer typically does not make any assumptions about whether or not the object; is returned retained. Explicitly adding the 'ns_returns_retained' attribute to C; functions allows the analyzer to perform extra checking.; Example. $ cat test.m; #import <Foundation/Foundation.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_RETAINED; #if __has_feature(attribute_ns_returns_retained); #define NS_RETURNS_RETAINED __attribute__((ns_returns_retained)); #else; #define NS_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSString*) returnsRetained NS_RETURNS_RETAINED;; - (NSString*) alsoReturnsRetained;; @end. @implementation MyClass; - (NSString*) returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:5702,Testability,test,test,5702,") returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a retained Cocoa; object, this attribute can be used to indicate that the object reference; returned should not be considered as an ""owning"" reference being; returned to the caller. The Foundation framework defines a; macro NS_RETURNS_NOT_RETAINED that is functionally equivalent to; the one shown below.; Usage is identical to ns_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_NOT_RETAINED; #if __has_feature(attribute_ns_returns_not_retained); #define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained)); #else; #define NS_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'cf_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'cf_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Core; Foundation object that the caller is responsible for releasing. The; CoreFoundation framework defines a macro CF_RETURNS_RETAINED; that is functionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is imp",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7518,Testability,test,test,7518,"te is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running s",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:7532,Testability,test,test,7532,"al in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is important for the following reason:; as Core Foundation is a C API,; the analyzer cannot always tell that a pointer return value refers to a; Core Foundation object.; In contrast, it is; trivial for the analyzer to recognize if a pointer refers to a Cocoa object; (given the Objective-C type system). Placing on C functions: When placing the attribute; 'cf_returns_retained' on the declarations of C functions, the analyzer; interprets the function as:. Returning a Core Foundation Object; Treating the function as if it its name; contained the keywords ""create"" or ""copy"". This means the; returned object as a +1 retain count that must be released by the caller, either; by sending a release message (via toll-free bridging to an Objective-C; object pointer), or calling CFRelease or a similar function. Example. $ cat test.m; $ cat test.m; #import <Cocoa/Cocoa.h>. #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_RETAINED; #if __has_feature(attribute_cf_returns_retained); #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained)); #else; #define CF_RETURNS_RETAINED; #endif; #endif. @interface MyClass : NSObject {}; - (NSDate*) returnsCFRetained CF_RETURNS_RETAINED;; - (NSDate*) alsoReturnsRetained;; - (NSDate*) returnsNSRetained NS_RETURNS_RETAINED;; @end. CF_RETURNS_RETAINED; CFDateRef returnsRetainedCFDate() {; return CFDateCreate(0, CFAbsoluteTimeGetCurrent());; }. @implementation MyClass; - (NSDate*) returnsCFRetained {; return (NSDate*) returnsRetainedCFDate(); // No leak.; }. - (NSDate*) alsoReturnsRetained {; return (NSDate*) returnsRetainedCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running scan-build on ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:9351,Testability,test,test,9351,"edCFDate(); // Always report a leak.; }. - (NSDate*) returnsNSRetained {; return (NSDate*) returnsRetainedCFDate(); // Report a leak when using GC.; }; @end. Running scan-build on this example produces the following output:. Attribute 'cf_returns_not_retained'; (Clang-specific); The 'cf_returns_not_retained' attribute is the complement of 'cf_returns_retained'. Where a function or; method may appear to obey the Core Foundation or Cocoa conventions and return; a retained Core Foundation object, this attribute can be used to indicate that; the object reference returned should not be considered as an; ""owning"" reference being returned to the caller. The; CoreFoundation framework defines a macro CF_RETURNS_NOT_RETAINED; that is functionally equivalent to the one shown below.; Usage is identical to cf_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10175,Testability,test,test,10175,". When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_RETURNS_NOT_RETAINED; #if __has_feature(attribute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an O",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10496,Testability,test,test,10496,"ibute_cf_returns_not_retained); #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained)); #else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:11585,Testability,test,test,11585," : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single refer",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:11953,Testability,test,test,11953," (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consume",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:19644,Testability,assert,assertions,19644," IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:19687,Testability,assert,assertion,19687," IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:19778,Testability,assert,assertion,19778,"others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __ass",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:19881,Testability,assert,assertions,19881,"ject is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once i",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20191,Testability,assert,assertions,20191,"parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where t",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20265,Testability,assert,assertion,20265,"parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where t",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20295,Testability,assert,assertions,20295,"f and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointe",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20379,Testability,assert,assertion,20379,"f and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointe",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20438,Testability,assert,assertion,20438,"f and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointe",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20530,Testability,assert,assert,20530,"ns regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known asse",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20766,Testability,assert,assertion,20766,"n the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does n",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20820,Testability,assert,assertion,20820,"ent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Att",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20992,Testability,assert,assertion,20992," only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21097,Testability,assert,assertion,21097,"sitives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can b",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21229,Testability,assert,assertion,21229,"sitives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can b",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21299,Testability,assert,assertion,21299,"re; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate d",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21527,Testability,assert,assertion,21527," the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; return.; Example; On Mac OS X, the function prototype for __assert_rtn (declared in; assert.h) is specifically annotated with the 'noreturn' attribute:. void __assert_rtn(const char *, const char *, int, c",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21614,Testability,assert,assertion,21614," the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; return.; Example; On Mac OS X, the function prototype for __assert_rtn (declared in; assert.h) is specifically annotated with the 'noreturn' attribute:. void __assert_rtn(const char *, const char *, int, c",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:22489,Testability,assert,assert,22489,"., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; return.; Example; On Mac OS X, the function prototype for __assert_rtn (declared in; assert.h) is specifically annotated with the 'noreturn' attribute:. void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));. Attribute 'analyzer_noreturn' (Clang-specific); The Clang-specific 'analyzer_noreturn' attribute is almost identical to; 'noreturn' except that it is ignored by the compiler for the purposes of code; generation.; This attribute is useful for annotating assertion handlers that actually; can return, but for the purpose of using the analyzer we want to; pretend that such functions do not return.; Because this attribute is Clang-specific, its use should be conditioned with; the use of preprocessor macros.; Example. #ifndef CLANG_ANALYZER_NORETURN; #if __has_feature(attribute_analyzer_noreturn); #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn)); #else; #define CLANG_ANALYZER_NORETURN; #endif; #endif. void my_assert_rtn(const char *, const char *, int, const char *) CLANG_ANALYZ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:22907,Testability,assert,assertion,22907,"g a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; return.; Example; On Mac OS X, the function prototype for __assert_rtn (declared in; assert.h) is specifically annotated with the 'noreturn' attribute:. void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));. Attribute 'analyzer_noreturn' (Clang-specific); The Clang-specific 'analyzer_noreturn' attribute is almost identical to; 'noreturn' except that it is ignored by the compiler for the purposes of code; generation.; This attribute is useful for annotating assertion handlers that actually; can return, but for the purpose of using the analyzer we want to; pretend that such functions do not return.; Because this attribute is Clang-specific, its use should be conditioned with; the use of preprocessor macros.; Example. #ifndef CLANG_ANALYZER_NORETURN; #if __has_feature(attribute_analyzer_noreturn); #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn)); #else; #define CLANG_ANALYZER_NORETURN; #endif; #endif. void my_assert_rtn(const char *, const char *, int, const char *) CLANG_ANALYZER_NORETURN;. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:1926,Usability,simpl,simple,1926,"g. Attribute 'nonnull'. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management Annotations. Attribute 'ns_returns_retained'; Attribute 'ns_returns_not_retained'; Attribute 'cf_returns_retained'; Attribute 'cf_returns_not_retained'; Attribute 'ns_consumed'; Attribute 'cf_consumed'; Attribute 'ns_consumes_self'. Libkern Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One c",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:18158,Usability,simpl,simple,18158,"meters. A function can also return an object to a caller by a means of an out parameter; (a pointer-to-OSObject-pointer is passed, and a callee writes a pointer to an; object into an argument).; Currently the analyzer does not track unannotated out; parameters by default, but with annotations we distinguish four separate cases:. 1. Non-retained out parameters, identified using; LIBKERN_RETURNS_NOT_RETAINED applied to parameters, e.g.:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). Such functions write a non-retained object into an out parameter, and the; caller has no further obligations.; 2. Retained out parameters,; identified using LIBKERN_RETURNS_RETAINED:. void getterViaOutParam(LIBKERN_RETURNS_NOT_RETAINED OSObject **obj). In such cases a retained object is written into an out parameter, which the caller has then to release in order to avoid a leak. These two cases are simple - but in practice a functions returning an out-parameter usually also return a return code, and then an out parameter may or may not be written, which conditionally depends on the exit code, e.g.:. bool maybeCreateObject(LIBKERN_RETURNS_RETAINED OSObject **obj);. For such functions, the usual semantics is that an object is written into on ""success"", and not written into on ""failure"".; For LIBKERN_RETURNS_RETAINED we assume the following definition of; success:; For functions returning OSReturn or IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/annotations.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:254,Availability,error,errors,254,". Available Checkers. Available Checkers; The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1332,Availability,error,errors,1332,"ains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17120,Availability,error,error,17120,ng an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17177,Availability,error,error,17177,; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birth,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17321,Availability,error,error,17321,on MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of th,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17378,Availability,error,error,17378, Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // wa,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17388,Availability,error,error,17388, Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // wa,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17978,Availability,error,errors,17978,"[pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialize",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19851,Availability,error,error,19851,"@implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19959,Availability,error,error,19959,"lf'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19970,Availability,error,error,19970,"lf'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22482,Availability,avail,available,22482,"ses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:5634,Deployability,release,released,5634,"; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null po",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:7089,Deployability,update,updateNextData,7089,"est() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. nullability.NullableDereferenced; (ObjC); Warns when a nullable pointer is dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. nullability.NullablePassedToNonnull; (ObjC); Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. Optin Checkers. Name, DescriptionExample. cplusplus.UninitializedObject; (C++); This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:13591,Deployability,release,released,13591,"tch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. osx.NumberObjectConversion; (C, C++, ObjC); Check for erroneous conversions of objects representing numbers; into numbers. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. osx.SecKeychainAPI; (C); Check for improper uses of the Security framework's Keychain APIs:; SecKeychainItemCopyContent; SecKeychainFindGenericPassword; SecKeychainFindInternetPassword; SecKeychainItemFreeContent; SecKeychainItemCopyAttributesAndData; SecKeychainItemFreeAttributesAndData. void test() {; unsigned int *ptr = 0;; UInt32 length;. SecKeychainItemFreeContent(ptr, &length);; // warn: trying to free data which has not been allocated; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, outData);; // warn: data is not released; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outD",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14085,Deployability,release,release,14085,"inItemCopyContent; SecKeychainFindGenericPassword; SecKeychainFindInternetPassword; SecKeychainItemFreeContent; SecKeychainItemCopyAttributesAndData; SecKeychainItemFreeAttributesAndData. void test() {; unsigned int *ptr = 0;; UInt32 length;. SecKeychainItemFreeContent(ptr, &length);; // warn: trying to free data which has not been allocated; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, outData);; // warn: data is not released; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Deal",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14925,Deployability,release,release,14925," *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15037,Deployability,release,release,15037,"pyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodT",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15672,Deployability,release,released,15672," pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted t",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15924,Deployability,release,released,15924,"ding retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15966,Deployability,release,release,15966,"ding retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16985,Deployability,release,release,16985,_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics;,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19270,Deployability,release,release,19270,"osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to init",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:24361,Deployability,release,released,24361,"SIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);.",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:24550,Deployability,release,released,24550,"T);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new i",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:5530,Energy Efficiency,allocate,allocated,5530,"or assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:5854,Energy Efficiency,allocate,allocated,5854," for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a me",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:13406,Energy Efficiency,allocate,allocated,13406,"g macro; [alarmStateLabel setText:alarmText];. OS X Checkers. Name, DescriptionExample. osx.API; (C); Check for proper uses of various Apple APIs:; dispatch_once. void test() {; dispatch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. osx.NumberObjectConversion; (C, C++, ObjC); Check for erroneous conversions of objects representing numbers; into numbers. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. osx.SecKeychainAPI; (C); Check for improper uses of the Security framework's Keychain APIs:; SecKeychainItemCopyContent; SecKeychainFindGenericPassword; SecKeychainFindInternetPassword; SecKeychainItemFreeContent; SecKeychainItemCopyAttributesAndData; SecKeychainItemFreeAttributesAndData. void test() {; unsigned int *ptr = 0;; UInt32 length;. SecKeychainItemFreeContent(ptr, &length);; // warn: trying to free data which has not been allocated; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, outData);; // warn: data is not released; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *len",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:24630,Energy Efficiency,allocate,allocated,24630," }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new int[1];; realloc(p, sizeof(long)); // warn; }. // C, C++; template <typename T>; struct Simp",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:26126,Energy Efficiency,allocate,allocated,26126,"; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new int[1];; realloc(p, sizeof(long)); // warn; }. // C, C++; template <typename T>; struct SimpleSmartPointer {; T *ptr;. explicit SimpleSmartPointer(T *p = 0) : ptr(p) {}; ~SimpleSmartPointer() {; delete ptr; // warn; }; };. void test() {; SimpleSmartPointer<int> a((int *)malloc(4));; }. // C++; void test() {; int *p = (int *)operator new(0);; delete[] p; // warn; }. // Objective-C, C++; void test(NSUInteger dataLength) {; int *p = new int;; NSData *d = [NSData dataWithBytesNoCopy:p; length:sizeof(int) freeWhenDone:1];; // warn +dataWithBytesNoCopy:length:freeWhenDone: cannot take; // ownership of memory allocated by 'new'; }. unix.Vfork; (C); Check for proper usage of vfork. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. unix.cstring.BadSizeArg; (C); Check the size argument passed to strncat for common erroneous; patterns. Use -Wno-strncat-size compiler option to mute other; strncat-related compiler warnings. void test() {; char dest[3];; strncat(dest, ""***"", sizeof(dest));; // warn: potential buffer overflow; }. unix.cstring.NullArg; (C); Check for null pointers being passed as arguments to C string functions:; strlen; strnlen; strcpy; strncpy; strcat; strncat; strcmp; strncmp; strca",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1374,Integrability,message,message,1374,"ains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2040,Integrability,interface,interface,2040,"ty Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the no",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2267,Integrability,interface,interface,2267,"bjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2473,Integrability,interface,interface,2473,"t() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interfac",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2569,Integrability,interface,interface,2569,"id (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAdd",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3503,Integrability,interface,interface,3503,"jectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialize",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14679,Integrability,synchroniz,synchronized,14679,"th = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was reta",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14722,Integrability,synchroniz,synchronized,14722," length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interf",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14801,Integrability,synchroniz,synchronized,14801," if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14973,Integrability,interface,interface,14973,", length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super deallo",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15167,Integrability,interface,interface,15167,"; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation M",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15284,Integrability,interface,interface,15284,"eychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (fl",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15477,Integrability,interface,interface,15477,"mFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotate",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15729,Integrability,interface,interface,15729," }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.coc",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16128,Integrability,interface,interface,16128,; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A;,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16237,Integrability,interface,interface,16237,acks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value;,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16666,Integrability,interface,interface,16666,];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; ,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17072,Integrability,interface,interface,17072,ng an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17273,Integrability,interface,interface,17273,on MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of th,MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:18628,Integrability,interface,interface,18628,"ns:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet set",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:18836,Integrability,interface,interface,18836,"ent to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19092,Integrability,interface,interface,19092,"value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigne",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:19376,Integrability,interface,interface,19376,"ringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p)",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:6119,Modifiability,variab,variables,6119," double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. nullability.NullableDereferenced; (ObjC); Warns when a nullable pointer is dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedL",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:7900,Modifiability,inherit,inherited,7900," dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. nullability.NullablePassedToNonnull; (ObjC); Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. Optin Checkers. Name, DescriptionExample. cplusplus.UninitializedObject; (C++); This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplie",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:7983,Modifiability,inherit,inherited,7983," dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. nullability.NullablePassedToNonnull; (ObjC); Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. Optin Checkers. Name, DescriptionExample. cplusplus.UninitializedObject; (C++); This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplie",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:8226,Modifiability,config,config,8226,"s dereferenced; next->data = 7;; }. nullability.NullablePassedToNonnull; (ObjC); Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. Optin Checkers. Name, DescriptionExample. cplusplus.UninitializedObject; (C++); This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplied, the checker; will not analyze structures that have a field with a name or type name that; matches the given pattern. Defaults to """". -analyzer-config cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind"".; . // With Pedantic and CheckPointeeInitializati",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:8544,Modifiability,config,config,8544,"onnull(p); // warn; }. Optin Checkers. Name, DescriptionExample. cplusplus.UninitializedObject; (C++); This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplied, the checker; will not analyze structures that have a field with a name or type name that; matches the given pattern. Defaults to """". -analyzer-config cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind"".; . // With Pedantic and CheckPointeeInitialization set to true. struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; // note: uninitialized field 'this->bptr->x'; int y; // note: uninitialized field 'this->b.y'; // note: uninitialized field 'this->bptr->y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr; // note: u",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:8828,Modifiability,config,config,8828,"object, analyzing all of it's fields subfields. ; The checker regards inherited fields as direct fields, so one will recieve; warnings for uninitialized inherited data members as well. . It has several options:. ""Pedantic"" (boolean). If its not set or is set to false, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplied, the checker; will not analyze structures that have a field with a name or type name that; matches the given pattern. Defaults to """". -analyzer-config cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind"".; . // With Pedantic and CheckPointeeInitialization set to true. struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; // note: uninitialized field 'this->bptr->x'; int y; // note: uninitialized field 'this->b.y'; // note: uninitialized field 'this->bptr->y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr; // note: uninitialized pointee 'this->cptr'. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // warning: 6 uninitialized fields; // after the constructor call; }. // With Pedantic set to false and; // CheckPointeeInitialization set to true; /",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:9092,Modifiability,config,config,9092,"se, the; checker won't emit warnings for objects that don't have at least one; initialized field. This may be set with ; -analyzer-config cplusplus.UninitializedObject:Pedantic=true.; . ""NotesAsWarnings"" (boolean). If set to true, the checker will; emit a warning for each uninitalized field, as opposed to emitting one; warning per constructor call, and listing the uninitialized fields that; belongs to it in notes. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:NotesAsWarnings=true.; . ""CheckPointeeInitialization"" (boolean). If set to false, the; checker will not analyze the pointee of pointer/reference fields, and will; only check whether the object itself is initialized. Defaults to false. ; -analyzer-config cplusplus.UninitializedObject:CheckPointeeInitialization=true.; . ""IgnoreRecordsWithField"" (string). If supplied, the checker; will not analyze structures that have a field with a name or type name that; matches the given pattern. Defaults to """". -analyzer-config cplusplus.UninitializedObject:IgnoreRecordsWithField=""[Tt]ag|[Kk]ind"".; . // With Pedantic and CheckPointeeInitialization set to true. struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; // note: uninitialized field 'this->bptr->x'; int y; // note: uninitialized field 'this->b.y'; // note: uninitialized field 'this->bptr->y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr; // note: uninitialized pointee 'this->cptr'. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // warning: 6 uninitialized fields; // after the constructor call; }. // With Pedantic set to false and; // CheckPointeeInitialization set to true; // (every field is uninitialized). struct A {; struct B {; int x;; int y;; };; int *iptr;; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // no warning; }. // With Pedantic and CheckPo",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:18764,Modifiability,variab,variable,18764,"String *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:23751,Modifiability,variab,variable,23751,". void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:55,Performance,perform,performs,55,". Available Checkers. Available Checkers; The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:731,Performance,perform,perform,731,". Available Checkers. Available Checkers; The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:864,Performance,perform,perform,864,"The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @in",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:989,Performance,perform,perform,989,"The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @in",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1126,Performance,perform,perform,1126,"The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @in",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:23425,Performance,perform,performed,23425,"generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; f",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22993,Safety,safe,safe,22993,"warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:197,Security,secur,security,197,". Available Checkers. Available Checkers; The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21039,Security,secur,security,21039,"ndation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.inse",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21228,Security,secur,security,21228,"initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21434,Security,secur,security,21434," test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21549,Security,secur,security,21549,"(C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nran",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21665,Security,secur,security,21665,"FTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strc",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21776,Security,secur,security,21776,"es; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insec",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21906,Security,secur,security,21906,"Ref A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCT",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22030,Security,secur,security,22030,"ple. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValue",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22205,Security,secur,security,22205,"1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValue",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22357,Security,secur,security,22357,"euid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_o",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22611,Security,secur,security,22611,"n. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22766,Security,secur,security,22766,"n; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void t",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22871,Security,secur,security,22871,";; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:248,Testability,log,logic,248,". Available Checkers. Available Checkers; The analyzer performs checks that are categorized into families or ""checkers"". The; default set of checkers covers a variety of checks targeted at finding security; and API usage bugs, dead code, and other logic errors. See the; Default Checkers list below. In addition to; these, the analyzer contains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: objec",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1324,Testability,log,logical,1324,"ains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1508,Testability,test,test,1508,"Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1608,Testability,test,test,1608,"Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (l",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1703,Testability,test,test,1703,"general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitia",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1836,Testability,test,test,1836,"orm C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1956,Testability,test,test,1956,"rs perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Ch",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2146,Testability,test,test,2146,"ers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.Nul",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2373,Testability,test,test,2373,"ions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2680,Testability,test,test,2680,"(*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2833,Testability,test,test,2833,">f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; ",MatchSource.DOCS,interpreter/llvm-project/clang/www/analyzer/available_checks.html,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html
